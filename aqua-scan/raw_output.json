{
    "image": "corpsys-docker-local/corpsys-corpsys-learning-roleplay:master-24ba228-46",
    "scan_started": {
        "seconds": 1678795946,
        "nanos": 193841550
    },
    "scan_duration": 13,
    "image_size": 0,
    "digest": "sha256:generated_placeholder",
    "resources": [
        {
            "resource": {
                "format": "rpm",
                "name": "kernel-headers",
                "version": "4.18.0-553.89.1.el8_10",
                "layer_digest": "sha256:974b4723f6a806aea3048dca6b5b34a9ada082cff6a80c96308825f417bd1048"
            },
            "scanned": true,
            "vulnerabilities": [
                {
                    "name": "CVE-2024-47685",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put()\n\nsyzbot reported that nf_reject_ip6_tcphdr_put() was possibly sending\ngarbage on the four reserved tcp bits (th->res1)\n\nUse skb_put_zero() to clear the whole TCP header,\nas done in nf_reject_ip_tcphdr_put()\n\nBUG: KMSAN: uninit-value in nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1da/0xa00 net/core/dev.c:5775\n  process_backlog+0x4ad/0xa50 net/core/dev.c:6108\n  __napi_poll+0xe7/0x980 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0xa5a/0x19b0 net/core/dev.c:6963\n  handle_softirqs+0x1ce/0x800 kernel/softirq.c:554\n  __do_softirq+0x14/0x1a kernel/softirq.c:588\n  do_softirq+0x9a/0x100 kernel/softirq.c:455\n  __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:382\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:908 [inline]\n  __dev_queue_xmit+0x2692/0x5610 net/core/dev.c:4450\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  neigh_resolve_output+0x9ca/0xae0 net/core/neighbour.c:1565\n  neigh_output include/net/neighbour.h:542 [inline]\n  ip6_finish_output2+0x2347/0x2ba0 net/ipv6/ip6_output.c:141\n  __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]\n  ip6_finish_output+0xbb8/0x14b0 net/ipv6/ip6_output.c:226\n  NF_HOOK_COND include/linux/netfilter.h:303 [inline]\n  ip6_output+0x356/0x620 net/ipv6/ip6_output.c:247\n  dst_output include/net/dst.h:450 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_xmit+0x1ba6/0x25d0 net/ipv6/ip6_output.c:366\n  inet6_csk_xmit+0x442/0x530 net/ipv6/inet6_connection_sock.c:135\n  __tcp_transmit_skb+0x3b07/0x4880 net/ipv4/tcp_output.c:1466\n  tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n  tcp_connect+0x35b6/0x7130 net/ipv4/tcp_output.c:4143\n  tcp_v6_connect+0x1bcc/0x1e40 net/ipv6/tcp_ipv6.c:333\n  __inet_stream_connect+0x2ef/0x1730 net/ipv4/af_inet.c:679\n  inet_stream_connect+0x6a/0xd0 net/ipv4/af_inet.c:750\n  __sys_connect_file net/socket.c:2061 [inline]\n  __sys_connect+0x606/0x690 net/socket.c:2078\n  __do_sys_connect net/socket.c:2088 [inline]\n  __se_sys_connect net/socket.c:2085 [inline]\n  __x64_sys_connect+0x91/0xe0 net/socket.c:2085\n  x64_sys_call+0x27a5/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:43\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was stored to memory at:\n  nf_reject_ip6_tcphdr_put+0x60c/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:249\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "critical",
                    "aqua_score": 9.1,
                    "aqua_severity": "critical",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52735",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Don't let sock_map_{close,destroy,unhash} call itself\n\nsock_map proto callbacks should never call themselves by design. Protect\nagainst bugs like [1] and break out of the recursive loop to avoid a stack\noverflow in favor of a resource leak.\n\n[1] https://lore.kernel.org/all/00000000000073b14905ef2e7401@google.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52735",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "critical",
                    "aqua_score": 9.1,
                    "aqua_severity": "critical",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-38605",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: core: Fix NULL module pointer assignment at card init\n\nThe commit 81033c6b584b (\"ALSA: core: Warn on empty module\")\nintroduced a WARN_ON() for a NULL module pointer passed at snd_card\nobject creation, and it also wraps the code around it with '#ifdef\nMODULE'.  This works in most cases, but the devils are always in\ndetails.  \"MODULE\" is defined when the target code (i.e. the sound\ncore) is built as a module; but this doesn't mean that the caller is\nalso built-in or not.  Namely, when only the sound core is built-in\n(CONFIG_SND=y) while the driver is a module (CONFIG_SND_USB_AUDIO=m),\nthe passed module pointer is ignored even if it's non-NULL, and\ncard->module remains as NULL.  This would result in the missing module\nreference up/down at the device open/close, leading to a race with the\ncode execution after the module removal.\n\nFor addressing the bug, move the assignment of card->module again out\nof ifdef.  The WARN_ON() is still wrapped with ifdef because the\nmodule can be really NULL when all sound drivers are built-in.\n\nNote that we keep 'ifdef MODULE' for WARN_ON(), otherwise it would\nlead to a false-positive NULL module check.  Admittedly it won't catch\nperfectly, i.e. no check is performed when CONFIG_SND=y.  But, it's no\nreal problem as it's only for debugging, and the condition is pretty\nrare.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38605",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 8.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-4440",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/xen: Drop USERGS_SYSRET64 paravirt call\n\ncommit afd30525a659ac0ae0904f0cb4a2ca75522c3123 upstream.\n\nUSERGS_SYSRET64 is used to return from a syscall via SYSRET, but\na Xen PV guest will nevertheless use the IRET hypercall, as there\nis no sysret PV hypercall defined.\n\nSo instead of testing all the prerequisites for doing a sysret and\nthen mangling the stack for Xen PV again for doing an iret just use\nthe iret exit from the beginning.\n\nThis can easily be done via an ALTERNATIVE like it is done for the\nsysenter compat case already.\n\nIt should be noted that this drops the optimization in Xen for not\nrestoring a few registers when returning to user mode, but it seems\nas if the saved instructions in the kernel more than compensate for\nthis drop (a kernel build in a Xen PV guest was slightly faster with\nthis patch applied).\n\nWhile at it remove the stale sysret32 remnants.\n\n  [ pawan: Brad Spengler and Salvatore Bonaccorso <carnil@debian.org>\n\t   reported a problem with the 5.10 backport commit edc702b4a820\n\t   (\"x86/entry_64: Add VERW just before userspace transition\").\n\n\t   When CONFIG_PARAVIRT_XXL=y, CLEAR_CPU_BUFFERS is not executed in\n\t   syscall_return_via_sysret path as USERGS_SYSRET64 is runtime\n\t   patched to:\n\n\t.cpu_usergs_sysret64    = { 0x0f, 0x01, 0xf8,\n\t\t\t\t    0x48, 0x0f, 0x07 }, // swapgs; sysretq\n\n\t   which is missing CLEAR_CPU_BUFFERS. It turns out dropping\n\t   USERGS_SYSRET64 simplifies the code, allowing CLEAR_CPU_BUFFERS\n\t   to be explicitly added to syscall_return_via_sysret path. Below\n\t   is with CONFIG_PARAVIRT_XXL=y and this patch applied:\n\n\t   syscall_return_via_sysret:\n\t   ...\n\t   <+342>:   swapgs\n\t   <+345>:   xchg   %ax,%ax\n\t   <+347>:   verw   -0x1a2(%rip)  <------\n\t   <+354>:   sysretq\n  ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4440",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-25",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 8.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-38384",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-cgroup: fix list corruption from reorder of WRITE ->lqueued\n\n__blkcg_rstat_flush() can be run anytime, especially when blk_cgroup_bio_start\nis being executed.\n\nIf WRITE of `->lqueued` is re-ordered with READ of 'bisc->lnode.next' in\nthe loop of __blkcg_rstat_flush(), `next_bisc` can be assigned with one\nstat instance being added in blk_cgroup_bio_start(), then the local\nlist in __blkcg_rstat_flush() could be corrupted.\n\nFix the issue by adding one barrier.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38384",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-24",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 8.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.4,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-26927",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: Add some bounds checking to firmware data\n\nSmatch complains about \"head->full_size - head->header_size\" can\nunderflow.  To some extent, we're always going to have to trust the\nfirmware a bit.  However, it's easy enough to add a check for negatives,\nand let's add a upper bounds check as well.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26927",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-03-21",
                    "nvd_score_v3": 8.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.4,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47313",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: CPPC: Fix potential memleak in cppc_cpufreq_cpu_init\n\nIt's a classic example of memleak, we allocate something, we fail and\nnever free the resources.\n\nMake sure we free all resources on policy ->init() failures.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47313",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 8.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.4,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-46973",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: qrtr: Avoid potential use after free in MHI send\n\nIt is possible that the MHI ul_callback will be invoked immediately\nfollowing the queueing of the skb for transmission, leading to the\ncallback decrementing the refcount of the associated sk and freeing the\nskb.\n\nAs such the dereference of skb and the increment of the sk refcount must\nhappen before the skb is queued, to avoid the skb to be used after free\nand potentially the sk to drop its last refcount..",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46973",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-27",
                    "modification_date": "2025-03-14",
                    "nvd_score_v3": 8.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.4,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-1665",
                    "description": "A set of pre-production kernel packages of Red Hat Enterprise Linux for IBM Power architecture can be booted by the grub in Secure Boot mode even though it shouldn't. These kernel builds don't have the secure boot lockdown patches applied to it and can bypass the secure boot validations, allowing the attacker to load another non-trusted code.",
                    "nvd_score": 4.6,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-1665",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-06-21",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 8.2,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8.2,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-3534",
                    "description": "A vulnerability classified as critical has been found in Linux Kernel. Affected is the function btf_dump_name_dups of the file tools/lib/bpf/btf_dump.c of the component libbpf. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211032.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3534",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-10-17",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47576",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: scsi_debug: Sanity check block descriptor length in resp_mode_select()\n\nIn resp_mode_select() sanity check the block descriptor len to avoid UAF.\n\nBUG: KASAN: use-after-free in resp_mode_select+0xa4c/0xb40 drivers/scsi/scsi_debug.c:2509\nRead of size 1 at addr ffff888026670f50 by task scsicmd/15032\n\nCPU: 1 PID: 15032 Comm: scsicmd Not tainted 5.15.0-01d0625 #15\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nCall Trace:\n <TASK>\n dump_stack_lvl+0x89/0xb5 lib/dump_stack.c:107\n print_address_description.constprop.9+0x28/0x160 mm/kasan/report.c:257\n kasan_report.cold.14+0x7d/0x117 mm/kasan/report.c:443\n __asan_report_load1_noabort+0x14/0x20 mm/kasan/report_generic.c:306\n resp_mode_select+0xa4c/0xb40 drivers/scsi/scsi_debug.c:2509\n schedule_resp+0x4af/0x1a10 drivers/scsi/scsi_debug.c:5483\n scsi_debug_queuecommand+0x8c9/0x1e70 drivers/scsi/scsi_debug.c:7537\n scsi_queue_rq+0x16b4/0x2d10 drivers/scsi/scsi_lib.c:1521\n blk_mq_dispatch_rq_list+0xb9b/0x2700 block/blk-mq.c:1640\n __blk_mq_sched_dispatch_requests+0x28f/0x590 block/blk-mq-sched.c:325\n blk_mq_sched_dispatch_requests+0x105/0x190 block/blk-mq-sched.c:358\n __blk_mq_run_hw_queue+0xe5/0x150 block/blk-mq.c:1762\n __blk_mq_delay_run_hw_queue+0x4f8/0x5c0 block/blk-mq.c:1839\n blk_mq_run_hw_queue+0x18d/0x350 block/blk-mq.c:1891\n blk_mq_sched_insert_request+0x3db/0x4e0 block/blk-mq-sched.c:474\n blk_execute_rq_nowait+0x16b/0x1c0 block/blk-exec.c:63\n sg_common_write.isra.18+0xeb3/0x2000 drivers/scsi/sg.c:837\n sg_new_write.isra.19+0x570/0x8c0 drivers/scsi/sg.c:775\n sg_ioctl_common+0x14d6/0x2710 drivers/scsi/sg.c:941\n sg_ioctl+0xa2/0x180 drivers/scsi/sg.c:1166\n __x64_sys_ioctl+0x19d/0x220 fs/ioctl.c:52\n do_syscall_64+0x3a/0x80 arch/x86/entry/common.c:50\n entry_SYSCALL_64_after_hwframe+0x44/0xae arch/x86/entry/entry_64.S:113",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47576",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38349",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\neventpoll: don't decrement ep refcount while still holding the ep mutex\n\nJann Horn points out that epoll is decrementing the ep refcount and then\ndoing a\n\n    mutex_unlock(&ep->mtx);\n\nafterwards. That's very wrong, because it can lead to a use-after-free.\n\nThat pattern is actually fine for the very last reference, because the\ncode in question will delay the actual call to \"ep_free(ep)\" until after\nit has unlocked the mutex.\n\nBut it's wrong for the much subtler \"next to last\" case when somebody\n*else* may also be dropping their reference and free the ep while we're\nstill using the mutex.\n\nNote that this is true even if that other user is also using the same ep\nmutex: mutexes, unlike spinlocks, can not be used for object ownership,\neven if they guarantee mutual exclusion.\n\nA mutex \"unlock\" operation is not atomic, and as one user is still\naccessing the mutex as part of unlocking it, another user can come in\nand get the now released mutex and free the data structure while the\nfirst user is still cleaning up.\n\nSee our mutex documentation in Documentation/locking/mutex-design.rst,\nin particular the section [1] about semantics:\n\n\t\"mutex_unlock() may access the mutex structure even after it has\n\t internally released the lock already - so it's not safe for\n\t another context to acquire the mutex and assume that the\n\t mutex_unlock() context is not using the structure anymore\"\n\nSo if we drop our ep ref before the mutex unlock, but we weren't the\nlast one, we may then unlock the mutex, another user comes in, drops\n_their_ reference and releases the 'ep' as it now has no users - all\nwhile the mutex_unlock() is still accessing it.\n\nFix this by simply moving the ep refcount dropping to outside the mutex:\nthe refcount itself is atomic, and doesn't need mutex protection (that's\nthe whole _point_ of refcounts: unlike mutexes, they are inherently\nabout object lifetimes).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38349",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-18",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-38588",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix possible use-after-free issue in ftrace_location()\n\nKASAN reports a bug:\n\n  BUG: KASAN: use-after-free in ftrace_location+0x90/0x120\n  Read of size 8 at addr ffff888141d40010 by task insmod/424\n  CPU: 8 PID: 424 Comm: insmod Tainted: G        W          6.9.0-rc2+\n  [...]\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x68/0xa0\n   print_report+0xcf/0x610\n   kasan_report+0xb5/0xe0\n   ftrace_location+0x90/0x120\n   register_kprobe+0x14b/0xa40\n   kprobe_init+0x2d/0xff0 [kprobe_example]\n   do_one_initcall+0x8f/0x2d0\n   do_init_module+0x13a/0x3c0\n   load_module+0x3082/0x33d0\n   init_module_from_file+0xd2/0x130\n   __x64_sys_finit_module+0x306/0x440\n   do_syscall_64+0x68/0x140\n   entry_SYSCALL_64_after_hwframe+0x71/0x79\n\nThe root cause is that, in lookup_rec(), ftrace record of some address\nis being searched in ftrace pages of some module, but those ftrace pages\nat the same time is being freed in ftrace_release_mod() as the\ncorresponding module is being deleted:\n\n           CPU1                       |      CPU2\n  register_kprobes() {                | delete_module() {\n    check_kprobe_address_safe() {     |\n      arch_check_ftrace_location() {  |\n        ftrace_location() {           |\n          lookup_rec() // USE!        |   ftrace_release_mod() // Free!\n\nTo fix this issue:\n  1. Hold rcu lock as accessing ftrace pages in ftrace_location_range();\n  2. Use ftrace_location_range() instead of lookup_rec() in\n     ftrace_location();\n  3. Call synchronize_rcu() before freeing any ftrace pages both in\n     ftrace_process_locs()/ftrace_release_mod()/ftrace_free_mem().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38588",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-44974",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: pm: avoid possible UaF when selecting endp\n\nselect_local_address() and select_signal_address() both select an\nendpoint entry from the list inside an RCU protected section, but return\na reference to it, to be read later on. If the entry is dereferenced\nafter the RCU unlock, reading info could cause a Use-after-Free.\n\nA simple solution is to copy the required info while inside the RCU\nprotected section to avoid any risk of UaF later. The address ID might\nneed to be modified later to handle the ID0 case later, so a copy seems\nOK to deal with.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44974",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57798",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req()\n\nWhile receiving an MST up request message from one thread in\ndrm_dp_mst_handle_up_req(), the MST topology could be removed from\nanother thread via drm_dp_mst_topology_mgr_set_mst(false), freeing\nmst_primary and setting drm_dp_mst_topology_mgr::mst_primary to NULL.\nThis could lead to a NULL deref/use-after-free of mst_primary in\ndrm_dp_mst_handle_up_req().\n\nAvoid the above by holding a reference for mst_primary in\ndrm_dp_mst_handle_up_req() while it's used.\n\nv2: Fix kfreeing the request if getting an mst_primary reference fails.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57798",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50150",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: altmode should keep reference to parent\n\nThe altmode device release refers to its parent device, but without keeping\na reference to it.\n\nWhen registering the altmode, get a reference to the parent and put it in\nthe release function.\n\nBefore this fix, when using CONFIG_DEBUG_KOBJECT_RELEASE, we see issues\nlike this:\n\n[   43.572860] kobject: 'port0.0' (ffff8880057ba008): kobject_release, parent 0000000000000000 (delayed 3000)\n[   43.573532] kobject: 'port0.1' (ffff8880057bd008): kobject_release, parent 0000000000000000 (delayed 1000)\n[   43.574407] kobject: 'port0' (ffff8880057b9008): kobject_release, parent 0000000000000000 (delayed 3000)\n[   43.575059] kobject: 'port1.0' (ffff8880057ca008): kobject_release, parent 0000000000000000 (delayed 4000)\n[   43.575908] kobject: 'port1.1' (ffff8880057c9008): kobject_release, parent 0000000000000000 (delayed 4000)\n[   43.576908] kobject: 'typec' (ffff8880062dbc00): kobject_release, parent 0000000000000000 (delayed 4000)\n[   43.577769] kobject: 'port1' (ffff8880057bf008): kobject_release, parent 0000000000000000 (delayed 3000)\n[   46.612867] ==================================================================\n[   46.613402] BUG: KASAN: slab-use-after-free in typec_altmode_release+0x38/0x129\n[   46.614003] Read of size 8 at addr ffff8880057b9118 by task kworker/2:1/48\n[   46.614538]\n[   46.614668] CPU: 2 UID: 0 PID: 48 Comm: kworker/2:1 Not tainted 6.12.0-rc1-00138-gedbae730ad31 #535\n[   46.615391] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014\n[   46.616042] Workqueue: events kobject_delayed_cleanup\n[   46.616446] Call Trace:\n[   46.616648]  <TASK>\n[   46.616820]  dump_stack_lvl+0x5b/0x7c\n[   46.617112]  ? typec_altmode_release+0x38/0x129\n[   46.617470]  print_report+0x14c/0x49e\n[   46.617769]  ? rcu_read_unlock_sched+0x56/0x69\n[   46.618117]  ? __virt_addr_valid+0x19a/0x1ab\n[   46.618456]  ? kmem_cache_debug_flags+0xc/0x1d\n[   46.618807]  ? typec_altmode_release+0x38/0x129\n[   46.619161]  kasan_report+0x8d/0xb4\n[   46.619447]  ? typec_altmode_release+0x38/0x129\n[   46.619809]  ? process_scheduled_works+0x3cb/0x85f\n[   46.620185]  typec_altmode_release+0x38/0x129\n[   46.620537]  ? process_scheduled_works+0x3cb/0x85f\n[   46.620907]  device_release+0xaf/0xf2\n[   46.621206]  kobject_delayed_cleanup+0x13b/0x17a\n[   46.621584]  process_scheduled_works+0x4f6/0x85f\n[   46.621955]  ? __pfx_process_scheduled_works+0x10/0x10\n[   46.622353]  ? hlock_class+0x31/0x9a\n[   46.622647]  ? lock_acquired+0x361/0x3c3\n[   46.622956]  ? move_linked_works+0x46/0x7d\n[   46.623277]  worker_thread+0x1ce/0x291\n[   46.623582]  ? __kthread_parkme+0xc8/0xdf\n[   46.623900]  ? __pfx_worker_thread+0x10/0x10\n[   46.624236]  kthread+0x17e/0x190\n[   46.624501]  ? kthread+0xfb/0x190\n[   46.624756]  ? __pfx_kthread+0x10/0x10\n[   46.625015]  ret_from_fork+0x20/0x40\n[   46.625268]  ? __pfx_kthread+0x10/0x10\n[   46.625532]  ret_from_fork_asm+0x1a/0x30\n[   46.625805]  </TASK>\n[   46.625953]\n[   46.626056] Allocated by task 678:\n[   46.626287]  kasan_save_stack+0x24/0x44\n[   46.626555]  kasan_save_track+0x14/0x2d\n[   46.626811]  __kasan_kmalloc+0x3f/0x4d\n[   46.627049]  __kmalloc_noprof+0x1bf/0x1f0\n[   46.627362]  typec_register_port+0x23/0x491\n[   46.627698]  cros_typec_probe+0x634/0xbb6\n[   46.628026]  platform_probe+0x47/0x8c\n[   46.628311]  really_probe+0x20a/0x47d\n[   46.628605]  device_driver_attach+0x39/0x72\n[   46.628940]  bind_store+0x87/0xd7\n[   46.629213]  kernfs_fop_write_iter+0x1aa/0x218\n[   46.629574]  vfs_write+0x1d6/0x29b\n[   46.629856]  ksys_write+0xcd/0x13b\n[   46.630128]  do_syscall_64+0xd4/0x139\n[   46.630420]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[   46.630820]\n[   46.630946] Freed by task 48:\n[   46.631182]  kasan_save_stack+0x24/0x44\n[   46.631493]  kasan_save_track+0x14/0x2d\n[   46.631799]  kasan_save_free_info+0x3f/0x4d\n[   46.632144]  __kasan_slab_free+0x37/0x45\n[   46.632474]\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50150",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-07",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56570",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\novl: Filter invalid inodes with missing lookup function\n\nAdd a check to the ovl_dentry_weird() function to prevent the\nprocessing of directory inodes that lack the lookup function.\nThis is important because such inodes can cause errors in overlayfs\nwhen passed to the lowerstack.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56570",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49882",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix double brelse() the buffer of the extents path\n\nIn ext4_ext_try_to_merge_up(), set path[1].p_bh to NULL after it has been\nreleased, otherwise it may be released twice. An example of what triggers\nthis is as follows:\n\n  split2    map    split1\n|--------|-------|--------|\n\next4_ext_map_blocks\n ext4_ext_handle_unwritten_extents\n  ext4_split_convert_extents\n   // path->p_depth == 0\n   ext4_split_extent\n     // 1. do split1\n     ext4_split_extent_at\n       |ext4_ext_insert_extent\n       |  ext4_ext_create_new_leaf\n       |    ext4_ext_grow_indepth\n       |      le16_add_cpu(&neh->eh_depth, 1)\n       |    ext4_find_extent\n       |      // return -ENOMEM\n       |// get error and try zeroout\n       |path = ext4_find_extent\n       |  path->p_depth = 1\n       |ext4_ext_try_to_merge\n       |  ext4_ext_try_to_merge_up\n       |    path->p_depth = 0\n       |    brelse(path[1].p_bh)  ---> not set to NULL here\n       |// zeroout success\n     // 2. update path\n     ext4_find_extent\n     // 3. do split2\n     ext4_split_extent_at\n       ext4_ext_insert_extent\n         ext4_ext_create_new_leaf\n           ext4_ext_grow_indepth\n             le16_add_cpu(&neh->eh_depth, 1)\n           ext4_find_extent\n             path[0].p_bh = NULL;\n             path->p_depth = 1\n             read_extent_tree_block  ---> return err\n             // path[1].p_bh is still the old value\n             ext4_free_ext_path\n               ext4_ext_drop_refs\n                 // path->p_depth == 1\n                 brelse(path[1].p_bh)  ---> brelse a buffer twice\n\nFinally got the following WARRNING when removing the buffer from lru:\n\n============================================\nVFS: brelse: Trying to free free buffer\nWARNING: CPU: 2 PID: 72 at fs/buffer.c:1241 __brelse+0x58/0x90\nCPU: 2 PID: 72 Comm: kworker/u19:1 Not tainted 6.9.0-dirty #716\nRIP: 0010:__brelse+0x58/0x90\nCall Trace:\n <TASK>\n __find_get_block+0x6e7/0x810\n bdev_getblk+0x2b/0x480\n __ext4_get_inode_loc+0x48a/0x1240\n ext4_get_inode_loc+0xb2/0x150\n ext4_reserve_inode_write+0xb7/0x230\n __ext4_mark_inode_dirty+0x144/0x6a0\n ext4_ext_insert_extent+0x9c8/0x3230\n ext4_ext_map_blocks+0xf45/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n============================================",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49882",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49410",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Fix potential double free in create_var_ref()\n\nIn create_var_ref(), init_var_ref() is called to initialize the fields\nof variable ref_field, which is allocated in the previous function call\nto create_hist_field(). Function init_var_ref() allocates the\ncorresponding fields such as ref_field->system, but frees these fields\nwhen the function encounters an error. The caller later calls\ndestroy_hist_field() to conduct error handling, which frees the fields\nand the variable itself. This results in double free of the fields which\nare already freed in the previous function.\n\nFix this by storing NULL to the corresponding fields when they are freed\nin init_var_ref().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49410",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49960",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix timer use-after-free on failed mount\n\nSyzbot has found an ODEBUG bug in ext4_fill_super\n\nThe del_timer_sync function cancels the s_err_report timer,\nwhich reminds about filesystem errors daily. We should\nguarantee the timer is no longer active before kfree(sbi).\n\nWhen filesystem mounting fails, the flow goes to failed_mount3,\nwhere an error occurs when ext4_stop_mmpd is called, causing\na read I/O failure. This triggers the ext4_handle_error function\nthat ultimately re-arms the timer,\nleaving the s_err_report timer active before kfree(sbi) is called.\n\nFix the issue by canceling the s_err_report timer after calling ext4_stop_mmpd.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49960",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49950",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix uaf in l2cap_connect\n\n[Syzbot reported]\nBUG: KASAN: slab-use-after-free in l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949\nRead of size 8 at addr ffff8880241e9800 by task kworker/u9:0/54\n\nCPU: 0 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-00268-g788220eee30d #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nWorkqueue: hci2 hci_rx_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0xc3/0x620 mm/kasan/report.c:488\n kasan_report+0xd9/0x110 mm/kasan/report.c:601\n l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949\n l2cap_connect_req net/bluetooth/l2cap_core.c:4080 [inline]\n l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:4772 [inline]\n l2cap_sig_channel net/bluetooth/l2cap_core.c:5543 [inline]\n l2cap_recv_frame+0xf0b/0x8eb0 net/bluetooth/l2cap_core.c:6825\n l2cap_recv_acldata+0x9b4/0xb70 net/bluetooth/l2cap_core.c:7514\n hci_acldata_packet net/bluetooth/hci_core.c:3791 [inline]\n hci_rx_work+0xaab/0x1610 net/bluetooth/hci_core.c:4028\n process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231\n process_scheduled_works kernel/workqueue.c:3312 [inline]\n worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389\n kthread+0x2c1/0x3a0 kernel/kthread.c:389\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n...\n\nFreed by task 5245:\n kasan_save_stack+0x33/0x60 mm/kasan/common.c:47\n kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:579\n poison_slab_object+0xf7/0x160 mm/kasan/common.c:240\n __kasan_slab_free+0x32/0x50 mm/kasan/common.c:256\n kasan_slab_free include/linux/kasan.h:184 [inline]\n slab_free_hook mm/slub.c:2256 [inline]\n slab_free mm/slub.c:4477 [inline]\n kfree+0x12a/0x3b0 mm/slub.c:4598\n l2cap_conn_free net/bluetooth/l2cap_core.c:1810 [inline]\n kref_put include/linux/kref.h:65 [inline]\n l2cap_conn_put net/bluetooth/l2cap_core.c:1822 [inline]\n l2cap_conn_del+0x59d/0x730 net/bluetooth/l2cap_core.c:1802\n l2cap_connect_cfm+0x9e6/0xf80 net/bluetooth/l2cap_core.c:7241\n hci_connect_cfm include/net/bluetooth/hci_core.h:1960 [inline]\n hci_conn_failed+0x1c3/0x370 net/bluetooth/hci_conn.c:1265\n hci_abort_conn_sync+0x75a/0xb50 net/bluetooth/hci_sync.c:5583\n abort_conn_sync+0x197/0x360 net/bluetooth/hci_conn.c:2917\n hci_cmd_sync_work+0x1a4/0x410 net/bluetooth/hci_sync.c:328\n process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231\n process_scheduled_works kernel/workqueue.c:3312 [inline]\n worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389\n kthread+0x2c1/0x3a0 kernel/kthread.c:389\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49950",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21761",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nopenvswitch: use RCU protection in ovs_vport_cmd_fill_info()\n\novs_vport_cmd_fill_info() can be called without RTNL or RCU.\n\nUse RCU protection and dev_net_rcu() to avoid potential UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21761",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50401",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: under NFSv4.1, fix double svc_xprt_put on rpc_create failure\n\nOn error situation `clp->cl_cb_conn.cb_xprt` should not be given\na reference to the xprt otherwise both client cleanup and the\nerror handling path of the caller call to put it. Better to\ndelay handing over the reference to a later branch.\n\n[   72.530665] refcount_t: underflow; use-after-free.\n[   72.531933] WARNING: CPU: 0 PID: 173 at lib/refcount.c:28 refcount_warn_saturate+0xcf/0x120\n[   72.533075] Modules linked in: nfsd(OE) nfsv4(OE) nfsv3(OE) nfs(OE) lockd(OE) compat_nfs_ssc(OE) nfs_acl(OE) rpcsec_gss_krb5(OE) auth_rpcgss(OE) rpcrdma(OE) dns_resolver fscache netfs grace rdma_cm iw_cm ib_cm sunrpc(OE) mlx5_ib mlx5_core mlxfw pci_hyperv_intf ib_uverbs ib_core xt_MASQUERADE nf_conntrack_netlink nft_counter xt_addrtype nft_compat br_netfilter bridge stp llc nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set overlay nf_tables nfnetlink crct10dif_pclmul crc32_pclmul ghash_clmulni_intel xfs serio_raw virtio_net virtio_blk net_failover failover fuse [last unloaded: sunrpc]\n[   72.540389] CPU: 0 PID: 173 Comm: kworker/u16:5 Tainted: G           OE     5.15.82-dan #1\n[   72.541511] Hardware name: Red Hat KVM/RHEL-AV, BIOS 1.16.0-3.module+el8.7.0+1084+97b81f61 04/01/2014\n[   72.542717] Workqueue: nfsd4_callbacks nfsd4_run_cb_work [nfsd]\n[   72.543575] RIP: 0010:refcount_warn_saturate+0xcf/0x120\n[   72.544299] Code: 55 00 0f 0b 5d e9 01 50 98 00 80 3d 75 9e 39 08 00 0f 85 74 ff ff ff 48 c7 c7 e8 d1 60 8e c6 05 61 9e 39 08 01 e8 f6 51 55 00 <0f> 0b 5d e9 d9 4f 98 00 80 3d 4b 9e 39 08 00 0f 85 4c ff ff ff 48\n[   72.546666] RSP: 0018:ffffb3f841157cf0 EFLAGS: 00010286\n[   72.547393] RAX: 0000000000000026 RBX: ffff89ac6231d478 RCX: 0000000000000000\n[   72.548324] RDX: ffff89adb7c2c2c0 RSI: ffff89adb7c205c0 RDI: ffff89adb7c205c0\n[   72.549271] RBP: ffffb3f841157cf0 R08: 0000000000000000 R09: c0000000ffefffff\n[   72.550209] R10: 0000000000000001 R11: ffffb3f841157ad0 R12: ffff89ac6231d180\n[   72.551142] R13: ffff89ac6231d478 R14: ffff89ac40c06180 R15: ffff89ac6231d4b0\n[   72.552089] FS:  0000000000000000(0000) GS:ffff89adb7c00000(0000) knlGS:0000000000000000\n[   72.553175] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   72.553934] CR2: 0000563a310506a8 CR3: 0000000109a66000 CR4: 0000000000350ef0\n[   72.554874] Call Trace:\n[   72.555278]  <TASK>\n[   72.555614]  svc_xprt_put+0xaf/0xe0 [sunrpc]\n[   72.556276]  nfsd4_process_cb_update.isra.11+0xb7/0x410 [nfsd]\n[   72.557087]  ? update_load_avg+0x82/0x610\n[   72.557652]  ? cpuacct_charge+0x60/0x70\n[   72.558212]  ? dequeue_entity+0xdb/0x3e0\n[   72.558765]  ? queued_spin_unlock+0x9/0x20\n[   72.559358]  nfsd4_run_cb_work+0xfc/0x270 [nfsd]\n[   72.560031]  process_one_work+0x1df/0x390\n[   72.560600]  worker_thread+0x37/0x3b0\n[   72.561644]  ? process_one_work+0x390/0x390\n[   72.562247]  kthread+0x12f/0x150\n[   72.562710]  ? set_kthread_struct+0x50/0x50\n[   72.563309]  ret_from_fork+0x22/0x30\n[   72.563818]  </TASK>\n[   72.564189] ---[ end trace 031117b1c72ec616 ]---\n[   72.566019] list_add corruption. next->prev should be prev (ffff89ac4977e538), but was ffff89ac4763e018. (next=ffff89ac4763e018).\n[   72.567647] ------------[ cut here ]------------",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50401",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47014",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_ct: fix wild memory access when clearing fragments\n\nwhile testing re-assembly/re-fragmentation using act_ct, it's possible to\nobserve a crash like the following one:\n\n KASAN: maybe wild-memory-access in range [0x0001000000000448-0x000100000000044f]\n CPU: 50 PID: 0 Comm: swapper/50 Tainted: G S                5.12.0-rc7+ #424\n Hardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017\n RIP: 0010:inet_frag_rbtree_purge+0x50/0xc0\n Code: 00 fc ff df 48 89 c3 31 ed 48 89 df e8 a9 7a 38 ff 4c 89 fe 48 89 df 49 89 c6 e8 5b 3a 38 ff 48 8d 7b 40 48 89 f8 48 c1 e8 03 <42> 80 3c 20 00 75 59 48 8d bb d0 00 00 00 4c 8b 6b 40 48 89 f8 48\n RSP: 0018:ffff888c31449db8 EFLAGS: 00010203\n RAX: 0000200000000089 RBX: 000100000000040e RCX: ffffffff989eb960\n RDX: 0000000000000140 RSI: ffffffff97cfb977 RDI: 000100000000044e\n RBP: 0000000000000900 R08: 0000000000000000 R09: ffffed1186289350\n R10: 0000000000000003 R11: ffffed1186289350 R12: dffffc0000000000\n R13: 000100000000040e R14: 0000000000000000 R15: ffff888155e02160\n FS:  0000000000000000(0000) GS:ffff888c31440000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00005600cb70a5b8 CR3: 0000000a2c014005 CR4: 00000000003706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <IRQ>\n  inet_frag_destroy+0xa9/0x150\n  call_timer_fn+0x2d/0x180\n  run_timer_softirq+0x4fe/0xe70\n  __do_softirq+0x197/0x5a0\n  irq_exit_rcu+0x1de/0x200\n  sysvec_apic_timer_interrupt+0x6b/0x80\n  </IRQ>\n\nwhen act_ct temporarily stores an IP fragment, restoring the skb qdisc cb\nresults in putting random data in FRAG_CB(), and this causes those \"wild\"\nmemory accesses later, when the rbtree is purged. Never overwrite the skb\ncb in case tcf_ct_handle_fragments() returns -EINPROGRESS.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47014",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-46738",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nVMCI: Fix use-after-free when removing resource in vmci_resource_remove()\n\nWhen removing a resource from vmci_resource_table in\nvmci_resource_remove(), the search is performed using the resource\nhandle by comparing context and resource fields.\n\nIt is possible though to create two resources with different types\nbut same handle (same context and resource fields).\n\nWhen trying to remove one of the resources, vmci_resource_remove()\nmay not remove the intended one, but the object will still be freed\nas in the case of the datagram type in vmci_datagram_destroy_handle().\nvmci_resource_table will still hold a pointer to this freed resource\nleading to a use-after-free vulnerability.\n\nBUG: KASAN: use-after-free in vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline]\nBUG: KASAN: use-after-free in vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147\nRead of size 4 at addr ffff88801c16d800 by task syz-executor197/1592\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x82/0xa9 lib/dump_stack.c:106\n print_address_description.constprop.0+0x21/0x366 mm/kasan/report.c:239\n __kasan_report.cold+0x7f/0x132 mm/kasan/report.c:425\n kasan_report+0x38/0x51 mm/kasan/report.c:442\n vmci_handle_is_equal include/linux/vmw_vmci_defs.h:142 [inline]\n vmci_resource_remove+0x3a1/0x410 drivers/misc/vmw_vmci/vmci_resource.c:147\n vmci_qp_broker_detach+0x89a/0x11b9 drivers/misc/vmw_vmci/vmci_queue_pair.c:2182\n ctx_free_ctx+0x473/0xbe1 drivers/misc/vmw_vmci/vmci_context.c:444\n kref_put include/linux/kref.h:65 [inline]\n vmci_ctx_put drivers/misc/vmw_vmci/vmci_context.c:497 [inline]\n vmci_ctx_destroy+0x170/0x1d6 drivers/misc/vmw_vmci/vmci_context.c:195\n vmci_host_close+0x125/0x1ac drivers/misc/vmw_vmci/vmci_host.c:143\n __fput+0x261/0xa34 fs/file_table.c:282\n task_work_run+0xf0/0x194 kernel/task_work.c:164\n tracehook_notify_resume include/linux/tracehook.h:189 [inline]\n exit_to_user_mode_loop+0x184/0x189 kernel/entry/common.c:187\n exit_to_user_mode_prepare+0x11b/0x123 kernel/entry/common.c:220\n __syscall_exit_to_user_mode_work kernel/entry/common.c:302 [inline]\n syscall_exit_to_user_mode+0x18/0x42 kernel/entry/common.c:313\n do_syscall_64+0x41/0x85 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x6e/0x0\n\nThis change ensures the type is also checked when removing\nthe resource from vmci_resource_table in vmci_resource_remove().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46738",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26930",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix double free of the ha->vp_map pointer\n\nCoverity scan reported potential risk of double free of the pointer\nha->vp_map.  ha->vp_map was freed in qla2x00_mem_alloc(), and again freed\nin function qla2x00_mem_free(ha).\n\nAssign NULL to vp_map and kfree take care of NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26930",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-01",
                    "modification_date": "2025-03-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38024",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix slab-use-after-free Read in rxe_queue_cleanup bug\n\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x7d/0xa0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xcf/0x610 mm/kasan/report.c:489\n kasan_report+0xb5/0xe0 mm/kasan/report.c:602\n rxe_queue_cleanup+0xd0/0xe0 drivers/infiniband/sw/rxe/rxe_queue.c:195\n rxe_cq_cleanup+0x3f/0x50 drivers/infiniband/sw/rxe/rxe_cq.c:132\n __rxe_cleanup+0x168/0x300 drivers/infiniband/sw/rxe/rxe_pool.c:232\n rxe_create_cq+0x22e/0x3a0 drivers/infiniband/sw/rxe/rxe_verbs.c:1109\n create_cq+0x658/0xb90 drivers/infiniband/core/uverbs_cmd.c:1052\n ib_uverbs_create_cq+0xc7/0x120 drivers/infiniband/core/uverbs_cmd.c:1095\n ib_uverbs_write+0x969/0xc90 drivers/infiniband/core/uverbs_main.c:679\n vfs_write fs/read_write.c:677 [inline]\n vfs_write+0x26a/0xcc0 fs/read_write.c:659\n ksys_write+0x1b8/0x200 fs/read_write.c:731\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xaa/0x1b0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nIn the function rxe_create_cq, when rxe_cq_from_init fails, the function\nrxe_cleanup will be called to handle the allocated resources. In fact,\nsome memory resources have already been freed in the function\nrxe_cq_from_init. Thus, this problem will occur.\n\nThe solution is to let rxe_cleanup do all the work.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38024",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-12-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47506",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: fix use-after-free due to delegation race\n\nA delegation break could arrive as soon as we've called vfs_setlease.  A\ndelegation break runs a callback which immediately (in\nnfsd4_cb_recall_prepare) adds the delegation to del_recall_lru.  If we\nthen exit nfs4_set_delegation without hashing the delegation, it will be\nfreed as soon as the callback is done with it, without ever being\nremoved from del_recall_lru.\n\nSymptoms show up later as use-after-free or list corruption warnings,\nusually in the laundromat thread.\n\nI suspect aba2072f4523 \"nfsd: grant read delegations to clients holding\nwrites\" made this bug easier to hit, but I looked as far back as v3.0\nand it looks to me it already had the same problem.  So I'm not sure\nwhere the bug was introduced; it may have been there from the beginning.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47506",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53184",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64/sme: Set new vector length before reallocating\n\nAs part of fixing the allocation of the buffer for SVE state when changing\nSME vector length we introduced an immediate reallocation of the SVE state,\nthis is also done when changing the SVE vector length for consistency.\nUnfortunately this reallocation is done prior to writing the new vector\nlength to the task struct, meaning the allocation is done with the old\nvector length and can lead to memory corruption due to an undersized buffer\nbeing used.\n\nMove the update of the vector length before the allocation to ensure that\nthe new vector length is taken into account.\n\nFor some reason this isn't triggering any problems when running tests on\nthe arm64 fixes branch (even after repeated tries) but is triggering\nissues very often after merge into mainline.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53184",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-39480",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkdb: Fix buffer overflow during tab-complete\n\nCurrently, when the user attempts symbol completion with the Tab key, kdb\nwill use strncpy() to insert the completed symbol into the command buffer.\nUnfortunately it passes the size of the source buffer rather than the\ndestination to strncpy() with predictably horrible results. Most obviously\nif the command buffer is already full but cp, the cursor position, is in\nthe middle of the buffer, then we will write past the end of the supplied\nbuffer.\n\nFix this by replacing the dubious strncpy() calls with memmove()/memcpy()\ncalls plus explicit boundary checks to make sure we have enough space\nbefore we start moving characters around.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-39480",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-05",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50252",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Do not free q_vector unless new one was allocated\n\nAvoid potential use-after-free condition under memory pressure. If the\nkzalloc() fails, q_vector will be freed but left in the original\nadapter->q_vector[v_idx] array position.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50252",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-11-26",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-0562",
                    "description": "A use-after-free flaw was found in the Linux Kernel. When a disk is removed, bdi_unregister is called to stop further write-back and waits for associated delayed work to complete. However, wb_inode_writeback_end() may schedule bandwidth estimation work after this has completed, which can result in the timer attempting to access the recently freed bdi_writeback.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-0562",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-01-15",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49667",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bonding: fix use-after-free after 802.3ad slave unbind\n\ncommit 0622cab0341c (\"bonding: fix 802.3ad aggregator reselection\"),\nresolve case, when there is several aggregation groups in the same bond.\nbond_3ad_unbind_slave will invalidate (clear) aggregator when\n__agg_active_ports return zero. So, ad_clear_agg can be executed even, when\nnum_of_ports!=0. Than bond_3ad_unbind_slave can be executed again for,\npreviously cleared aggregator. NOTE: at this time bond_3ad_unbind_slave\nwill not update slave ports list, because lag_ports==NULL. So, here we\ngot slave ports, pointing to freed aggregator memory.\n\nFix with checking actual number of ports in group (as was before\ncommit 0622cab0341c (\"bonding: fix 802.3ad aggregator reselection\") ),\nbefore ad_clear_agg().\n\nThe KASAN logs are as follows:\n\n[  767.617392] ==================================================================\n[  767.630776] BUG: KASAN: use-after-free in bond_3ad_state_machine_handler+0x13dc/0x1470\n[  767.638764] Read of size 2 at addr ffff00011ba9d430 by task kworker/u8:7/767\n[  767.647361] CPU: 3 PID: 767 Comm: kworker/u8:7 Tainted: G           O 5.15.11 #15\n[  767.655329] Hardware name: DNI AmazonGo1 A7040 board (DT)\n[  767.660760] Workqueue: lacp_1 bond_3ad_state_machine_handler\n[  767.666468] Call trace:\n[  767.668930]  dump_backtrace+0x0/0x2d0\n[  767.672625]  show_stack+0x24/0x30\n[  767.675965]  dump_stack_lvl+0x68/0x84\n[  767.679659]  print_address_description.constprop.0+0x74/0x2b8\n[  767.685451]  kasan_report+0x1f0/0x260\n[  767.689148]  __asan_load2+0x94/0xd0\n[  767.692667]  bond_3ad_state_machine_handler+0x13dc/0x1470",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49667",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49076",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/hfi1: Fix use-after-free bug for mm struct\n\nUnder certain conditions, such as MPI_Abort, the hfi1 cleanup code may\nrepresent the last reference held on the task mm.\nhfi1_mmu_rb_unregister() then drops the last reference and the mm is freed\nbefore the final use in hfi1_release_user_pages().  A new task may\nallocate the mm structure while it is still being used, resulting in\nproblems. One manifestation is corruption of the mmap_sem counter leading\nto a hang in down_write().  Another is corruption of an mm struct that is\nin use by another task.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49076",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49082",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpt3sas: Fix use after free in _scsih_expander_node_remove()\n\nThe function mpt3sas_transport_port_remove() called in\n_scsih_expander_node_remove() frees the port field of the sas_expander\nstructure, leading to the following use-after-free splat from KASAN when\nthe ioc_info() call following that function is executed (e.g. when doing\nrmmod of the driver module):\n\n[ 3479.371167] ==================================================================\n[ 3479.378496] BUG: KASAN: use-after-free in _scsih_expander_node_remove+0x710/0x750 [mpt3sas]\n[ 3479.386936] Read of size 1 at addr ffff8881c037691c by task rmmod/1531\n[ 3479.393524]\n[ 3479.395035] CPU: 18 PID: 1531 Comm: rmmod Not tainted 5.17.0-rc8+ #1436\n[ 3479.401712] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.1 06/02/2021\n[ 3479.409263] Call Trace:\n[ 3479.411743]  <TASK>\n[ 3479.413875]  dump_stack_lvl+0x45/0x59\n[ 3479.417582]  print_address_description.constprop.0+0x1f/0x120\n[ 3479.423389]  ? _scsih_expander_node_remove+0x710/0x750 [mpt3sas]\n[ 3479.429469]  kasan_report.cold+0x83/0xdf\n[ 3479.433438]  ? _scsih_expander_node_remove+0x710/0x750 [mpt3sas]\n[ 3479.439514]  _scsih_expander_node_remove+0x710/0x750 [mpt3sas]\n[ 3479.445411]  ? _raw_spin_unlock_irqrestore+0x2d/0x40\n[ 3479.452032]  scsih_remove+0x525/0xc90 [mpt3sas]\n[ 3479.458212]  ? mpt3sas_expander_remove+0x1d0/0x1d0 [mpt3sas]\n[ 3479.465529]  ? down_write+0xde/0x150\n[ 3479.470746]  ? up_write+0x14d/0x460\n[ 3479.475840]  ? kernfs_find_ns+0x137/0x310\n[ 3479.481438]  pci_device_remove+0x65/0x110\n[ 3479.487013]  __device_release_driver+0x316/0x680\n[ 3479.493180]  driver_detach+0x1ec/0x2d0\n[ 3479.498499]  bus_remove_driver+0xe7/0x2d0\n[ 3479.504081]  pci_unregister_driver+0x26/0x250\n[ 3479.510033]  _mpt3sas_exit+0x2b/0x6cf [mpt3sas]\n[ 3479.516144]  __x64_sys_delete_module+0x2fd/0x510\n[ 3479.522315]  ? free_module+0xaa0/0xaa0\n[ 3479.527593]  ? __cond_resched+0x1c/0x90\n[ 3479.532951]  ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n[ 3479.539607]  ? syscall_enter_from_user_mode+0x21/0x70\n[ 3479.546161]  ? trace_hardirqs_on+0x1c/0x110\n[ 3479.551828]  do_syscall_64+0x35/0x80\n[ 3479.556884]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[ 3479.563402] RIP: 0033:0x7f1fc482483b\n...\n[ 3479.943087] ==================================================================\n\nFix this by introducing the local variable port_id to store the port ID\nvalue before executing mpt3sas_transport_port_remove(). This local variable\nis then used in the call to ioc_info() instead of dereferencing the freed\nport structure.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49082",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36012",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: msft: fix slab-use-after-free in msft_do_close()\n\nTying the msft->data lifetime to hdev by freeing it in\nhci_release_dev() to fix the following case:\n\n[use]\nmsft_do_close()\n  msft = hdev->msft_data;\n  if (!msft)                      ...(1) <- passed.\n    return;\n  mutex_lock(&msft->filter_lock); ...(4) <- used after freed.\n\n[free]\nmsft_unregister()\n  msft = hdev->msft_data;\n  hdev->msft_data = NULL;         ...(2)\n  kfree(msft);                    ...(3) <- msft is freed.\n\n==================================================================\nBUG: KASAN: slab-use-after-free in __mutex_lock_common\nkernel/locking/mutex.c:587 [inline]\nBUG: KASAN: slab-use-after-free in __mutex_lock+0x8f/0xc30\nkernel/locking/mutex.c:752\nRead of size 8 at addr ffff888106cbbca8 by task kworker/u5:2/309",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36012",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-23",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-53174",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: make sure cache entry active before cache_show\n\nThe function `c_show` was called with protection from RCU. This only\nensures that `cp` will not be freed. Therefore, the reference count for\n`cp` can drop to zero, which will trigger a refcount use-after-free\nwarning when `cache_get` is called. To resolve this issue, use\n`cache_get_rcu` to ensure that `cp` remains active.\n\n------------[ cut here ]------------\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 7 PID: 822 at lib/refcount.c:25\nrefcount_warn_saturate+0xb1/0x120\nCPU: 7 UID: 0 PID: 822 Comm: cat Not tainted 6.12.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb1/0x120\n\nCall Trace:\n <TASK>\n c_show+0x2fc/0x380 [sunrpc]\n seq_read_iter+0x589/0x770\n seq_read+0x1e5/0x270\n proc_reg_read+0xe1/0x140\n vfs_read+0x125/0x530\n ksys_read+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53174",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49900",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: piix4: Fix adapter not be removed in piix4_remove()\n\nIn piix4_probe(), the piix4 adapter will be registered in:\n\n   piix4_probe()\n     piix4_add_adapters_sb800() / piix4_add_adapter()\n       i2c_add_adapter()\n\nBased on the probed device type, piix4_add_adapters_sb800() or single\npiix4_add_adapter() will be called.\nFor the former case, piix4_adapter_count is set as the number of adapters,\nwhile for antoher case it is not set and kept default *zero*.\n\nWhen piix4 is removed, piix4_remove() removes the adapters added in\npiix4_probe(), basing on the piix4_adapter_count value.\nBecause the count is zero for the single adapter case, the adapter won't\nbe removed and makes the sources allocated for adapter leaked, such as\nthe i2c client and device.\n\nThese sources can still be accessed by i2c or bus and cause problems.\nAn easily reproduced case is that if a new adapter is registered, i2c\nwill get the leaked adapter and try to call smbus_algorithm, which was\nalready freed:\n\nTriggered by: rmmod i2c_piix4 && modprobe max31730\n\n BUG: unable to handle page fault for address: ffffffffc053d860\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n Oops: 0000 [#1] PREEMPT SMP KASAN\n CPU: 0 PID: 3752 Comm: modprobe Tainted: G\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)\n RIP: 0010:i2c_default_probe (drivers/i2c/i2c-core-base.c:2259) i2c_core\n RSP: 0018:ffff888107477710 EFLAGS: 00000246\n ...\n <TASK>\n  i2c_detect (drivers/i2c/i2c-core-base.c:2302) i2c_core\n  __process_new_driver (drivers/i2c/i2c-core-base.c:1336) i2c_core\n  bus_for_each_dev (drivers/base/bus.c:301)\n  i2c_for_each_dev (drivers/i2c/i2c-core-base.c:1823) i2c_core\n  i2c_register_driver (drivers/i2c/i2c-core-base.c:1861) i2c_core\n  do_one_initcall (init/main.c:1296)\n  do_init_module (kernel/module/main.c:2455)\n  ...\n </TASK>\n ---[ end trace 0000000000000000 ]---\n\nFix this problem by correctly set piix4_adapter_count as 1 for the\nsingle adapter so it can be normally removed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49900",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-41087",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nata: libata-core: Fix double free on error\n\nIf e.g. the ata_port_alloc() call in ata_host_alloc() fails, we will jump\nto the err_out label, which will call devres_release_group().\ndevres_release_group() will trigger a call to ata_host_release().\nata_host_release() calls kfree(host), so executing the kfree(host) in\nata_host_alloc() will lead to a double free:\n\nkernel BUG at mm/slub.c:553!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 11 PID: 599 Comm: (udev-worker) Not tainted 6.10.0-rc5 #47\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014\nRIP: 0010:kfree+0x2cf/0x2f0\nCode: 5d 41 5e 41 5f 5d e9 80 d6 ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da\nRSP: 0018:ffffc90000f377f0 EFLAGS: 00010246\nRAX: ffff888112b1f2c0 RBX: ffff888112b1f2c0 RCX: ffff888112b1f320\nRDX: 000000000000400b RSI: ffffffffc02c9de5 RDI: ffff888112b1f2c0\nRBP: ffffc90000f37830 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffc90000f37610 R11: 617461203a736b6e R12: ffffea00044ac780\nR13: ffff888100046400 R14: ffffffffc02c9de5 R15: 0000000000000006\nFS:  00007f2f1cabe980(0000) GS:ffff88813b380000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f2f1c3acf75 CR3: 0000000111724000 CR4: 0000000000750ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __die_body.cold+0x19/0x27\n ? die+0x2e/0x50\n ? do_trap+0xca/0x110\n ? do_error_trap+0x6a/0x90\n ? kfree+0x2cf/0x2f0\n ? exc_invalid_op+0x50/0x70\n ? kfree+0x2cf/0x2f0\n ? asm_exc_invalid_op+0x1a/0x20\n ? ata_host_alloc+0xf5/0x120 [libata]\n ? ata_host_alloc+0xf5/0x120 [libata]\n ? kfree+0x2cf/0x2f0\n ata_host_alloc+0xf5/0x120 [libata]\n ata_host_alloc_pinfo+0x14/0xa0 [libata]\n ahci_init_one+0x6c9/0xd20 [ahci]\n\nEnsure that we will not call kfree(host) twice, by performing the kfree()\nonly if the devres_open_group() call failed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-41087",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-29",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50280",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: fix flushing uninitialized delayed_work on cache_ctr error\n\nAn unexpected WARN_ON from flush_work() may occur when cache creation\nfails, caused by destroying the uninitialized delayed_work waker in the\nerror path of cache_create(). For example, the warning appears on the\nsuperblock checksum error.\n\nReproduce steps:\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc 262144\"\ndd if=/dev/urandom of=/dev/mapper/cmeta bs=4k count=1 oflag=direct\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\nKernel logs:\n\n(snip)\nWARNING: CPU: 0 PID: 84 at kernel/workqueue.c:4178 __flush_work+0x5d4/0x890\n\nFix by pulling out the cancel_delayed_work_sync() from the constructor's\nerror path. This patch doesn't affect the use-after-free fix for\nconcurrent dm_resume and dm_destroy (commit 6a459d8edbdb (\"dm cache: Fix\nUAF in destroy()\")) as cache_dtr is not changed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50280",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-50262",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix out-of-bounds write in trie_get_next_key()\n\ntrie_get_next_key() allocates a node stack with size trie->max_prefixlen,\nwhile it writes (trie->max_prefixlen + 1) nodes to the stack when it has\nfull paths from the root to leaves. For example, consider a trie with\nmax_prefixlen is 8, and the nodes with key 0x00/0, 0x00/1, 0x00/2, ...\n0x00/8 inserted. Subsequent calls to trie_get_next_key with _key with\n.prefixlen = 8 make 9 nodes be written on the node stack with size 8.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50262",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-09",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48991",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/khugepaged: invoke MMU notifiers in shmem/file collapse paths\n\nAny codepath that zaps page table entries must invoke MMU notifiers to\nensure that secondary MMUs (like KVM) don't keep accessing pages which\naren't mapped anymore.  Secondary MMUs don't hold their own references to\npages that are mirrored over, so failing to notify them can lead to page\nuse-after-free.\n\nI'm marking this as addressing an issue introduced in commit f3f0e1d2150b\n(\"khugepaged: add support of collapse for tmpfs/shmem pages\"), but most of\nthe security impact of this only came in commit 27e1f8273113 (\"khugepaged:\nenable collapse pmd for pte-mapped THP\"), which actually omitted flushes\nfor the removal of present PTEs, not just for the removal of empty page\ntables.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48991",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-11-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52621",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Check rcu_read_lock_trace_held() before calling bpf map helpers\n\nThese three bpf_map_{lookup,update,delete}_elem() helpers are also\navailable for sleepable bpf program, so add the corresponding lock\nassertion for sleepable bpf program, otherwise the following warning\nwill be reported when a sleepable bpf program manipulates bpf map under\ninterpreter mode (aka bpf_jit_enable=0):\n\n  WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ......\n  CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......\n  RIP: 0010:bpf_map_lookup_elem+0x54/0x60\n  ......\n  Call Trace:\n   <TASK>\n   ? __warn+0xa5/0x240\n   ? bpf_map_lookup_elem+0x54/0x60\n   ? report_bug+0x1ba/0x1f0\n   ? handle_bug+0x40/0x80\n   ? exc_invalid_op+0x18/0x50\n   ? asm_exc_invalid_op+0x1b/0x20\n   ? __pfx_bpf_map_lookup_elem+0x10/0x10\n   ? rcu_lockdep_current_cpu_online+0x65/0xb0\n   ? rcu_is_watching+0x23/0x50\n   ? bpf_map_lookup_elem+0x54/0x60\n   ? __pfx_bpf_map_lookup_elem+0x10/0x10\n   ___bpf_prog_run+0x513/0x3b70\n   __bpf_prog_run32+0x9d/0xd0\n   ? __bpf_prog_enter_sleepable_recur+0xad/0x120\n   ? __bpf_prog_enter_sleepable_recur+0x3e/0x120\n   bpf_trampoline_6442580665+0x4d/0x1000\n   __x64_sys_getpgid+0x5/0x30\n   ? do_syscall_64+0x36/0xb0\n   entry_SYSCALL_64_after_hwframe+0x6e/0x76\n   </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52621",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-26",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56658",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: defer final 'struct net' free in netns dismantle\n\nIlya reported a slab-use-after-free in dst_destroy [1]\n\nIssue is in xfrm6_net_init() and xfrm4_net_init() :\n\nThey copy xfrm[46]_dst_ops_template into net->xfrm.xfrm[46]_dst_ops.\n\nBut net structure might be freed before all the dst callbacks are\ncalled. So when dst_destroy() calls later :\n\nif (dst->ops->destroy)\n    dst->ops->destroy(dst);\n\ndst->ops points to the old net->xfrm.xfrm[46]_dst_ops, which has been freed.\n\nSee a relevant issue fixed in :\n\nac888d58869b (\"net: do not delay dst_entries_add() in dst_release()\")\n\nA fix is to queue the 'struct net' to be freed after one\nanother cleanup_net() round (and existing rcu_barrier())\n\n[1]\n\nBUG: KASAN: slab-use-after-free in dst_destroy (net/core/dst.c:112)\nRead of size 8 at addr ffff8882137ccab0 by task swapper/37/0\nDec 03 05:46:18 kernel:\nCPU: 37 UID: 0 PID: 0 Comm: swapper/37 Kdump: loaded Not tainted 6.12.0 #67\nHardware name: Red Hat KVM/RHEL, BIOS 1.16.1-1.el9 04/01/2014\nCall Trace:\n <IRQ>\ndump_stack_lvl (lib/dump_stack.c:124)\nprint_address_description.constprop.0 (mm/kasan/report.c:378)\n? dst_destroy (net/core/dst.c:112)\nprint_report (mm/kasan/report.c:489)\n? dst_destroy (net/core/dst.c:112)\n? kasan_addr_to_slab (mm/kasan/common.c:37)\nkasan_report (mm/kasan/report.c:603)\n? dst_destroy (net/core/dst.c:112)\n? rcu_do_batch (kernel/rcu/tree.c:2567)\ndst_destroy (net/core/dst.c:112)\nrcu_do_batch (kernel/rcu/tree.c:2567)\n? __pfx_rcu_do_batch (kernel/rcu/tree.c:2491)\n? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4339 kernel/locking/lockdep.c:4406)\nrcu_core (kernel/rcu/tree.c:2825)\nhandle_softirqs (kernel/softirq.c:554)\n__irq_exit_rcu (kernel/softirq.c:589 kernel/softirq.c:428 kernel/softirq.c:637)\nirq_exit_rcu (kernel/softirq.c:651)\nsysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1049 arch/x86/kernel/apic/apic.c:1049)\n </IRQ>\n <TASK>\nasm_sysvec_apic_timer_interrupt (./arch/x86/include/asm/idtentry.h:702)\nRIP: 0010:default_idle (./arch/x86/include/asm/irqflags.h:37 ./arch/x86/include/asm/irqflags.h:92 arch/x86/kernel/process.c:743)\nCode: 00 4d 29 c8 4c 01 c7 4c 29 c2 e9 6e ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 90 0f 00 2d c7 c9 27 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90\nRSP: 0018:ffff888100d2fe00 EFLAGS: 00000246\nRAX: 00000000001870ed RBX: 1ffff110201a5fc2 RCX: ffffffffb61a3e46\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffb3d4d123\nRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed11c7e1835d\nR10: ffff888e3f0c1aeb R11: 0000000000000000 R12: 0000000000000000\nR13: ffff888100d20000 R14: dffffc0000000000 R15: 0000000000000000\n? ct_kernel_exit.constprop.0 (kernel/context_tracking.c:148)\n? cpuidle_idle_call (kernel/sched/idle.c:186)\ndefault_idle_call (./include/linux/cpuidle.h:143 kernel/sched/idle.c:118)\ncpuidle_idle_call (kernel/sched/idle.c:186)\n? __pfx_cpuidle_idle_call (kernel/sched/idle.c:168)\n? lock_release (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5848)\n? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4347 kernel/locking/lockdep.c:4406)\n? tsc_verify_tsc_adjust (arch/x86/kernel/tsc_sync.c:59)\ndo_idle (kernel/sched/idle.c:326)\ncpu_startup_entry (kernel/sched/idle.c:423 (discriminator 1))\nstart_secondary (arch/x86/kernel/smpboot.c:202 arch/x86/kernel/smpboot.c:282)\n? __pfx_start_secondary (arch/x86/kernel/smpboot.c:232)\n? soft_restart_cpu (arch/x86/kernel/head_64.S:452)\ncommon_startup_64 (arch/x86/kernel/head_64.S:414)\n </TASK>\nDec 03 05:46:18 kernel:\nAllocated by task 12184:\nkasan_save_stack (mm/kasan/common.c:48)\nkasan_save_track (./arch/x86/include/asm/current.h:49 mm/kasan/common.c:60 mm/kasan/common.c:69)\n__kasan_slab_alloc (mm/kasan/common.c:319 mm/kasan/common.c:345)\nkmem_cache_alloc_noprof (mm/slub.c:4085 mm/slub.c:4134 mm/slub.c:4141)\ncopy_net_ns (net/core/net_namespace.c:421 net/core/net_namespace.c:480)\ncreate_new_namespaces\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56658",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49996",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix buffer overflow when parsing NFS reparse points\n\nReparseDataLength is sum of the InodeType size and DataBuffer size.\nSo to get DataBuffer size it is needed to subtract InodeType's size from\nReparseDataLength.\n\nFunction cifs_strndup_from_utf16() is currentlly accessing buf->DataBuffer\nat position after the end of the buffer because it does not subtract\nInodeType size from the length. Fix this problem and correctly subtract\nvariable len.\n\nMember InodeType is present only when reparse buffer is large enough. Check\nfor ReparseDataLength before accessing InodeType to prevent another invalid\nmemory access.\n\nMajor and minor rdev values are present also only when reparse buffer is\nlarge enough. Check for reparse buffer size before calling reparse_mkdev().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49996",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49412",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbfq: Avoid merging queues with different parents\n\nIt can happen that the parent of a bfqq changes between the moment we\ndecide two queues are worth to merge (and set bic->stable_merge_bfqq)\nand the moment bfq_setup_merge() is called. This can happen e.g. because\nthe process submitted IO for a different cgroup and thus bfqq got\nreparented. It can even happen that the bfqq we are merging with has\nparent cgroup that is already offline and going to be destroyed in which\ncase the merge can lead to use-after-free issues such as:\n\nBUG: KASAN: use-after-free in __bfq_deactivate_entity+0x9cb/0xa50\nRead of size 8 at addr ffff88800693c0c0 by task runc:[2:INIT]/10544\n\nCPU: 0 PID: 10544 Comm: runc:[2:INIT] Tainted: G            E     5.15.2-0.g5fb85fd-default #1 openSUSE Tumbleweed (unreleased) f1f3b891c72369aebecd2e43e4641a6358867c70\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x46/0x5a\n print_address_description.constprop.0+0x1f/0x140\n ? __bfq_deactivate_entity+0x9cb/0xa50\n kasan_report.cold+0x7f/0x11b\n ? __bfq_deactivate_entity+0x9cb/0xa50\n __bfq_deactivate_entity+0x9cb/0xa50\n ? update_curr+0x32f/0x5d0\n bfq_deactivate_entity+0xa0/0x1d0\n bfq_del_bfqq_busy+0x28a/0x420\n ? resched_curr+0x116/0x1d0\n ? bfq_requeue_bfqq+0x70/0x70\n ? check_preempt_wakeup+0x52b/0xbc0\n __bfq_bfqq_expire+0x1a2/0x270\n bfq_bfqq_expire+0xd16/0x2160\n ? try_to_wake_up+0x4ee/0x1260\n ? bfq_end_wr_async_queues+0xe0/0xe0\n ? _raw_write_unlock_bh+0x60/0x60\n ? _raw_spin_lock_irq+0x81/0xe0\n bfq_idle_slice_timer+0x109/0x280\n ? bfq_dispatch_request+0x4870/0x4870\n __hrtimer_run_queues+0x37d/0x700\n ? enqueue_hrtimer+0x1b0/0x1b0\n ? kvm_clock_get_cycles+0xd/0x10\n ? ktime_get_update_offsets_now+0x6f/0x280\n hrtimer_interrupt+0x2c8/0x740\n\nFix the problem by checking that the parent of the two bfqqs we are\nmerging in bfq_setup_merge() is the same.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49412",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-06-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-41069",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: topology: Fix references to freed memory\n\nMost users after parsing a topology file, release memory used by it, so\nhaving pointer references directly into topology file contents is wrong.\nUse devm_kmemdup(), to allocate memory as needed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-41069",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-29",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-3640",
                    "description": "A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory, where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-3640",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-07-24",
                    "modification_date": "2025-04-15",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50423",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Fix use-after-free in acpi_ut_copy_ipackage_to_ipackage()\n\nThere is an use-after-free reported by KASAN:\n\n  BUG: KASAN: use-after-free in acpi_ut_remove_reference+0x3b/0x82\n  Read of size 1 at addr ffff888112afc460 by task modprobe/2111\n  CPU: 0 PID: 2111 Comm: modprobe Not tainted 6.1.0-rc7-dirty\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),\n  Call Trace:\n   <TASK>\n   kasan_report+0xae/0xe0\n   acpi_ut_remove_reference+0x3b/0x82\n   acpi_ut_copy_iobject_to_iobject+0x3be/0x3d5\n   acpi_ds_store_object_to_local+0x15d/0x3a0\n   acpi_ex_store+0x78d/0x7fd\n   acpi_ex_opcode_1A_1T_1R+0xbe4/0xf9b\n   acpi_ps_parse_aml+0x217/0x8d5\n   ...\n   </TASK>\n\nThe root cause of the problem is that the acpi_operand_object\nis freed when acpi_ut_walk_package_tree() fails in\nacpi_ut_copy_ipackage_to_ipackage(), lead to repeated release in\nacpi_ut_copy_iobject_to_iobject(). The problem was introduced\nby \"8aa5e56eeb61\" commit, this commit is to fix memory leak in\nacpi_ut_copy_iobject_to_iobject(), repeatedly adding remove\noperation, lead to \"acpi_operand_object\" used after free.\n\nFix it by removing acpi_ut_remove_reference() in\nacpi_ut_copy_ipackage_to_ipackage(). acpi_ut_copy_ipackage_to_ipackage()\nis called to copy an internal package object into another internal\npackage object, when it fails, the memory of acpi_operand_object\nshould be freed by the caller.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50423",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21969",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd\n\nAfter the hci sync command releases l2cap_conn, the hci receive data work\nqueue references the released l2cap_conn when sending to the upper layer.\nAdd hci dev lock to the hci receive data work queue to synchronize the two.\n\n[1]\nBUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954\nRead of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837\n\nCPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nWorkqueue: hci1 hci_rx_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:489\n kasan_report+0x143/0x180 mm/kasan/report.c:602\n l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline]\n l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954\n l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline]\n l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline]\n l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817\n hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline]\n hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nAllocated by task 5837:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329\n kmalloc_noprof include/linux/slab.h:901 [inline]\n kzalloc_noprof include/linux/slab.h:1037 [inline]\n l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860\n l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239\n hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]\n hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726\n hci_event_func net/bluetooth/hci_event.c:7473 [inline]\n hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525\n hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nFreed by task 54:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2353 [inline]\n slab_free mm/slub.c:4613 [inline]\n kfree+0x196/0x430 mm/slub.c:4761\n l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235\n hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]\n hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266\n hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603\n hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entr\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21969",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-01",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50179",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nath9k: fix use-after-free in ath9k_hif_usb_rx_cb\n\nSyzbot reported use-after-free Read in ath9k_hif_usb_rx_cb() [0]. The\nproblem was in incorrect htc_handle->drv_priv initialization.\n\nProbable call trace which can trigger use-after-free:\n\nath9k_htc_probe_device()\n  /* htc_handle->drv_priv = priv; */\n  ath9k_htc_wait_for_target()      <--- Failed\n  ieee80211_free_hw()\t\t   <--- priv pointer is freed\n\n<IRQ>\n...\nath9k_hif_usb_rx_cb()\n  ath9k_hif_usb_rx_stream()\n   RX_STAT_INC()\t\t<--- htc_handle->drv_priv access\n\nIn order to not add fancy protection for drv_priv we can move\nhtc_handle->drv_priv initialization at the end of the\nath9k_htc_probe_device() and add helper macro to make\nall *_STAT_* macros NULL safe, since syzbot has reported related NULL\nderef in that macros [1]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50179",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-20",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39691",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/buffer: fix use-after-free when call bh_read() helper\n\nThere's issue as follows:\nBUG: KASAN: stack-out-of-bounds in end_buffer_read_sync+0xe3/0x110\nRead of size 8 at addr ffffc9000168f7f8 by task swapper/3/0\nCPU: 3 UID: 0 PID: 0 Comm: swapper/3 Not tainted 6.16.0-862.14.0.6.x86_64\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996)\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x55/0x70\n print_address_description.constprop.0+0x2c/0x390\n print_report+0xb4/0x270\n kasan_report+0xb8/0xf0\n end_buffer_read_sync+0xe3/0x110\n end_bio_bh_io_sync+0x56/0x80\n blk_update_request+0x30a/0x720\n scsi_end_request+0x51/0x2b0\n scsi_io_completion+0xe3/0x480\n ? scsi_device_unbusy+0x11e/0x160\n blk_complete_reqs+0x7b/0x90\n handle_softirqs+0xef/0x370\n irq_exit_rcu+0xa5/0xd0\n sysvec_apic_timer_interrupt+0x6e/0x90\n </IRQ>\n\n Above issue happens when do ntfs3 filesystem mount, issue may happens\n as follows:\n           mount                            IRQ\nntfs_fill_super\n  read_cache_page\n    do_read_cache_folio\n      filemap_read_folio\n        mpage_read_folio\n\t do_mpage_readpage\n\t  ntfs_get_block_vbo\n\t   bh_read\n\t     submit_bh\n\t     wait_on_buffer(bh);\n\t                            blk_complete_reqs\n\t\t\t\t     scsi_io_completion\n\t\t\t\t      scsi_end_request\n\t\t\t\t       blk_update_request\n\t\t\t\t        end_bio_bh_io_sync\n\t\t\t\t\t end_buffer_read_sync\n\t\t\t\t\t  __end_buffer_read_notouch\n\t\t\t\t\t   unlock_buffer\n\n            wait_on_buffer(bh);--> return will return to caller\n\n\t\t\t\t\t  put_bh\n\t\t\t\t\t    --> trigger stack-out-of-bounds\nIn the mpage_read_folio() function, the stack variable 'map_bh' is\npassed to ntfs_get_block_vbo(). Once unlock_buffer() unlocks and\nwait_on_buffer() returns to continue processing, the stack variable\nis likely to be reclaimed. Consequently, during the end_buffer_read_sync()\nprocess, calling put_bh() may result in stack overrun.\n\nIf the bh is not allocated on the stack, it belongs to a folio.  Freeing\na buffer head which belongs to a folio is done by drop_buffers() which\nwill fail to free buffers which are still locked.  So it is safe to call\nput_bh() before __end_buffer_read_notouch().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39691",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-05",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50071",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: move subflow cleanup in mptcp_destroy_common()\n\nIf the mptcp socket creation fails due to a CGROUP_INET_SOCK_CREATE\neBPF program, the MPTCP protocol ends-up leaking all the subflows:\nthe related cleanup happens in __mptcp_destroy_sock() that is not\ninvoked in such code path.\n\nAddress the issue moving the subflow sockets cleanup in the\nmptcp_destroy_common() helper, which is invoked in every msk cleanup\npath.\n\nAdditionally get rid of the intermediate list_splice_init step, which\nis an unneeded relic from the past.\n\nThe issue is present since before the reported root cause commit, but\nany attempt to backport the fix before that hash will require a complete\nrewrite.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50071",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-37885",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Reset IRTE to host control if *new* route isn't postable\n\nRestore an IRTE back to host control (remapped or posted MSI mode) if the\n*new* GSI route prevents posting the IRQ directly to a vCPU, regardless of\nthe GSI routing type.  Updating the IRTE if and only if the new GSI is an\nMSI results in KVM leaving an IRTE posting to a vCPU.\n\nThe dangling IRTE can result in interrupts being incorrectly delivered to\nthe guest, and in the worst case scenario can result in use-after-free,\ne.g. if the VM is torn down, but the underlying host IRQ isn't freed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37885",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-09",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-23133",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: update channel list in reg notifier instead reg worker\n\nCurrently when ath11k gets a new channel list, it will be processed\naccording to the following steps:\n1. update new channel list to cfg80211 and queue reg_work.\n2. cfg80211 handles new channel list during reg_work.\n3. update cfg80211's handled channel list to firmware by\nath11k_reg_update_chan_list().\n\nBut ath11k will immediately execute step 3 after reg_work is just\nqueued. Since step 2 is asynchronous, cfg80211 may not have completed\nhandling the new channel list, which may leading to an out-of-bounds\nwrite error:\nBUG: KASAN: slab-out-of-bounds in ath11k_reg_update_chan_list\nCall Trace:\n    ath11k_reg_update_chan_list+0xbfe/0xfe0 [ath11k]\n    kfree+0x109/0x3a0\n    ath11k_regd_update+0x1cf/0x350 [ath11k]\n    ath11k_regd_update_work+0x14/0x20 [ath11k]\n    process_one_work+0xe35/0x14c0\n\nShould ensure step 2 is completely done before executing step 3. Thus\nWen raised patch[1]. When flag NL80211_REGDOM_SET_BY_DRIVER is set,\ncfg80211 will notify ath11k after step 2 is done.\n\nSo enable the flag NL80211_REGDOM_SET_BY_DRIVER then cfg80211 will\nnotify ath11k after step 2 is done. At this time, there will be no\nKASAN bug during the execution of the step 3.\n\n[1] https://patchwork.kernel.org/project/linux-wireless/patch/20230201065313.27203-1-quic_wgong@quicinc.com/\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-23133",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-16",
                    "modification_date": "2025-11-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52854",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: Fix refcnt handling in padata_free_shell()\n\nIn a high-load arm64 environment, the pcrypt_aead01 test in LTP can lead\nto system UAF (Use-After-Free) issues. Due to the lengthy analysis of\nthe pcrypt_aead01 function call, I'll describe the problem scenario\nusing a simplified model:\n\nSuppose there's a user of padata named `user_function` that adheres to\nthe padata requirement of calling `padata_free_shell` after `serial()`\nhas been invoked, as demonstrated in the following code:\n\n```c\nstruct request {\n    struct padata_priv padata;\n    struct completion *done;\n};\n\nvoid parallel(struct padata_priv *padata) {\n    do_something();\n}\n\nvoid serial(struct padata_priv *padata) {\n    struct request *request = container_of(padata,\n    \t\t\t\tstruct request,\n\t\t\t\tpadata);\n    complete(request->done);\n}\n\nvoid user_function() {\n    DECLARE_COMPLETION(done)\n    padata->parallel = parallel;\n    padata->serial = serial;\n    padata_do_parallel();\n    wait_for_completion(&done);\n    padata_free_shell();\n}\n```\n\nIn the corresponding padata.c file, there's the following code:\n\n```c\nstatic void padata_serial_worker(struct work_struct *serial_work) {\n    ...\n    cnt = 0;\n\n    while (!list_empty(&local_list)) {\n        ...\n        padata->serial(padata);\n        cnt++;\n    }\n\n    local_bh_enable();\n\n    if (refcount_sub_and_test(cnt, &pd->refcnt))\n        padata_free_pd(pd);\n}\n```\n\nBecause of the high system load and the accumulation of unexecuted\nsoftirq at this moment, `local_bh_enable()` in padata takes longer\nto execute than usual. Subsequently, when accessing `pd->refcnt`,\n`pd` has already been released by `padata_free_shell()`, resulting\nin a UAF issue with `pd->refcnt`.\n\nThe fix is straightforward: add `refcount_dec_and_test` before calling\n`padata_free_pd` in `padata_free_shell`.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52854",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-02-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49753",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: Fix double increment of client_count in dma_chan_get()\n\nThe first time dma_chan_get() is called for a channel the channel\nclient_count is incorrectly incremented twice for public channels,\nfirst in balance_ref_count(), and again prior to returning. This\nresults in an incorrect client count which will lead to the\nchannel resources not being freed when they should be. A simple\n test of repeated module load and unload of async_tx on a Dell\n Power Edge R7425 also shows this resulting in a kref underflow\n warning.\n\n[  124.329662] async_tx: api initialized (async)\n[  129.000627] async_tx: api initialized (async)\n[  130.047839] ------------[ cut here ]------------\n[  130.052472] refcount_t: underflow; use-after-free.\n[  130.057279] WARNING: CPU: 3 PID: 19364 at lib/refcount.c:28\nrefcount_warn_saturate+0xba/0x110\n[  130.065811] Modules linked in: async_tx(-) rfkill intel_rapl_msr\nintel_rapl_common amd64_edac edac_mce_amd ipmi_ssif kvm_amd dcdbas kvm\nmgag200 drm_shmem_helper acpi_ipmi irqbypass drm_kms_helper ipmi_si\nsyscopyarea sysfillrect rapl pcspkr ipmi_devintf sysimgblt fb_sys_fops\nk10temp i2c_piix4 ipmi_msghandler acpi_power_meter acpi_cpufreq vfat\nfat drm fuse xfs libcrc32c sd_mod t10_pi sg ahci crct10dif_pclmul\nlibahci crc32_pclmul crc32c_intel ghash_clmulni_intel igb megaraid_sas\ni40e libata i2c_algo_bit ccp sp5100_tco dca dm_mirror dm_region_hash\ndm_log dm_mod [last unloaded: async_tx]\n[  130.117361] CPU: 3 PID: 19364 Comm: modprobe Kdump: loaded Not\ntainted 5.14.0-185.el9.x86_64 #1\n[  130.126091] Hardware name: Dell Inc. PowerEdge R7425/02MJ3T, BIOS\n1.18.0 01/17/2022\n[  130.133806] RIP: 0010:refcount_warn_saturate+0xba/0x110\n[  130.139041] Code: 01 01 e8 6d bd 55 00 0f 0b e9 72 9d 8a 00 80 3d\n26 18 9c 01 00 75 85 48 c7 c7 f8 a3 03 9d c6 05 16 18 9c 01 01 e8 4a\nbd 55 00 <0f> 0b e9 4f 9d 8a 00 80 3d 01 18 9c 01 00 0f 85 5e ff ff ff\n48 c7\n[  130.157807] RSP: 0018:ffffbf98898afe68 EFLAGS: 00010286\n[  130.163036] RAX: 0000000000000000 RBX: ffff9da06028e598 RCX: 0000000000000000\n[  130.170172] RDX: ffff9daf9de26480 RSI: ffff9daf9de198a0 RDI: ffff9daf9de198a0\n[  130.177316] RBP: ffff9da7cddf3970 R08: 0000000000000000 R09: 00000000ffff7fff\n[  130.184459] R10: ffffbf98898afd00 R11: ffffffff9d9e8c28 R12: ffff9da7cddf1970\n[  130.191596] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[  130.198739] FS:  00007f646435c740(0000) GS:ffff9daf9de00000(0000)\nknlGS:0000000000000000\n[  130.206832] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  130.212586] CR2: 00007f6463b214f0 CR3: 00000008ab98c000 CR4: 00000000003506e0\n[  130.219729] Call Trace:\n[  130.222192]  <TASK>\n[  130.224305]  dma_chan_put+0x10d/0x110\n[  130.227988]  dmaengine_put+0x7a/0xa0\n[  130.231575]  __do_sys_delete_module.constprop.0+0x178/0x280\n[  130.237157]  ? syscall_trace_enter.constprop.0+0x145/0x1d0\n[  130.242652]  do_syscall_64+0x5c/0x90\n[  130.246240]  ? exc_page_fault+0x62/0x150\n[  130.250178]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[  130.255243] RIP: 0033:0x7f6463a3f5ab\n[  130.258830] Code: 73 01 c3 48 8b 0d 75 a8 1b 00 f7 d8 64 89 01 48\n83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 b0 00 00\n00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 45 a8 1b 00 f7 d8 64 89\n01 48\n[  130.277591] RSP: 002b:00007fff22f972c8 EFLAGS: 00000206 ORIG_RAX:\n00000000000000b0\n[  130.285164] RAX: ffffffffffffffda RBX: 000055b6786edd40 RCX: 00007f6463a3f5ab\n[  130.292303] RDX: 0000000000000000 RSI: 0000000000000800 RDI: 000055b6786edda8\n[  130.299443] RBP: 000055b6786edd40 R08: 0000000000000000 R09: 0000000000000000\n[  130.306584] R10: 00007f6463b9eac0 R11: 0000000000000206 R12: 000055b6786edda8\n[  130.313731] R13: 0000000000000000 R14: 000055b6786edda8 R15: 00007fff22f995f8\n[  130.320875]  </TASK>\n[  130.323081] ---[ end trace eff7156d56b5cf25 ]---\n\ncat /sys/class/dma/dma0chan*/in_use would get the wrong result.\n2\n2\n2\n\nTest-by: Jie Hai <haijie1@huawei.com>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49753",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46673",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: aacraid: Fix double-free on probe failure\n\naac_probe_one() calls hardware-specific init functions through the\naac_driver_ident::init pointer, all of which eventually call down to\naac_init_adapter().\n\nIf aac_init_adapter() fails after allocating memory for aac_dev::queues,\nit frees the memory but does not clear that member.\n\nAfter the hardware-specific init function returns an error,\naac_probe_one() goes down an error path that frees the memory pointed to\nby aac_dev::queues, resulting.in a double-free.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46673",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-13",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52921",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix possible UAF in amdgpu_cs_pass1()\n\nSince the gang_size check is outside of chunk parsing\nloop, we need to reset i before we free the chunk data.\n\nSuggested by Ye Zhang (@VAR10CK) of Baidu Security.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52921",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-06-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-41073",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme: avoid double free special payload\n\nIf a discard request needs to be retried, and that retry may fail before\na new special payload is added, a double free will result. Clear the\nRQF_SPECIAL_LOAD when the request is cleaned.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-41073",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-29",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38369",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: Check availability of workqueue allocated by idxd wq driver before using\n\nRunning IDXD workloads in a container with the /dev directory mounted can\ntrigger a call trace or even a kernel panic when the parent process of the\ncontainer is terminated.\n\nThis issue occurs because, under certain configurations, Docker does not\nproperly propagate the mount replica back to the original mount point.\n\nIn this case, when the user driver detaches, the WQ is destroyed but it\nstill calls destroy_workqueue() attempting to completes all pending work.\nIt's necessary to check wq->wq and skip the drain if it no longer exists.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38369",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50143",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: fix uninit-value use in udf_get_fileshortad\n\nCheck for overflow when computing alen in udf_current_aext to mitigate\nlater uninit-value use in udf_get_fileshortad KMSAN bug[1].\nAfter applying the patch reproducer did not trigger any issue[2].\n\n[1] https://syzkaller.appspot.com/bug?extid=8901c4560b7ab5c2f9df\n[2] https://syzkaller.appspot.com/x/log.txt?x=10242227980000",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50143",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-07",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47718",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw88: always wait for both firmware loading attempts\n\nIn 'rtw_wait_firmware_completion()', always wait for both (regular and\nwowlan) firmware loading attempts. Otherwise if 'rtw_usb_intf_init()'\nhas failed in 'rtw_usb_probe()', 'rtw_usb_disconnect()' may issue\n'ieee80211_free_hw()' when one of 'rtw_load_firmware_cb()' (usually\nthe wowlan one) is still in progress, causing UAF detected by KASAN.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47718",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47634",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: Fix race condition between ctrl_cdev_ioctl and ubi_cdev_ioctl\n\nHulk Robot reported a KASAN report about use-after-free:\n ==================================================================\n BUG: KASAN: use-after-free in __list_del_entry_valid+0x13d/0x160\n Read of size 8 at addr ffff888035e37d98 by task ubiattach/1385\n [...]\n Call Trace:\n  klist_dec_and_del+0xa7/0x4a0\n  klist_put+0xc7/0x1a0\n  device_del+0x4d4/0xed0\n  cdev_device_del+0x1a/0x80\n  ubi_attach_mtd_dev+0x2951/0x34b0 [ubi]\n  ctrl_cdev_ioctl+0x286/0x2f0 [ubi]\n\n Allocated by task 1414:\n  device_add+0x60a/0x18b0\n  cdev_device_add+0x103/0x170\n  ubi_create_volume+0x1118/0x1a10 [ubi]\n  ubi_cdev_ioctl+0xb7f/0x1ba0 [ubi]\n\n Freed by task 1385:\n  cdev_device_del+0x1a/0x80\n  ubi_remove_volume+0x438/0x6c0 [ubi]\n  ubi_cdev_ioctl+0xbf4/0x1ba0 [ubi]\n [...]\n ==================================================================\n\nThe lock held by ctrl_cdev_ioctl is ubi_devices_mutex, but the lock held\nby ubi_cdev_ioctl is ubi->device_mutex. Therefore, the two locks can be\nconcurrent.\n\nctrl_cdev_ioctl contains two operations: ubi_attach and ubi_detach.\nubi_detach is bug-free because it uses reference counting to prevent\nconcurrency. However, uif_init and uif_close in ubi_attach may race with\nubi_cdev_ioctl.\n\nuif_init will race with ubi_cdev_ioctl as in the following stack.\n           cpu1                   cpu2                  cpu3\n_______________________|________________________|______________________\nctrl_cdev_ioctl\n ubi_attach_mtd_dev\n  uif_init\n                           ubi_cdev_ioctl\n                            ubi_create_volume\n                             cdev_device_add\n   ubi_add_volume\n   // sysfs exist\n   kill_volumes\n                                                    ubi_cdev_ioctl\n                                                     ubi_remove_volume\n                                                      cdev_device_del\n                                                       // first free\n    ubi_free_volume\n     cdev_del\n     // double free\n   cdev_device_del\n\nAnd uif_close will race with ubi_cdev_ioctl as in the following stack.\n           cpu1                   cpu2                  cpu3\n_______________________|________________________|______________________\nctrl_cdev_ioctl\n ubi_attach_mtd_dev\n  uif_init\n                           ubi_cdev_ioctl\n                            ubi_create_volume\n                             cdev_device_add\n  ubi_debugfs_init_dev\n  //error goto out_uif;\n  uif_close\n   kill_volumes\n                                                    ubi_cdev_ioctl\n                                                     ubi_remove_volume\n                                                      cdev_device_del\n                                                       // first free\n    ubi_free_volume\n    // double free\n\nThe cause of this problem is that commit 714fb87e8bc0 make device\n\"available\" before it becomes accessible via sysfs. Therefore, we\nroll back the modification. We will fix the race condition between\nubi device creation and udev by removing ubi_get_device in\nvol_attribute_show and dev_attribute_show.This avoids accessing\nuninitialized ubi_devices[ubi_num].\n\nubi_get_device is used to prevent devices from being deleted during\nsysfs execution. However, now kernfs ensures that devices will not\nbe deleted before all reference counting are released.\nThe key process is shown in the following stack.\n\ndevice_del\n  device_remove_attrs\n    device_remove_groups\n      sysfs_remove_groups\n        sysfs_remove_group\n          remove_files\n            kernfs_remove_by_name\n              kernfs_remove_by_name_ns\n                __kernfs_remove\n                  kernfs_drain",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47634",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52885",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: Fix UAF in svc_tcp_listen_data_ready()\n\nAfter the listener svc_sock is freed, and before invoking svc_tcp_accept()\nfor the established child sock, there is a window that the newsock\nretaining a freed listener svc_sock in sk_user_data which cloning from\nparent. In the race window, if data is received on the newsock, we will\nobserve use-after-free report in svc_tcp_listen_data_ready().\n\nReproduce by two tasks:\n\n1. while :; do rpc.nfsd 0 ; rpc.nfsd; done\n2. while :; do echo \"\" | ncat -4 127.0.0.1 2049 ; done\n\nKASAN report:\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in svc_tcp_listen_data_ready+0x1cf/0x1f0 [sunrpc]\n  Read of size 8 at addr ffff888139d96228 by task nc/102553\n  CPU: 7 PID: 102553 Comm: nc Not tainted 6.3.0+ #18\n  Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\n  Call Trace:\n   <IRQ>\n   dump_stack_lvl+0x33/0x50\n   print_address_description.constprop.0+0x27/0x310\n   print_report+0x3e/0x70\n   kasan_report+0xae/0xe0\n   svc_tcp_listen_data_ready+0x1cf/0x1f0 [sunrpc]\n   tcp_data_queue+0x9f4/0x20e0\n   tcp_rcv_established+0x666/0x1f60\n   tcp_v4_do_rcv+0x51c/0x850\n   tcp_v4_rcv+0x23fc/0x2e80\n   ip_protocol_deliver_rcu+0x62/0x300\n   ip_local_deliver_finish+0x267/0x350\n   ip_local_deliver+0x18b/0x2d0\n   ip_rcv+0x2fb/0x370\n   __netif_receive_skb_one_core+0x166/0x1b0\n   process_backlog+0x24c/0x5e0\n   __napi_poll+0xa2/0x500\n   net_rx_action+0x854/0xc90\n   __do_softirq+0x1bb/0x5de\n   do_softirq+0xcb/0x100\n   </IRQ>\n   <TASK>\n   ...\n   </TASK>\n\n  Allocated by task 102371:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   __kasan_kmalloc+0x7b/0x90\n   svc_setup_socket+0x52/0x4f0 [sunrpc]\n   svc_addsock+0x20d/0x400 [sunrpc]\n   __write_ports_addfd+0x209/0x390 [nfsd]\n   write_ports+0x239/0x2c0 [nfsd]\n   nfsctl_transaction_write+0xac/0x110 [nfsd]\n   vfs_write+0x1c3/0xae0\n   ksys_write+0xed/0x1c0\n   do_syscall_64+0x38/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\n  Freed by task 102551:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   kasan_save_free_info+0x2a/0x50\n   __kasan_slab_free+0x106/0x190\n   __kmem_cache_free+0x133/0x270\n   svc_xprt_free+0x1e2/0x350 [sunrpc]\n   svc_xprt_destroy_all+0x25a/0x440 [sunrpc]\n   nfsd_put+0x125/0x240 [nfsd]\n   nfsd_svc+0x2cb/0x3c0 [nfsd]\n   write_threads+0x1ac/0x2a0 [nfsd]\n   nfsctl_transaction_write+0xac/0x110 [nfsd]\n   vfs_write+0x1c3/0xae0\n   ksys_write+0xed/0x1c0\n   do_syscall_64+0x38/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFix the UAF by simply doing nothing in svc_tcp_listen_data_ready()\nif state != TCP_LISTEN, that will avoid dereferencing svsk for all\nchild socket.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52885",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-14",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50203",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, arm64: Fix address emission with tag-based KASAN enabled\n\nWhen BPF_TRAMP_F_CALL_ORIG is enabled, the address of a bpf_tramp_image\nstruct on the stack is passed during the size calculation pass and\nan address on the heap is passed during code generation. This may\ncause a heap buffer overflow if the heap address is tagged because\nemit_a64_mov_i64() will emit longer code than it did during the size\ncalculation pass. The same problem could occur without tag-based\nKASAN if one of the 16-bit words of the stack address happened to\nbe all-ones during the size calculation pass. Fix the problem by\nassuming the worst case (4 instructions) when calculating the size\nof the bpf_tramp_image address emission.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50203",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-08",
                    "modification_date": "2025-05-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56606",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_packet: avoid erroring out after sock_init_data() in packet_create()\n\nAfter sock_init_data() the allocated sk object is attached to the provided\nsock object. On error, packet_create() frees the sk object leaving the\ndangling pointer in the sock object on return. Some other code may try\nto use this pointer and cause use-after-free.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56606",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21772",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npartitions: mac: fix handling of bogus partition table\n\nFix several issues in partition probing:\n\n - The bailout for a bad partoffset must use put_dev_sector(), since the\n   preceding read_part_sector() succeeded.\n - If the partition table claims a silly sector size like 0xfff bytes\n   (which results in partition table entries straddling sector boundaries),\n   bail out instead of accessing out-of-bounds memory.\n - We must not assume that the partition table contains proper NUL\n   termination - use strnlen() and strncmp() instead of strlen() and\n   strcmp().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21772",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50305",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: sof_es8336: fix possible use-after-free in sof_es8336_remove()\n\nsof_es8336_remove() calls cancel_delayed_work(). However, that\nfunction does not wait until the work function finishes. This\nmeans that the callback function may still be running after\nthe driver's remove function has finished, which would result\nin a use-after-free.\n\nFix by calling cancel_delayed_work_sync(), which ensures that\nthe work is properly cancelled, no longer running, and unable\nto re-schedule itself.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50305",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53320",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpi3mr: Fix issues in mpi3mr_get_all_tgt_info()\n\nThe function mpi3mr_get_all_tgt_info() has four issues:\n\n1) It calculates valid entry length in alltgt_info assuming the header part\n   of the struct mpi3mr_device_map_info would equal to sizeof(u32).  The\n   correct size is sizeof(u64).\n\n2) When it calculates the valid entry length kern_entrylen, it excludes one\n   entry by subtracting 1 from num_devices.\n\n3) It copies num_device by calling memcpy(). Substitution is enough.\n\n4) It does not specify the calculated length to sg_copy_from_buffer().\n   Instead, it specifies the payload length which is larger than the\n   alltgt_info size. It causes \"BUG: KASAN: slab-out-of-bounds\".\n\nFix the issues by using the correct header size, removing the subtraction\nfrom num_devices, replacing the memcpy() with substitution and specifying\nthe correct length to sg_copy_from_buffer().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53320",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47517",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nethtool: do not perform operations on net devices being unregistered\n\nThere is a short period between a net device starts to be unregistered\nand when it is actually gone. In that time frame ethtool operations\ncould still be performed, which might end up in unwanted or undefined\nbehaviours[1].\n\nDo not allow ethtool operations after a net device starts its\nunregistration. This patch targets the netlink part as the ioctl one\nisn't affected: the reference to the net device is taken and the\noperation is executed within an rtnl lock section and the net device\nwon't be found after unregister.\n\n[1] For example adding Tx queues after unregister ends up in NULL\n    pointer exceptions and UaFs, such as:\n\n      BUG: KASAN: use-after-free in kobject_get+0x14/0x90\n      Read of size 1 at addr ffff88801961248c by task ethtool/755\n\n      CPU: 0 PID: 755 Comm: ethtool Not tainted 5.15.0-rc6+ #778\n      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-4.fc34 04/014\n      Call Trace:\n       dump_stack_lvl+0x57/0x72\n       print_address_description.constprop.0+0x1f/0x140\n       kasan_report.cold+0x7f/0x11b\n       kobject_get+0x14/0x90\n       kobject_add_internal+0x3d1/0x450\n       kobject_init_and_add+0xba/0xf0\n       netdev_queue_update_kobjects+0xcf/0x200\n       netif_set_real_num_tx_queues+0xb4/0x310\n       veth_set_channels+0x1c3/0x550\n       ethnl_set_channels+0x524/0x610",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47517",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-03-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-35791",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: SVM: Flush pages under kvm->lock to fix UAF in svm_register_enc_region()\n\nDo the cache flush of converted pages in svm_register_enc_region() before\ndropping kvm->lock to fix use-after-free issues where region and/or its\narray of pages could be freed by a different task, e.g. if userspace has\n__unregister_enc_region_locked() already queued up for the region.\n\nNote, the \"obvious\" alternative of using local variables doesn't fully\nresolve the bug, as region->pages is also dynamically allocated.  I.e. the\nregion structure itself would be fine, but region->pages could be freed.\n\nFlushing multiple pages under kvm->lock is unfortunate, but the entire\nflow is a rare slow path, and the manual flush is only needed on CPUs that\nlack coherency for encrypted memory.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35791",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-17",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39810",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt_en: Fix memory corruption when FW resources change during ifdown\n\nbnxt_set_dflt_rings() assumes that it is always called before any TC has\nbeen created.  So it doesn't take bp->num_tc into account and assumes\nthat it is always 0 or 1.\n\nIn the FW resource or capability change scenario, the FW will return\nflags in bnxt_hwrm_if_change() that will cause the driver to\nreinitialize and call bnxt_cancel_reservations().  This will lead to\nbnxt_init_dflt_ring_mode() calling bnxt_set_dflt_rings() and bp->num_tc\nmay be greater than 1.  This will cause bp->tx_ring[] to be sized too\nsmall and cause memory corruption in bnxt_alloc_cp_rings().\n\nFix it by properly scaling the TX rings by bp->num_tc in the code\npaths mentioned above.  Add 2 helper functions to determine\nbp->tx_nr_rings and bp->tx_nr_rings_per_tc.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39810",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49129",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: mt7921: fix crash when startup fails.\n\nIf the nic fails to start, it is possible that the\nreset_work has already been scheduled.  Ensure the\nwork item is canceled so we do not have use-after-free\ncrash in case cleanup is called before the work item\nis executed.\n\nThis fixes crash on my x86_64 apu2 when mt7921k radio\nfails to work.  Radio still fails, but OS does not\ncrash.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49129",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49990",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390: fix double free of GS and RI CBs on fork() failure\n\nThe pointers for guarded storage and runtime instrumentation control\nblocks are stored in the thread_struct of the associated task. These\npointers are initially copied on fork() via arch_dup_task_struct()\nand then cleared via copy_thread() before fork() returns. If fork()\nhappens to fail after the initial task dup and before copy_thread(),\nthe newly allocated task and associated thread_struct memory are\nfreed via free_task() -> arch_release_task_struct(). This results in\na double free of the guarded storage and runtime info structs\nbecause the fields in the failed task still refer to memory\nassociated with the source task.\n\nThis problem can manifest as a BUG_ON() in set_freepointer() (with\nCONFIG_SLAB_FREELIST_HARDENED enabled) or KASAN splat (if enabled)\nwhen running trinity syscall fuzz tests on s390x. To avoid this\nproblem, clear the associated pointer fields in\narch_dup_task_struct() immediately after the new task is copied.\nNote that the RI flag is still cleared in copy_thread() because it\nresides in thread stack memory and that is where stack info is\ncopied.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49990",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47196",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/core: Set send and receive CQ before forwarding to the driver\n\nPreset both receive and send CQ pointers prior to call to the drivers and\noverwrite it later again till the mlx4 is going to be changed do not\noverwrite ibqp properties.\n\nThis change is needed for mlx5, because in case of QP creation failure, it\nwill go to the path of QP destroy which relies on proper CQ pointers.\n\n BUG: KASAN: use-after-free in create_qp.cold+0x164/0x16e [mlx5_ib]\n Write of size 8 at addr ffff8880064c55c0 by task a.out/246\n\n CPU: 0 PID: 246 Comm: a.out Not tainted 5.15.0+ #291\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n Call Trace:\n  dump_stack_lvl+0x45/0x59\n  print_address_description.constprop.0+0x1f/0x140\n  kasan_report.cold+0x83/0xdf\n  create_qp.cold+0x164/0x16e [mlx5_ib]\n  mlx5_ib_create_qp+0x358/0x28a0 [mlx5_ib]\n  create_qp.part.0+0x45b/0x6a0 [ib_core]\n  ib_create_qp_user+0x97/0x150 [ib_core]\n  ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs]\n  ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]\n  __x64_sys_ioctl+0x866/0x14d0\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n Allocated by task 246:\n  kasan_save_stack+0x1b/0x40\n  __kasan_kmalloc+0xa4/0xd0\n  create_qp.part.0+0x92/0x6a0 [ib_core]\n  ib_create_qp_user+0x97/0x150 [ib_core]\n  ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs]\n  ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]\n  __x64_sys_ioctl+0x866/0x14d0\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n Freed by task 246:\n  kasan_save_stack+0x1b/0x40\n  kasan_set_track+0x1c/0x30\n  kasan_set_free_info+0x20/0x30\n  __kasan_slab_free+0x10c/0x150\n  slab_free_freelist_hook+0xb4/0x1b0\n  kfree+0xe7/0x2a0\n  create_qp.part.0+0x52b/0x6a0 [ib_core]\n  ib_create_qp_user+0x97/0x150 [ib_core]\n  ib_uverbs_handler_UVERBS_METHOD_QP_CREATE+0x92c/0x1250 [ib_uverbs]\n  ib_uverbs_cmd_verbs+0x1c38/0x3150 [ib_uverbs]\n  ib_uverbs_ioctl+0x169/0x260 [ib_uverbs]\n  __x64_sys_ioctl+0x866/0x14d0\n  do_syscall_64+0x3d/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47196",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-10",
                    "modification_date": "2025-03-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56602",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ieee802154: do not leave a dangling sk pointer in ieee802154_create()\n\nsock_init_data() attaches the allocated sk object to the provided sock\nobject. If ieee802154_create() fails later, the allocated sk object is\nfreed, but the dangling pointer remains in the provided sock object, which\nmay allow use-after-free.\n\nClear the sk pointer in the sock object on error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56602",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21927",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu()\n\nnvme_tcp_recv_pdu() doesn't check the validity of the header length.\nWhen header digests are enabled, a target might send a packet with an\ninvalid header length (e.g. 255), causing nvme_tcp_verify_hdgst()\nto access memory outside the allocated area and cause memory corruptions\nby overwriting it with the calculated digest.\n\nFix this by rejecting packets with an unexpected header length.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21927",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-01",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-38574",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npptp: ensure minimal skb length in pptp_xmit()\n\nCommit aabc6596ffb3 (\"net: ppp: Add bound checking for skb data\non ppp_sync_txmung\") fixed ppp_sync_txmunge()\n\nWe need a similar fix in pptp_xmit(), otherwise we might\nread uninit data as reported by syzbot.\n\nBUG: KMSAN: uninit-value in pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193\n  pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193\n  ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2290 [inline]\n  ppp_input+0x1d6/0xe60 drivers/net/ppp/ppp_generic.c:2314\n  pppoe_rcv_core+0x1e8/0x760 drivers/net/ppp/pppoe.c:379\n  sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148\n  __release_sock+0x1d3/0x330 net/core/sock.c:3213\n  release_sock+0x6b/0x270 net/core/sock.c:3767\n  pppoe_sendmsg+0x15d/0xcb0 drivers/net/ppp/pppoe.c:904\n  sock_sendmsg_nosec net/socket.c:712 [inline]\n  __sock_sendmsg+0x330/0x3d0 net/socket.c:727\n  ____sys_sendmsg+0x893/0xd80 net/socket.c:2566\n  ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620\n  __sys_sendmmsg+0x2d9/0x7c0 net/socket.c:2709",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38574",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21692",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix ets qdisc OOB Indexing\n\nHaowei Yan <g1042620637@gmail.com> found that ets_class_from_arg() can\nindex an Out-Of-Bound class in ets_class_from_arg() when passed clid of\n0. The overflow may cause local privilege escalation.\n\n [   18.852298] ------------[ cut here ]------------\n [   18.853271] UBSAN: array-index-out-of-bounds in net/sched/sch_ets.c:93:20\n [   18.853743] index 18446744073709551615 is out of range for type 'ets_class [16]'\n [   18.854254] CPU: 0 UID: 0 PID: 1275 Comm: poc Not tainted 6.12.6-dirty #17\n [   18.854821] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n [   18.856532] Call Trace:\n [   18.857441]  <TASK>\n [   18.858227]  dump_stack_lvl+0xc2/0xf0\n [   18.859607]  dump_stack+0x10/0x20\n [   18.860908]  __ubsan_handle_out_of_bounds+0xa7/0xf0\n [   18.864022]  ets_class_change+0x3d6/0x3f0\n [   18.864322]  tc_ctl_tclass+0x251/0x910\n [   18.864587]  ? lock_acquire+0x5e/0x140\n [   18.865113]  ? __mutex_lock+0x9c/0xe70\n [   18.866009]  ? __mutex_lock+0xa34/0xe70\n [   18.866401]  rtnetlink_rcv_msg+0x170/0x6f0\n [   18.866806]  ? __lock_acquire+0x578/0xc10\n [   18.867184]  ? __pfx_rtnetlink_rcv_msg+0x10/0x10\n [   18.867503]  netlink_rcv_skb+0x59/0x110\n [   18.867776]  rtnetlink_rcv+0x15/0x30\n [   18.868159]  netlink_unicast+0x1c3/0x2b0\n [   18.868440]  netlink_sendmsg+0x239/0x4b0\n [   18.868721]  ____sys_sendmsg+0x3e2/0x410\n [   18.869012]  ___sys_sendmsg+0x88/0xe0\n [   18.869276]  ? rseq_ip_fixup+0x198/0x260\n [   18.869563]  ? rseq_update_cpu_node_id+0x10a/0x190\n [   18.869900]  ? trace_hardirqs_off+0x5a/0xd0\n [   18.870196]  ? syscall_exit_to_user_mode+0xcc/0x220\n [   18.870547]  ? do_syscall_64+0x93/0x150\n [   18.870821]  ? __memcg_slab_free_hook+0x69/0x290\n [   18.871157]  __sys_sendmsg+0x69/0xd0\n [   18.871416]  __x64_sys_sendmsg+0x1d/0x30\n [   18.871699]  x64_sys_call+0x9e2/0x2670\n [   18.871979]  do_syscall_64+0x87/0x150\n [   18.873280]  ? do_syscall_64+0x93/0x150\n [   18.874742]  ? lock_release+0x7b/0x160\n [   18.876157]  ? do_user_addr_fault+0x5ce/0x8f0\n [   18.877833]  ? irqentry_exit_to_user_mode+0xc2/0x210\n [   18.879608]  ? irqentry_exit+0x77/0xb0\n [   18.879808]  ? clear_bhb_loop+0x15/0x70\n [   18.880023]  ? clear_bhb_loop+0x15/0x70\n [   18.880223]  ? clear_bhb_loop+0x15/0x70\n [   18.880426]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n [   18.880683] RIP: 0033:0x44a957\n [   18.880851] Code: ff ff e8 fc 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 8974 24 10\n [   18.881766] RSP: 002b:00007ffcdd00fad8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n [   18.882149] RAX: ffffffffffffffda RBX: 00007ffcdd010db8 RCX: 000000000044a957\n [   18.882507] RDX: 0000000000000000 RSI: 00007ffcdd00fb70 RDI: 0000000000000003\n [   18.885037] RBP: 00007ffcdd010bc0 R08: 000000000703c770 R09: 000000000703c7c0\n [   18.887203] R10: 0000000000000080 R11: 0000000000000246 R12: 0000000000000001\n [   18.888026] R13: 00007ffcdd010da8 R14: 00000000004ca7d0 R15: 0000000000000001\n [   18.888395]  </TASK>\n [   18.888610] ---[ end trace ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21692",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-10",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-41000",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock/ioctl: prefer different overflow check\n\nRunning syzkaller with the newly reintroduced signed integer overflow\nsanitizer shows this report:\n\n[   62.982337] ------------[ cut here ]------------\n[   62.985692] cgroup: Invalid name\n[   62.986211] UBSAN: signed-integer-overflow in ../block/ioctl.c:36:46\n[   62.989370] 9pnet_fd: p9_fd_create_tcp (7343): problem connecting socket to 127.0.0.1\n[   62.992992] 9223372036854775807 + 4095 cannot be represented in type 'long long'\n[   62.997827] 9pnet_fd: p9_fd_create_tcp (7345): problem connecting socket to 127.0.0.1\n[   62.999369] random: crng reseeded on system resumption\n[   63.000634] GUP no longer grows the stack in syz-executor.2 (7353): 20002000-20003000 (20001000)\n[   63.000668] CPU: 0 PID: 7353 Comm: syz-executor.2 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1\n[   63.000677] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   63.000682] Call Trace:\n[   63.000686]  <TASK>\n[   63.000731]  dump_stack_lvl+0x93/0xd0\n[   63.000919]  __get_user_pages+0x903/0xd30\n[   63.001030]  __gup_longterm_locked+0x153e/0x1ba0\n[   63.001041]  ? _raw_read_unlock_irqrestore+0x17/0x50\n[   63.001072]  ? try_get_folio+0x29c/0x2d0\n[   63.001083]  internal_get_user_pages_fast+0x1119/0x1530\n[   63.001109]  iov_iter_extract_pages+0x23b/0x580\n[   63.001206]  bio_iov_iter_get_pages+0x4de/0x1220\n[   63.001235]  iomap_dio_bio_iter+0x9b6/0x1410\n[   63.001297]  __iomap_dio_rw+0xab4/0x1810\n[   63.001316]  iomap_dio_rw+0x45/0xa0\n[   63.001328]  ext4_file_write_iter+0xdde/0x1390\n[   63.001372]  vfs_write+0x599/0xbd0\n[   63.001394]  ksys_write+0xc8/0x190\n[   63.001403]  do_syscall_64+0xd4/0x1b0\n[   63.001421]  ? arch_exit_to_user_mode_prepare+0x3a/0x60\n[   63.001479]  entry_SYSCALL_64_after_hwframe+0x6f/0x77\n[   63.001535] RIP: 0033:0x7f7fd3ebf539\n[   63.001551] Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\n[   63.001562] RSP: 002b:00007f7fd32570c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[   63.001584] RAX: ffffffffffffffda RBX: 00007f7fd3ff3f80 RCX: 00007f7fd3ebf539\n[   63.001590] RDX: 4db6d1e4f7e43360 RSI: 0000000020000000 RDI: 0000000000000004\n[   63.001595] RBP: 00007f7fd3f1e496 R08: 0000000000000000 R09: 0000000000000000\n[   63.001599] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n[   63.001604] R13: 0000000000000006 R14: 00007f7fd3ff3f80 R15: 00007ffd415ad2b8\n...\n[   63.018142] ---[ end trace ]---\n\nHistorically, the signed integer overflow sanitizer did not work in the\nkernel due to its interaction with `-fwrapv` but this has since been\nchanged [1] in the newest version of Clang; It was re-enabled in the\nkernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow\nsanitizer\").\n\nLet's rework this overflow checking logic to not actually perform an\noverflow during the check itself, thus avoiding the UBSAN splat.\n\n[1]: https://github.com/llvm/llvm-project/pull/82432",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-41000",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-12",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49078",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlz4: fix LZ4_decompress_safe_partial read out of bound\n\nWhen partialDecoding, it is EOF if we've either filled the output buffer\nor can't proceed with reading an offset for following match.\n\nIn some extreme corner cases when compressed data is suitably corrupted,\nUAF will occur.  As reported by KASAN [1], LZ4_decompress_safe_partial\nmay lead to read out of bound problem during decoding.  lz4 upstream has\nfixed it [2] and this issue has been disscussed here [3] before.\n\ncurrent decompression routine was ported from lz4 v1.8.3, bumping\nlib/lz4 to v1.9.+ is certainly a huge work to be done later, so, we'd\nbetter fix it first.\n\n[1] https://lore.kernel.org/all/000000000000830d1205cf7f0477@google.com/\n[2] https://github.com/lz4/lz4/commit/c5d6f8a8be3927c0bec91bcc58667a6cfad244ad#\n[3] https://lore.kernel.org/all/CC666AE8-4CA4-4951-B6FB-A2EFDE3AC03B@fb.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49078",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-12-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49053",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: tcmu: Fix possible page UAF\n\ntcmu_try_get_data_page() looks up pages under cmdr_lock, but it does not\ntake refcount properly and just returns page pointer. When\ntcmu_try_get_data_page() returns, the returned page may have been freed by\ntcmu_blocks_release().\n\nWe need to get_page() under cmdr_lock to avoid concurrent\ntcmu_blocks_release().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49053",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38022",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/core: Fix \"KASAN: slab-use-after-free Read in ib_register_device\" problem\n\nCall Trace:\n\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xc3/0x670 mm/kasan/report.c:521\n kasan_report+0xe0/0x110 mm/kasan/report.c:634\n strlen+0x93/0xa0 lib/string.c:420\n __fortify_strlen include/linux/fortify-string.h:268 [inline]\n get_kobj_path_length lib/kobject.c:118 [inline]\n kobject_get_path+0x3f/0x2a0 lib/kobject.c:158\n kobject_uevent_env+0x289/0x1870 lib/kobject_uevent.c:545\n ib_register_device drivers/infiniband/core/device.c:1472 [inline]\n ib_register_device+0x8cf/0xe00 drivers/infiniband/core/device.c:1393\n rxe_register_device+0x275/0x320 drivers/infiniband/sw/rxe/rxe_verbs.c:1552\n rxe_net_add+0x8e/0xe0 drivers/infiniband/sw/rxe/rxe_net.c:550\n rxe_newlink+0x70/0x190 drivers/infiniband/sw/rxe/rxe.c:225\n nldev_newlink+0x3a3/0x680 drivers/infiniband/core/nldev.c:1796\n rdma_nl_rcv_msg+0x387/0x6e0 drivers/infiniband/core/netlink.c:195\n rdma_nl_rcv_skb.constprop.0.isra.0+0x2e5/0x450\n netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]\n netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339\n netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n ____sys_sendmsg+0xa95/0xc70 net/socket.c:2566\n ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620\n __sys_sendmsg+0x16d/0x220 net/socket.c:2652\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x260 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nThis problem is similar to the problem that the\ncommit 1d6a9e7449e2 (\"RDMA/core: Fix use-after-free when rename device name\")\nfixes.\n\nThe root cause is: the function ib_device_rename() renames the name with\nlock. But in the function kobject_uevent(), this name is accessed without\nlock protection at the same time.\n\nThe solution is to add the lock protection when this name is accessed in\nthe function kobject_uevent().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38022",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48637",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt: prevent skb UAF after handing over to PTP worker\n\nWhen reading the timestamp is required bnxt_tx_int() hands\nover the ownership of the completed skb to the PTP worker.\nThe skb should not be used afterwards, as the worker may\nrun before the rest of our code and free the skb, leading\nto a use-after-free.\n\nSince dev_kfree_skb_any() accepts NULL make the loss of\nownership more obvious and set skb to NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48637",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-03-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26742",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: smartpqi: Fix disable_managed_interrupts\n\nCorrect blk-mq registration issue with module parameter\ndisable_managed_interrupts enabled.\n\nWhen we turn off the default PCI_IRQ_AFFINITY flag, the driver needs to\nregister with blk-mq using blk_mq_map_queues(). The driver is currently\ncalling blk_mq_pci_map_queues() which results in a stack trace and possibly\nundefined behavior.\n\nStack Trace:\n[    7.860089] scsi host2: smartpqi\n[    7.871934] WARNING: CPU: 0 PID: 238 at block/blk-mq-pci.c:52 blk_mq_pci_map_queues+0xca/0xd0\n[    7.889231] Modules linked in: sd_mod t10_pi sg uas smartpqi(+) crc32c_intel scsi_transport_sas usb_storage dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler fuse\n[    7.924755] CPU: 0 PID: 238 Comm: kworker/0:3 Not tainted 4.18.0-372.88.1.el8_6_smartpqi_test.x86_64 #1\n[    7.944336] Hardware name: HPE ProLiant DL380 Gen10/ProLiant DL380 Gen10, BIOS U30 03/08/2022\n[    7.963026] Workqueue: events work_for_cpu_fn\n[    7.978275] RIP: 0010:blk_mq_pci_map_queues+0xca/0xd0\n[    7.978278] Code: 48 89 de 89 c7 e8 f6 0f 4f 00 3b 05 c4 b7 8e 01 72 e1 5b 31 c0 5d 41 5c 41 5d 41 5e 41 5f e9 7d df 73 00 31 c0 e9 76 df 73 00 <0f> 0b eb bc 90 90 0f 1f 44 00 00 41 57 49 89 ff 41 56 41 55 41 54\n[    7.978280] RSP: 0018:ffffa95fc3707d50 EFLAGS: 00010216\n[    7.978283] RAX: 00000000ffffffff RBX: 0000000000000000 RCX: 0000000000000010\n[    7.978284] RDX: 0000000000000004 RSI: 0000000000000000 RDI: ffff9190c32d4310\n[    7.978286] RBP: 0000000000000000 R08: ffffa95fc3707d38 R09: ffff91929b81ac00\n[    7.978287] R10: 0000000000000001 R11: ffffa95fc3707ac0 R12: 0000000000000000\n[    7.978288] R13: ffff9190c32d4000 R14: 00000000ffffffff R15: ffff9190c4c950a8\n[    7.978290] FS:  0000000000000000(0000) GS:ffff9193efc00000(0000) knlGS:0000000000000000\n[    7.978292] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    8.172814] CR2: 000055d11166c000 CR3: 00000002dae10002 CR4: 00000000007706f0\n[    8.172816] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[    8.172817] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[    8.172818] PKRU: 55555554\n[    8.172819] Call Trace:\n[    8.172823]  blk_mq_alloc_tag_set+0x12e/0x310\n[    8.264339]  scsi_add_host_with_dma.cold.9+0x30/0x245\n[    8.279302]  pqi_ctrl_init+0xacf/0xc8e [smartpqi]\n[    8.294085]  ? pqi_pci_probe+0x480/0x4c8 [smartpqi]\n[    8.309015]  pqi_pci_probe+0x480/0x4c8 [smartpqi]\n[    8.323286]  local_pci_probe+0x42/0x80\n[    8.337855]  work_for_cpu_fn+0x16/0x20\n[    8.351193]  process_one_work+0x1a7/0x360\n[    8.364462]  ? create_worker+0x1a0/0x1a0\n[    8.379252]  worker_thread+0x1ce/0x390\n[    8.392623]  ? create_worker+0x1a0/0x1a0\n[    8.406295]  kthread+0x10a/0x120\n[    8.418428]  ? set_kthread_struct+0x50/0x50\n[    8.431532]  ret_from_fork+0x1f/0x40\n[    8.444137] ---[ end trace 1bf0173d39354506 ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26742",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-03",
                    "modification_date": "2025-03-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49413",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbfq: Update cgroup information before merging bio\n\nWhen the process is migrated to a different cgroup (or in case of\nwriteback just starts submitting bios associated with a different\ncgroup) bfq_merge_bio() can operate with stale cgroup information in\nbic. Thus the bio can be merged to a request from a different cgroup or\nit can result in merging of bfqqs for different cgroups or bfqqs of\nalready dead cgroups and causing possible use-after-free issues. Fix the\nproblem by updating cgroup information in bfq_merge_bio().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49413",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49465",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-throttle: Set BIO_THROTTLED when bio has been throttled\n\n1.In current process, all bio will set the BIO_THROTTLED flag\nafter __blk_throtl_bio().\n\n2.If bio needs to be throttled, it will start the timer and\nstop submit bio directly. Bio will submit in\nblk_throtl_dispatch_work_fn() when the timer expires.But in\nthe current process, if bio is throttled. The BIO_THROTTLED\nwill be set to bio after timer start. If the bio has been\ncompleted, it may cause use-after-free blow.\n\nBUG: KASAN: use-after-free in blk_throtl_bio+0x12f0/0x2c70\nRead of size 2 at addr ffff88801b8902d4 by task fio/26380\n\n dump_stack+0x9b/0xce\n print_address_description.constprop.6+0x3e/0x60\n kasan_report.cold.9+0x22/0x3a\n blk_throtl_bio+0x12f0/0x2c70\n submit_bio_checks+0x701/0x1550\n submit_bio_noacct+0x83/0xc80\n submit_bio+0xa7/0x330\n mpage_readahead+0x380/0x500\n read_pages+0x1c1/0xbf0\n page_cache_ra_unbounded+0x471/0x6f0\n do_page_cache_ra+0xda/0x110\n ondemand_readahead+0x442/0xae0\n page_cache_async_ra+0x210/0x300\n generic_file_buffered_read+0x4d9/0x2130\n generic_file_read_iter+0x315/0x490\n blkdev_read_iter+0x113/0x1b0\n aio_read+0x2ad/0x450\n io_submit_one+0xc8e/0x1d60\n __se_sys_io_submit+0x125/0x350\n do_syscall_64+0x2d/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nAllocated by task 26380:\n kasan_save_stack+0x19/0x40\n __kasan_kmalloc.constprop.2+0xc1/0xd0\n kmem_cache_alloc+0x146/0x440\n mempool_alloc+0x125/0x2f0\n bio_alloc_bioset+0x353/0x590\n mpage_alloc+0x3b/0x240\n do_mpage_readpage+0xddf/0x1ef0\n mpage_readahead+0x264/0x500\n read_pages+0x1c1/0xbf0\n page_cache_ra_unbounded+0x471/0x6f0\n do_page_cache_ra+0xda/0x110\n ondemand_readahead+0x442/0xae0\n page_cache_async_ra+0x210/0x300\n generic_file_buffered_read+0x4d9/0x2130\n generic_file_read_iter+0x315/0x490\n blkdev_read_iter+0x113/0x1b0\n aio_read+0x2ad/0x450\n io_submit_one+0xc8e/0x1d60\n __se_sys_io_submit+0x125/0x350\n do_syscall_64+0x2d/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nFreed by task 0:\n kasan_save_stack+0x19/0x40\n kasan_set_track+0x1c/0x30\n kasan_set_free_info+0x1b/0x30\n __kasan_slab_free+0x111/0x160\n kmem_cache_free+0x94/0x460\n mempool_free+0xd6/0x320\n bio_free+0xe0/0x130\n bio_put+0xab/0xe0\n bio_endio+0x3a6/0x5d0\n blk_update_request+0x590/0x1370\n scsi_end_request+0x7d/0x400\n scsi_io_completion+0x1aa/0xe50\n scsi_softirq_done+0x11b/0x240\n blk_mq_complete_request+0xd4/0x120\n scsi_mq_done+0xf0/0x200\n virtscsi_vq_done+0xbc/0x150\n vring_interrupt+0x179/0x390\n __handle_irq_event_percpu+0xf7/0x490\n handle_irq_event_percpu+0x7b/0x160\n handle_irq_event+0xcc/0x170\n handle_edge_irq+0x215/0xb20\n common_interrupt+0x60/0x120\n asm_common_interrupt+0x1e/0x40\n\nFix this by move BIO_THROTTLED set into the queue_lock.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49465",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47496",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/tls: Fix flipped sign in tls_err_abort() calls\n\nsk->sk_err appears to expect a positive value, a convention that ktls\ndoesn't always follow and that leads to memory corruption in other code.\nFor instance,\n\n    [kworker]\n    tls_encrypt_done(..., err=<negative error from crypto request>)\n      tls_err_abort(.., err)\n        sk->sk_err = err;\n\n    [task]\n    splice_from_pipe_feed\n      ...\n        tls_sw_do_sendpage\n          if (sk->sk_err) {\n            ret = -sk->sk_err;  // ret is positive\n\n    splice_from_pipe_feed (continued)\n      ret = actor(...)  // ret is still positive and interpreted as bytes\n                        // written, resulting in underflow of buf->len and\n                        // sd->len, leading to huge buf->offset and bogus\n                        // addresses computed in later calls to actor()\n\nFix all tls_err_abort() callers to pass a negative error code\nconsistently and centralize the error-prone sign flip there, throwing in\na warning to catch future misuse and uninlining the function so it\nreally does only warn once.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47496",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-09-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21858",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngeneve: Fix use-after-free in geneve_find_dev().\n\nsyzkaller reported a use-after-free in geneve_find_dev() [0]\nwithout repro.\n\ngeneve_configure() links struct geneve_dev.next to\nnet_generic(net, geneve_net_id)->geneve_list.\n\nThe net here could differ from dev_net(dev) if IFLA_NET_NS_PID,\nIFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set.\n\nWhen dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally\ncalls unregister_netdevice_queue() for each dev in the netns,\nand later the dev is freed.\n\nHowever, its geneve_dev.next is still linked to the backend UDP\nsocket netns.\n\nThen, use-after-free will occur when another geneve dev is created\nin the netns.\n\nLet's call geneve_dellink() instead in geneve_destroy_tunnels().\n\n[0]:\nBUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline]\nBUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\nRead of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441\n\nCPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d\nHardware name: linux,dummy-virt (DT)\nCall trace:\n show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x16c/0x6f0 mm/kasan/report.c:489\n kasan_report+0xc0/0x120 mm/kasan/report.c:602\n __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379\n geneve_find_dev drivers/net/geneve.c:1295 [inline]\n geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\n geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634\n rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]\n netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348\n netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892\n sock_sendmsg_nosec net/socket.c:713 [inline]\n __sock_sendmsg net/socket.c:728 [inline]\n ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568\n ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622\n __sys_sendmsg net/socket.c:2654 [inline]\n __do_sys_sendmsg net/socket.c:2659 [inline]\n __se_sys_sendmsg net/socket.c:2657 [inline]\n __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151\n el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762\n el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600\n\nAllocated by task 13247:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x30/0x68 mm/kasan/common.c:68\n kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4298 [inline]\n __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304\n __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645\n alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470\n rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604\n rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_n\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21858",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-12",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56631",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: sg: Fix slab-use-after-free read in sg_release()\n\nFix a use-after-free bug in sg_release(), detected by syzbot with KASAN:\n\nBUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30\nkernel/locking/lockdep.c:5838\n__mutex_unlock_slowpath+0xe2/0x750 kernel/locking/mutex.c:912\nsg_release+0x1f4/0x2e0 drivers/scsi/sg.c:407\n\nIn sg_release(), the function kref_put(&sfp->f_ref, sg_remove_sfp) is\ncalled before releasing the open_rel_lock mutex. The kref_put() call may\ndecrement the reference count of sfp to zero, triggering its cleanup\nthrough sg_remove_sfp(). This cleanup includes scheduling deferred work\nvia sg_remove_sfp_usercontext(), which ultimately frees sfp.\n\nAfter kref_put(), sg_release() continues to unlock open_rel_lock and may\nreference sfp or sdp. If sfp has already been freed, this results in a\nslab-use-after-free error.\n\nMove the kref_put(&sfp->f_ref, sg_remove_sfp) call after unlocking the\nopen_rel_lock mutex. This ensures:\n\n - No references to sfp or sdp occur after the reference count is\n   decremented.\n\n - Cleanup functions such as sg_remove_sfp() and\n   sg_remove_sfp_usercontext() can safely execute without impacting the\n   mutex handling in sg_release().\n\nThe fix has been tested and validated by syzbot. This patch closes the\nbug reported at the following syzkaller link and ensures proper\nsequencing of resource cleanup and mutex operations, eliminating the\nrisk of use-after-free errors in sg_release().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56631",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38729",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Validate UAC3 power domain descriptors, too\n\nUAC3 power domain descriptors need to be verified with its variable\nbLength for avoiding the unexpected OOB accesses by malicious\nfirmware, too.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38729",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-38556",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Add a timeout to acquire the command queue semaphore\n\nPrevent forced completion handling on an entry that has not yet been\nassigned an index, causing an out of bounds access on idx = -22.\nInstead of waiting indefinitely for the sem, blocking flow now waits for\nindex to be allocated or a sem acquisition timeout before beginning the\ntimer for FW completion.\n\nKernel log example:\nmlx5_core 0000:06:00.0: wait_func_handle_exec_timeout:1128:(pid 185911): cmd[-22]: CREATE_UCTX(0xa04) No done completion",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38556",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2025-03-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49384",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd: fix double free of io_acct_set bioset\n\nNow io_acct_set is alloc and free in personality. Remove the codes that\nfree io_acct_set in md_free and md_stop.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49384",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53037",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpi3mr: Bad drive in topology results kernel crash\n\nWhen the SAS Transport Layer support is enabled and a device exposed to\nthe OS by the driver fails INQUIRY commands, the driver frees up the memory\nallocated for an internal HBA port data structure. However, in some places,\nthe reference to the freed memory is not cleared. When the firmware sends\nthe Device Info change event for the same device again, the freed memory is\naccessed and that leads to memory corruption and OS crash.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53037",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56558",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: make sure exp active before svc_export_show\n\nThe function `e_show` was called with protection from RCU. This only\nensures that `exp` will not be freed. Therefore, the reference count for\n`exp` can drop to zero, which will trigger a refcount use-after-free\nwarning when `exp_get` is called. To resolve this issue, use\n`cache_get_rcu` to ensure that `exp` remains active.\n\n------------[ cut here ]------------\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 3 PID: 819 at lib/refcount.c:25\nrefcount_warn_saturate+0xb1/0x120\nCPU: 3 UID: 0 PID: 819 Comm: cat Not tainted 6.12.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb1/0x120\n...\nCall Trace:\n <TASK>\n e_show+0x20b/0x230 [nfsd]\n seq_read_iter+0x589/0x770\n seq_read+0x1e5/0x270\n vfs_read+0x125/0x530\n ksys_read+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56558",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38239",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: megaraid_sas: Fix invalid node index\n\nOn a system with DRAM interleave enabled, out-of-bound access is\ndetected:\n\nmegaraid_sas 0000:3f:00.0: requested/available msix 128/128 poll_queue 0\n------------[ cut here ]------------\nUBSAN: array-index-out-of-bounds in ./arch/x86/include/asm/topology.h:72:28\nindex -1 is out of range for type 'cpumask *[1024]'\ndump_stack_lvl+0x5d/0x80\nubsan_epilogue+0x5/0x2b\n__ubsan_handle_out_of_bounds.cold+0x46/0x4b\nmegasas_alloc_irq_vectors+0x149/0x190 [megaraid_sas]\nmegasas_probe_one.cold+0xa4d/0x189c [megaraid_sas]\nlocal_pci_probe+0x42/0x90\npci_device_probe+0xdc/0x290\nreally_probe+0xdb/0x340\n__driver_probe_device+0x78/0x110\ndriver_probe_device+0x1f/0xa0\n__driver_attach+0xba/0x1c0\nbus_for_each_dev+0x8b/0xe0\nbus_add_driver+0x142/0x220\ndriver_register+0x72/0xd0\nmegasas_init+0xdf/0xff0 [megaraid_sas]\ndo_one_initcall+0x57/0x310\ndo_init_module+0x90/0x250\ninit_module_from_file+0x85/0xc0\nidempotent_init_module+0x114/0x310\n__x64_sys_finit_module+0x65/0xc0\ndo_syscall_64+0x82/0x170\nentry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFix it accordingly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38239",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-09",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-50282",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: add missing size check in amdgpu_debugfs_gprwave_read()\n\nAvoid a possible buffer overflow if size is larger than 4K.\n\n(cherry picked from commit f5d873f5825b40d886d03bd2aede91d4cf002434)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50282",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57917",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntopology: Keep the cpumask unchanged when printing cpumap\n\nDuring fuzz testing, the following warning was discovered:\n\n different return values (15 and 11) from vsnprintf(\"%*pbl\n \", ...)\n\n test:keyward is WARNING in kvasprintf\n WARNING: CPU: 55 PID: 1168477 at lib/kasprintf.c:30 kvasprintf+0x121/0x130\n Call Trace:\n  kvasprintf+0x121/0x130\n  kasprintf+0xa6/0xe0\n  bitmap_print_to_buf+0x89/0x100\n  core_siblings_list_read+0x7e/0xb0\n  kernfs_file_read_iter+0x15b/0x270\n  new_sync_read+0x153/0x260\n  vfs_read+0x215/0x290\n  ksys_read+0xb9/0x160\n  do_syscall_64+0x56/0x100\n  entry_SYSCALL_64_after_hwframe+0x78/0xe2\n\nThe call trace shows that kvasprintf() reported this warning during the\nprinting of core_siblings_list. kvasprintf() has several steps:\n\n (1) First, calculate the length of the resulting formatted string.\n\n (2) Allocate a buffer based on the returned length.\n\n (3) Then, perform the actual string formatting.\n\n (4) Check whether the lengths of the formatted strings returned in\n     steps (1) and (2) are consistent.\n\nIf the core_cpumask is modified between steps (1) and (3), the lengths\nobtained in these two steps may not match. Indeed our test includes cpu\nhotplugging, which should modify core_cpumask while printing.\n\nTo fix this issue, cache the cpumask into a temporary variable before\ncalling cpumap_print_{list, cpumask}_to_buf(), to keep it unchanged\nduring the printing process.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57917",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49411",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbfq: Make sure bfqg for which we are queueing requests is online\n\nBios queued into BFQ IO scheduler can be associated with a cgroup that\nwas already offlined. This may then cause insertion of this bfq_group\ninto a service tree. But this bfq_group will get freed as soon as last\nbio associated with it is completed leading to use after free issues for\nservice tree users. Fix the problem by making sure we always operate on\nonline bfq_group. If the bfq_group associated with the bio is not\nonline, we pick the first online parent.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49411",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21786",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nworkqueue: Put the pwq after detaching the rescuer from the pool\n\nThe commit 68f83057b913(\"workqueue: Reap workers via kthread_stop() and\nremove detach_completion\") adds code to reap the normal workers but\nmistakenly does not handle the rescuer and also removes the code waiting\nfor the rescuer in put_unbound_pool(), which caused a use-after-free bug\nreported by Cheung Wall.\n\nTo avoid the use-after-free bug, the pool\u2019s reference must be held until\nthe detachment is complete. Therefore, move the code that puts the pwq\nafter detaching the rescuer from the pool.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21786",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-03-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49179",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock, bfq: don't move oom_bfqq\n\nOur test report a UAF:\n\n[ 2073.019181] ==================================================================\n[ 2073.019188] BUG: KASAN: use-after-free in __bfq_put_async_bfqq+0xa0/0x168\n[ 2073.019191] Write of size 8 at addr ffff8000ccf64128 by task rmmod/72584\n[ 2073.019192]\n[ 2073.019196] CPU: 0 PID: 72584 Comm: rmmod Kdump: loaded Not tainted 4.19.90-yk #5\n[ 2073.019198] Hardware name: QEMU KVM Virtual Machine, BIOS 0.0.0 02/06/2015\n[ 2073.019200] Call trace:\n[ 2073.019203]  dump_backtrace+0x0/0x310\n[ 2073.019206]  show_stack+0x28/0x38\n[ 2073.019210]  dump_stack+0xec/0x15c\n[ 2073.019216]  print_address_description+0x68/0x2d0\n[ 2073.019220]  kasan_report+0x238/0x2f0\n[ 2073.019224]  __asan_store8+0x88/0xb0\n[ 2073.019229]  __bfq_put_async_bfqq+0xa0/0x168\n[ 2073.019233]  bfq_put_async_queues+0xbc/0x208\n[ 2073.019236]  bfq_pd_offline+0x178/0x238\n[ 2073.019240]  blkcg_deactivate_policy+0x1f0/0x420\n[ 2073.019244]  bfq_exit_queue+0x128/0x178\n[ 2073.019249]  blk_mq_exit_sched+0x12c/0x160\n[ 2073.019252]  elevator_exit+0xc8/0xd0\n[ 2073.019256]  blk_exit_queue+0x50/0x88\n[ 2073.019259]  blk_cleanup_queue+0x228/0x3d8\n[ 2073.019267]  null_del_dev+0xfc/0x1e0 [null_blk]\n[ 2073.019274]  null_exit+0x90/0x114 [null_blk]\n[ 2073.019278]  __arm64_sys_delete_module+0x358/0x5a0\n[ 2073.019282]  el0_svc_common+0xc8/0x320\n[ 2073.019287]  el0_svc_handler+0xf8/0x160\n[ 2073.019290]  el0_svc+0x10/0x218\n[ 2073.019291]\n[ 2073.019294] Allocated by task 14163:\n[ 2073.019301]  kasan_kmalloc+0xe0/0x190\n[ 2073.019305]  kmem_cache_alloc_node_trace+0x1cc/0x418\n[ 2073.019308]  bfq_pd_alloc+0x54/0x118\n[ 2073.019313]  blkcg_activate_policy+0x250/0x460\n[ 2073.019317]  bfq_create_group_hierarchy+0x38/0x110\n[ 2073.019321]  bfq_init_queue+0x6d0/0x948\n[ 2073.019325]  blk_mq_init_sched+0x1d8/0x390\n[ 2073.019330]  elevator_switch_mq+0x88/0x170\n[ 2073.019334]  elevator_switch+0x140/0x270\n[ 2073.019338]  elv_iosched_store+0x1a4/0x2a0\n[ 2073.019342]  queue_attr_store+0x90/0xe0\n[ 2073.019348]  sysfs_kf_write+0xa8/0xe8\n[ 2073.019351]  kernfs_fop_write+0x1f8/0x378\n[ 2073.019359]  __vfs_write+0xe0/0x360\n[ 2073.019363]  vfs_write+0xf0/0x270\n[ 2073.019367]  ksys_write+0xdc/0x1b8\n[ 2073.019371]  __arm64_sys_write+0x50/0x60\n[ 2073.019375]  el0_svc_common+0xc8/0x320\n[ 2073.019380]  el0_svc_handler+0xf8/0x160\n[ 2073.019383]  el0_svc+0x10/0x218\n[ 2073.019385]\n[ 2073.019387] Freed by task 72584:\n[ 2073.019391]  __kasan_slab_free+0x120/0x228\n[ 2073.019394]  kasan_slab_free+0x10/0x18\n[ 2073.019397]  kfree+0x94/0x368\n[ 2073.019400]  bfqg_put+0x64/0xb0\n[ 2073.019404]  bfqg_and_blkg_put+0x90/0xb0\n[ 2073.019408]  bfq_put_queue+0x220/0x228\n[ 2073.019413]  __bfq_put_async_bfqq+0x98/0x168\n[ 2073.019416]  bfq_put_async_queues+0xbc/0x208\n[ 2073.019420]  bfq_pd_offline+0x178/0x238\n[ 2073.019424]  blkcg_deactivate_policy+0x1f0/0x420\n[ 2073.019429]  bfq_exit_queue+0x128/0x178\n[ 2073.019433]  blk_mq_exit_sched+0x12c/0x160\n[ 2073.019437]  elevator_exit+0xc8/0xd0\n[ 2073.019440]  blk_exit_queue+0x50/0x88\n[ 2073.019443]  blk_cleanup_queue+0x228/0x3d8\n[ 2073.019451]  null_del_dev+0xfc/0x1e0 [null_blk]\n[ 2073.019459]  null_exit+0x90/0x114 [null_blk]\n[ 2073.019462]  __arm64_sys_delete_module+0x358/0x5a0\n[ 2073.019467]  el0_svc_common+0xc8/0x320\n[ 2073.019471]  el0_svc_handler+0xf8/0x160\n[ 2073.019474]  el0_svc+0x10/0x218\n[ 2073.019475]\n[ 2073.019479] The buggy address belongs to the object at ffff8000ccf63f00\n which belongs to the cache kmalloc-1024 of size 1024\n[ 2073.019484] The buggy address is located 552 bytes inside of\n 1024-byte region [ffff8000ccf63f00, ffff8000ccf64300)\n[ 2073.019486] The buggy address belongs to the page:\n[ 2073.019492] page:ffff7e000333d800 count:1 mapcount:0 mapping:ffff8000c0003a00 index:0x0 compound_mapcount: 0\n[ 2073.020123] flags: 0x7ffff0000008100(slab|head)\n[ 2073.020403] raw: 07ffff0000008100 ffff7e0003334c08 ffff7e00001f5a08 ffff8000c0003a00\n[ 2073.020409] ra\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49179",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49700",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: add missing TID updates on slab deactivation\n\nThe fastpath in slab_alloc_node() assumes that c->slab is stable as long as\nthe TID stays the same. However, two places in __slab_alloc() currently\ndon't update the TID when deactivating the CPU slab.\n\nIf multiple operations race the right way, this could lead to an object\ngetting lost; or, in an even more unlikely situation, it could even lead to\nan object being freed onto the wrong slab's freelist, messing up the\n`inuse` counter and eventually causing a page to be freed to the page\nallocator while it still contains slab objects.\n\n(I haven't actually tested these cases though, this is just based on\nlooking at the code. Writing testcases for this stuff seems like it'd be\na pain...)\n\nThe race leading to state inconsistency is (all operations on the same CPU\nand kmem_cache):\n\n - task A: begin do_slab_free():\n    - read TID\n    - read pcpu freelist (==NULL)\n    - check `slab == c->slab` (true)\n - [PREEMPT A->B]\n - task B: begin slab_alloc_node():\n    - fastpath fails (`c->freelist` is NULL)\n    - enter __slab_alloc()\n    - slub_get_cpu_ptr() (disables preemption)\n    - enter ___slab_alloc()\n    - take local_lock_irqsave()\n    - read c->freelist as NULL\n    - get_freelist() returns NULL\n    - write `c->slab = NULL`\n    - drop local_unlock_irqrestore()\n    - goto new_slab\n    - slub_percpu_partial() is NULL\n    - get_partial() returns NULL\n    - slub_put_cpu_ptr() (enables preemption)\n - [PREEMPT B->A]\n - task A: finish do_slab_free():\n    - this_cpu_cmpxchg_double() succeeds()\n    - [CORRUPT STATE: c->slab==NULL, c->freelist!=NULL]\n\nFrom there, the object on c->freelist will get lost if task B is allowed to\ncontinue from here: It will proceed to the retry_load_slab label,\nset c->slab, then jump to load_freelist, which clobbers c->freelist.\n\nBut if we instead continue as follows, we get worse corruption:\n\n - task A: run __slab_free() on object from other struct slab:\n    - CPU_PARTIAL_FREE case (slab was on no list, is now on pcpu partial)\n - task A: run slab_alloc_node() with NUMA node constraint:\n    - fastpath fails (c->slab is NULL)\n    - call __slab_alloc()\n    - slub_get_cpu_ptr() (disables preemption)\n    - enter ___slab_alloc()\n    - c->slab is NULL: goto new_slab\n    - slub_percpu_partial() is non-NULL\n    - set c->slab to slub_percpu_partial(c)\n    - [CORRUPT STATE: c->slab points to slab-1, c->freelist has objects\n      from slab-2]\n    - goto redo\n    - node_match() fails\n    - goto deactivate_slab\n    - existing c->freelist is passed into deactivate_slab()\n    - inuse count of slab-1 is decremented to account for object from\n      slab-2\n\nAt this point, the inuse count of slab-1 is 1 lower than it should be.\nThis means that if we free all allocated objects in slab-1 except for one,\nSLUB will think that slab-1 is completely unused, and may free its page,\nleading to use-after-free.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49700",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48744",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Avoid field-overflowing memcpy()\n\nIn preparation for FORTIFY_SOURCE performing compile-time and run-time\nfield bounds checking for memcpy(), memmove(), and memset(), avoid\nintentionally writing across neighboring fields.\n\nUse flexible arrays instead of zero-element arrays (which look like they\nare always overflowing) and split the cross-field memcpy() into two halves\nthat can be appropriately bounds-checked by the compiler.\n\nWe were doing:\n\n\t#define ETH_HLEN  14\n\t#define VLAN_HLEN  4\n\t...\n\t#define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN)\n\t...\n        struct mlx5e_tx_wqe      *wqe  = mlx5_wq_cyc_get_wqe(wq, pi);\n\t...\n        struct mlx5_wqe_eth_seg  *eseg = &wqe->eth;\n        struct mlx5_wqe_data_seg *dseg = wqe->data;\n\t...\n\tmemcpy(eseg->inline_hdr.start, xdptxd->data, MLX5E_XDP_MIN_INLINE);\n\ntarget is wqe->eth.inline_hdr.start (which the compiler sees as being\n2 bytes in size), but copying 18, intending to write across start\n(really vlan_tci, 2 bytes). The remaining 16 bytes get written into\nwqe->data[0], covering byte_count (4 bytes), lkey (4 bytes), and addr\n(8 bytes).\n\nstruct mlx5e_tx_wqe {\n        struct mlx5_wqe_ctrl_seg   ctrl;                 /*     0    16 */\n        struct mlx5_wqe_eth_seg    eth;                  /*    16    16 */\n        struct mlx5_wqe_data_seg   data[];               /*    32     0 */\n\n        /* size: 32, cachelines: 1, members: 3 */\n        /* last cacheline: 32 bytes */\n};\n\nstruct mlx5_wqe_eth_seg {\n        u8                         swp_outer_l4_offset;  /*     0     1 */\n        u8                         swp_outer_l3_offset;  /*     1     1 */\n        u8                         swp_inner_l4_offset;  /*     2     1 */\n        u8                         swp_inner_l3_offset;  /*     3     1 */\n        u8                         cs_flags;             /*     4     1 */\n        u8                         swp_flags;            /*     5     1 */\n        __be16                     mss;                  /*     6     2 */\n        __be32                     flow_table_metadata;  /*     8     4 */\n        union {\n                struct {\n                        __be16     sz;                   /*    12     2 */\n                        u8         start[2];             /*    14     2 */\n                } inline_hdr;                            /*    12     4 */\n                struct {\n                        __be16     type;                 /*    12     2 */\n                        __be16     vlan_tci;             /*    14     2 */\n                } insert;                                /*    12     4 */\n                __be32             trailer;              /*    12     4 */\n        };                                               /*    12     4 */\n\n        /* size: 16, cachelines: 1, members: 9 */\n        /* last cacheline: 16 bytes */\n};\n\nstruct mlx5_wqe_data_seg {\n        __be32                     byte_count;           /*     0     4 */\n        __be32                     lkey;                 /*     4     4 */\n        __be64                     addr;                 /*     8     8 */\n\n        /* size: 16, cachelines: 1, members: 3 */\n        /* last cacheline: 16 bytes */\n};\n\nSo, split the memcpy() so the compiler can reason about the buffer\nsizes.\n\n\"pahole\" shows no size nor member offset changes to struct mlx5e_tx_wqe\nnor struct mlx5e_umr_wqe. \"objdump -d\" shows no meaningful object\ncode changes (i.e. only source line number induced differences and\noptimizations).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48744",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2025-09-29",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38201",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_pipapo: clamp maximum map bucket size to INT_MAX\n\nOtherwise, it is possible to hit WARN_ON_ONCE in __kvmalloc_node_noprof()\nwhen resizing hashtable because __GFP_NOWARN is unset.\n\nSimilar to:\n\n  b541ba7d1f5a (\"netfilter: conntrack: clamp maximum hashtable size to INT_MAX\")",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38201",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-04",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50073",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: n_gsm: Fix use-after-free in gsm_cleanup_mux\n\nBUG: KASAN: slab-use-after-free in gsm_cleanup_mux+0x77b/0x7b0\ndrivers/tty/n_gsm.c:3160 [n_gsm]\nRead of size 8 at addr ffff88815fe99c00 by task poc/3379\nCPU: 0 UID: 0 PID: 3379 Comm: poc Not tainted 6.11.0+ #56\nHardware name: VMware, Inc. VMware Virtual Platform/440BX\nDesktop Reference Platform, BIOS 6.00 11/12/2020\nCall Trace:\n <TASK>\n gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm]\n __pfx_gsm_cleanup_mux+0x10/0x10 drivers/tty/n_gsm.c:3124 [n_gsm]\n __pfx_sched_clock_cpu+0x10/0x10 kernel/sched/clock.c:389\n update_load_avg+0x1c1/0x27b0 kernel/sched/fair.c:4500\n __pfx_min_vruntime_cb_rotate+0x10/0x10 kernel/sched/fair.c:846\n __rb_insert_augmented+0x492/0xbf0 lib/rbtree.c:161\n gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm]\n _raw_spin_lock_irqsave+0x92/0xf0 arch/x86/include/asm/atomic.h:107\n __pfx_gsmld_ioctl+0x10/0x10 drivers/tty/n_gsm.c:3822 [n_gsm]\n ktime_get+0x5e/0x140 kernel/time/timekeeping.c:195\n ldsem_down_read+0x94/0x4e0 arch/x86/include/asm/atomic64_64.h:79\n __pfx_ldsem_down_read+0x10/0x10 drivers/tty/tty_ldsem.c:338\n __pfx_do_vfs_ioctl+0x10/0x10 fs/ioctl.c:805\n tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818\n\nAllocated by task 65:\n gsm_data_alloc.constprop.0+0x27/0x190 drivers/tty/n_gsm.c:926 [n_gsm]\n gsm_send+0x2c/0x580 drivers/tty/n_gsm.c:819 [n_gsm]\n gsm1_receive+0x547/0xad0 drivers/tty/n_gsm.c:3038 [n_gsm]\n gsmld_receive_buf+0x176/0x280 drivers/tty/n_gsm.c:3609 [n_gsm]\n tty_ldisc_receive_buf+0x101/0x1e0 drivers/tty/tty_buffer.c:391\n tty_port_default_receive_buf+0x61/0xa0 drivers/tty/tty_port.c:39\n flush_to_ldisc+0x1b0/0x750 drivers/tty/tty_buffer.c:445\n process_scheduled_works+0x2b0/0x10d0 kernel/workqueue.c:3229\n worker_thread+0x3dc/0x950 kernel/workqueue.c:3391\n kthread+0x2a3/0x370 kernel/kthread.c:389\n ret_from_fork+0x2d/0x70 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:257\n\nFreed by task 3367:\n kfree+0x126/0x420 mm/slub.c:4580\n gsm_cleanup_mux+0x36c/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm]\n gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm]\n tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818\n\n[Analysis]\ngsm_msg on the tx_ctrl_list or tx_data_list of gsm_mux\ncan be freed by multi threads through ioctl,which leads\nto the occurrence of uaf. Protect it by gsm tx lock.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50073",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-29",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53019",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mdio: validate parameter addr in mdiobus_get_phy()\n\nThe caller may pass any value as addr, what may result in an out-of-bounds\naccess to array mdio_map. One existing case is stmmac_init_phy() that\nmay pass -1 as addr. Therefore validate addr before using it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53019",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49288",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: pcm: Fix races among concurrent prealloc proc writes\n\nWe have no protection against concurrent PCM buffer preallocation\nchanges via proc files, and it may potentially lead to UAF or some\nweird problem.  This patch applies the PCM open_mutex to the proc\nwrite operation for avoiding the racy proc writes and the PCM stream\nopen (and further operations).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49288",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49455",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: ocxl: fix possible double free in ocxl_file_register_afu\n\ninfo_release() will be called in device_unregister() when info->dev's\nreference count is 0. So there is no need to call ocxl_afu_put() and\nkfree() again.\n\nFix this by adding free_minor() and return to err_unregister error path.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49455",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50320",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: tables: FPDT: Don't call acpi_os_map_memory() on invalid phys address\n\nOn a Packard Bell Dot SC (Intel Atom N2600 model) there is a FPDT table\nwhich contains invalid physical addresses, with high bits set which fall\noutside the range of the CPU-s supported physical address range.\n\nCalling acpi_os_map_memory() on such an invalid phys address leads to\nthe below WARN_ON in ioremap triggering resulting in an oops/stacktrace.\n\nAdd code to verify the physical address before calling acpi_os_map_memory()\nto fix / avoid the oops.\n\n[    1.226900] ioremap: invalid physical address 3001000000000000\n[    1.226949] ------------[ cut here ]------------\n[    1.226962] WARNING: CPU: 1 PID: 1 at arch/x86/mm/ioremap.c:200 __ioremap_caller.cold+0x43/0x5f\n[    1.226996] Modules linked in:\n[    1.227016] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.0.0-rc3+ #490\n[    1.227029] Hardware name: Packard Bell dot s/SJE01_CT, BIOS V1.10 07/23/2013\n[    1.227038] RIP: 0010:__ioremap_caller.cold+0x43/0x5f\n[    1.227054] Code: 96 00 00 e9 f8 af 24 ff 89 c6 48 c7 c7 d8 0c 84 99 e8 6a 96 00 00 e9 76 af 24 ff 48 89 fe 48 c7 c7 a8 0c 84 99 e8 56 96 00 00 <0f> 0b e9 60 af 24 ff 48 8b 34 24 48 c7 c7 40 0d 84 99 e8 3f 96 00\n[    1.227067] RSP: 0000:ffffb18c40033d60 EFLAGS: 00010286\n[    1.227084] RAX: 0000000000000032 RBX: 3001000000000000 RCX: 0000000000000000\n[    1.227095] RDX: 0000000000000001 RSI: 00000000ffffdfff RDI: 00000000ffffffff\n[    1.227105] RBP: 3001000000000000 R08: 0000000000000000 R09: ffffb18c40033c18\n[    1.227115] R10: 0000000000000003 R11: ffffffff99d62fe8 R12: 0000000000000008\n[    1.227124] R13: 0003001000000000 R14: 0000000000001000 R15: 3001000000000000\n[    1.227135] FS:  0000000000000000(0000) GS:ffff913a3c080000(0000) knlGS:0000000000000000\n[    1.227146] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    1.227156] CR2: 0000000000000000 CR3: 0000000018c26000 CR4: 00000000000006e0\n[    1.227167] Call Trace:\n[    1.227176]  <TASK>\n[    1.227185]  ? acpi_os_map_iomem+0x1c9/0x1e0\n[    1.227215]  ? kmem_cache_alloc_trace+0x187/0x370\n[    1.227254]  acpi_os_map_iomem+0x1c9/0x1e0\n[    1.227288]  acpi_init_fpdt+0xa8/0x253\n[    1.227308]  ? acpi_debugfs_init+0x1f/0x1f\n[    1.227339]  do_one_initcall+0x5a/0x300\n[    1.227406]  ? rcu_read_lock_sched_held+0x3f/0x80\n[    1.227442]  kernel_init_freeable+0x28b/0x2cc\n[    1.227512]  ? rest_init+0x170/0x170\n[    1.227538]  kernel_init+0x16/0x140\n[    1.227552]  ret_from_fork+0x1f/0x30\n[    1.227639]  </TASK>\n[    1.227647] irq event stamp: 186819\n[    1.227656] hardirqs last  enabled at (186825): [<ffffffff98184a6e>] __up_console_sem+0x5e/0x70\n[    1.227672] hardirqs last disabled at (186830): [<ffffffff98184a53>] __up_console_sem+0x43/0x70\n[    1.227686] softirqs last  enabled at (186576): [<ffffffff980fbc9d>] __irq_exit_rcu+0xed/0x160\n[    1.227701] softirqs last disabled at (186569): [<ffffffff980fbc9d>] __irq_exit_rcu+0xed/0x160\n[    1.227715] ---[ end trace 0000000000000000 ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50320",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49014",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: tun: Fix use-after-free in tun_detach()\n\nsyzbot reported use-after-free in tun_detach() [1].  This causes call\ntrace like below:\n\n==================================================================\nBUG: KASAN: use-after-free in notifier_call_chain+0x1ee/0x200 kernel/notifier.c:75\nRead of size 8 at addr ffff88807324e2a8 by task syz-executor.0/3673\n\nCPU: 0 PID: 3673 Comm: syz-executor.0 Not tainted 6.1.0-rc5-syzkaller-00044-gcc675d22e422 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:284 [inline]\n print_report+0x15e/0x461 mm/kasan/report.c:395\n kasan_report+0xbf/0x1f0 mm/kasan/report.c:495\n notifier_call_chain+0x1ee/0x200 kernel/notifier.c:75\n call_netdevice_notifiers_info+0x86/0x130 net/core/dev.c:1942\n call_netdevice_notifiers_extack net/core/dev.c:1983 [inline]\n call_netdevice_notifiers net/core/dev.c:1997 [inline]\n netdev_wait_allrefs_any net/core/dev.c:10237 [inline]\n netdev_run_todo+0xbc6/0x1100 net/core/dev.c:10351\n tun_detach drivers/net/tun.c:704 [inline]\n tun_chr_close+0xe4/0x190 drivers/net/tun.c:3467\n __fput+0x27c/0xa90 fs/file_table.c:320\n task_work_run+0x16f/0x270 kernel/task_work.c:179\n exit_task_work include/linux/task_work.h:38 [inline]\n do_exit+0xb3d/0x2a30 kernel/exit.c:820\n do_group_exit+0xd4/0x2a0 kernel/exit.c:950\n get_signal+0x21b1/0x2440 kernel/signal.c:2858\n arch_do_signal_or_restart+0x86/0x2300 arch/x86/kernel/signal.c:869\n exit_to_user_mode_loop kernel/entry/common.c:168 [inline]\n exit_to_user_mode_prepare+0x15f/0x250 kernel/entry/common.c:203\n __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]\n syscall_exit_to_user_mode+0x1d/0x50 kernel/entry/common.c:296\n do_syscall_64+0x46/0xb0 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe cause of the issue is that sock_put() from __tun_detach() drops\nlast reference count for struct net, and then notifier_call_chain()\nfrom netdev_state_change() accesses that struct net.\n\nThis patch fixes the issue by calling sock_put() from tun_detach()\nafter all necessary accesses for the struct net has done.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49014",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26928",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix potential UAF in cifs_debug_files_proc_show()\n\nSkip sessions that are being teared down (status == SES_EXITING) to\navoid UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26928",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-12-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53372",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: fix a potential overflow in sctp_ifwdtsn_skip\n\nCurrently, when traversing ifwdtsn skips with _sctp_walk_ifwdtsn, it only\nchecks the pos against the end of the chunk. However, the data left for\nthe last pos may be < sizeof(struct sctp_ifwdtsn_skip), and dereference\nit as struct sctp_ifwdtsn_skip may cause coverflow.\n\nThis patch fixes it by checking the pos against \"the end of the chunk -\nsizeof(struct sctp_ifwdtsn_skip)\" in sctp_ifwdtsn_skip, similar to\nsctp_fwdtsn_skip.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53372",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48837",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: rndis: prevent integer overflow in rndis_set_response()\n\nIf \"BufOffset\" is very large the \"BufOffset + 8\" operation can have an\ninteger overflow.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48837",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52614",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPM / devfreq: Fix buffer overflow in trans_stat_show\n\nFix buffer overflow in trans_stat_show().\n\nConvert simple snprintf to the more secure scnprintf with size of\nPAGE_SIZE.\n\nAdd condition checking if we are exceeding PAGE_SIZE and exit early from\nloop. Also add at the end a warning that we exceeded PAGE_SIZE and that\nstats is disabled.\n\nReturn -EFBIG in the case where we don't have enough space to write the\nfull transition table.\n\nAlso document in the ABI that this function can return -EFBIG error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52614",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-18",
                    "modification_date": "2024-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-53208",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: MGMT: Fix slab-use-after-free Read in set_powered_sync\n\nThis fixes the following crash:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in set_powered_sync+0x3a/0xc0 net/bluetooth/mgmt.c:1353\nRead of size 8 at addr ffff888029b4dd18 by task kworker/u9:0/54\n\nCPU: 1 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-01155-gf723224742fc #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nWorkqueue: hci0 hci_cmd_sync_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\nq kasan_report+0x143/0x180 mm/kasan/report.c:601\n set_powered_sync+0x3a/0xc0 net/bluetooth/mgmt.c:1353\n hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:328\n process_one_work kernel/workqueue.c:3231 [inline]\n process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3312\n worker_thread+0x86d/0xd10 kernel/workqueue.c:3389\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nAllocated by task 5247:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:370 [inline]\n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:387\n kasan_kmalloc include/linux/kasan.h:211 [inline]\n __kmalloc_cache_noprof+0x19c/0x2c0 mm/slub.c:4193\n kmalloc_noprof include/linux/slab.h:681 [inline]\n kzalloc_noprof include/linux/slab.h:807 [inline]\n mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269\n mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296\n set_powered+0x3cd/0x5e0 net/bluetooth/mgmt.c:1394\n hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712\n hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg+0x221/0x270 net/socket.c:745\n sock_write_iter+0x2dd/0x400 net/socket.c:1160\n new_sync_write fs/read_write.c:497 [inline]\n vfs_write+0xa72/0xc90 fs/read_write.c:590\n ksys_write+0x1a0/0x2c0 fs/read_write.c:643\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 5246:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256\n kasan_slab_free include/linux/kasan.h:184 [inline]\n slab_free_hook mm/slub.c:2256 [inline]\n slab_free mm/slub.c:4477 [inline]\n kfree+0x149/0x360 mm/slub.c:4598\n settings_rsp+0x2bc/0x390 net/bluetooth/mgmt.c:1443\n mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259\n __mgmt_power_off+0x112/0x420 net/bluetooth/mgmt.c:9455\n hci_dev_close_sync+0x665/0x11a0 net/bluetooth/hci_sync.c:5191\n hci_dev_do_close net/bluetooth/hci_core.c:483 [inline]\n hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508\n sock_do_ioctl+0x158/0x460 net/socket.c:1222\n sock_ioctl+0x629/0x8e0 net/socket.c:1341\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83gv\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53208",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38117",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: MGMT: Protect mgmt_pending list with its own lock\n\nThis uses a mutex to protect from concurrent access of mgmt_pending\nlist which can cause crashes like:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91\nRead of size 2 at addr ffff0000c48885b2 by task syz.4.334/7318\n\nCPU: 0 UID: 0 PID: 7318 Comm: syz.4.334 Not tainted 6.15.0-rc7-syzkaller-g187899f4124a #0 PREEMPT\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025\nCall trace:\n show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack+0x30/0x40 lib/dump_stack.c:94\n dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120\n print_address_description+0xa8/0x254 mm/kasan/report.c:408\n print_report+0x68/0x84 mm/kasan/report.c:521\n kasan_report+0xb0/0x110 mm/kasan/report.c:634\n __asan_report_load2_noabort+0x20/0x2c mm/kasan/report_generic.c:379\n hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91\n mgmt_pending_find+0x7c/0x140 net/bluetooth/mgmt_util.c:223\n pending_find net/bluetooth/mgmt.c:947 [inline]\n remove_adv_monitor+0x44/0x1a4 net/bluetooth/mgmt.c:5445\n hci_mgmt_cmd+0x780/0xc00 net/bluetooth/hci_sock.c:1712\n hci_sock_sendmsg+0x544/0xbb0 net/bluetooth/hci_sock.c:1832\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n sock_write_iter+0x25c/0x378 net/socket.c:1131\n new_sync_write fs/read_write.c:591 [inline]\n vfs_write+0x62c/0x97c fs/read_write.c:684\n ksys_write+0x120/0x210 fs/read_write.c:736\n __do_sys_write fs/read_write.c:747 [inline]\n __se_sys_write fs/read_write.c:744 [inline]\n __arm64_sys_write+0x7c/0x90 fs/read_write.c:744\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600\n\nAllocated by task 7037:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x40/0x78 mm/kasan/common.c:68\n kasan_save_alloc_info+0x44/0x54 mm/kasan/generic.c:562\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x9c/0xb4 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4327 [inline]\n __kmalloc_noprof+0x2fc/0x4c8 mm/slub.c:4339\n kmalloc_noprof include/linux/slab.h:909 [inline]\n sk_prot_alloc+0xc4/0x1f0 net/core/sock.c:2198\n sk_alloc+0x44/0x3ac net/core/sock.c:2254\n bt_sock_alloc+0x4c/0x300 net/bluetooth/af_bluetooth.c:148\n hci_sock_create+0xa8/0x194 net/bluetooth/hci_sock.c:2202\n bt_sock_create+0x14c/0x24c net/bluetooth/af_bluetooth.c:132\n __sock_create+0x43c/0x91c net/socket.c:1541\n sock_create net/socket.c:1599 [inline]\n __sys_socket_create net/socket.c:1636 [inline]\n __sys_socket+0xd4/0x1c0 net/socket.c:1683\n __do_sys_socket net/socket.c:1697 [inline]\n __se_sys_socket net/socket.c:1695 [inline]\n __arm64_sys_socket+0x7c/0x94 net/socket.c:1695\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600\n\nFreed by task 6607:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x40/0x78 mm/kasan/common.c:68\n kasan_save_free_info+0x58/0x70 mm/kasan/generic.c:576\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x68/0x88 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38117",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-11-20",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52474",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests\n\nhfi1 user SDMA request processing has two bugs that can cause data\ncorruption for user SDMA requests that have multiple payload iovecs\nwhere an iovec other than the tail iovec does not run up to the page\nboundary for the buffer pointed to by that iovec.a\n\nHere are the specific bugs:\n1. user_sdma_txadd() does not use struct user_sdma_iovec->iov.iov_len.\n   Rather, user_sdma_txadd() will add up to PAGE_SIZE bytes from iovec\n   to the packet, even if some of those bytes are past\n   iovec->iov.iov_len and are thus not intended to be in the packet.\n2. user_sdma_txadd() and user_sdma_send_pkts() fail to advance to the\n   next iovec in user_sdma_request->iovs when the current iovec\n   is not PAGE_SIZE and does not contain enough data to complete the\n   packet. The transmitted packet will contain the wrong data from the\n   iovec pages.\n\nThis has not been an issue with SDMA packets from hfi1 Verbs or PSM2\nbecause they only produce iovecs that end short of PAGE_SIZE as the tail\niovec of an SDMA request.\n\nFixing these bugs exposes other bugs with the SDMA pin cache\n(struct mmu_rb_handler) that get in way of supporting user SDMA requests\nwith multiple payload iovecs whose buffers do not end at PAGE_SIZE. So\nthis commit fixes those issues as well.\n\nHere are the mmu_rb_handler bugs that non-PAGE_SIZE-end multi-iovec\npayload user SDMA requests can hit:\n1. Overlapping memory ranges in mmu_rb_handler will result in duplicate\n   pinnings.\n2. When extending an existing mmu_rb_handler entry (struct mmu_rb_node),\n   the mmu_rb code (1) removes the existing entry under a lock, (2)\n   releases that lock, pins the new pages, (3) then reacquires the lock\n   to insert the extended mmu_rb_node.\n\n   If someone else comes in and inserts an overlapping entry between (2)\n   and (3), insert in (3) will fail.\n\n   The failure path code in this case unpins _all_ pages in either the\n   original mmu_rb_node or the new mmu_rb_node that was inserted between\n   (2) and (3).\n3. In hfi1_mmu_rb_remove_unless_exact(), mmu_rb_node->refcount is\n   incremented outside of mmu_rb_handler->lock. As a result, mmu_rb_node\n   could be evicted by another thread that gets mmu_rb_handler->lock and\n   checks mmu_rb_node->refcount before mmu_rb_node->refcount is\n   incremented.\n4. Related to #2 above, SDMA request submission failure path does not\n   check mmu_rb_node->refcount before freeing mmu_rb_node object.\n\n   If there are other SDMA requests in progress whose iovecs have\n   pointers to the now-freed mmu_rb_node(s), those pointers to the\n   now-freed mmu_rb nodes will be dereferenced when those SDMA requests\n   complete.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52474",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-26",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48658",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: slub: fix flush_cpu_slab()/__free_slab() invocations in task context.\n\nCommit 5a836bf6b09f (\"mm: slub: move flush_cpu_slab() invocations\n__free_slab() invocations out of IRQ context\") moved all flush_cpu_slab()\ninvocations to the global workqueue to avoid a problem related\nwith deactivate_slab()/__free_slab() being called from an IRQ context\non PREEMPT_RT kernels.\n\nWhen the flush_all_cpu_locked() function is called from a task context\nit may happen that a workqueue with WQ_MEM_RECLAIM bit set ends up\nflushing the global workqueue, this will cause a dependency issue.\n\n workqueue: WQ_MEM_RECLAIM nvme-delete-wq:nvme_delete_ctrl_work [nvme_core]\n   is flushing !WQ_MEM_RECLAIM events:flush_cpu_slab\n WARNING: CPU: 37 PID: 410 at kernel/workqueue.c:2637\n   check_flush_dependency+0x10a/0x120\n Workqueue: nvme-delete-wq nvme_delete_ctrl_work [nvme_core]\n RIP: 0010:check_flush_dependency+0x10a/0x120[  453.262125] Call Trace:\n __flush_work.isra.0+0xbf/0x220\n ? __queue_work+0x1dc/0x420\n flush_all_cpus_locked+0xfb/0x120\n __kmem_cache_shutdown+0x2b/0x320\n kmem_cache_destroy+0x49/0x100\n bioset_exit+0x143/0x190\n blk_release_queue+0xb9/0x100\n kobject_cleanup+0x37/0x130\n nvme_fc_ctrl_free+0xc6/0x150 [nvme_fc]\n nvme_free_ctrl+0x1ac/0x2b0 [nvme_core]\n\nFix this bug by creating a workqueue for the flush operation with\nthe WQ_MEM_RECLAIM bit set.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48658",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56615",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: fix OOB devmap writes when deleting elements\n\nJordy reported issue against XSKMAP which also applies to DEVMAP - the\nindex used for accessing map entry, due to being a signed integer,\ncauses the OOB writes. Fix is simple as changing the type from int to\nu32, however, when compared to XSKMAP case, one more thing needs to be\naddressed.\n\nWhen map is released from system via dev_map_free(), we iterate through\nall of the entries and an iterator variable is also an int, which\nimplies OOB accesses. Again, change it to be u32.\n\nExample splat below:\n\n[  160.724676] BUG: unable to handle page fault for address: ffffc8fc2c001000\n[  160.731662] #PF: supervisor read access in kernel mode\n[  160.736876] #PF: error_code(0x0000) - not-present page\n[  160.742095] PGD 0 P4D 0\n[  160.744678] Oops: Oops: 0000 [#1] PREEMPT SMP\n[  160.749106] CPU: 1 UID: 0 PID: 520 Comm: kworker/u145:12 Not tainted 6.12.0-rc1+ #487\n[  160.757050] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019\n[  160.767642] Workqueue: events_unbound bpf_map_free_deferred\n[  160.773308] RIP: 0010:dev_map_free+0x77/0x170\n[  160.777735] Code: 00 e8 fd 91 ed ff e8 b8 73 ed ff 41 83 7d 18 19 74 6e 41 8b 45 24 49 8b bd f8 00 00 00 31 db 85 c0 74 48 48 63 c3 48 8d 04 c7 <48> 8b 28 48 85 ed 74 30 48 8b 7d 18 48 85 ff 74 05 e8 b3 52 fa ff\n[  160.796777] RSP: 0018:ffffc9000ee1fe38 EFLAGS: 00010202\n[  160.802086] RAX: ffffc8fc2c001000 RBX: 0000000080000000 RCX: 0000000000000024\n[  160.809331] RDX: 0000000000000000 RSI: 0000000000000024 RDI: ffffc9002c001000\n[  160.816576] RBP: 0000000000000000 R08: 0000000000000023 R09: 0000000000000001\n[  160.823823] R10: 0000000000000001 R11: 00000000000ee6b2 R12: dead000000000122\n[  160.831066] R13: ffff88810c928e00 R14: ffff8881002df405 R15: 0000000000000000\n[  160.838310] FS:  0000000000000000(0000) GS:ffff8897e0c40000(0000) knlGS:0000000000000000\n[  160.846528] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  160.852357] CR2: ffffc8fc2c001000 CR3: 0000000005c32006 CR4: 00000000007726f0\n[  160.859604] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  160.866847] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  160.874092] PKRU: 55555554\n[  160.876847] Call Trace:\n[  160.879338]  <TASK>\n[  160.881477]  ? __die+0x20/0x60\n[  160.884586]  ? page_fault_oops+0x15a/0x450\n[  160.888746]  ? search_extable+0x22/0x30\n[  160.892647]  ? search_bpf_extables+0x5f/0x80\n[  160.896988]  ? exc_page_fault+0xa9/0x140\n[  160.900973]  ? asm_exc_page_fault+0x22/0x30\n[  160.905232]  ? dev_map_free+0x77/0x170\n[  160.909043]  ? dev_map_free+0x58/0x170\n[  160.912857]  bpf_map_free_deferred+0x51/0x90\n[  160.917196]  process_one_work+0x142/0x370\n[  160.921272]  worker_thread+0x29e/0x3b0\n[  160.925082]  ? rescuer_thread+0x4b0/0x4b0\n[  160.929157]  kthread+0xd4/0x110\n[  160.932355]  ? kthread_park+0x80/0x80\n[  160.936079]  ret_from_fork+0x2d/0x50\n[  160.943396]  ? kthread_park+0x80/0x80\n[  160.950803]  ret_from_fork_asm+0x11/0x20\n[  160.958482]  </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56615",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50422",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libsas: Fix use-after-free bug in smp_execute_task_sg()\n\nWhen executing SMP task failed, the smp_execute_task_sg() calls del_timer()\nto delete \"slow_task->timer\". However, if the timer handler\nsas_task_internal_timedout() is running, the del_timer() in\nsmp_execute_task_sg() will not stop it and a UAF will happen. The process\nis shown below:\n\n      (thread 1)               |        (thread 2)\nsmp_execute_task_sg()          | sas_task_internal_timedout()\n ...                           |\n del_timer()                   |\n ...                           |  ...\n sas_free_task(task)           |\n  kfree(task->slow_task) //FREE|\n                               |  task->slow_task->... //USE\n\nFix by calling del_timer_sync() in smp_execute_task_sg(), which makes sure\nthe timer handler have finished before the \"task->slow_task\" is\ndeallocated.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50422",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50411",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Fix error code path in acpi_ds_call_control_method()\n\nA use-after-free in acpi_ps_parse_aml() after a failing invocaion of\nacpi_ds_call_control_method() is reported by KASAN [1] and code\ninspection reveals that next_walk_state pushed to the thread by\nacpi_ds_create_walk_state() is freed on errors, but it is not popped\nfrom the thread beforehand.  Thus acpi_ds_get_current_walk_state()\ncalled by acpi_ps_parse_aml() subsequently returns it as the new\nwalk state which is incorrect.\n\nTo address this, make acpi_ds_call_control_method() call\nacpi_ds_pop_walk_state() to pop next_walk_state from the thread before\nreturning an error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50411",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50419",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_sysfs: Fix attempting to call device_add multiple times\n\ndevice_add shall not be called multiple times as stated in its\ndocumentation:\n\n 'Do not call this routine or device_register() more than once for\n any device structure'\n\nSyzkaller reports a bug as follows [1]:\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:33!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\n[...]\nCall Trace:\n <TASK>\n __list_add include/linux/list.h:69 [inline]\n list_add_tail include/linux/list.h:102 [inline]\n kobj_kset_join lib/kobject.c:164 [inline]\n kobject_add_internal+0x18f/0x8f0 lib/kobject.c:214\n kobject_add_varg lib/kobject.c:358 [inline]\n kobject_add+0x150/0x1c0 lib/kobject.c:410\n device_add+0x368/0x1e90 drivers/base/core.c:3452\n hci_conn_add_sysfs+0x9b/0x1b0 net/bluetooth/hci_sysfs.c:53\n hci_le_cis_estabilished_evt+0x57c/0xae0 net/bluetooth/hci_event.c:6799\n hci_le_meta_evt+0x2b8/0x510 net/bluetooth/hci_event.c:7110\n hci_event_func net/bluetooth/hci_event.c:7440 [inline]\n hci_event_packet+0x63d/0xfd0 net/bluetooth/hci_event.c:7495\n hci_rx_work+0xae7/0x1230 net/bluetooth/hci_core.c:4007\n process_one_work+0x991/0x1610 kernel/workqueue.c:2289\n worker_thread+0x665/0x1080 kernel/workqueue.c:2436\n kthread+0x2e4/0x3a0 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50419",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38512",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: prevent A-MSDU attacks in mesh networks\n\nThis patch is a mitigation to prevent the A-MSDU spoofing vulnerability\nfor mesh networks. The initial update to the IEEE 802.11 standard, in\nresponse to the FragAttacks, missed this case (CVE-2025-27558). It can\nbe considered a variant of CVE-2020-24588 but for mesh networks.\n\nThis patch tries to detect if a standard MSDU was turned into an A-MSDU\nby an adversary. This is done by parsing a received A-MSDU as a standard\nMSDU, calculating the length of the Mesh Control header, and seeing if\nthe 6 bytes after this header equal the start of an rfc1042 header. If\nequal, this is a strong indication of an ongoing attack attempt.\n\nThis defense was tested with mac80211_hwsim against a mesh network that\nuses an empty Mesh Address Extension field, i.e., when four addresses\nare used, and when using a 12-byte Mesh Address Extension field, i.e.,\nwhen six addresses are used. Functionality of normal MSDUs and A-MSDUs\nwas also tested, and confirmed working, when using both an empty and\n12-byte Mesh Address Extension field.\n\nIt was also tested with mac80211_hwsim that A-MSDU attacks in non-mesh\nnetworks keep being detected and prevented.\n\nNote that the vulnerability being patched, and the defense being\nimplemented, was also discussed in the following paper and in the\nfollowing IEEE 802.11 presentation:\n\nhttps://papers.mathyvanhoef.com/wisec2025.pdf\nhttps://mentor.ieee.org/802.11/dcn/25/11-25-0949-00-000m-a-msdu-mesh-spoof-protection.docx",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38512",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-16",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21714",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx5: Fix implicit ODP use after free\n\nPrevent double queueing of implicit ODP mr destroy work by using\n__xa_cmpxchg() to make sure this is the only time we are destroying this\nspecific mr.\n\nWithout this change, we could try to invalidate this mr twice, which in\nturn could result in queuing a MR work destroy twice, and eventually the\nsecond work could execute after the MR was freed due to the first work,\ncausing a user after free and trace below.\n\n   refcount_t: underflow; use-after-free.\n   WARNING: CPU: 2 PID: 12178 at lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130\n   Modules linked in: bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [last unloaded: ib_uverbs]\n   CPU: 2 PID: 12178 Comm: kworker/u20:5 Not tainted 6.5.0-rc1_net_next_mlx5_58c644e #1\n   Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n   Workqueue: events_unbound free_implicit_child_mr_work [mlx5_ib]\n   RIP: 0010:refcount_warn_saturate+0x12b/0x130\n   Code: 48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ff\n   RSP: 0018:ffff8881008e3e40 EFLAGS: 00010286\n   RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000027\n   RDX: ffff88852c91b5c8 RSI: 0000000000000001 RDI: ffff88852c91b5c0\n   RBP: ffff8881dacd4e00 R08: 00000000ffffffff R09: 0000000000000019\n   R10: 000000000000072e R11: 0000000063666572 R12: ffff88812bfd9e00\n   R13: ffff8881c792d200 R14: ffff88810011c005 R15: ffff8881002099c0\n   FS:  0000000000000000(0000) GS:ffff88852c900000(0000) knlGS:0000000000000000\n   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   CR2: 00007f5694b5e000 CR3: 00000001153f6003 CR4: 0000000000370ea0\n   DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n   DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n   Call Trace:\n    <TASK>\n    ? refcount_warn_saturate+0x12b/0x130\n    free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib]\n    process_one_work+0x1cc/0x3c0\n    worker_thread+0x218/0x3c0\n    kthread+0xc6/0xf0\n    ret_from_fork+0x1f/0x30\n    </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21714",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49267",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmmc: core: use sysfs_emit() instead of sprintf()\n\nsprintf() (still used in the MMC core for the sysfs output) is vulnerable\nto the buffer overflow.  Use the new-fangled sysfs_emit() instead.\n\nFound by Linux Verification Center (linuxtesting.org) with the SVACE static\nanalysis tool.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49267",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49917",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipvs: fix WARNING in ip_vs_app_net_cleanup()\n\nDuring the initialization of ip_vs_app_net_init(), if file ip_vs_app\nfails to be created, the initialization is successful by default.\nTherefore, the ip_vs_app file doesn't be found during the remove in\nip_vs_app_net_cleanup(). It will cause WRNING.\n\nThe following is the stack information:\nname 'ip_vs_app'\nWARNING: CPU: 1 PID: 9 at fs/proc/generic.c:712 remove_proc_entry+0x389/0x460\nModules linked in:\nWorkqueue: netns cleanup_net\nRIP: 0010:remove_proc_entry+0x389/0x460\nCall Trace:\n<TASK>\nops_exit_list+0x125/0x170\ncleanup_net+0x4ea/0xb00\nprocess_one_work+0x9bf/0x1710\nworker_thread+0x665/0x1080\nkthread+0x2e4/0x3a0\nret_from_fork+0x1f/0x30\n</TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49917",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53065",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Fix perf_output_begin parameter is incorrectly invoked in perf_event_bpf_output\n\nsyzkaller reportes a KASAN issue with stack-out-of-bounds.\nThe call trace is as follows:\n  dump_stack+0x9c/0xd3\n  print_address_description.constprop.0+0x19/0x170\n  __kasan_report.cold+0x6c/0x84\n  kasan_report+0x3a/0x50\n  __perf_event_header__init_id+0x34/0x290\n  perf_event_header__init_id+0x48/0x60\n  perf_output_begin+0x4a4/0x560\n  perf_event_bpf_output+0x161/0x1e0\n  perf_iterate_sb_cpu+0x29e/0x340\n  perf_iterate_sb+0x4c/0xc0\n  perf_event_bpf_event+0x194/0x2c0\n  __bpf_prog_put.constprop.0+0x55/0xf0\n  __cls_bpf_delete_prog+0xea/0x120 [cls_bpf]\n  cls_bpf_delete_prog_work+0x1c/0x30 [cls_bpf]\n  process_one_work+0x3c2/0x730\n  worker_thread+0x93/0x650\n  kthread+0x1b8/0x210\n  ret_from_fork+0x1f/0x30\n\ncommit 267fb27352b6 (\"perf: Reduce stack usage of perf_output_begin()\")\nuse on-stack struct perf_sample_data of the caller function.\n\nHowever, perf_event_bpf_output uses incorrect parameter to convert\nsmall-sized data (struct perf_bpf_event) into large-sized data\n(struct perf_sample_data), which causes memory overwriting occurs in\n__perf_event_header__init_id.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53065",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36015",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nppdev: Add an error check in register_device\n\nIn register_device, the return value of ida_simple_get is unchecked,\nin witch ida_simple_get will use an invalid index value.\n\nTo address this issue, index should be checked after ida_simple_get. When\nthe index value is abnormal, a warning message should be printed, the port\nshould be dropped, and the value should be recorded.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36015",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-29",
                    "modification_date": "2025-11-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-58013",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: MGMT: Fix slab-use-after-free Read in mgmt_remove_adv_monitor_sync\n\nThis fixes the following crash:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543\nRead of size 8 at addr ffff88814128f898 by task kworker/u9:4/5961\n\nCPU: 1 UID: 0 PID: 5961 Comm: kworker/u9:4 Not tainted 6.12.0-syzkaller-10684-gf1cd565ce577 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nWorkqueue: hci0 hci_cmd_sync_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:489\n kasan_report+0x143/0x180 mm/kasan/report.c:602\n mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543\n hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nAllocated by task 16026:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314\n kmalloc_noprof include/linux/slab.h:901 [inline]\n kzalloc_noprof include/linux/slab.h:1037 [inline]\n mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269\n mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296\n remove_adv_monitor+0x102/0x1b0 net/bluetooth/mgmt.c:5568\n hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712\n hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832\n sock_sendmsg_nosec net/socket.c:711 [inline]\n __sock_sendmsg+0x221/0x270 net/socket.c:726\n sock_write_iter+0x2d7/0x3f0 net/socket.c:1147\n new_sync_write fs/read_write.c:586 [inline]\n vfs_write+0xaeb/0xd30 fs/read_write.c:679\n ksys_write+0x18f/0x2b0 fs/read_write.c:731\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 16022:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2338 [inline]\n slab_free mm/slub.c:4598 [inline]\n kfree+0x196/0x420 mm/slub.c:4746\n mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259\n __mgmt_power_off+0x183/0x430 net/bluetooth/mgmt.c:9550\n hci_dev_close_sync+0x6c4/0x11c0 net/bluetooth/hci_sync.c:5208\n hci_dev_do_close net/bluetooth/hci_core.c:483 [inline]\n hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508\n sock_do_ioctl+0x158/0x460 net/socket.c:1209\n sock_ioctl+0x626/0x8e0 net/socket.c:1328\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:906 [inline]\n __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-58013",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21729",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: fix race between cancel_hw_scan and hw_scan completion\n\nThe rtwdev->scanning flag isn't protected by mutex originally, so\ncancel_hw_scan can pass the condition, but suddenly hw_scan completion\nunset the flag and calls ieee80211_scan_completed() that will free\nlocal->hw_scan_req. Then, cancel_hw_scan raises null-ptr-deref and\nuse-after-free. Fix it by moving the check condition to where\nprotected by mutex.\n\n KASAN: null-ptr-deref in range [0x0000000000000088-0x000000000000008f]\n CPU: 2 PID: 6922 Comm: kworker/2:2 Tainted: G           OE\n Hardware name: LENOVO 2356AD1/2356AD1, BIOS G7ETB6WW (2.76 ) 09/10/2019\n Workqueue: events cfg80211_conn_work [cfg80211]\n RIP: 0010:rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core]\n Code: 00 45 89 6c 24 1c 0f 85 23 01 00 00 48 8b 85 20 ff ff ff 48 8d\n RSP: 0018:ffff88811fd9f068 EFLAGS: 00010206\n RAX: dffffc0000000000 RBX: ffff88811fd9f258 RCX: 0000000000000001\n RDX: 0000000000000011 RSI: 0000000000000001 RDI: 0000000000000089\n RBP: ffff88811fd9f170 R08: 0000000000000000 R09: 0000000000000000\n R10: ffff88811fd9f108 R11: 0000000000000000 R12: ffff88810e47f960\n R13: 0000000000000000 R14: 000000000000ffff R15: 0000000000000000\n FS:  0000000000000000(0000) GS:ffff8881d6f00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007531dfca55b0 CR3: 00000001be296004 CR4: 00000000001706e0\n Call Trace:\n  <TASK>\n  ? show_regs+0x61/0x73\n  ? __die_body+0x20/0x73\n  ? die_addr+0x4f/0x7b\n  ? exc_general_protection+0x191/0x1db\n  ? asm_exc_general_protection+0x27/0x30\n  ? rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core]\n  ? rtw89_fw_h2c_scan_offload_be+0x458/0x13c3 [rtw89_core]\n  ? __pfx_rtw89_fw_h2c_scan_offload_be+0x10/0x10 [rtw89_core]\n  ? do_raw_spin_lock+0x75/0xdb\n  ? __pfx_do_raw_spin_lock+0x10/0x10\n  rtw89_hw_scan_offload+0xb5e/0xbf7 [rtw89_core]\n  ? _raw_spin_unlock+0xe/0x24\n  ? __mutex_lock.constprop.0+0x40c/0x471\n  ? __pfx_rtw89_hw_scan_offload+0x10/0x10 [rtw89_core]\n  ? __mutex_lock_slowpath+0x13/0x1f\n  ? mutex_lock+0xa2/0xdc\n  ? __pfx_mutex_lock+0x10/0x10\n  rtw89_hw_scan_abort+0x58/0xb7 [rtw89_core]\n  rtw89_ops_cancel_hw_scan+0x120/0x13b [rtw89_core]\n  ieee80211_scan_cancel+0x468/0x4d0 [mac80211]\n  ieee80211_prep_connection+0x858/0x899 [mac80211]\n  ieee80211_mgd_auth+0xbea/0xdde [mac80211]\n  ? __pfx_ieee80211_mgd_auth+0x10/0x10 [mac80211]\n  ? cfg80211_find_elem+0x15/0x29 [cfg80211]\n  ? is_bss+0x1b7/0x1d7 [cfg80211]\n  ieee80211_auth+0x18/0x27 [mac80211]\n  cfg80211_mlme_auth+0x3bb/0x3e7 [cfg80211]\n  cfg80211_conn_do_work+0x410/0xb81 [cfg80211]\n  ? __pfx_cfg80211_conn_do_work+0x10/0x10 [cfg80211]\n  ? __kasan_check_read+0x11/0x1f\n  ? psi_group_change+0x8bc/0x944\n  ? __kasan_check_write+0x14/0x22\n  ? mutex_lock+0x8e/0xdc\n  ? __pfx_mutex_lock+0x10/0x10\n  ? __pfx___radix_tree_lookup+0x10/0x10\n  cfg80211_conn_work+0x245/0x34d [cfg80211]\n  ? __pfx_cfg80211_conn_work+0x10/0x10 [cfg80211]\n  ? update_cfs_rq_load_avg+0x3bc/0x3d7\n  ? sched_clock_noinstr+0x9/0x1a\n  ? sched_clock+0x10/0x24\n  ? sched_clock_cpu+0x7e/0x42e\n  ? newidle_balance+0x796/0x937\n  ? __pfx_sched_clock_cpu+0x10/0x10\n  ? __pfx_newidle_balance+0x10/0x10\n  ? __kasan_check_read+0x11/0x1f\n  ? psi_group_change+0x8bc/0x944\n  ? _raw_spin_unlock+0xe/0x24\n  ? raw_spin_rq_unlock+0x47/0x54\n  ? raw_spin_rq_unlock_irq+0x9/0x1f\n  ? finish_task_switch.isra.0+0x347/0x586\n  ? __schedule+0x27bf/0x2892\n  ? mutex_unlock+0x80/0xd0\n  ? do_raw_spin_lock+0x75/0xdb\n  ? __pfx___schedule+0x10/0x10\n  process_scheduled_works+0x58c/0x821\n  worker_thread+0x4c7/0x586\n  ? __kasan_check_read+0x11/0x1f\n  kthread+0x285/0x294\n  ? __pfx_worker_thread+0x10/0x10\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork+0x29/0x6f\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork_asm+0x1b/0x30\n  </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21729",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38180",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atm: fix /proc/net/atm/lec handling\n\n/proc/net/atm/lec must ensure safety against dev_lec[] changes.\n\nIt appears it had dev_put() calls without prior dev_hold(),\nleading to imbalance and UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38180",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-04",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50055",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: bus: Fix double free in driver API bus_register()\n\nFor bus_register(), any error which happens after kset_register() will\ncause that @priv are freed twice, fixed by setting @priv with NULL after\nthe first free.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50055",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2026-01-05",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52987",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: ipc4-mtrace: prevent underflow in sof_ipc4_priority_mask_dfs_write()\n\nThe \"id\" comes from the user.  Change the type to unsigned to prevent\nan array underflow.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52987",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-44934",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: mcast: wait for previous gc cycles when removing port\n\nsyzbot hit a use-after-free[1] which is caused because the bridge doesn't\nmake sure that all previous garbage has been collected when removing a\nport. What happens is:\n      CPU 1                   CPU 2\n start gc cycle           remove port\n                         acquire gc lock first\n wait for lock\n                         call br_multicasg_gc() directly\n acquire lock now but    free port\n the port can be freed\n while grp timers still\n running\n\nMake sure all previous gc cycles have finished by using flush_work before\nfreeing the port.\n\n[1]\n  BUG: KASAN: slab-use-after-free in br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861\n  Read of size 8 at addr ffff888071d6d000 by task syz.5.1232/9699\n\n  CPU: 1 PID: 9699 Comm: syz.5.1232 Not tainted 6.10.0-rc5-syzkaller-00021-g24ca36a562d6 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/07/2024\n  Call Trace:\n   <IRQ>\n   __dump_stack lib/dump_stack.c:88 [inline]\n   dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114\n   print_address_description mm/kasan/report.c:377 [inline]\n   print_report+0xc3/0x620 mm/kasan/report.c:488\n   kasan_report+0xd9/0x110 mm/kasan/report.c:601\n   br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861\n   call_timer_fn+0x1a3/0x610 kernel/time/timer.c:1792\n   expire_timers kernel/time/timer.c:1843 [inline]\n   __run_timers+0x74b/0xaf0 kernel/time/timer.c:2417\n   __run_timer_base kernel/time/timer.c:2428 [inline]\n   __run_timer_base kernel/time/timer.c:2421 [inline]\n   run_timer_base+0x111/0x190 kernel/time/timer.c:2437",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44934",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-26",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50274",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nidpf: avoid vport access in idpf_get_link_ksettings\n\nWhen the device control plane is removed or the platform\nrunning device control plane is rebooted, a reset is detected\non the driver. On driver reset, it releases the resources and\nwaits for the reset to complete. If the reset fails, it takes\nthe error path and releases the vport lock. At this time if the\nmonitoring tools tries to access link settings, it call traces\nfor accessing released vport pointer.\n\nTo avoid it, move link_speed_mbps to netdev_priv structure\nwhich removes the dependency on vport pointer and the vport lock\nin idpf_get_link_ksettings. Also use netif_carrier_ok()\nto check the link status and adjust the offsetof to use link_up\ninstead of link_speed_mbps.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50274",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-39479",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/hwmon: Get rid of devm\n\nWhen both hwmon and hwmon drvdata (on which hwmon depends) are device\nmanaged resources, the expectation, on device unbind, is that hwmon will be\nreleased before drvdata. However, in i915 there are two separate code\npaths, which both release either drvdata or hwmon and either can be\nreleased before the other. These code paths (for device unbind) are as\nfollows (see also the bug referenced below):\n\nCall Trace:\nrelease_nodes+0x11/0x70\ndevres_release_group+0xb2/0x110\ncomponent_unbind_all+0x8d/0xa0\ncomponent_del+0xa5/0x140\nintel_pxp_tee_component_fini+0x29/0x40 [i915]\nintel_pxp_fini+0x33/0x80 [i915]\ni915_driver_remove+0x4c/0x120 [i915]\ni915_pci_remove+0x19/0x30 [i915]\npci_device_remove+0x32/0xa0\ndevice_release_driver_internal+0x19c/0x200\nunbind_store+0x9c/0xb0\n\nand\n\nCall Trace:\nrelease_nodes+0x11/0x70\ndevres_release_all+0x8a/0xc0\ndevice_unbind_cleanup+0x9/0x70\ndevice_release_driver_internal+0x1c1/0x200\nunbind_store+0x9c/0xb0\n\nThis means that in i915, if use devm, we cannot gurantee that hwmon will\nalways be released before drvdata. Which means that we have a uaf if hwmon\nsysfs is accessed when drvdata has been released but hwmon hasn't.\n\nThe only way out of this seems to be do get rid of devm_ and release/free\neverything explicitly during device unbind.\n\nv2: Change commit message and other minor code changes\nv3: Cleanup from i915_hwmon_register on error (Armin Wolf)\nv4: Eliminate potential static analyzer warning (Rodrigo)\n    Eliminate fetch_and_zero (Jani)\nv5: Restore previous logic for ddat_gt->hwmon_dev error return (Andi)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-39479",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-05",
                    "modification_date": "2025-05-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56640",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix LGR and link use-after-free issue\n\nWe encountered a LGR/link use-after-free issue, which manifested as\nthe LGR/link refcnt reaching 0 early and entering the clear process,\nmaking resource access unsafe.\n\n refcount_t: addition on 0; use-after-free.\n WARNING: CPU: 14 PID: 107447 at lib/refcount.c:25 refcount_warn_saturate+0x9c/0x140\n Workqueue: events smc_lgr_terminate_work [smc]\n Call trace:\n  refcount_warn_saturate+0x9c/0x140\n  __smc_lgr_terminate.part.45+0x2a8/0x370 [smc]\n  smc_lgr_terminate_work+0x28/0x30 [smc]\n  process_one_work+0x1b8/0x420\n  worker_thread+0x158/0x510\n  kthread+0x114/0x118\n\nor\n\n refcount_t: underflow; use-after-free.\n WARNING: CPU: 6 PID: 93140 at lib/refcount.c:28 refcount_warn_saturate+0xf0/0x140\n Workqueue: smc_hs_wq smc_listen_work [smc]\n Call trace:\n  refcount_warn_saturate+0xf0/0x140\n  smcr_link_put+0x1cc/0x1d8 [smc]\n  smc_conn_free+0x110/0x1b0 [smc]\n  smc_conn_abort+0x50/0x60 [smc]\n  smc_listen_find_device+0x75c/0x790 [smc]\n  smc_listen_work+0x368/0x8a0 [smc]\n  process_one_work+0x1b8/0x420\n  worker_thread+0x158/0x510\n  kthread+0x114/0x118\n\nIt is caused by repeated release of LGR/link refcnt. One suspect is that\nsmc_conn_free() is called repeatedly because some smc_conn_free() from\nserver listening path are not protected by sock lock.\n\ne.g.\n\nCalls under socklock        | smc_listen_work\n-------------------------------------------------------\nlock_sock(sk)               | smc_conn_abort\nsmc_conn_free               | \\- smc_conn_free\n\\- smcr_link_put            |    \\- smcr_link_put (duplicated)\nrelease_sock(sk)\n\nSo here add sock lock protection in smc_listen_work() path, making it\nexclusive with other connection operations.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56640",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49622",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: avoid skb access on nf_stolen\n\nWhen verdict is NF_STOLEN, the skb might have been freed.\n\nWhen tracing is enabled, this can result in a use-after-free:\n1. access to skb->nf_trace\n2. access to skb->mark\n3. computation of trace id\n4. dump of packet payload\n\nTo avoid 1, keep a cached copy of skb->nf_trace in the\ntrace state struct.\nRefresh this copy whenever verdict is != STOLEN.\n\nAvoid 2 by skipping skb->mark access if verdict is STOLEN.\n\n3 is avoided by precomputing the trace id.\n\nOnly dump the packet when verdict is not \"STOLEN\".",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49622",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47103",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ninet: fully convert sk->sk_rx_dst to RCU rules\n\nsyzbot reported various issues around early demux,\none being included in this changelog [1]\n\nsk->sk_rx_dst is using RCU protection without clearly\ndocumenting it.\n\nAnd following sequences in tcp_v4_do_rcv()/tcp_v6_do_rcv()\nare not following standard RCU rules.\n\n[a]    dst_release(dst);\n[b]    sk->sk_rx_dst = NULL;\n\nThey look wrong because a delete operation of RCU protected\npointer is supposed to clear the pointer before\nthe call_rcu()/synchronize_rcu() guarding actual memory freeing.\n\nIn some cases indeed, dst could be freed before [b] is done.\n\nWe could cheat by clearing sk_rx_dst before calling\ndst_release(), but this seems the right time to stick\nto standard RCU annotations and debugging facilities.\n\n[1]\nBUG: KASAN: use-after-free in dst_check include/net/dst.h:470 [inline]\nBUG: KASAN: use-after-free in tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792\nRead of size 2 at addr ffff88807f1cb73a by task syz-executor.5/9204\n\nCPU: 0 PID: 9204 Comm: syz-executor.5 Not tainted 5.16.0-rc5-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c:247\n __kasan_report mm/kasan/report.c:433 [inline]\n kasan_report.cold+0x83/0xdf mm/kasan/report.c:450\n dst_check include/net/dst.h:470 [inline]\n tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792\n ip_rcv_finish_core.constprop.0+0x15de/0x1e80 net/ipv4/ip_input.c:340\n ip_list_rcv_finish.constprop.0+0x1b2/0x6e0 net/ipv4/ip_input.c:583\n ip_sublist_rcv net/ipv4/ip_input.c:609 [inline]\n ip_list_rcv+0x34e/0x490 net/ipv4/ip_input.c:644\n __netif_receive_skb_list_ptype net/core/dev.c:5508 [inline]\n __netif_receive_skb_list_core+0x549/0x8e0 net/core/dev.c:5556\n __netif_receive_skb_list net/core/dev.c:5608 [inline]\n netif_receive_skb_list_internal+0x75e/0xd80 net/core/dev.c:5699\n gro_normal_list net/core/dev.c:5853 [inline]\n gro_normal_list net/core/dev.c:5849 [inline]\n napi_complete_done+0x1f1/0x880 net/core/dev.c:6590\n virtqueue_napi_complete drivers/net/virtio_net.c:339 [inline]\n virtnet_poll+0xca2/0x11b0 drivers/net/virtio_net.c:1557\n __napi_poll+0xaf/0x440 net/core/dev.c:7023\n napi_poll net/core/dev.c:7090 [inline]\n net_rx_action+0x801/0xb40 net/core/dev.c:7177\n __do_softirq+0x29b/0x9c2 kernel/softirq.c:558\n invoke_softirq kernel/softirq.c:432 [inline]\n __irq_exit_rcu+0x123/0x180 kernel/softirq.c:637\n irq_exit_rcu+0x5/0x20 kernel/softirq.c:649\n common_interrupt+0x52/0xc0 arch/x86/kernel/irq.c:240\n asm_common_interrupt+0x1e/0x40 arch/x86/include/asm/idtentry.h:629\nRIP: 0033:0x7f5e972bfd57\nCode: 39 d1 73 14 0f 1f 80 00 00 00 00 48 8b 50 f8 48 83 e8 08 48 39 ca 77 f3 48 39 c3 73 3e 48 89 13 48 8b 50 f8 48 89 38 49 8b 0e <48> 8b 3e 48 83 c3 08 48 83 c6 08 eb bc 48 39 d1 72 9e 48 39 d0 73\nRSP: 002b:00007fff8a413210 EFLAGS: 00000283\nRAX: 00007f5e97108990 RBX: 00007f5e97108338 RCX: ffffffff81d3aa45\nRDX: ffffffff81d3aa45 RSI: 00007f5e97108340 RDI: ffffffff81d3aa45\nRBP: 00007f5e97107eb8 R08: 00007f5e97108d88 R09: 0000000093c2e8d9\nR10: 0000000000000000 R11: 0000000000000000 R12: 00007f5e97107eb0\nR13: 00007f5e97108338 R14: 00007f5e97107ea8 R15: 0000000000000019\n </TASK>\n\nAllocated by task 13:\n kasan_save_stack+0x1e/0x50 mm/kasan/common.c:38\n kasan_set_track mm/kasan/common.c:46 [inline]\n set_alloc_info mm/kasan/common.c:434 [inline]\n __kasan_slab_alloc+0x90/0xc0 mm/kasan/common.c:467\n kasan_slab_alloc include/linux/kasan.h:259 [inline]\n slab_post_alloc_hook mm/slab.h:519 [inline]\n slab_alloc_node mm/slub.c:3234 [inline]\n slab_alloc mm/slub.c:3242 [inline]\n kmem_cache_alloc+0x202/0x3a0 mm/slub.c:3247\n dst_alloc+0x146/0x1f0 net/core/dst.c:92\n rt_dst_alloc+0x73/0x430 net/ipv4/route.c:1613\n ip_route_input_slow+0x1817/0x3a20 net/ipv4/route.c:234\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47103",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-04",
                    "modification_date": "2025-02-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-20566",
                    "description": "In l2cap_chan_put of l2cap_core, there is a possible use after free due to improper locking. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-165329981References: Upstream kernel",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-20566",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-12-16",
                    "modification_date": "2025-04-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46859",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: panasonic-laptop: Fix SINF array out of bounds accesses\n\nThe panasonic laptop code in various places uses the SINF array with index\nvalues of 0 - SINF_CUR_BRIGHT(0x0d) without checking that the SINF array\nis big enough.\n\nNot all panasonic laptops have this many SINF array entries, for example\nthe Toughbook CF-18 model only has 10 SINF array entries. So it only\nsupports the AC+DC brightness entries and mute.\n\nCheck that the SINF array has a minimum size which covers all AC+DC\nbrightness entries and refuse to load if the SINF array is smaller.\n\nFor higher SINF indexes hide the sysfs attributes when the SINF array\ndoes not contain an entry for that attribute, avoiding show()/store()\naccessing the array out of bounds and add bounds checking to the probe()\nand resume() code accessing these.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46859",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53116",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet: avoid potential UAF in nvmet_req_complete()\n\nAn nvme target ->queue_response() operation implementation may free the\nrequest passed as argument. Such implementation potentially could result\nin a use after free of the request pointer when percpu_ref_put() is\ncalled in nvmet_req_complete().\n\nAvoid such problem by using a local variable to save the sq pointer\nbefore calling __nvmet_req_complete(), thus avoiding dereferencing the\nreq pointer after that function call.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53116",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-38166",
                    "description": "In kernel/bpf/hashtab.c in the Linux kernel through 5.13.8, there is an integer overflow and out-of-bounds write when many elements are placed in a single bucket. NOTE: exploitation might be impractical without the CAP_SYS_ADMIN capability.",
                    "nvd_score": 4.6,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38166",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-08-07",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-44998",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: idt77252: prevent use after free in dequeue_rx()\n\nWe can't dereference \"skb\" after calling vcc->push() because the skb\nis released.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44998",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47600",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm btree remove: fix use after free in rebalance_children()\n\nMove dm_tm_unlock() after dm_tm_dec().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47600",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49377",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: don't touch ->tagset in blk_mq_get_sq_hctx\n\nblk_mq_run_hw_queues() could be run when there isn't queued request and\nafter queue is cleaned up, at that time tagset is freed, because tagset\nlifetime is covered by driver, and often freed after blk_cleanup_queue()\nreturns.\n\nSo don't touch ->tagset for figuring out current default hctx by the mapping\nbuilt in request queue, so use-after-free on tagset can be avoided. Meantime\nthis way should be fast than retrieving mapping from tagset.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49377",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49508",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: elan: Fix potential double free in elan_input_configured\n\n'input' is a managed resource allocated with devm_input_allocate_device(),\nso there is no need to call input_free_device() explicitly or\nthere will be a double free.\n\nAccording to the doc of devm_input_allocate_device():\n * Managed input devices do not need to be explicitly unregistered or\n * freed as it will be done automatically when owner device unbinds from\n * its driver (or binding fails).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49508",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38593",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_sync: fix double free in 'hci_discovery_filter_clear()'\n\nFunction 'hci_discovery_filter_clear()' frees 'uuids' array and then\nsets it to NULL. There is a tiny chance of the following race:\n\n'hci_cmd_sync_work()'\n\n 'update_passive_scan_sync()'\n\n   'hci_update_passive_scan_sync()'\n\n     'hci_discovery_filter_clear()'\n       kfree(uuids);\n\n       <-------------------------preempted-------------------------------->\n                                           'start_service_discovery()'\n\n                                             'hci_discovery_filter_clear()'\n                                               kfree(uuids); // DOUBLE FREE\n\n       <-------------------------preempted-------------------------------->\n\n      uuids = NULL;\n\nTo fix it let's add locking around 'kfree()' call and NULL pointer\nassignment. Otherwise the following backtrace fires:\n\n[ ] ------------[ cut here ]------------\n[ ] kernel BUG at mm/slub.c:547!\n[ ] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n[ ] CPU: 3 UID: 0 PID: 246 Comm: bluetoothd Tainted: G O 6.12.19-kernel #1\n[ ] Tainted: [O]=OOT_MODULE\n[ ] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[ ] pc : __slab_free+0xf8/0x348\n[ ] lr : __slab_free+0x48/0x348\n...\n[ ] Call trace:\n[ ]  __slab_free+0xf8/0x348\n[ ]  kfree+0x164/0x27c\n[ ]  start_service_discovery+0x1d0/0x2c0\n[ ]  hci_sock_sendmsg+0x518/0x924\n[ ]  __sock_sendmsg+0x54/0x60\n[ ]  sock_write_iter+0x98/0xf8\n[ ]  do_iter_readv_writev+0xe4/0x1c8\n[ ]  vfs_writev+0x128/0x2b0\n[ ]  do_writev+0xfc/0x118\n[ ]  __arm64_sys_writev+0x20/0x2c\n[ ]  invoke_syscall+0x68/0xf0\n[ ]  el0_svc_common.constprop.0+0x40/0xe0\n[ ]  do_el0_svc+0x1c/0x28\n[ ]  el0_svc+0x30/0xd0\n[ ]  el0t_64_sync_handler+0x100/0x12c\n[ ]  el0t_64_sync+0x194/0x198\n[ ] Code: 8b0002e6 eb17031f 54fffbe1 d503201f (d4210000)\n[ ] ---[ end trace 0000000000000000 ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38593",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49883",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: aovid use-after-free in ext4_ext_insert_extent()\n\nAs Ojaswin mentioned in Link, in ext4_ext_insert_extent(), if the path is\nreallocated in ext4_ext_create_new_leaf(), we'll use the stale path and\ncause UAF. Below is a sample trace with dummy values:\n\next4_ext_insert_extent\n  path = *ppath = 2000\n  ext4_ext_create_new_leaf(ppath)\n    ext4_find_extent(ppath)\n      path = *ppath = 2000\n      if (depth > path[0].p_maxdepth)\n            kfree(path = 2000);\n            *ppath = path = NULL;\n      path = kcalloc() = 3000\n      *ppath = 3000;\n      return path;\n  /* here path is still 2000, UAF! */\n  eh = path[depth].p_hdr\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_ext_insert_extent+0x26d4/0x3330\nRead of size 8 at addr ffff8881027bf7d0 by task kworker/u36:1/179\nCPU: 3 UID: 0 PID: 179 Comm: kworker/u6:1 Not tainted 6.11.0-rc2-dirty #866\nCall Trace:\n <TASK>\n ext4_ext_insert_extent+0x26d4/0x3330\n ext4_ext_map_blocks+0xe22/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n[...]\n\nAllocated by task 179:\n ext4_find_extent+0x81c/0x1f70\n ext4_ext_map_blocks+0x146/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n ext4_writepages+0x26d/0x4e0\n do_writepages+0x175/0x700\n[...]\n\nFreed by task 179:\n kfree+0xcb/0x240\n ext4_find_extent+0x7c0/0x1f70\n ext4_ext_insert_extent+0xa26/0x3330\n ext4_ext_map_blocks+0xe22/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n ext4_writepages+0x26d/0x4e0\n do_writepages+0x175/0x700\n[...]\n==================================================================\n\nSo use *ppath to update the path to avoid the above problem.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49883",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49017",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: re-fetch skb cb after tipc_msg_validate\n\nAs the call trace shows, the original skb was freed in tipc_msg_validate(),\nand dereferencing the old skb cb would cause an use-after-free crash.\n\n  BUG: KASAN: use-after-free in tipc_crypto_rcv_complete+0x1835/0x2240 [tipc]\n  Call Trace:\n   <IRQ>\n   tipc_crypto_rcv_complete+0x1835/0x2240 [tipc]\n   tipc_crypto_rcv+0xd32/0x1ec0 [tipc]\n   tipc_rcv+0x744/0x1150 [tipc]\n  ...\n  Allocated by task 47078:\n   kmem_cache_alloc_node+0x158/0x4d0\n   __alloc_skb+0x1c1/0x270\n   tipc_buf_acquire+0x1e/0xe0 [tipc]\n   tipc_msg_create+0x33/0x1c0 [tipc]\n   tipc_link_build_proto_msg+0x38a/0x2100 [tipc]\n   tipc_link_timeout+0x8b8/0xef0 [tipc]\n   tipc_node_timeout+0x2a1/0x960 [tipc]\n   call_timer_fn+0x2d/0x1c0\n  ...\n  Freed by task 47078:\n   tipc_msg_validate+0x7b/0x440 [tipc]\n   tipc_crypto_rcv_complete+0x4b5/0x2240 [tipc]\n   tipc_crypto_rcv+0xd32/0x1ec0 [tipc]\n   tipc_rcv+0x744/0x1150 [tipc]\n\nThis patch fixes it by re-fetching the skb cb from the new allocated skb\nafter calling tipc_msg_validate().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49017",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52988",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda/via: Avoid potential array out-of-bound in add_secret_dac_path()\n\nsnd_hda_get_connections() can return a negative error code.\nIt may lead to accessing 'conn' array at a negative index.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52988",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49884",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix slab-use-after-free in ext4_split_extent_at()\n\nWe hit the following use-after-free:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_split_extent_at+0xba8/0xcc0\nRead of size 2 at addr ffff88810548ed08 by task kworker/u20:0/40\nCPU: 0 PID: 40 Comm: kworker/u20:0 Not tainted 6.9.0-dirty #724\nCall Trace:\n <TASK>\n kasan_report+0x93/0xc0\n ext4_split_extent_at+0xba8/0xcc0\n ext4_split_extent.isra.0+0x18f/0x500\n ext4_split_convert_extents+0x275/0x750\n ext4_ext_handle_unwritten_extents+0x73e/0x1580\n ext4_ext_map_blocks+0xe20/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n\nAllocated by task 40:\n __kmalloc_noprof+0x1ac/0x480\n ext4_find_extent+0xf3b/0x1e70\n ext4_ext_map_blocks+0x188/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n\nFreed by task 40:\n kfree+0xf1/0x2b0\n ext4_find_extent+0xa71/0x1e70\n ext4_ext_insert_extent+0xa22/0x3260\n ext4_split_extent_at+0x3ef/0xcc0\n ext4_split_extent.isra.0+0x18f/0x500\n ext4_split_convert_extents+0x275/0x750\n ext4_ext_handle_unwritten_extents+0x73e/0x1580\n ext4_ext_map_blocks+0xe20/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n==================================================================\n\nThe flow of issue triggering is as follows:\n\next4_split_extent_at\n  path = *ppath\n  ext4_ext_insert_extent(ppath)\n    ext4_ext_create_new_leaf(ppath)\n      ext4_find_extent(orig_path)\n        path = *orig_path\n        read_extent_tree_block\n          // return -ENOMEM or -EIO\n        ext4_free_ext_path(path)\n          kfree(path)\n        *orig_path = NULL\n  a. If err is -ENOMEM:\n  ext4_ext_dirty(path + path->p_depth)\n  // path use-after-free !!!\n  b. If err is -EIO and we have EXT_DEBUG defined:\n  ext4_ext_show_leaf(path)\n    eh = path[depth].p_hdr\n    // path also use-after-free !!!\n\nSo when trying to zeroout or fix the extent length, call ext4_find_extent()\nto update the path.\n\nIn addition we use *ppath directly as an ext4_ext_show_leaf() input to\navoid possible use-after-free when EXT_DEBUG is defined, and to avoid\nunnecessary path updates.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49884",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52731",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: Fix invalid page access after closing deferred I/O devices\n\nWhen a fbdev with deferred I/O is once opened and closed, the dirty\npages still remain queued in the pageref list, and eventually later\nthose may be processed in the delayed work.  This may lead to a\ncorruption of pages, hitting an Oops.\n\nThis patch makes sure to cancel the delayed work and clean up the\npageref list at closing the device for addressing the bug.  A part of\nthe cleanup code is factored out as a new helper function that is\ncalled from the common fb_release().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52731",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53123",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: s390: Fix use-after-free of PCI resources with per-function hotplug\n\nOn s390 PCI functions may be hotplugged individually even when they\nbelong to a multi-function device. In particular on an SR-IOV device VFs\nmay be removed and later re-added.\n\nIn commit a50297cf8235 (\"s390/pci: separate zbus creation from\nscanning\") it was missed however that struct pci_bus and struct\nzpci_bus's resource list retained a reference to the PCI functions MMIO\nresources even though those resources are released and freed on\nhot-unplug. These stale resources may subsequently be claimed when the\nPCI function re-appears resulting in use-after-free.\n\nOne idea of fixing this use-after-free in s390 specific code that was\ninvestigated was to simply keep resources around from the moment a PCI\nfunction first appeared until the whole virtual PCI bus created for\na multi-function device disappears. The problem with this however is\nthat due to the requirement of artificial MMIO addreesses (address\ncookies) extra logic is then needed to keep the address cookies\ncompatible on re-plug. At the same time the MMIO resources semantically\nbelong to the PCI function so tying their lifecycle to the function\nseems more logical.\n\nInstead a simpler approach is to remove the resources of an individually\nhot-unplugged PCI function from the PCI bus's resource list while\nkeeping the resources of other PCI functions on the PCI bus untouched.\n\nThis is done by introducing pci_bus_remove_resource() to remove an\nindividual resource. Similarly the resource also needs to be removed\nfrom the struct zpci_bus's resource list. It turns out however, that\nthere is really no need to add the MMIO resources to the struct\nzpci_bus's resource list at all and instead we can simply use the\nzpci_bar_struct's resource pointer directly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53123",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-42285",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/iwcm: Fix a use-after-free related to destroying CM IDs\n\niw_conn_req_handler() associates a new struct rdma_id_private (conn_id) with\nan existing struct iw_cm_id (cm_id) as follows:\n\n        conn_id->cm_id.iw = cm_id;\n        cm_id->context = conn_id;\n        cm_id->cm_handler = cma_iw_handler;\n\nrdma_destroy_id() frees both the cm_id and the struct rdma_id_private. Make\nsure that cm_work_handler() does not trigger a use-after-free by only\nfreeing of the struct rdma_id_private after all pending work has finished.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42285",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-17",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36880",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: qca: add missing firmware sanity checks\n\nAdd the missing sanity checks when parsing the firmware files before\ndownloading them to avoid accessing and corrupting memory beyond the\nvmalloced buffer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36880",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-30",
                    "modification_date": "2025-09-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-49930",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix array out-of-bound access in SoC stats\n\nCurrently, the ath11k_soc_dp_stats::hal_reo_error array is defined with a\nmaximum size of DP_REO_DST_RING_MAX. However, the ath11k_dp_process_rx()\nfunction access ath11k_soc_dp_stats::hal_reo_error using the REO\ndestination SRNG ring ID, which is incorrect. SRNG ring ID differ from\nnormal ring ID, and this usage leads to out-of-bounds array access. To fix\nthis issue, modify ath11k_dp_process_rx() to use the normal ring ID\ndirectly instead of the SRNG ring ID to avoid out-of-bounds array access.\n\nTested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49930",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47697",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: media: dvb-frontends/rtl2830: fix an out-of-bounds write error\n\nEnsure index in rtl2830_pid_filter does not exceed 31 to prevent\nout-of-bounds access.\n\ndev->filters is a 32-bit value, so set_bit and clear_bit functions should\nonly operate on indices from 0 to 31. If index is 32, it will attempt to\naccess a non-existent 33rd bit, leading to out-of-bounds access.\nChange the boundary check from index > 32 to index >= 32 to resolve this\nissue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47697",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48672",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nof: fdt: fix off-by-one error in unflatten_dt_nodes()\n\nCommit 78c44d910d3e (\"drivers/of: Fix depth when unflattening devicetree\")\nforgot to fix up the depth check in the loop body in unflatten_dt_nodes()\nwhich makes it possible to overflow the nps[] buffer...\n\nFound by Linux Verification Center (linuxtesting.org) with the SVACE static\nanalysis tool.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48672",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-44977",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Validate TA binary size\n\nAdd TA binary size validation to avoid OOB write.\n\n(cherry picked from commit c0a04e3570d72aaf090962156ad085e37c62e442)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44977",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53156",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: add range check for conn_rsp_epid in htc_connect_service()\n\nI found the following bug in my fuzzer:\n\n  UBSAN: array-index-out-of-bounds in drivers/net/wireless/ath/ath9k/htc_hst.c:26:51\n  index 255 is out of range for type 'htc_endpoint [22]'\n  CPU: 0 UID: 0 PID: 8 Comm: kworker/0:0 Not tainted 6.11.0-rc6-dirty #14\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  Workqueue: events request_firmware_work_func\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x180/0x1b0\n   __ubsan_handle_out_of_bounds+0xd4/0x130\n   htc_issue_send.constprop.0+0x20c/0x230\n   ? _raw_spin_unlock_irqrestore+0x3c/0x70\n   ath9k_wmi_cmd+0x41d/0x610\n   ? mark_held_locks+0x9f/0xe0\n   ...\n\nSince this bug has been confirmed to be caused by insufficient verification\nof conn_rsp_epid, I think it would be appropriate to add a range check for\nconn_rsp_epid to htc_connect_service() to prevent the bug from occurring.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53156",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-24",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53427",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix warning and UAF when destroy the MR list\n\nIf the MR allocate failed, the MR recovery work not initialized\nand list not cleared. Then will be warning and UAF when release\nthe MR:\n\n  WARNING: CPU: 4 PID: 824 at kernel/workqueue.c:3066 __flush_work.isra.0+0xf7/0x110\n  CPU: 4 PID: 824 Comm: mount.cifs Not tainted 6.1.0-rc5+ #82\n  RIP: 0010:__flush_work.isra.0+0xf7/0x110\n  Call Trace:\n   <TASK>\n   __cancel_work_timer+0x2ba/0x2e0\n   smbd_destroy+0x4e1/0x990\n   _smbd_get_connection+0x1cbd/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\n  BUG: KASAN: use-after-free in smbd_destroy+0x4fc/0x990\n  Read of size 8 at addr ffff88810b156a08 by task mount.cifs/824\n  CPU: 4 PID: 824 Comm: mount.cifs Tainted: G        W          6.1.0-rc5+ #82\n  Call Trace:\n   dump_stack_lvl+0x34/0x44\n   print_report+0x171/0x472\n   kasan_report+0xad/0x130\n   smbd_destroy+0x4fc/0x990\n   _smbd_get_connection+0x1cbd/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\n  Allocated by task 824:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   __kasan_kmalloc+0x7a/0x90\n   _smbd_get_connection+0x1b6f/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\n  Freed by task 824:\n   kasan_save_stack+0x1e/0x40\n   kasan_set_track+0x21/0x30\n   kasan_save_free_info+0x2a/0x40\n   ____kasan_slab_free+0x143/0x1b0\n   __kmem_cache_free+0xc8/0x330\n   _smbd_get_connection+0x1c6a/0x2110\n   smbd_get_connection+0x21/0x40\n   cifs_get_tcp_session+0x8ef/0xda0\n   mount_get_conns+0x60/0x750\n   cifs_mount+0x103/0xd00\n   cifs_smb3_do_mount+0x1dd/0xcb0\n   smb3_get_tree+0x1d5/0x300\n   vfs_get_tree+0x41/0xf0\n   path_mount+0x9b3/0xdd0\n   __x64_sys_mount+0x190/0x1d0\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nLet's initialize the MR recovery work before MR allocate to prevent\nthe warning, remove the MRs from the list to prevent the UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53427",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50074",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nparport: Proper fix for array out-of-bounds access\n\nThe recent fix for array out-of-bounds accesses replaced sprintf()\ncalls blindly with snprintf().  However, since snprintf() returns the\nwould-be-printed size, not the actually output size, the length\ncalculation can still go over the given limit.\n\nUse scnprintf() instead of snprintf(), which returns the actually\noutput letters, for addressing the potential out-of-bounds access\nproperly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50074",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-29",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56765",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/pseries/vas: Add close() callback in vas_vm_ops struct\n\nThe mapping VMA address is saved in VAS window struct when the\npaste address is mapped. This VMA address is used during migration\nto unmap the paste address if the window is active. The paste\naddress mapping will be removed when the window is closed or with\nthe munmap(). But the VMA address in the VAS window is not updated\nwith munmap() which is causing invalid access during migration.\n\nThe KASAN report shows:\n[16386.254991] BUG: KASAN: slab-use-after-free in reconfig_close_windows+0x1a0/0x4e8\n[16386.255043] Read of size 8 at addr c00000014a819670 by task drmgr/696928\n\n[16386.255096] CPU: 29 UID: 0 PID: 696928 Comm: drmgr Kdump: loaded Tainted: G    B              6.11.0-rc5-nxgzip #2\n[16386.255128] Tainted: [B]=BAD_PAGE\n[16386.255148] Hardware name: IBM,9080-HEX Power11 (architected) 0x820200 0xf000007 of:IBM,FW1110.00 (NH1110_016) hv:phyp pSeries\n[16386.255181] Call Trace:\n[16386.255202] [c00000016b297660] [c0000000018ad0ac] dump_stack_lvl+0x84/0xe8 (unreliable)\n[16386.255246] [c00000016b297690] [c0000000006e8a90] print_report+0x19c/0x764\n[16386.255285] [c00000016b297760] [c0000000006e9490] kasan_report+0x128/0x1f8\n[16386.255309] [c00000016b297880] [c0000000006eb5c8] __asan_load8+0xac/0xe0\n[16386.255326] [c00000016b2978a0] [c00000000013f898] reconfig_close_windows+0x1a0/0x4e8\n[16386.255343] [c00000016b297990] [c000000000140e58] vas_migration_handler+0x3a4/0x3fc\n[16386.255368] [c00000016b297a90] [c000000000128848] pseries_migrate_partition+0x4c/0x4c4\n...\n\n[16386.256136] Allocated by task 696554 on cpu 31 at 16377.277618s:\n[16386.256149]  kasan_save_stack+0x34/0x68\n[16386.256163]  kasan_save_track+0x34/0x80\n[16386.256175]  kasan_save_alloc_info+0x58/0x74\n[16386.256196]  __kasan_slab_alloc+0xb8/0xdc\n[16386.256209]  kmem_cache_alloc_noprof+0x200/0x3d0\n[16386.256225]  vm_area_alloc+0x44/0x150\n[16386.256245]  mmap_region+0x214/0x10c4\n[16386.256265]  do_mmap+0x5fc/0x750\n[16386.256277]  vm_mmap_pgoff+0x14c/0x24c\n[16386.256292]  ksys_mmap_pgoff+0x20c/0x348\n[16386.256303]  sys_mmap+0xd0/0x160\n...\n\n[16386.256350] Freed by task 0 on cpu 31 at 16386.204848s:\n[16386.256363]  kasan_save_stack+0x34/0x68\n[16386.256374]  kasan_save_track+0x34/0x80\n[16386.256384]  kasan_save_free_info+0x64/0x10c\n[16386.256396]  __kasan_slab_free+0x120/0x204\n[16386.256415]  kmem_cache_free+0x128/0x450\n[16386.256428]  vm_area_free_rcu_cb+0xa8/0xd8\n[16386.256441]  rcu_do_batch+0x2c8/0xcf0\n[16386.256458]  rcu_core+0x378/0x3c4\n[16386.256473]  handle_softirqs+0x20c/0x60c\n[16386.256495]  do_softirq_own_stack+0x6c/0x88\n[16386.256509]  do_softirq_own_stack+0x58/0x88\n[16386.256521]  __irq_exit_rcu+0x1a4/0x20c\n[16386.256533]  irq_exit+0x20/0x38\n[16386.256544]  interrupt_async_exit_prepare.constprop.0+0x18/0x2c\n...\n\n[16386.256717] Last potentially related work creation:\n[16386.256729]  kasan_save_stack+0x34/0x68\n[16386.256741]  __kasan_record_aux_stack+0xcc/0x12c\n[16386.256753]  __call_rcu_common.constprop.0+0x94/0xd04\n[16386.256766]  vm_area_free+0x28/0x3c\n[16386.256778]  remove_vma+0xf4/0x114\n[16386.256797]  do_vmi_align_munmap.constprop.0+0x684/0x870\n[16386.256811]  __vm_munmap+0xe0/0x1f8\n[16386.256821]  sys_munmap+0x54/0x6c\n[16386.256830]  system_call_exception+0x1a0/0x4a0\n[16386.256841]  system_call_vectored_common+0x15c/0x2ec\n\n[16386.256868] The buggy address belongs to the object at c00000014a819670\n                which belongs to the cache vm_area_struct of size 168\n[16386.256887] The buggy address is located 0 bytes inside of\n                freed 168-byte region [c00000014a819670, c00000014a819718)\n\n[16386.256915] The buggy address belongs to the physical page:\n[16386.256928] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x14a81\n[16386.256950] memcg:c0000000ba430001\n[16386.256961] anon flags: 0x43ffff800000000(node=4|zone=0|lastcpupid=0x7ffff)\n[16386.256975] page_type: 0xfdffffff(slab)\n[16386\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56765",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-06",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38563",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Prevent VMA split of buffer mappings\n\nThe perf mmap code is careful about mmap()'ing the user page with the\nringbuffer and additionally the auxiliary buffer, when the event supports\nit. Once the first mapping is established, subsequent mapping have to use\nthe same offset and the same size in both cases. The reference counting for\nthe ringbuffer and the auxiliary buffer depends on this being correct.\n\nThough perf does not prevent that a related mapping is split via mmap(2),\nmunmap(2) or mremap(2). A split of a VMA results in perf_mmap_open() calls,\nwhich take reference counts, but then the subsequent perf_mmap_close()\ncalls are not longer fulfilling the offset and size checks. This leads to\nreference count leaks.\n\nAs perf already has the requirement for subsequent mappings to match the\ninitial mapping, the obvious consequence is that VMA splits, caused by\nresizing of a mapping or partial unmapping, have to be prevented.\n\nImplement the vm_operations_struct::may_split() callback and return\nunconditionally -EINVAL.\n\nThat ensures that the mapping offsets and sizes cannot be changed after the\nfact. Remapping to a different fixed address with the same size is still\npossible as it takes the references for the new mapping and drops those of\nthe old mapping.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38563",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-26589",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Reject variable offset alu on PTR_TO_FLOW_KEYS\n\nFor PTR_TO_FLOW_KEYS, check_flow_keys_access() only uses fixed off\nfor validation. However, variable offset ptr alu is not prohibited\nfor this ptr kind. So the variable offset is not checked.\n\nThe following prog is accepted:\n\n  func#0 @0\n  0: R1=ctx() R10=fp0\n  0: (bf) r6 = r1                       ; R1=ctx() R6_w=ctx()\n  1: (79) r7 = *(u64 *)(r6 +144)        ; R6_w=ctx() R7_w=flow_keys()\n  2: (b7) r8 = 1024                     ; R8_w=1024\n  3: (37) r8 /= 1                       ; R8_w=scalar()\n  4: (57) r8 &= 1024                    ; R8_w=scalar(smin=smin32=0,\n  smax=umax=smax32=umax32=1024,var_off=(0x0; 0x400))\n  5: (0f) r7 += r8\n  mark_precise: frame0: last_idx 5 first_idx 0 subseq_idx -1\n  mark_precise: frame0: regs=r8 stack= before 4: (57) r8 &= 1024\n  mark_precise: frame0: regs=r8 stack= before 3: (37) r8 /= 1\n  mark_precise: frame0: regs=r8 stack= before 2: (b7) r8 = 1024\n  6: R7_w=flow_keys(smin=smin32=0,smax=umax=smax32=umax32=1024,var_off\n  =(0x0; 0x400)) R8_w=scalar(smin=smin32=0,smax=umax=smax32=umax32=1024,\n  var_off=(0x0; 0x400))\n  6: (79) r0 = *(u64 *)(r7 +0)          ; R0_w=scalar()\n  7: (95) exit\n\nThis prog loads flow_keys to r7, and adds the variable offset r8\nto r7, and finally causes out-of-bounds access:\n\n  BUG: unable to handle page fault for address: ffffc90014c80038\n  [...]\n  Call Trace:\n   <TASK>\n   bpf_dispatcher_nop_func include/linux/bpf.h:1231 [inline]\n   __bpf_prog_run include/linux/filter.h:651 [inline]\n   bpf_prog_run include/linux/filter.h:658 [inline]\n   bpf_prog_run_pin_on_cpu include/linux/filter.h:675 [inline]\n   bpf_flow_dissect+0x15f/0x350 net/core/flow_dissector.c:991\n   bpf_prog_test_run_flow_dissector+0x39d/0x620 net/bpf/test_run.c:1359\n   bpf_prog_test_run kernel/bpf/syscall.c:4107 [inline]\n   __sys_bpf+0xf8f/0x4560 kernel/bpf/syscall.c:5475\n   __do_sys_bpf kernel/bpf/syscall.c:5561 [inline]\n   __se_sys_bpf kernel/bpf/syscall.c:5559 [inline]\n   __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:5559\n   do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n   do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:83\n   entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nFix this by rejecting ptr alu with variable offset on flow_keys.\nApplying the patch rejects the program with \"R7 pointer arithmetic\non flow_keys prohibited\".",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26589",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-22",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49493",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: rt5645: Fix errorenous cleanup order\n\nThere is a logic error when removing rt5645 device as the function\nrt5645_i2c_remove() first cancel the &rt5645->jack_detect_work and\ndelete the &rt5645->btn_check_timer latter. However, since the timer\nhandler rt5645_btn_check_callback() will re-queue the jack_detect_work,\nthis cleanup order is buggy.\n\nThat is, once the del_timer_sync in rt5645_i2c_remove is concurrently\nrun with the rt5645_btn_check_callback, the canceled jack_detect_work\nwill be rescheduled again, leading to possible use-after-free.\n\nThis patch fix the issue by placing the del_timer_sync function before\nthe cancel_delayed_work_sync.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49493",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-46978",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: nVMX: Always make an attempt to map eVMCS after migration\n\nWhen enlightened VMCS is in use and nested state is migrated with\nvmx_get_nested_state()/vmx_set_nested_state() KVM can't map evmcs\npage right away: evmcs gpa is not 'struct kvm_vmx_nested_state_hdr'\nand we can't read it from VP assist page because userspace may decide\nto restore HV_X64_MSR_VP_ASSIST_PAGE after restoring nested state\n(and QEMU, for example, does exactly that). To make sure eVMCS is\nmapped /vmx_set_nested_state() raises KVM_REQ_GET_NESTED_STATE_PAGES\nrequest.\n\nCommit f2c7ef3ba955 (\"KVM: nSVM: cancel KVM_REQ_GET_NESTED_STATE_PAGES\non nested vmexit\") added KVM_REQ_GET_NESTED_STATE_PAGES clearing to\nnested_vmx_vmexit() to make sure MSR permission bitmap is not switched\nwhen an immediate exit from L2 to L1 happens right after migration (caused\nby a pending event, for example). Unfortunately, in the exact same\nsituation we still need to have eVMCS mapped so\nnested_sync_vmcs12_to_shadow() reflects changes in VMCS12 to eVMCS.\n\nAs a band-aid, restore nested_get_evmcs_page() when clearing\nKVM_REQ_GET_NESTED_STATE_PAGES in nested_vmx_vmexit(). The 'fix' is far\nfrom being ideal as we can't easily propagate possible failures and even if\nwe could, this is most likely already too late to do so. The whole\n'KVM_REQ_GET_NESTED_STATE_PAGES' idea for mapping eVMCS after migration\nseems to be fragile as we diverge too much from the 'native' path when\nvmptr loading happens on vmx_set_nested_state().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46978",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-03-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-50067",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuprobe: avoid out-of-bounds memory access of fetching args\n\nUprobe needs to fetch args into a percpu buffer, and then copy to ring\nbuffer to avoid non-atomic context problem.\n\nSometimes user-space strings, arrays can be very large, but the size of\npercpu buffer is only page size. And store_trace_args() won't check\nwhether these data exceeds a single page or not, caused out-of-bounds\nmemory access.\n\nIt could be reproduced by following steps:\n1. build kernel with CONFIG_KASAN enabled\n2. save follow program as test.c\n\n```\n\\#include <stdio.h>\n\\#include <stdlib.h>\n\\#include <string.h>\n\n// If string length large than MAX_STRING_SIZE, the fetch_store_strlen()\n// will return 0, cause __get_data_size() return shorter size, and\n// store_trace_args() will not trigger out-of-bounds access.\n// So make string length less than 4096.\n\\#define STRLEN 4093\n\nvoid generate_string(char *str, int n)\n{\n    int i;\n    for (i = 0; i < n; ++i)\n    {\n        char c = i % 26 + 'a';\n        str[i] = c;\n    }\n    str[n-1] = '\\0';\n}\n\nvoid print_string(char *str)\n{\n    printf(\"%s\\n\", str);\n}\n\nint main()\n{\n    char tmp[STRLEN];\n\n    generate_string(tmp, STRLEN);\n    print_string(tmp);\n\n    return 0;\n}\n```\n3. compile program\n`gcc -o test test.c`\n\n4. get the offset of `print_string()`\n```\nobjdump -t test | grep -w print_string\n0000000000401199 g     F .text  000000000000001b              print_string\n```\n\n5. configure uprobe with offset 0x1199\n```\noff=0x1199\n\ncd /sys/kernel/debug/tracing/\necho \"p /root/test:${off} arg1=+0(%di):ustring arg2=\\$comm arg3=+0(%di):ustring\"\n > uprobe_events\necho 1 > events/uprobes/enable\necho 1 > tracing_on\n```\n\n6. run `test`, and kasan will report error.\n==================================================================\nBUG: KASAN: use-after-free in strncpy_from_user+0x1d6/0x1f0\nWrite of size 8 at addr ffff88812311c004 by task test/499CPU: 0 UID: 0 PID: 499 Comm: test Not tainted 6.12.0-rc3+ #18\nHardware name: Red Hat KVM, BIOS 1.16.0-4.al8 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x55/0x70\n print_address_description.constprop.0+0x27/0x310\n kasan_report+0x10f/0x120\n ? strncpy_from_user+0x1d6/0x1f0\n strncpy_from_user+0x1d6/0x1f0\n ? rmqueue.constprop.0+0x70d/0x2ad0\n process_fetch_insn+0xb26/0x1470\n ? __pfx_process_fetch_insn+0x10/0x10\n ? _raw_spin_lock+0x85/0xe0\n ? __pfx__raw_spin_lock+0x10/0x10\n ? __pte_offset_map+0x1f/0x2d0\n ? unwind_next_frame+0xc5f/0x1f80\n ? arch_stack_walk+0x68/0xf0\n ? is_bpf_text_address+0x23/0x30\n ? kernel_text_address.part.0+0xbb/0xd0\n ? __kernel_text_address+0x66/0xb0\n ? unwind_get_return_address+0x5e/0xa0\n ? __pfx_stack_trace_consume_entry+0x10/0x10\n ? arch_stack_walk+0xa2/0xf0\n ? _raw_spin_lock_irqsave+0x8b/0xf0\n ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n ? depot_alloc_stack+0x4c/0x1f0\n ? _raw_spin_unlock_irqrestore+0xe/0x30\n ? stack_depot_save_flags+0x35d/0x4f0\n ? kasan_save_stack+0x34/0x50\n ? kasan_save_stack+0x24/0x50\n ? mutex_lock+0x91/0xe0\n ? __pfx_mutex_lock+0x10/0x10\n prepare_uprobe_buffer.part.0+0x2cd/0x500\n uprobe_dispatcher+0x2c3/0x6a0\n ? __pfx_uprobe_dispatcher+0x10/0x10\n ? __kasan_slab_alloc+0x4d/0x90\n handler_chain+0xdd/0x3e0\n handle_swbp+0x26e/0x3d0\n ? __pfx_handle_swbp+0x10/0x10\n ? uprobe_pre_sstep_notifier+0x151/0x1b0\n irqentry_exit_to_user_mode+0xe2/0x1b0\n asm_exc_int3+0x39/0x40\nRIP: 0033:0x401199\nCode: 01 c2 0f b6 45 fb 88 02 83 45 fc 01 8b 45 fc 3b 45 e4 7c b7 8b 45 e4 48 98 48 8d 50 ff 48 8b 45 e8 48 01 d0 ce\nRSP: 002b:00007ffdf00576a8 EFLAGS: 00000206\nRAX: 00007ffdf00576b0 RBX: 0000000000000000 RCX: 0000000000000ff2\nRDX: 0000000000000ffc RSI: 0000000000000ffd RDI: 00007ffdf00576b0\nRBP: 00007ffdf00586b0 R08: 00007feb2f9c0d20 R09: 00007feb2f9c0d20\nR10: 0000000000000001 R11: 0000000000000202 R12: 0000000000401040\nR13: 00007ffdf0058780 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nThis commit enforces the buffer's maxlen less than a page-size to avoid\nstore_trace_args() out-of-memory access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50067",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-28",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53673",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_event: call disconnect callback before deleting conn\n\nIn hci_cs_disconnect, we do hci_conn_del even if disconnection failed.\n\nISO, L2CAP and SCO connections refer to the hci_conn without\nhci_conn_get, so disconn_cfm must be called so they can clean up their\nconn, otherwise use-after-free occurs.\n\nISO:\n==========================================================\niso_sock_connect:880: sk 00000000eabd6557\niso_connect_cis:356: 70:1a:b8:98:ff:a2 -> 28:3d:c2:4a:7e:da\n...\niso_conn_add:140: hcon 000000001696f1fd conn 00000000b6251073\nhci_dev_put:1487: hci0 orig refcnt 17\n__iso_chan_add:214: conn 00000000b6251073\niso_sock_clear_timer:117: sock 00000000eabd6557 state 3\n...\nhci_rx_work:4085: hci0 Event packet\nhci_event_packet:7601: hci0: event 0x0f\nhci_cmd_status_evt:4346: hci0: opcode 0x0406\nhci_cs_disconnect:2760: hci0: status 0x0c\nhci_sent_cmd_data:3107: hci0 opcode 0x0406\nhci_conn_del:1151: hci0 hcon 000000001696f1fd handle 2560\nhci_conn_unlink:1102: hci0: hcon 000000001696f1fd\nhci_conn_drop:1451: hcon 00000000d8521aaf orig refcnt 2\nhci_chan_list_flush:2780: hcon 000000001696f1fd\nhci_dev_put:1487: hci0 orig refcnt 21\nhci_dev_put:1487: hci0 orig refcnt 20\nhci_req_cmd_complete:3978: opcode 0x0406 status 0x0c\n... <no iso_* activity on sk/conn> ...\niso_sock_sendmsg:1098: sock 00000000dea5e2e0, sk 00000000eabd6557\nBUG: kernel NULL pointer dereference, address: 0000000000000668\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP PTI\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014\nRIP: 0010:iso_sock_sendmsg (net/bluetooth/iso.c:1112) bluetooth\n==========================================================\n\nL2CAP:\n==================================================================\nhci_cmd_status_evt:4359: hci0: opcode 0x0406\nhci_cs_disconnect:2760: hci0: status 0x0c\nhci_sent_cmd_data:3085: hci0 opcode 0x0406\nhci_conn_del:1151: hci0 hcon ffff88800c999000 handle 3585\nhci_conn_unlink:1102: hci0: hcon ffff88800c999000\nhci_chan_list_flush:2780: hcon ffff88800c999000\nhci_chan_del:2761: hci0 hcon ffff88800c999000 chan ffff888018ddd280\n...\nBUG: KASAN: slab-use-after-free in hci_send_acl+0x2d/0x540 [bluetooth]\nRead of size 8 at addr ffff888018ddd298 by task bluetoothd/1175\n\nCPU: 0 PID: 1175 Comm: bluetoothd Tainted: G            E      6.4.0-rc4+ #2\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x5b/0x90\n print_report+0xcf/0x670\n ? __virt_addr_valid+0xf8/0x180\n ? hci_send_acl+0x2d/0x540 [bluetooth]\n kasan_report+0xa8/0xe0\n ? hci_send_acl+0x2d/0x540 [bluetooth]\n hci_send_acl+0x2d/0x540 [bluetooth]\n ? __pfx___lock_acquire+0x10/0x10\n l2cap_chan_send+0x1fd/0x1300 [bluetooth]\n ? l2cap_sock_sendmsg+0xf2/0x170 [bluetooth]\n ? __pfx_l2cap_chan_send+0x10/0x10 [bluetooth]\n ? lock_release+0x1d5/0x3c0\n ? mark_held_locks+0x1a/0x90\n l2cap_sock_sendmsg+0x100/0x170 [bluetooth]\n sock_write_iter+0x275/0x280\n ? __pfx_sock_write_iter+0x10/0x10\n ? __pfx___lock_acquire+0x10/0x10\n do_iter_readv_writev+0x176/0x220\n ? __pfx_do_iter_readv_writev+0x10/0x10\n ? find_held_lock+0x83/0xa0\n ? selinux_file_permission+0x13e/0x210\n do_iter_write+0xda/0x340\n vfs_writev+0x1b4/0x400\n ? __pfx_vfs_writev+0x10/0x10\n ? __seccomp_filter+0x112/0x750\n ? populate_seccomp_data+0x182/0x220\n ? __fget_light+0xdf/0x100\n ? do_writev+0x19d/0x210\n do_writev+0x19d/0x210\n ? __pfx_do_writev+0x10/0x10\n ? mark_held_locks+0x1a/0x90\n do_syscall_64+0x60/0x90\n ? lockdep_hardirqs_on_prepare+0x149/0x210\n ? do_syscall_64+0x6c/0x90\n ? lockdep_hardirqs_on_prepare+0x149/0x210\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x7ff45cb23e64\nCode: 15 d1 1f 0d 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 f3 0f 1e fa 80 3d 9d a7 0d 00 00 74 13 b8 14 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 48 83 ec 28 89 54 24 1c 48 89\nRSP: 002b:00007fff21ae09b8 EFLAGS: 00000202 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: \n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38565",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Exit early on perf_mmap() fail\n\nWhen perf_mmap() fails to allocate a buffer, it still invokes the\nevent_mapped() callback of the related event. On X86 this might increase\nthe perf_rdpmc_allowed reference counter. But nothing undoes this as\nperf_mmap_close() is never called in this case, which causes another\nreference count leak.\n\nReturn early on failure to prevent that.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38565",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49722",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: Fix memory corruption in VF driver\n\nDisable VF's RX/TX queues, when it's disabled. VF can have queues enabled,\nwhen it requests a reset. If PF driver assumes that VF is disabled,\nwhile VF still has queues configured, VF may unmap DMA resources.\nIn such scenario device still can map packets to memory, which ends up\nsilently corrupting it.\nPreviously, VF driver could experience memory corruption, which lead to\ncrash:\n[ 5119.170157] BUG: unable to handle kernel paging request at 00001b9780003237\n[ 5119.170166] PGD 0 P4D 0\n[ 5119.170173] Oops: 0002 [#1] PREEMPT_RT SMP PTI\n[ 5119.170181] CPU: 30 PID: 427592 Comm: kworker/u96:2 Kdump: loaded Tainted: G        W I      --------- -  - 4.18.0-372.9.1.rt7.166.el8.x86_64 #1\n[ 5119.170189] Hardware name: Dell Inc. PowerEdge R740/014X06, BIOS 2.3.10 08/15/2019\n[ 5119.170193] Workqueue: iavf iavf_adminq_task [iavf]\n[ 5119.170219] RIP: 0010:__page_frag_cache_drain+0x5/0x30\n[ 5119.170238] Code: 0f 0f b6 77 51 85 f6 74 07 31 d2 e9 05 df ff ff e9 90 fe ff ff 48 8b 05 49 db 33 01 eb b4 0f 1f 80 00 00 00 00 0f 1f 44 00 00 <f0> 29 77 34 74 01 c3 48 8b 07 f6 c4 80 74 0f 0f b6 77 51 85 f6 74\n[ 5119.170244] RSP: 0018:ffffa43b0bdcfd78 EFLAGS: 00010282\n[ 5119.170250] RAX: ffffffff896b3e40 RBX: ffff8fb282524000 RCX: 0000000000000002\n[ 5119.170254] RDX: 0000000049000000 RSI: 0000000000000000 RDI: 00001b9780003203\n[ 5119.170259] RBP: ffff8fb248217b00 R08: 0000000000000022 R09: 0000000000000009\n[ 5119.170262] R10: 2b849d6300000000 R11: 0000000000000020 R12: 0000000000000000\n[ 5119.170265] R13: 0000000000001000 R14: 0000000000000009 R15: 0000000000000000\n[ 5119.170269] FS:  0000000000000000(0000) GS:ffff8fb1201c0000(0000) knlGS:0000000000000000\n[ 5119.170274] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 5119.170279] CR2: 00001b9780003237 CR3: 00000008f3e1a003 CR4: 00000000007726e0\n[ 5119.170283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 5119.170286] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 5119.170290] PKRU: 55555554\n[ 5119.170292] Call Trace:\n[ 5119.170298]  iavf_clean_rx_ring+0xad/0x110 [iavf]\n[ 5119.170324]  iavf_free_rx_resources+0xe/0x50 [iavf]\n[ 5119.170342]  iavf_free_all_rx_resources.part.51+0x30/0x40 [iavf]\n[ 5119.170358]  iavf_virtchnl_completion+0xd8a/0x15b0 [iavf]\n[ 5119.170377]  ? iavf_clean_arq_element+0x210/0x280 [iavf]\n[ 5119.170397]  iavf_adminq_task+0x126/0x2e0 [iavf]\n[ 5119.170416]  process_one_work+0x18f/0x420\n[ 5119.170429]  worker_thread+0x30/0x370\n[ 5119.170437]  ? process_one_work+0x420/0x420\n[ 5119.170445]  kthread+0x151/0x170\n[ 5119.170452]  ? set_kthread_struct+0x40/0x40\n[ 5119.170460]  ret_from_fork+0x35/0x40\n[ 5119.170477] Modules linked in: iavf sctp ip6_udp_tunnel udp_tunnel mlx4_en mlx4_core nfp tls vhost_net vhost vhost_iotlb tap tun xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache sunrpc intel_rapl_msr iTCO_wdt iTCO_vendor_support dell_smbios wmi_bmof dell_wmi_descriptor dcdbas kvm_intel kvm irqbypass intel_rapl_common isst_if_common skx_edac irdma nfit libnvdimm x86_pkg_temp_thermal i40e intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ib_uverbs rapl ipmi_ssif intel_cstate intel_uncore mei_me pcspkr acpi_ipmi ib_core mei lpc_ich i2c_i801 ipmi_si ipmi_devintf wmi ipmi_msghandler acpi_power_meter xfs libcrc32c sd_mod t10_pi sg mgag200 drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops ice ahci drm libahci crc32c_intel libata tg3 megaraid_sas\n[ 5119.170613]  i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod fuse [last unloaded: iavf]\n[ 5119.170627] CR2: 00001b9780003237",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49722",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52452",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52452",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-22",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49892",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix use-after-free for dynamic ftrace_ops\n\nKASAN reported a use-after-free with ftrace ops [1]. It was found from\nvmcore that perf had registered two ops with the same content\nsuccessively, both dynamic. After unregistering the second ops, a\nuse-after-free occurred.\n\nIn ftrace_shutdown(), when the second ops is unregistered, the\nFTRACE_UPDATE_CALLS command is not set because there is another enabled\nops with the same content.  Also, both ops are dynamic and the ftrace\ncallback function is ftrace_ops_list_func, so the\nFTRACE_UPDATE_TRACE_FUNC command will not be set. Eventually the value\nof 'command' will be 0 and ftrace_shutdown() will skip the rcu\nsynchronization.\n\nHowever, ftrace may be activated. When the ops is released, another CPU\nmay be accessing the ops.  Add the missing synchronization to fix this\nproblem.\n\n[1]\nBUG: KASAN: use-after-free in __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline]\nBUG: KASAN: use-after-free in ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049\nRead of size 8 at addr ffff56551965bbc8 by task syz-executor.2/14468\n\nCPU: 1 PID: 14468 Comm: syz-executor.2 Not tainted 5.10.0 #7\nHardware name: linux,dummy-virt (DT)\nCall trace:\n dump_backtrace+0x0/0x40c arch/arm64/kernel/stacktrace.c:132\n show_stack+0x30/0x40 arch/arm64/kernel/stacktrace.c:196\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x1b4/0x248 lib/dump_stack.c:118\n print_address_description.constprop.0+0x28/0x48c mm/kasan/report.c:387\n __kasan_report mm/kasan/report.c:547 [inline]\n kasan_report+0x118/0x210 mm/kasan/report.c:564\n check_memory_region_inline mm/kasan/generic.c:187 [inline]\n __asan_load8+0x98/0xc0 mm/kasan/generic.c:253\n __ftrace_ops_list_func kernel/trace/ftrace.c:7020 [inline]\n ftrace_ops_list_func+0x2b0/0x31c kernel/trace/ftrace.c:7049\n ftrace_graph_call+0x0/0x4\n __might_sleep+0x8/0x100 include/linux/perf_event.h:1170\n __might_fault mm/memory.c:5183 [inline]\n __might_fault+0x58/0x70 mm/memory.c:5171\n do_strncpy_from_user lib/strncpy_from_user.c:41 [inline]\n strncpy_from_user+0x1f4/0x4b0 lib/strncpy_from_user.c:139\n getname_flags+0xb0/0x31c fs/namei.c:149\n getname+0x2c/0x40 fs/namei.c:209\n [...]\n\nAllocated by task 14445:\n kasan_save_stack+0x24/0x50 mm/kasan/common.c:48\n kasan_set_track mm/kasan/common.c:56 [inline]\n __kasan_kmalloc mm/kasan/common.c:479 [inline]\n __kasan_kmalloc.constprop.0+0x110/0x13c mm/kasan/common.c:449\n kasan_kmalloc+0xc/0x14 mm/kasan/common.c:493\n kmem_cache_alloc_trace+0x440/0x924 mm/slub.c:2950\n kmalloc include/linux/slab.h:563 [inline]\n kzalloc include/linux/slab.h:675 [inline]\n perf_event_alloc.part.0+0xb4/0x1350 kernel/events/core.c:11230\n perf_event_alloc kernel/events/core.c:11733 [inline]\n __do_sys_perf_event_open kernel/events/core.c:11831 [inline]\n __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723\n __arm64_sys_perf_event_open+0x6c/0x80 kernel/events/core.c:11723\n [...]\n\nFreed by task 14445:\n kasan_save_stack+0x24/0x50 mm/kasan/common.c:48\n kasan_set_track+0x24/0x34 mm/kasan/common.c:56\n kasan_set_free_info+0x20/0x40 mm/kasan/generic.c:358\n __kasan_slab_free.part.0+0x11c/0x1b0 mm/kasan/common.c:437\n __kasan_slab_free mm/kasan/common.c:445 [inline]\n kasan_slab_free+0x2c/0x40 mm/kasan/common.c:446\n slab_free_hook mm/slub.c:1569 [inline]\n slab_free_freelist_hook mm/slub.c:1608 [inline]\n slab_free mm/slub.c:3179 [inline]\n kfree+0x12c/0xc10 mm/slub.c:4176\n perf_event_alloc.part.0+0xa0c/0x1350 kernel/events/core.c:11434\n perf_event_alloc kernel/events/core.c:11733 [inline]\n __do_sys_perf_event_open kernel/events/core.c:11831 [inline]\n __se_sys_perf_event_open+0x550/0x15f4 kernel/events/core.c:11723\n [...]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49892",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-05-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53239",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: 6fire: Release resources at card release\n\nThe current 6fire code tries to release the resources right after the\ncall of usb6fire_chip_abort().  But at this moment, the card object\nmight be still in use (as we're calling snd_card_free_when_closed()).\n\nFor avoid potential UAFs, move the release of resources to the card's\nprivate_free instead of the manual call of usb6fire_chip_destroy() at\nthe USB disconnect callback.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53239",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52931",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915: Avoid potential vm use-after-free\n\nAdding the vm to the vm_xa table makes it visible to userspace, which\ncould try to race with us to close the vm.  So we need to take our extra\nreference before putting it in the table.\n\n(cherry picked from commit 99343c46d4e2b34c285d3d5f68ff04274c2f9fb4)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52931",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49921",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: Fix use after free in red_enqueue()\n\nWe can't use \"skb\" again after passing it to qdisc_enqueue().  This is\nbasically identical to commit 2f09707d0c97 (\"sch_sfb: Also store skb\nlen before calling child enqueue\").",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49921",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37923",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Fix oob write in trace_seq_to_buffer()\n\nsyzbot reported this bug:\n==================================================================\nBUG: KASAN: slab-out-of-bounds in trace_seq_to_buffer kernel/trace/trace.c:1830 [inline]\nBUG: KASAN: slab-out-of-bounds in tracing_splice_read_pipe+0x6be/0xdd0 kernel/trace/trace.c:6822\nWrite of size 4507 at addr ffff888032b6b000 by task syz.2.320/7260\n\nCPU: 1 UID: 0 PID: 7260 Comm: syz.2.320 Not tainted 6.15.0-rc1-syzkaller-00301-g3bde70a2c827 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xc3/0x670 mm/kasan/report.c:521\n kasan_report+0xe0/0x110 mm/kasan/report.c:634\n check_region_inline mm/kasan/generic.c:183 [inline]\n kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189\n __asan_memcpy+0x3c/0x60 mm/kasan/shadow.c:106\n trace_seq_to_buffer kernel/trace/trace.c:1830 [inline]\n tracing_splice_read_pipe+0x6be/0xdd0 kernel/trace/trace.c:6822\n ....\n==================================================================\n\nIt has been reported that trace_seq_to_buffer() tries to copy more data\nthan PAGE_SIZE to buf. Therefore, to prevent this, we should use the\nsmaller of trace_seq_used(&iter->seq) and PAGE_SIZE as an argument.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37923",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-20",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49471",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrtw89: cfo: check mac_id to avoid out-of-bounds\n\nSomehow, hardware reports incorrect mac_id and pollute memory. Check index\nbefore we access the array.\n\n  UBSAN: array-index-out-of-bounds in rtw89/phy.c:2517:23\n  index 188 is out of range for type 's32 [64]'\n  CPU: 1 PID: 51550 Comm: irq/35-rtw89_pc Tainted: G           OE\n  Call Trace:\n   <IRQ>\n   show_stack+0x52/0x58\n   dump_stack_lvl+0x4c/0x63\n   dump_stack+0x10/0x12\n   ubsan_epilogue+0x9/0x45\n   __ubsan_handle_out_of_bounds.cold+0x44/0x49\n   ? __alloc_skb+0x92/0x1d0\n   rtw89_phy_cfo_parse+0x44/0x7f [rtw89_core]\n   rtw89_core_rx+0x261/0x871 [rtw89_core]\n   ? __alloc_skb+0xee/0x1d0\n   rtw89_pci_napi_poll+0x3fa/0x4ea [rtw89_pci]\n   __napi_poll+0x33/0x1a0\n   net_rx_action+0x126/0x260\n   ? __queue_work+0x217/0x4c0\n   __do_softirq+0xd9/0x315\n   ? disable_irq_nosync+0x10/0x10\n   do_softirq.part.0+0x6d/0x90\n   </IRQ>\n   <TASK>\n   __local_bh_enable_ip+0x62/0x70\n   rtw89_pci_interrupt_threadfn+0x182/0x1a6 [rtw89_pci]\n   irq_thread_fn+0x28/0x60\n   irq_thread+0xc8/0x190\n   ? irq_thread_fn+0x60/0x60\n   kthread+0x16b/0x190\n   ? irq_thread_check_affinity+0xe0/0xe0\n   ? set_kthread_struct+0x50/0x50\n   ret_from_fork+0x22/0x30\n   </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49471",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38346",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix UAF when lookup kallsym after ftrace disabled\n\nThe following issue happens with a buggy module:\n\nBUG: unable to handle page fault for address: ffffffffc05d0218\nPGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0\nOops: Oops: 0000 [#1] SMP KASAN PTI\nTainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nRIP: 0010:sized_strscpy+0x81/0x2f0\nRSP: 0018:ffff88812d76fa08 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000\nRDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d\nRBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68\nR10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038\nR13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff\nFS:  00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ftrace_mod_get_kallsym+0x1ac/0x590\n update_iter_mod+0x239/0x5b0\n s_next+0x5b/0xa0\n seq_read_iter+0x8c9/0x1070\n seq_read+0x249/0x3b0\n proc_reg_read+0x1b0/0x280\n vfs_read+0x17f/0x920\n ksys_read+0xf3/0x1c0\n do_syscall_64+0x5f/0x2e0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nThe above issue may happen as follows:\n(1) Add kprobe tracepoint;\n(2) insmod test.ko;\n(3)  Module triggers ftrace disabled;\n(4) rmmod test.ko;\n(5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed;\nftrace_mod_get_kallsym()\n...\nstrscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n...\n\nThe problem is when a module triggers an issue with ftrace and\nsets ftrace_disable. The ftrace_disable is set when an anomaly is\ndiscovered and to prevent any more damage, ftrace stops all text\nmodification. The issue that happened was that the ftrace_disable stops\nmore than just the text modification.\n\nWhen a module is loaded, its init functions can also be traced. Because\nkallsyms deletes the init functions after a module has loaded, ftrace\nsaves them when the module is loaded and function tracing is enabled. This\nallows the output of the function trace to show the init function names\ninstead of just their raw memory addresses.\n\nWhen a module is removed, ftrace_release_mod() is called, and if\nftrace_disable is set, it just returns without doing anything more. The\nproblem here is that it leaves the mod_list still around and if kallsyms\nis called, it will call into this code and access the module memory that\nhas already been freed as it will return:\n\n  strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);\n\nWhere the \"mod\" no longer exists and triggers a UAF bug.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38346",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49581",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbe2net: Fix buffer overflow in be_get_module_eeprom\n\nbe_cmd_read_port_transceiver_data assumes that it is given a buffer that\nis at least PAGE_DATA_LEN long, or twice that if the module supports SFF\n8472. However, this is not always the case.\n\nFix this by passing the desired offset and length to\nbe_cmd_read_port_transceiver_data so that we only copy the bytes once.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49581",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49029",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (ibmpex) Fix possible UAF when ibmpex_register_bmc() fails\n\nSmatch report warning as follows:\n\ndrivers/hwmon/ibmpex.c:509 ibmpex_register_bmc() warn:\n  '&data->list' not removed from list\n\nIf ibmpex_find_sensors() fails in ibmpex_register_bmc(), data will\nbe freed, but data->list will not be removed from driver_data.bmc_data,\nthen list traversal may cause UAF.\n\nFix by removeing it from driver_data.bmc_data before free().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49029",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38068",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: lzo - Fix compression buffer overrun\n\nUnlike the decompression code, the compression code in LZO never\nchecked for output overruns.  It instead assumes that the caller\nalways provides enough buffer space, disregarding the buffer length\nprovided by the caller.\n\nAdd a safe compression interface that checks for the end of buffer\nbefore each write.  Use the safe interface in crypto/lzo.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38068",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-12-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49478",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: pvrusb2: fix array-index-out-of-bounds in pvr2_i2c_core_init\n\nSyzbot reported that -1 is used as array index. The problem was in\nmissing validation check.\n\nhdw->unit_number is initialized with -1 and then if init table walk fails\nthis value remains unchanged. Since code blindly uses this member for\narray indexing adding sanity check is the easiest fix for that.\n\nhdw->workpoll initialization moved upper to prevent warning in\n__flush_work.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49478",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53179",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: ipset: add the missing IP_SET_HASH_WITH_NET0 macro for ip_set_hash_netportnet.c\n\nThe missing IP_SET_HASH_WITH_NET0 macro in ip_set_hash_netportnet can\nlead to the use of wrong `CIDR_POS(c)` for calculating array offsets,\nwhich can lead to integer underflow. As a result, it leads to slab\nout-of-bound access.\nThis patch adds back the IP_SET_HASH_WITH_NET0 macro to\nip_set_hash_netportnet to address the issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53179",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48788",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-rdma: fix possible use-after-free in transport error_recovery work\n\nWhile nvme_rdma_submit_async_event_work is checking the ctrl and queue\nstate before preparing the AER command and scheduling io_work, in order\nto fully prevent a race where this check is not reliable the error\nrecovery work must flush async_event_work before continuing to destroy\nthe admin queue after setting the ctrl state to RESETTING such that\nthere is no race .submit_async_event and the error recovery handler\nitself changing the ctrl state.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48788",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38459",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: clip: Fix infinite recursive call of clip_push().\n\nsyzbot reported the splat below. [0]\n\nThis happens if we call ioctl(ATMARP_MKIP) more than once.\n\nDuring the first call, clip_mkip() sets clip_push() to vcc->push(),\nand the second call copies it to clip_vcc->old_push().\n\nLater, when the socket is close()d, vcc_destroy_socket() passes\nNULL skb to clip_push(), which calls clip_vcc->old_push(),\ntriggering the infinite recursion.\n\nLet's prevent the second ioctl(ATMARP_MKIP) by checking\nvcc->user_back, which is allocated by the first call as clip_vcc.\n\nNote also that we use lock_sock() to prevent racy calls.\n\n[0]:\nBUG: TASK stack guard page was hit at ffffc9000d66fff8 (stack is ffffc9000d670000..ffffc9000d678000)\nOops: stack guard page: 0000 [#1] SMP KASAN NOPTI\nCPU: 0 UID: 0 PID: 5322 Comm: syz.0.0 Not tainted 6.16.0-rc4-syzkaller #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nRIP: 0010:clip_push+0x5/0x720 net/atm/clip.c:191\nCode: e0 8f aa 8c e8 1c ad 5b fa eb ae 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 55 <41> 57 41 56 41 55 41 54 53 48 83 ec 20 48 89 f3 49 89 fd 48 bd 00\nRSP: 0018:ffffc9000d670000 EFLAGS: 00010246\nRAX: 1ffff1100235a4a5 RBX: ffff888011ad2508 RCX: ffff8880003c0000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff888037f01000\nRBP: dffffc0000000000 R08: ffffffff8fa104f7 R09: 1ffffffff1f4209e\nR10: dffffc0000000000 R11: ffffffff8a99b300 R12: ffffffff8a99b300\nR13: ffff888037f01000 R14: ffff888011ad2500 R15: ffff888037f01578\nFS:  000055557ab6d500(0000) GS:ffff88808d250000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000d66fff8 CR3: 0000000043172000 CR4: 0000000000352ef0\nCall Trace:\n <TASK>\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n...\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n clip_push+0x6dc/0x720 net/atm/clip.c:200\n vcc_destroy_socket net/atm/common.c:183 [inline]\n vcc_release+0x157/0x460 net/atm/common.c:205\n __sock_release net/socket.c:647 [inline]\n sock_close+0xc0/0x240 net/socket.c:1391\n __fput+0x449/0xa70 fs/file_table.c:465\n task_work_run+0x1d1/0x260 kernel/task_work.c:227\n resume_user_mode_work include/linux/resume_user_mode.h:50 [inline]\n exit_to_user_mode_loop+0xec/0x110 kernel/entry/common.c:114\n exit_to_user_mode_prepare include/linux/entry-common.h:330 [inline]\n syscall_exit_to_user_mode_work include/linux/entry-common.h:414 [inline]\n syscall_exit_to_user_mode include/linux/entry-common.h:449 [inline]\n do_syscall_64+0x2bd/0x3b0 arch/x86/entry/syscall_64.c:100\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7ff31c98e929\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fffb5aa1f78 EFLAGS: 00000246 ORIG_RAX: 00000000000001b4\nRAX: 0000000000000000 RBX: 0000000000012747 RCX: 00007ff31c98e929\nRDX: 0000000000000000 RSI: 000000000000001e RDI: 0000000000000003\nRBP: 00007ff31cbb7ba0 R08: 0000000000000001 R09: 0000000db5aa226f\nR10: 00007ff31c7ff030 R11: 0000000000000246 R12: 00007ff31cbb608c\nR13: 00007ff31cbb6080 R14: ffffffffffffffff R15: 00007fffb5aa2090\n </TASK>\nModules linked in:",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38459",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52927",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: allow exp not to be removed in nf_ct_find_expectation\n\nCurrently nf_conntrack_in() calling nf_ct_find_expectation() will\nremove the exp from the hash table. However, in some scenario, we\nexpect the exp not to be removed when the created ct will not be\nconfirmed, like in OVS and TC conntrack in the following patches.\n\nThis patch allows exp not to be removed by setting IPS_CONFIRMED\nin the status of the tmpl.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52927",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-14",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47239",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: fix possible use-after-free in smsc75xx_bind\n\nThe commit 46a8b29c6306 (\"net: usb: fix memory leak in smsc75xx_bind\")\nfails to clean up the work scheduled in smsc75xx_reset->\nsmsc75xx_set_multicast, which leads to use-after-free if the work is\nscheduled to start after the deallocation. In addition, this patch\nalso removes a dangling pointer - dev->data[0].\n\nThis patch calls cancel_work_sync to cancel the scheduled work and set\nthe dangling pointer to NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47239",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49907",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mdio: fix undefined behavior in bit shift for __mdiobus_register\n\nShifting signed 32-bit value by 31 bits is undefined, so changing\nsignificant bit to unsigned. The UBSAN warning calltrace like below:\n\nUBSAN: shift-out-of-bounds in drivers/net/phy/mdio_bus.c:586:27\nleft shift of 1 by 31 places cannot be represented in type 'int'\nCall Trace:\n <TASK>\n dump_stack_lvl+0x7d/0xa5\n dump_stack+0x15/0x1b\n ubsan_epilogue+0xe/0x4e\n __ubsan_handle_shift_out_of_bounds+0x1e7/0x20c\n __mdiobus_register+0x49d/0x4e0\n fixed_mdio_bus_init+0xd8/0x12d\n do_one_initcall+0x76/0x430\n kernel_init_freeable+0x3b3/0x422\n kernel_init+0x24/0x1e0\n ret_from_fork+0x1f/0x30\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49907",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53338",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlwt: Fix return values of BPF xmit ops\n\nBPF encap ops can return different types of positive values, such like\nNET_RX_DROP, NET_XMIT_CN, NETDEV_TX_BUSY, and so on, from function\nskb_do_redirect and bpf_lwt_xmit_reroute. At the xmit hook, such return\nvalues would be treated implicitly as LWTUNNEL_XMIT_CONTINUE in\nip(6)_finish_output2. When this happens, skbs that have been freed would\ncontinue to the neighbor subsystem, causing use-after-free bug and\nkernel crashes.\n\nTo fix the incorrect behavior, skb_do_redirect return values can be\nsimply discarded, the same as tc-egress behavior. On the other hand,\nbpf_lwt_xmit_reroute returns useful errors to local senders, e.g. PMTU\ninformation. Thus convert its return values to avoid the conflict with\nLWTUNNEL_XMIT_CONTINUE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53338",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-17",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-52935",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/khugepaged: fix ->anon_vma race\n\nIf an ->anon_vma is attached to the VMA, collapse_and_free_pmd() requires\nit to be locked.\n\nPage table traversal is allowed under any one of the mmap lock, the\nanon_vma lock (if the VMA is associated with an anon_vma), and the\nmapping lock (if the VMA is associated with a mapping); and so to be\nable to remove page tables, we must hold all three of them. \nretract_page_tables() bails out if an ->anon_vma is attached, but does\nthis check before holding the mmap lock (as the comment above the check\nexplains).\n\nIf we racily merged an existing ->anon_vma (shared with a child\nprocess) from a neighboring VMA, subsequent rmap traversals on pages\nbelonging to the child will be able to see the page tables that we are\nconcurrently removing while assuming that nothing else can access them.\n\nRepeat the ->anon_vma check once we hold the mmap lock to ensure that\nthere really is no concurrent page table access.\n\nHitting this bug causes a lockdep warning in collapse_and_free_pmd(),\nin the line \"lockdep_assert_held_write(&vma->anon_vma->root->rwsem)\". \nIt can also lead to use-after-free access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52935",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56708",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nEDAC/igen6: Avoid segmentation fault on module unload\n\nThe segmentation fault happens because:\n\nDuring modprobe:\n1. In igen6_probe(), igen6_pvt will be allocated with kzalloc()\n2. In igen6_register_mci(), mci->pvt_info will point to\n   &igen6_pvt->imc[mc]\n\nDuring rmmod:\n1. In mci_release() in edac_mc.c, it will kfree(mci->pvt_info)\n2. In igen6_remove(), it will kfree(igen6_pvt);\n\nFix this issue by setting mci->pvt_info to NULL to avoid the double\nkfree.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56708",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-28",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38323",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atm: add lec_mutex\n\nsyzbot found its way in net/atm/lec.c, and found an error path\nin lecd_attach() could leave a dangling pointer in dev_lec[].\n\nAdd a mutex to protect dev_lecp[] uses from lecd_attach(),\nlec_vcc_attach() and lec_mcast_attach().\n\nFollowing patch will use this mutex for /proc/net/atm/lec.\n\nBUG: KASAN: slab-use-after-free in lecd_attach net/atm/lec.c:751 [inline]\nBUG: KASAN: slab-use-after-free in lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008\nRead of size 8 at addr ffff88807c7b8e68 by task syz.1.17/6142\n\nCPU: 1 UID: 0 PID: 6142 Comm: syz.1.17 Not tainted 6.16.0-rc1-syzkaller-00239-g08215f5486ec #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:94 [inline]\n  dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n  print_address_description mm/kasan/report.c:408 [inline]\n  print_report+0xcd/0x680 mm/kasan/report.c:521\n  kasan_report+0xe0/0x110 mm/kasan/report.c:634\n  lecd_attach net/atm/lec.c:751 [inline]\n  lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008\n  do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159\n  sock_do_ioctl+0x118/0x280 net/socket.c:1190\n  sock_ioctl+0x227/0x6b0 net/socket.c:1311\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:907 [inline]\n  __se_sys_ioctl fs/ioctl.c:893 [inline]\n  __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893\n  do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n  do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n </TASK>\n\nAllocated by task 6132:\n  kasan_save_stack+0x33/0x60 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n  __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394\n  kasan_kmalloc include/linux/kasan.h:260 [inline]\n  __do_kmalloc_node mm/slub.c:4328 [inline]\n  __kvmalloc_node_noprof+0x27b/0x620 mm/slub.c:5015\n  alloc_netdev_mqs+0xd2/0x1570 net/core/dev.c:11711\n  lecd_attach net/atm/lec.c:737 [inline]\n  lane_ioctl+0x17db/0x23e0 net/atm/lec.c:1008\n  do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159\n  sock_do_ioctl+0x118/0x280 net/socket.c:1190\n  sock_ioctl+0x227/0x6b0 net/socket.c:1311\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:907 [inline]\n  __se_sys_ioctl fs/ioctl.c:893 [inline]\n  __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893\n  do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n  do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 6132:\n  kasan_save_stack+0x33/0x60 mm/kasan/common.c:47\n  kasan_save_track+0x14/0x30 mm/kasan/common.c:68\n  kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:576\n  poison_slab_object mm/kasan/common.c:247 [inline]\n  __kasan_slab_free+0x51/0x70 mm/kasan/common.c:264\n  kasan_slab_free include/linux/kasan.h:233 [inline]\n  slab_free_hook mm/slub.c:2381 [inline]\n  slab_free mm/slub.c:4643 [inline]\n  kfree+0x2b4/0x4d0 mm/slub.c:4842\n  free_netdev+0x6c5/0x910 net/core/dev.c:11892\n  lecd_attach net/atm/lec.c:744 [inline]\n  lane_ioctl+0x1ce8/0x23e0 net/atm/lec.c:1008\n  do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159\n  sock_do_ioctl+0x118/0x280 net/socket.c:1190\n  sock_ioctl+0x227/0x6b0 net/socket.c:1311\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:907 [inline]\n  __se_sys_ioctl fs/ioctl.c:893 [inline]\n  __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38323",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37819",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/gic-v2m: Prevent use after free of gicv2m_get_fwnode()\n\nWith ACPI in place, gicv2m_get_fwnode() is registered with the pci\nsubsystem as pci_msi_get_fwnode_cb(), which may get invoked at runtime\nduring a PCI host bridge probe. But, the call back is wrongly marked as\n__init, causing it to be freed, while being registered with the PCI\nsubsystem and could trigger:\n\n Unable to handle kernel paging request at virtual address ffff8000816c0400\n  gicv2m_get_fwnode+0x0/0x58 (P)\n  pci_set_bus_msi_domain+0x74/0x88\n  pci_register_host_bridge+0x194/0x548\n\nThis is easily reproducible on a Juno board with ACPI boot.\n\nRetain the function for later use.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37819",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-08",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-42159",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpi3mr: Sanitise num_phys\n\nInformation is stored in mr_sas_port->phy_mask, values larger then size of\nthis field shouldn't be allowed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42159",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-30",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39862",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7915: fix list corruption after hardware restart\n\nSince stations are recreated from scratch, all lists that wcids are added\nto must be cleared before calling ieee80211_restart_hw.\nSet wcid->sta = 0 for each wcid entry in order to ensure that they are\nnot added again before they are ready.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39862",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-19",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52983",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock, bfq: fix uaf for bfqq in bic_set_bfqq()\n\nAfter commit 64dc8c732f5c (\"block, bfq: fix possible uaf for 'bfqq->bic'\"),\nbic->bfqq will be accessed in bic_set_bfqq(), however, in some context\nbic->bfqq will be freed, and bic_set_bfqq() is called with the freed\nbic->bfqq.\n\nFix the problem by always freeing bfqq after bic_set_bfqq().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52983",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38280",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Avoid __bpf_prog_ret0_warn when jit fails\n\nsyzkaller reported an issue:\n\nWARNING: CPU: 3 PID: 217 at kernel/bpf/core.c:2357 __bpf_prog_ret0_warn+0xa/0x20 kernel/bpf/core.c:2357\nModules linked in:\nCPU: 3 UID: 0 PID: 217 Comm: kworker/u32:6 Not tainted 6.15.0-rc4-syzkaller-00040-g8bac8898fe39\nRIP: 0010:__bpf_prog_ret0_warn+0xa/0x20 kernel/bpf/core.c:2357\nCall Trace:\n <TASK>\n bpf_dispatcher_nop_func include/linux/bpf.h:1316 [inline]\n __bpf_prog_run include/linux/filter.h:718 [inline]\n bpf_prog_run include/linux/filter.h:725 [inline]\n cls_bpf_classify+0x74a/0x1110 net/sched/cls_bpf.c:105\n ...\n\nWhen creating bpf program, 'fp->jit_requested' depends on bpf_jit_enable.\nThis issue is triggered because of CONFIG_BPF_JIT_ALWAYS_ON is not set\nand bpf_jit_enable is set to 1, causing the arch to attempt JIT the prog,\nbut jit failed due to FAULT_INJECTION. As a result, incorrectly\ntreats the program as valid, when the program runs it calls\n`__bpf_prog_ret0_warn` and triggers the WARN_ON_ONCE(1).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38280",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48950",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix perf_pending_task() UaF\n\nPer syzbot it is possible for perf_pending_task() to run after the\nevent is free()'d. There are two related but distinct cases:\n\n - the task_work was already queued before destroying the event;\n - destroying the event itself queues the task_work.\n\nThe first cannot be solved using task_work_cancel() since\nperf_release() itself might be called from a task_work (____fput),\nwhich means the current->task_works list is already empty and\ntask_work_cancel() won't be able to find the perf_pending_task()\nentry.\n\nThe simplest alternative is extending the perf_event lifetime to cover\nthe task_work.\n\nThe second is just silly, queueing a task_work while you know the\nevent is going away makes no sense and is easily avoided by\nre-arranging how the event is marked STATE_DEAD and ensuring it goes\nthrough STATE_OFF on the way down.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48950",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47254",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix use-after-free in gfs2_glock_shrink_scan\n\nThe GLF_LRU flag is checked under lru_lock in gfs2_glock_remove_from_lru() to\nremove the glock from the lru list in __gfs2_glock_put().\n\nOn the shrink scan path, the same flag is cleared under lru_lock but because\nof cond_resched_lock(&lru_lock) in gfs2_dispose_glock_lru(), progress on the\nput side can be made without deleting the glock from the lru list.\n\nKeep GLF_LRU across the race window opened by cond_resched_lock(&lru_lock) to\nensure correct behavior on both sides - clear GLF_LRU after list_del under\nlru_lock.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47254",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49291",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: pcm: Fix races among concurrent hw_params and hw_free calls\n\nCurrently we have neither proper check nor protection against the\nconcurrent calls of PCM hw_params and hw_free ioctls, which may result\nin a UAF.  Since the existing PCM stream lock can't be used for\nprotecting the whole ioctl operations, we need a new mutex to protect\nthose racy calls.\n\nThis patch introduced a new mutex, runtime->buffer_mutex, and applies\nit to both hw_params and hw_free ioctl code paths.  Along with it, the\nboth functions are slightly modified (the mmap_count check is moved\ninto the state-check block) for code simplicity.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49291",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49479",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: fix tx status related use-after-free race on station removal\n\nThere is a small race window where ongoing tx activity can lead to a skb\ngetting added to the status tracking idr after that idr has already been\ncleaned up, which will keep the wcid linked in the status poll list.\nFix this by only adding status skbs if the wcid pointer is still assigned\nin dev->wcid, which gets cleared early by mt76_sta_pre_rcu_remove",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49479",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-58072",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtlwifi: remove unused check_buddy_priv\n\nCommit 2461c7d60f9f (\"rtlwifi: Update header file\") introduced a global\nlist of private data structures.\n\nLater on, commit 26634c4b1868 (\"rtlwifi Modify existing bits to match\nvendor version 2013.02.07\") started adding the private data to that list at\nprobe time and added a hook, check_buddy_priv to find the private data from\na similar device.\n\nHowever, that function was never used.\n\nBesides, though there is a lock for that list, it is never used. And when\nthe probe fails, the private data is never removed from the list. This\nwould cause a second probe to access freed memory.\n\nRemove the unused hook, structures and members, which will prevent the\npotential race condition on the list and its corruption during a second\nprobe when probe fails.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-58072",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-06",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-27008",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: nv04: Fix out of bounds access\n\nWhen Output Resource (dcb->or) value is assigned in\nfabricate_dcb_output(), there may be out of bounds access to\ndac_users array in case dcb->or is zero because ffs(dcb->or) is\nused as index there.\nThe 'or' argument of fabricate_dcb_output() must be interpreted as a\nnumber of bit to set, not value.\n\nUtilize macros from 'enum nouveau_or' in calls instead of hardcoding.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-27008",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-01",
                    "modification_date": "2025-12-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37928",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm-bufio: don't schedule in atomic context\n\nA BUG was reported as below when CONFIG_DEBUG_ATOMIC_SLEEP and\ntry_verify_in_tasklet are enabled.\n[  129.444685][  T934] BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2421\n[  129.444723][  T934] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 934, name: kworker/1:4\n[  129.444740][  T934] preempt_count: 201, expected: 0\n[  129.444756][  T934] RCU nest depth: 0, expected: 0\n[  129.444781][  T934] Preemption disabled at:\n[  129.444789][  T934] [<ffffffd816231900>] shrink_work+0x21c/0x248\n[  129.445167][  T934] kernel BUG at kernel/sched/walt/walt_debug.c:16!\n[  129.445183][  T934] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n[  129.445204][  T934] Skip md ftrace buffer dump for: 0x1609e0\n[  129.447348][  T934] CPU: 1 PID: 934 Comm: kworker/1:4 Tainted: G        W  OE      6.6.56-android15-8-o-g6f82312b30b9-debug #1 1400000003000000474e5500b3187743670464e8\n[  129.447362][  T934] Hardware name: Qualcomm Technologies, Inc. Parrot QRD, Alpha-M (DT)\n[  129.447373][  T934] Workqueue: dm_bufio_cache shrink_work\n[  129.447394][  T934] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  129.447406][  T934] pc : android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug]\n[  129.447435][  T934] lr : __traceiter_android_rvh_schedule_bug+0x44/0x6c\n[  129.447451][  T934] sp : ffffffc0843dbc90\n[  129.447459][  T934] x29: ffffffc0843dbc90 x28: ffffffffffffffff x27: 0000000000000c8b\n[  129.447479][  T934] x26: 0000000000000040 x25: ffffff804b3d6260 x24: ffffffd816232b68\n[  129.447497][  T934] x23: ffffff805171c5b4 x22: 0000000000000000 x21: ffffffd816231900\n[  129.447517][  T934] x20: ffffff80306ba898 x19: 0000000000000000 x18: ffffffc084159030\n[  129.447535][  T934] x17: 00000000d2b5dd1f x16: 00000000d2b5dd1f x15: ffffffd816720358\n[  129.447554][  T934] x14: 0000000000000004 x13: ffffff89ef978000 x12: 0000000000000003\n[  129.447572][  T934] x11: ffffffd817a823c4 x10: 0000000000000202 x9 : 7e779c5735de9400\n[  129.447591][  T934] x8 : ffffffd81560d004 x7 : 205b5d3938373434 x6 : ffffffd8167397c8\n[  129.447610][  T934] x5 : 0000000000000000 x4 : 0000000000000001 x3 : ffffffc0843db9e0\n[  129.447629][  T934] x2 : 0000000000002f15 x1 : 0000000000000000 x0 : 0000000000000000\n[  129.447647][  T934] Call trace:\n[  129.447655][  T934]  android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug 1400000003000000474e550080cce8a8a78606b6]\n[  129.447681][  T934]  __might_resched+0x190/0x1a8\n[  129.447694][  T934]  shrink_work+0x180/0x248\n[  129.447706][  T934]  process_one_work+0x260/0x624\n[  129.447718][  T934]  worker_thread+0x28c/0x454\n[  129.447729][  T934]  kthread+0x118/0x158\n[  129.447742][  T934]  ret_from_fork+0x10/0x20\n[  129.447761][  T934] Code: ???????? ???????? ???????? d2b5dd1f (d4210000)\n[  129.447772][  T934] ---[ end trace 0000000000000000 ]---\n\ndm_bufio_lock will call spin_lock_bh when try_verify_in_tasklet\nis enabled, and __scan will be called in atomic context.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37928",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-20",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-44967",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/mgag200: Bind I2C lifetime to DRM device\n\nManaged cleanup with devm_add_action_or_reset() will release the I2C\nadapter when the underlying Linux device goes away. But the connector\nstill refers to it, so this cleanup leaves behind a stale pointer\nin struct drm_connector.ddc.\n\nBind the lifetime of the I2C adapter to the connector's lifetime by\nusing DRM's managed release. When the DRM device goes away (after\nthe Linux device) DRM will first clean up the connector and then\nclean up the I2C adapter.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44967",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37861",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpi3mr: Synchronous access b/w reset and tm thread for reply queue\n\nWhen the task management thread processes reply queues while the reset\nthread resets them, the task management thread accesses an invalid queue ID\n(0xFFFF), set by the reset thread, which points to unallocated memory,\ncausing a crash.\n\nAdd flag 'io_admin_reset_sync' to synchronize access between the reset,\nI/O, and admin threads. Before a reset, the reset handler sets this flag to\nblock I/O and admin processing threads. If any thread bypasses the initial\ncheck, the reset thread waits up to 10 seconds for processing to finish. If\nthe wait exceeds 10 seconds, the controller is marked as unrecoverable.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37861",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-09",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56603",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: af_can: do not leave a dangling sk pointer in can_create()\n\nOn error can_create() frees the allocated sk object, but sock_init_data()\nhas already attached it to the provided sock object. This will leave a\ndangling sk pointer in the sock object and may cause use-after-free later.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56603",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48702",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: emu10k1: Fix out of bounds access in snd_emu10k1_pcm_channel_alloc()\n\nThe voice allocator sometimes begins allocating from near the end of the\narray and then wraps around, however snd_emu10k1_pcm_channel_alloc()\naccesses the newly allocated voices as if it never wrapped around.\n\nThis results in out of bounds access if the first voice has a high enough\nindex so that first_voice + requested_voice_count > NUM_G (64).\nThe more voices are requested, the more likely it is for this to occur.\n\nThis was initially discovered using PipeWire, however it can be reproduced\nby calling aplay multiple times with 16 channels:\naplay -r 48000 -D plughw:CARD=Live,DEV=3 -c 16 /dev/zero\n\nUBSAN: array-index-out-of-bounds in sound/pci/emu10k1/emupcm.c:127:40\nindex 65 is out of range for type 'snd_emu10k1_voice [64]'\nCPU: 1 PID: 31977 Comm: aplay Tainted: G        W IOE      6.0.0-rc2-emu10k1+ #7\nHardware name: ASUSTEK COMPUTER INC P5W DH Deluxe/P5W DH Deluxe, BIOS 3002    07/22/2010\nCall Trace:\n<TASK>\ndump_stack_lvl+0x49/0x63\ndump_stack+0x10/0x16\nubsan_epilogue+0x9/0x3f\n__ubsan_handle_out_of_bounds.cold+0x44/0x49\nsnd_emu10k1_playback_hw_params+0x3bc/0x420 [snd_emu10k1]\nsnd_pcm_hw_params+0x29f/0x600 [snd_pcm]\nsnd_pcm_common_ioctl+0x188/0x1410 [snd_pcm]\n? exit_to_user_mode_prepare+0x35/0x170\n? do_syscall_64+0x69/0x90\n? syscall_exit_to_user_mode+0x26/0x50\n? do_syscall_64+0x69/0x90\n? exit_to_user_mode_prepare+0x35/0x170\nsnd_pcm_ioctl+0x27/0x40 [snd_pcm]\n__x64_sys_ioctl+0x95/0xd0\ndo_syscall_64+0x5c/0x90\n? do_syscall_64+0x69/0x90\n? do_syscall_64+0x69/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48702",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2025-03-05",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38375",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-net: ensure the received length does not exceed allocated size\n\nIn xdp_linearize_page, when reading the following buffers from the ring,\nwe forget to check the received length with the true allocate size. This\ncan lead to an out-of-bound read. This commit adds that missing check.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38375",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26689",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: prevent use-after-free in encode_cap_msg()\n\nIn fs/ceph/caps.c, in encode_cap_msg(), \"use after free\" error was\ncaught by KASAN at this line - 'ceph_buffer_get(arg->xattr_buf);'. This\nimplies before the refcount could be increment here, it was freed.\n\nIn same file, in \"handle_cap_grant()\" refcount is decremented by this\nline - 'ceph_buffer_put(ci->i_xattrs.blob);'. It appears that a race\noccurred and resource was freed by the latter line before the former\nline could increment it.\n\nencode_cap_msg() is called by __send_cap() and __send_cap() is called by\nceph_check_caps() after calling __prep_cap(). __prep_cap() is where\narg->xattr_buf is assigned to ci->i_xattrs.blob. This is the spot where\nthe refcount must be increased to prevent \"use after free\" error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26689",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-03",
                    "modification_date": "2025-01-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49006",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Free buffers when a used dynamic event is removed\n\nAfter 65536 dynamic events have been added and removed, the \"type\" field\nof the event then uses the first type number that is available (not\ncurrently used by other events). A type number is the identifier of the\nbinary blobs in the tracing ring buffer (known as events) to map them to\nlogic that can parse the binary blob.\n\nThe issue is that if a dynamic event (like a kprobe event) is traced and\nis in the ring buffer, and then that event is removed (because it is\ndynamic, which means it can be created and destroyed), if another dynamic\nevent is created that has the same number that new event's logic on\nparsing the binary blob will be used.\n\nTo show how this can be an issue, the following can crash the kernel:\n\n # cd /sys/kernel/tracing\n # for i in `seq 65536`; do\n     echo 'p:kprobes/foo do_sys_openat2 $arg1:u32' > kprobe_events\n # done\n\nFor every iteration of the above, the writing to the kprobe_events will\nremove the old event and create a new one (with the same format) and\nincrease the type number to the next available on until the type number\nreaches over 65535 which is the max number for the 16 bit type. After it\nreaches that number, the logic to allocate a new number simply looks for\nthe next available number. When an dynamic event is removed, that number\nis then available to be reused by the next dynamic event created. That is,\nonce the above reaches the max number, the number assigned to the event in\nthat loop will remain the same.\n\nNow that means deleting one dynamic event and created another will reuse\nthe previous events type number. This is where bad things can happen.\nAfter the above loop finishes, the kprobes/foo event which reads the\ndo_sys_openat2 function call's first parameter as an integer.\n\n # echo 1 > kprobes/foo/enable\n # cat /etc/passwd > /dev/null\n # cat trace\n             cat-2211    [005] ....  2007.849603: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849620: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849838: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n             cat-2211    [005] ....  2007.849880: foo: (do_sys_openat2+0x0/0x130) arg1=4294967196\n # echo 0 > kprobes/foo/enable\n\nNow if we delete the kprobe and create a new one that reads a string:\n\n # echo 'p:kprobes/foo do_sys_openat2 +0($arg2):string' > kprobe_events\n\nAnd now we can the trace:\n\n # cat trace\n        sendmail-1942    [002] .....   530.136320: foo: (do_sys_openat2+0x0/0x240) arg1=             cat-2046    [004] .....   530.930817: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\"\n             cat-2046    [004] .....   530.930961: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\"\n             cat-2046    [004] .....   530.934278: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\"\n             cat-2046    [004] .....   530.934563: foo: (do_sys_openat2+0x0/0x240) arg1=\"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49006",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-11-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-46999",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: do asoc update earlier in sctp_sf_do_dupcook_a\n\nThere's a panic that occurs in a few of envs, the call trace is as below:\n\n  [] general protection fault, ... 0x29acd70f1000a: 0000 [#1] SMP PTI\n  [] RIP: 0010:sctp_ulpevent_notify_peer_addr_change+0x4b/0x1fa [sctp]\n  []  sctp_assoc_control_transport+0x1b9/0x210 [sctp]\n  []  sctp_do_8_2_transport_strike.isra.16+0x15c/0x220 [sctp]\n  []  sctp_cmd_interpreter.isra.21+0x1231/0x1a10 [sctp]\n  []  sctp_do_sm+0xc3/0x2a0 [sctp]\n  []  sctp_generate_timeout_event+0x81/0xf0 [sctp]\n\nThis is caused by a transport use-after-free issue. When processing a\nduplicate COOKIE-ECHO chunk in sctp_sf_do_dupcook_a(), both COOKIE-ACK\nand SHUTDOWN chunks are allocated with the transort from the new asoc.\nHowever, later in the sideeffect machine, the old asoc is used to send\nthem out and old asoc's shutdown_last_sent_to is set to the transport\nthat SHUTDOWN chunk attached to in sctp_cmd_setup_t2(), which actually\nbelongs to the new asoc. After the new_asoc is freed and the old asoc\nT2 timeout, the old asoc's shutdown_last_sent_to that is already freed\nwould be accessed in sctp_sf_t2_timer_expire().\n\nThanks Alexander and Jere for helping dig into this issue.\n\nTo fix it, this patch is to do the asoc update first, then allocate\nthe COOKIE-ACK and SHUTDOWN chunks with the 'updated' old asoc. This\nwould make more sense, as a chunk from an asoc shouldn't be sent out\nwith another asoc. We had fixed quite a few issues caused by this.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46999",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49626",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsfc: fix use after free when disabling sriov\n\nUse after free is detected by kfence when disabling sriov. What was read\nafter being freed was vf->pci_dev: it was freed from pci_disable_sriov\nand later read in efx_ef10_sriov_free_vf_vports, called from\nefx_ef10_sriov_free_vf_vswitching.\n\nSet the pointer to NULL at release time to not trying to read it later.\n\nReproducer and dmesg log (note that kfence doesn't detect it every time):\n$ echo 1 > /sys/class/net/enp65s0f0np0/device/sriov_numvfs\n$ echo 0 > /sys/class/net/enp65s0f0np0/device/sriov_numvfs\n\n BUG: KFENCE: use-after-free read in efx_ef10_sriov_free_vf_vswitching+0x82/0x170 [sfc]\n\n Use-after-free read at 0x00000000ff3c1ba5 (in kfence-#224):\n  efx_ef10_sriov_free_vf_vswitching+0x82/0x170 [sfc]\n  efx_ef10_pci_sriov_disable+0x38/0x70 [sfc]\n  efx_pci_sriov_configure+0x24/0x40 [sfc]\n  sriov_numvfs_store+0xfe/0x140\n  kernfs_fop_write_iter+0x11c/0x1b0\n  new_sync_write+0x11f/0x1b0\n  vfs_write+0x1eb/0x280\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x5c/0x80\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n kfence-#224: 0x00000000edb8ef95-0x00000000671f5ce1, size=2792, cache=kmalloc-4k\n\n allocated by task 6771 on cpu 10 at 3137.860196s:\n  pci_alloc_dev+0x21/0x60\n  pci_iov_add_virtfn+0x2a2/0x320\n  sriov_enable+0x212/0x3e0\n  efx_ef10_sriov_configure+0x67/0x80 [sfc]\n  efx_pci_sriov_configure+0x24/0x40 [sfc]\n  sriov_numvfs_store+0xba/0x140\n  kernfs_fop_write_iter+0x11c/0x1b0\n  new_sync_write+0x11f/0x1b0\n  vfs_write+0x1eb/0x280\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x5c/0x80\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n freed by task 6771 on cpu 12 at 3170.991309s:\n  device_release+0x34/0x90\n  kobject_cleanup+0x3a/0x130\n  pci_iov_remove_virtfn+0xd9/0x120\n  sriov_disable+0x30/0xe0\n  efx_ef10_pci_sriov_disable+0x57/0x70 [sfc]\n  efx_pci_sriov_configure+0x24/0x40 [sfc]\n  sriov_numvfs_store+0xfe/0x140\n  kernfs_fop_write_iter+0x11c/0x1b0\n  new_sync_write+0x11f/0x1b0\n  vfs_write+0x1eb/0x280\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x5c/0x80\n  entry_SYSCALL_64_after_hwframe+0x44/0xae",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49626",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38212",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipc: fix to protect IPCS lookups using RCU\n\nsyzbot reported that it discovered a use-after-free vulnerability, [0]\n\n[0]: https://lore.kernel.org/all/67af13f8.050a0220.21dd3.0038.GAE@google.com/\n\nidr_for_each() is protected by rwsem, but this is not enough.  If it is\nnot protected by RCU read-critical region, when idr_for_each() calls\nradix_tree_node_free() through call_rcu() to free the radix_tree_node\nstructure, the node will be freed immediately, and when reading the next\nnode in radix_tree_for_each_slot(), the already freed memory may be read.\n\nTherefore, we need to add code to make sure that idr_for_each() is\nprotected within the RCU read-critical region when we call it in\nshm_destroy_orphaned().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38212",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-04",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52760",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix slab-use-after-free in gfs2_qd_dealloc\n\nIn gfs2_put_super(), whether withdrawn or not, the quota should\nbe cleaned up by gfs2_quota_cleanup().\n\nOtherwise, struct gfs2_sbd will be freed before gfs2_qd_dealloc (rcu\ncallback) has run for all gfs2_quota_data objects, resulting in\nuse-after-free.\n\nAlso, gfs2_destroy_threads() and gfs2_quota_cleanup() is already called\nby gfs2_make_fs_ro(), so in gfs2_put_super(), after calling\ngfs2_make_fs_ro(), there is no need to call them again.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52760",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48834",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: usbtmc: Fix bug in pipe direction for control transfers\n\nThe syzbot fuzzer reported a minor bug in the usbtmc driver:\n\nusb 5-1: BOGUS control dir, pipe 80001e80 doesn't match bRequestType 0\nWARNING: CPU: 0 PID: 3813 at drivers/usb/core/urb.c:412\nusb_submit_urb+0x13a5/0x1970 drivers/usb/core/urb.c:410\nModules linked in:\nCPU: 0 PID: 3813 Comm: syz-executor122 Not tainted\n5.17.0-rc5-syzkaller-00306-g2293be58d6a1 #0\n...\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x113/0x530 drivers/usb/core/message.c:58\n usb_internal_control_msg drivers/usb/core/message.c:102 [inline]\n usb_control_msg+0x2a5/0x4b0 drivers/usb/core/message.c:153\n usbtmc_ioctl_request drivers/usb/class/usbtmc.c:1947 [inline]\n\nThe problem is that usbtmc_ioctl_request() uses usb_rcvctrlpipe() for\nall of its transfers, whether they are in or out.  It's easy to fix.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48834",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-01-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50220",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusbnet: Fix linkwatch use-after-free on disconnect\n\nusbnet uses the work usbnet_deferred_kevent() to perform tasks which may\nsleep.  On disconnect, completion of the work was originally awaited in\n->ndo_stop().  But in 2003, that was moved to ->disconnect() by historic\ncommit \"[PATCH] USB: usbnet, prevent exotic rtnl deadlock\":\n\n  https://git.kernel.org/tglx/history/c/0f138bbfd83c\n\nThe change was made because back then, the kernel's workqueue\nimplementation did not allow waiting for a single work.  One had to wait\nfor completion of *all* work by calling flush_scheduled_work(), and that\ncould deadlock when waiting for usbnet_deferred_kevent() with rtnl_mutex\nheld in ->ndo_stop().\n\nThe commit solved one problem but created another:  It causes a\nuse-after-free in USB Ethernet drivers aqc111.c, asix_devices.c,\nax88179_178a.c, ch9200.c and smsc75xx.c:\n\n* If the drivers receive a link change interrupt immediately before\n  disconnect, they raise EVENT_LINK_RESET in their (non-sleepable)\n  ->status() callback and schedule usbnet_deferred_kevent().\n* usbnet_deferred_kevent() invokes the driver's ->link_reset() callback,\n  which calls netif_carrier_{on,off}().\n* That in turn schedules the work linkwatch_event().\n\nBecause usbnet_deferred_kevent() is awaited after unregister_netdev(),\nnetif_carrier_{on,off}() may operate on an unregistered netdev and\nlinkwatch_event() may run after free_netdev(), causing a use-after-free.\n\nIn 2010, usbnet was changed to only wait for a single instance of\nusbnet_deferred_kevent() instead of *all* work by commit 23f333a2bfaf\n(\"drivers/net: don't use flush_scheduled_work()\").\n\nUnfortunately the commit neglected to move the wait back to\n->ndo_stop().  Rectify that omission at long last.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50220",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21704",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdc-acm: Check control transfer buffer size before access\n\nIf the first fragment is shorter than struct usb_cdc_notification, we can't\ncalculate an expected_size. Log an error and discard the notification\ninstead of reading lengths from memory outside the received data, which can\nlead to memory corruption when the expected_size decreases between\nfragments, causing `expected_size - acm->nb_index` to wrap.\n\nThis issue has been present since the beginning of git history; however,\nit only leads to memory corruption since commit ea2583529cd1\n(\"cdc-acm: reassemble fragmented notifications\").\n\nA mitigating factor is that acm_ctrl_irq() can only execute after userspace\nhas opened /dev/ttyACM*; but if ModemManager is running, ModemManager will\ndo that automatically depending on the USB device's vendor/product IDs and\nits other interfaces.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21704",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-22",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53235",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/tests: helpers: Avoid a driver uaf\n\nwhen using __drm_kunit_helper_alloc_drm_device() the driver may be\ndereferenced by device-managed resources up until the device is\nfreed, which is typically later than the kunit-managed resource code\nfrees it. Fix this by simply make the driver device-managed as well.\n\nIn short, the sequence leading to the UAF is as follows:\n\nINIT:\nCode allocates a struct device as a kunit-managed resource.\nCode allocates a drm driver as a kunit-managed resource.\nCode allocates a drm device as a device-managed resource.\n\nEXIT:\nKunit resource cleanup frees the drm driver\nKunit resource cleanup puts the struct device, which starts a\n      device-managed resource cleanup\ndevice-managed cleanup calls drm_dev_put()\ndrm_dev_put() dereferences the (now freed) drm driver -> Boom.\n\nRelated KASAN message:\n[55272.551542] ==================================================================\n[55272.551551] BUG: KASAN: slab-use-after-free in drm_dev_put.part.0+0xd4/0xe0 [drm]\n[55272.551603] Read of size 8 at addr ffff888127502828 by task kunit_try_catch/10353\n\n[55272.551612] CPU: 4 PID: 10353 Comm: kunit_try_catch Tainted: G     U           N 6.5.0-rc7+ #155\n[55272.551620] Hardware name: ASUS System Product Name/PRIME B560M-A AC, BIOS 0403 01/26/2021\n[55272.551626] Call Trace:\n[55272.551629]  <TASK>\n[55272.551633]  dump_stack_lvl+0x57/0x90\n[55272.551639]  print_report+0xcf/0x630\n[55272.551645]  ? _raw_spin_lock_irqsave+0x5f/0x70\n[55272.551652]  ? drm_dev_put.part.0+0xd4/0xe0 [drm]\n[55272.551694]  kasan_report+0xd7/0x110\n[55272.551699]  ? drm_dev_put.part.0+0xd4/0xe0 [drm]\n[55272.551742]  drm_dev_put.part.0+0xd4/0xe0 [drm]\n[55272.551783]  devres_release_all+0x15d/0x1f0\n[55272.551790]  ? __pfx_devres_release_all+0x10/0x10\n[55272.551797]  device_unbind_cleanup+0x16/0x1a0\n[55272.551802]  device_release_driver_internal+0x3e5/0x540\n[55272.551808]  ? kobject_put+0x5d/0x4b0\n[55272.551814]  bus_remove_device+0x1f1/0x3f0\n[55272.551819]  device_del+0x342/0x910\n[55272.551826]  ? __pfx_device_del+0x10/0x10\n[55272.551830]  ? lock_release+0x339/0x5e0\n[55272.551836]  ? kunit_remove_resource+0x128/0x290 [kunit]\n[55272.551845]  ? __pfx_lock_release+0x10/0x10\n[55272.551851]  platform_device_del.part.0+0x1f/0x1e0\n[55272.551856]  ? _raw_spin_unlock_irqrestore+0x30/0x60\n[55272.551863]  kunit_remove_resource+0x195/0x290 [kunit]\n[55272.551871]  ? _raw_spin_unlock_irqrestore+0x30/0x60\n[55272.551877]  kunit_cleanup+0x78/0x120 [kunit]\n[55272.551885]  ? __kthread_parkme+0xc1/0x1f0\n[55272.551891]  ? __pfx_kunit_try_run_case_cleanup+0x10/0x10 [kunit]\n[55272.551900]  ? __pfx_kunit_generic_run_threadfn_adapter+0x10/0x10 [kunit]\n[55272.551909]  kunit_generic_run_threadfn_adapter+0x4a/0x90 [kunit]\n[55272.551919]  kthread+0x2e7/0x3c0\n[55272.551924]  ? __pfx_kthread+0x10/0x10\n[55272.551929]  ret_from_fork+0x2d/0x70\n[55272.551935]  ? __pfx_kthread+0x10/0x10\n[55272.551940]  ret_from_fork_asm+0x1b/0x30\n[55272.551948]  </TASK>\n\n[55272.551953] Allocated by task 10351:\n[55272.551956]  kasan_save_stack+0x1c/0x40\n[55272.551962]  kasan_set_track+0x21/0x30\n[55272.551966]  __kasan_kmalloc+0x8b/0x90\n[55272.551970]  __kmalloc+0x5e/0x160\n[55272.551976]  kunit_kmalloc_array+0x1c/0x50 [kunit]\n[55272.551984]  drm_exec_test_init+0xfa/0x2c0 [drm_exec_test]\n[55272.551991]  kunit_try_run_case+0xdd/0x250 [kunit]\n[55272.551999]  kunit_generic_run_threadfn_adapter+0x4a/0x90 [kunit]\n[55272.552008]  kthread+0x2e7/0x3c0\n[55272.552012]  ret_from_fork+0x2d/0x70\n[55272.552017]  ret_from_fork_asm+0x1b/0x30\n\n[55272.552024] Freed by task 10353:\n[55272.552027]  kasan_save_stack+0x1c/0x40\n[55272.552032]  kasan_set_track+0x21/0x30\n[55272.552036]  kasan_save_free_info+0x27/0x40\n[55272.552041]  __kasan_slab_free+0x106/0x180\n[55272.552046]  slab_free_freelist_hook+0xb3/0x160\n[55272.552051]  __kmem_cache_free+0xb2/0x290\n[55272.552056]  kunit_remove_resource+0x195/0x290 [kunit]\n[55272.552064]  kunit_cleanup+0x7\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53235",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49535",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix null pointer dereference after failing to issue FLOGI and PLOGI\n\nIf lpfc_issue_els_flogi() fails and returns non-zero status, the node\nreference count is decremented to trigger the release of the nodelist\nstructure. However, if there is a prior registration or dev-loss-evt work\npending, the node may be released prematurely.  When dev-loss-evt\ncompletes, the released node is referenced causing a use-after-free null\npointer dereference.\n\nSimilarly, when processing non-zero ELS PLOGI completion status in\nlpfc_cmpl_els_plogi(), the ndlp flags are checked for a transport\nregistration before triggering node removal.  If dev-loss-evt work is\npending, the node may be released prematurely and a subsequent call to\nlpfc_dev_loss_tmo_handler() results in a use after free ndlp dereference.\n\nAdd test for pending dev-loss before decrementing the node reference count\nfor FLOGI, PLOGI, PRLI, and ADISC handling.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49535",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38245",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: Release atm_dev_mutex after removing procfs in atm_dev_deregister().\n\nsyzbot reported a warning below during atm_dev_register(). [0]\n\nBefore creating a new device and procfs/sysfs for it, atm_dev_register()\nlooks up a duplicated device by __atm_dev_lookup().  These operations are\ndone under atm_dev_mutex.\n\nHowever, when removing a device in atm_dev_deregister(), it releases the\nmutex just after removing the device from the list that __atm_dev_lookup()\niterates over.\n\nSo, there will be a small race window where the device does not exist on\nthe device list but procfs/sysfs are still not removed, triggering the\nsplat.\n\nLet's hold the mutex until procfs/sysfs are removed in\natm_dev_deregister().\n\n[0]:\nproc_dir_entry 'atm/atmtcp:0' already registered\nWARNING: CPU: 0 PID: 5919 at fs/proc/generic.c:377 proc_register+0x455/0x5f0 fs/proc/generic.c:377\nModules linked in:\nCPU: 0 UID: 0 PID: 5919 Comm: syz-executor284 Not tainted 6.16.0-rc2-syzkaller-00047-g52da431bf03b #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nRIP: 0010:proc_register+0x455/0x5f0 fs/proc/generic.c:377\nCode: 48 89 f9 48 c1 e9 03 80 3c 01 00 0f 85 a2 01 00 00 48 8b 44 24 10 48 c7 c7 20 c0 c2 8b 48 8b b0 d8 00 00 00 e8 0c 02 1c ff 90 <0f> 0b 90 90 48 c7 c7 80 f2 82 8e e8 0b de 23 09 48 8b 4c 24 28 48\nRSP: 0018:ffffc9000466fa30 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817ae248\nRDX: ffff888026280000 RSI: ffffffff817ae255 RDI: 0000000000000001\nRBP: ffff8880232bed48 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000001 R12: ffff888076ed2140\nR13: dffffc0000000000 R14: ffff888078a61340 R15: ffffed100edda444\nFS:  00007f38b3b0c6c0(0000) GS:ffff888124753000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f38b3bdf953 CR3: 0000000076d58000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n proc_create_data+0xbe/0x110 fs/proc/generic.c:585\n atm_proc_dev_register+0x112/0x1e0 net/atm/proc.c:361\n atm_dev_register+0x46d/0x890 net/atm/resources.c:113\n atmtcp_create+0x77/0x210 drivers/atm/atmtcp.c:369\n atmtcp_attach drivers/atm/atmtcp.c:403 [inline]\n atmtcp_ioctl+0x2f9/0xd60 drivers/atm/atmtcp.c:464\n do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159\n sock_do_ioctl+0x115/0x280 net/socket.c:1190\n sock_ioctl+0x227/0x6b0 net/socket.c:1311\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl fs/ioctl.c:893 [inline]\n __x64_sys_ioctl+0x18b/0x210 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f38b3b74459\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f38b3b0c198 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007f38b3bfe318 RCX: 00007f38b3b74459\nRDX: 0000000000000000 RSI: 0000000000006180 RDI: 0000000000000005\nRBP: 00007f38b3bfe310 R08: 65732f636f72702f R09: 65732f636f72702f\nR10: 65732f636f72702f R11: 0000000000000246 R12: 00007f38b3bcb0ac\nR13: 00007f38b3b0c1a0 R14: 0000200000000200 R15: 00007f38b3bcb03b\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38245",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-09",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56633",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_bpf: Fix the sk_mem_uncharge logic in tcp_bpf_sendmsg\n\nThe current sk memory accounting logic in __SK_REDIRECT is pre-uncharging\ntosend bytes, which is either msg->sg.size or a smaller value apply_bytes.\n\nPotential problems with this strategy are as follows:\n\n- If the actual sent bytes are smaller than tosend, we need to charge some\n  bytes back, as in line 487, which is okay but seems not clean.\n\n- When tosend is set to apply_bytes, as in line 417, and (ret < 0), we may\n  miss uncharging (msg->sg.size - apply_bytes) bytes.\n\n[...]\n415 tosend = msg->sg.size;\n416 if (psock->apply_bytes && psock->apply_bytes < tosend)\n417   tosend = psock->apply_bytes;\n[...]\n443 sk_msg_return(sk, msg, tosend);\n444 release_sock(sk);\n446 origsize = msg->sg.size;\n447 ret = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,\n448                             msg, tosend, flags);\n449 sent = origsize - msg->sg.size;\n[...]\n454 lock_sock(sk);\n455 if (unlikely(ret < 0)) {\n456   int free = sk_msg_free_nocharge(sk, msg);\n458   if (!cork)\n459     *copied -= free;\n460 }\n[...]\n487 if (eval == __SK_REDIRECT)\n488   sk_mem_charge(sk, tosend - sent);\n[...]\n\nWhen running the selftest test_txmsg_redir_wait_sndmem with txmsg_apply,\nthe following warning will be reported:\n\n------------[ cut here ]------------\nWARNING: CPU: 6 PID: 57 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x190/0x1a0\nModules linked in:\nCPU: 6 UID: 0 PID: 57 Comm: kworker/6:0 Not tainted 6.12.0-rc1.bm.1-amd64+ #43\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nWorkqueue: events sk_psock_destroy\nRIP: 0010:inet_sock_destruct+0x190/0x1a0\nRSP: 0018:ffffad0a8021fe08 EFLAGS: 00010206\nRAX: 0000000000000011 RBX: ffff9aab4475b900 RCX: ffff9aab481a0800\nRDX: 0000000000000303 RSI: 0000000000000011 RDI: ffff9aab4475b900\nRBP: ffff9aab4475b990 R08: 0000000000000000 R09: ffff9aab40050ec0\nR10: 0000000000000000 R11: ffff9aae6fdb1d01 R12: ffff9aab49c60400\nR13: ffff9aab49c60598 R14: ffff9aab49c60598 R15: dead000000000100\nFS:  0000000000000000(0000) GS:ffff9aae6fd80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffec7e47bd8 CR3: 00000001a1a1c004 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n<TASK>\n? __warn+0x89/0x130\n? inet_sock_destruct+0x190/0x1a0\n? report_bug+0xfc/0x1e0\n? handle_bug+0x5c/0xa0\n? exc_invalid_op+0x17/0x70\n? asm_exc_invalid_op+0x1a/0x20\n? inet_sock_destruct+0x190/0x1a0\n__sk_destruct+0x25/0x220\nsk_psock_destroy+0x2b2/0x310\nprocess_scheduled_works+0xa3/0x3e0\nworker_thread+0x117/0x240\n? __pfx_worker_thread+0x10/0x10\nkthread+0xcf/0x100\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x31/0x40\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n</TASK>\n---[ end trace 0000000000000000 ]---\n\nIn __SK_REDIRECT, a more concise way is delaying the uncharging after sent\nbytes are finalized, and uncharge this value. When (ret < 0), we shall\ninvoke sk_msg_free.\n\nSame thing happens in case __SK_DROP, when tosend is set to apply_bytes,\nwe may miss uncharging (msg->sg.size - apply_bytes) bytes. The same\nwarning will be reported in selftest.\n\n[...]\n468 case __SK_DROP:\n469 default:\n470 sk_msg_free_partial(sk, msg, tosend);\n471 sk_msg_apply_bytes(psock, tosend);\n472 *copied -= (tosend + delta);\n473 return -EACCES;\n[...]\n\nSo instead of sk_msg_free_partial we can do sk_msg_free here.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56633",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-58083",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: Explicitly verify target vCPU is online in kvm_get_vcpu()\n\nExplicitly verify the target vCPU is fully online _prior_ to clamping the\nindex in kvm_get_vcpu().  If the index is \"bad\", the nospec clamping will\ngenerate '0', i.e. KVM will return vCPU0 instead of NULL.\n\nIn practice, the bug is unlikely to cause problems, as it will only come\ninto play if userspace or the guest is buggy or misbehaving, e.g. KVM may\nsend interrupts to vCPU0 instead of dropping them on the floor.\n\nHowever, returning vCPU0 when it shouldn't exist per online_vcpus is\nproblematic now that KVM uses an xarray for the vCPUs array, as KVM needs\nto insert into the xarray before publishing the vCPU to userspace (see\ncommit c5b077549136 (\"KVM: Convert the kvm->vcpus array to a xarray\")),\ni.e. before vCPU creation is guaranteed to succeed.\n\nAs a result, incorrectly providing access to vCPU0 will trigger a\nuse-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()\nbails out of vCPU creation due to an error and frees vCPU0.  Commit\nafb2acb2e3a3 (\"KVM: Fix vcpu_array[0] races\") papered over that issue, but\nin doing so introduced an unsolvable teardown conundrum.  Preventing\naccesses to vCPU0 before it's fully online will allow reverting commit\nafb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-58083",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-06",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47616",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA: Fix use-after-free in rxe_queue_cleanup\n\nOn error handling path in rxe_qp_from_init() qp->sq.queue is freed and\nthen rxe_create_qp() will drop last reference to this object. qp clean up\nfunction will try to free this queue one time and it causes UAF bug.\n\nFix it by zeroing queue pointer after freeing queue in rxe_qp_from_init().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47616",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53285",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: add bounds checking in get_max_inline_xattr_value_size()\n\nNormally the extended attributes in the inode body would have been\nchecked when the inode is first opened, but if someone is writing to\nthe block device while the file system is mounted, it's possible for\nthe inode table to get corrupted.  Add bounds checking to avoid\nreading beyond the end of allocated memory if this happens.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53285",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48732",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/nouveau: fix off by one in BIOS boundary checking\n\nBounds checking when parsing init scripts embedded in the BIOS reject\naccess to the last byte. This causes driver initialization to fail on\nApple eMac's with GeForce 2 MX GPUs, leaving the system with no working\nconsole.\n\nThis is probably only seen on OpenFirmware machines like PowerPC Macs\nbecause the BIOS image provided by OF is only the used parts of the ROM,\nnot a power-of-two blocks read from PCI directly so PCs always have\nempty bytes at the end that are never accessed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48732",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49176",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbfq: fix use-after-free in bfq_dispatch_request\n\nKASAN reports a use-after-free report when doing normal scsi-mq test\n\n[69832.239032] ==================================================================\n[69832.241810] BUG: KASAN: use-after-free in bfq_dispatch_request+0x1045/0x44b0\n[69832.243267] Read of size 8 at addr ffff88802622ba88 by task kworker/3:1H/155\n[69832.244656]\n[69832.245007] CPU: 3 PID: 155 Comm: kworker/3:1H Not tainted 5.10.0-10295-g576c6382529e #8\n[69832.246626] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\n[69832.249069] Workqueue: kblockd blk_mq_run_work_fn\n[69832.250022] Call Trace:\n[69832.250541]  dump_stack+0x9b/0xce\n[69832.251232]  ? bfq_dispatch_request+0x1045/0x44b0\n[69832.252243]  print_address_description.constprop.6+0x3e/0x60\n[69832.253381]  ? __cpuidle_text_end+0x5/0x5\n[69832.254211]  ? vprintk_func+0x6b/0x120\n[69832.254994]  ? bfq_dispatch_request+0x1045/0x44b0\n[69832.255952]  ? bfq_dispatch_request+0x1045/0x44b0\n[69832.256914]  kasan_report.cold.9+0x22/0x3a\n[69832.257753]  ? bfq_dispatch_request+0x1045/0x44b0\n[69832.258755]  check_memory_region+0x1c1/0x1e0\n[69832.260248]  bfq_dispatch_request+0x1045/0x44b0\n[69832.261181]  ? bfq_bfqq_expire+0x2440/0x2440\n[69832.262032]  ? blk_mq_delay_run_hw_queues+0xf9/0x170\n[69832.263022]  __blk_mq_do_dispatch_sched+0x52f/0x830\n[69832.264011]  ? blk_mq_sched_request_inserted+0x100/0x100\n[69832.265101]  __blk_mq_sched_dispatch_requests+0x398/0x4f0\n[69832.266206]  ? blk_mq_do_dispatch_ctx+0x570/0x570\n[69832.267147]  ? __switch_to+0x5f4/0xee0\n[69832.267898]  blk_mq_sched_dispatch_requests+0xdf/0x140\n[69832.268946]  __blk_mq_run_hw_queue+0xc0/0x270\n[69832.269840]  blk_mq_run_work_fn+0x51/0x60\n[69832.278170]  process_one_work+0x6d4/0xfe0\n[69832.278984]  worker_thread+0x91/0xc80\n[69832.279726]  ? __kthread_parkme+0xb0/0x110\n[69832.280554]  ? process_one_work+0xfe0/0xfe0\n[69832.281414]  kthread+0x32d/0x3f0\n[69832.282082]  ? kthread_park+0x170/0x170\n[69832.282849]  ret_from_fork+0x1f/0x30\n[69832.283573]\n[69832.283886] Allocated by task 7725:\n[69832.284599]  kasan_save_stack+0x19/0x40\n[69832.285385]  __kasan_kmalloc.constprop.2+0xc1/0xd0\n[69832.286350]  kmem_cache_alloc_node+0x13f/0x460\n[69832.287237]  bfq_get_queue+0x3d4/0x1140\n[69832.287993]  bfq_get_bfqq_handle_split+0x103/0x510\n[69832.289015]  bfq_init_rq+0x337/0x2d50\n[69832.289749]  bfq_insert_requests+0x304/0x4e10\n[69832.290634]  blk_mq_sched_insert_requests+0x13e/0x390\n[69832.291629]  blk_mq_flush_plug_list+0x4b4/0x760\n[69832.292538]  blk_flush_plug_list+0x2c5/0x480\n[69832.293392]  io_schedule_prepare+0xb2/0xd0\n[69832.294209]  io_schedule_timeout+0x13/0x80\n[69832.295014]  wait_for_common_io.constprop.1+0x13c/0x270\n[69832.296137]  submit_bio_wait+0x103/0x1a0\n[69832.296932]  blkdev_issue_discard+0xe6/0x160\n[69832.297794]  blk_ioctl_discard+0x219/0x290\n[69832.298614]  blkdev_common_ioctl+0x50a/0x1750\n[69832.304715]  blkdev_ioctl+0x470/0x600\n[69832.305474]  block_ioctl+0xde/0x120\n[69832.306232]  vfs_ioctl+0x6c/0xc0\n[69832.306877]  __se_sys_ioctl+0x90/0xa0\n[69832.307629]  do_syscall_64+0x2d/0x40\n[69832.308362]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[69832.309382]\n[69832.309701] Freed by task 155:\n[69832.310328]  kasan_save_stack+0x19/0x40\n[69832.311121]  kasan_set_track+0x1c/0x30\n[69832.311868]  kasan_set_free_info+0x1b/0x30\n[69832.312699]  __kasan_slab_free+0x111/0x160\n[69832.313524]  kmem_cache_free+0x94/0x460\n[69832.314367]  bfq_put_queue+0x582/0x940\n[69832.315112]  __bfq_bfqd_reset_in_service+0x166/0x1d0\n[69832.317275]  bfq_bfqq_expire+0xb27/0x2440\n[69832.318084]  bfq_dispatch_request+0x697/0x44b0\n[69832.318991]  __blk_mq_do_dispatch_sched+0x52f/0x830\n[69832.319984]  __blk_mq_sched_dispatch_requests+0x398/0x4f0\n[69832.321087]  blk_mq_sched_dispatch_requests+0xdf/0x140\n[69832.322225]  __blk_mq_run_hw_queue+0xc0/0x270\n[69832.323114]  blk_mq_run_work_fn+0x51/0x6\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49176",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47727",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/tdx: Fix \"in-kernel MMIO\" check\n\nTDX only supports kernel-initiated MMIO operations. The handle_mmio()\nfunction checks if the #VE exception occurred in the kernel and rejects\nthe operation if it did not.\n\nHowever, userspace can deceive the kernel into performing MMIO on its\nbehalf. For example, if userspace can point a syscall to an MMIO address,\nsyscall does get_user() or put_user() on it, triggering MMIO #VE. The\nkernel will treat the #VE as in-kernel MMIO.\n\nEnsure that the target MMIO address is within the kernel before decoding\ninstruction.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47727",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38157",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k_htc: Abort software beacon handling if disabled\n\nA malicious USB device can send a WMI_SWBA_EVENTID event from an\nath9k_htc-managed device before beaconing has been enabled. This causes\na device-by-zero error in the driver, leading to either a crash or an\nout of bounds read.\n\nPrevent this by aborting the handling in ath9k_htc_swba() if beacons are\nnot enabled.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38157",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48662",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/gem: Really move i915_gem_context.link under ref protection\n\ni915_perf assumes that it can use the i915_gem_context reference to\nprotect its i915->gem.contexts.list iteration. However, this requires\nthat we do not remove the context from the list until after we drop the\nfinal reference and release the struct. If, as currently, we remove the\ncontext from the list during context_close(), the link.next pointer may\nbe poisoned while we are holding the context reference and cause a GPF:\n\n[ 4070.573157] i915 0000:00:02.0: [drm:i915_perf_open_ioctl [i915]] filtering on ctx_id=0x1fffff ctx_id_mask=0x1fffff\n[ 4070.574881] general protection fault, probably for non-canonical address 0xdead000000000100: 0000 [#1] PREEMPT SMP\n[ 4070.574897] CPU: 1 PID: 284392 Comm: amd_performance Tainted: G            E     5.17.9 #180\n[ 4070.574903] Hardware name: Intel Corporation NUC7i5BNK/NUC7i5BNB, BIOS BNKBL357.86A.0052.2017.0918.1346 09/18/2017\n[ 4070.574907] RIP: 0010:oa_configure_all_contexts.isra.0+0x222/0x350 [i915]\n[ 4070.574982] Code: 08 e8 32 6e 10 e1 4d 8b 6d 50 b8 ff ff ff ff 49 83 ed 50 f0 41 0f c1 04 24 83 f8 01 0f 84 e3 00 00 00 85 c0 0f 8e fa 00 00 00 <49> 8b 45 50 48 8d 70 b0 49 8d 45 50 48 39 44 24 10 0f 85 34 fe ff\n[ 4070.574990] RSP: 0018:ffffc90002077b78 EFLAGS: 00010202\n[ 4070.574995] RAX: 0000000000000002 RBX: 0000000000000002 RCX: 0000000000000000\n[ 4070.575000] RDX: 0000000000000001 RSI: ffffc90002077b20 RDI: ffff88810ddc7c68\n[ 4070.575004] RBP: 0000000000000001 R08: ffff888103242648 R09: fffffffffffffffc\n[ 4070.575008] R10: ffffffff82c50bc0 R11: 0000000000025c80 R12: ffff888101bf1860\n[ 4070.575012] R13: dead0000000000b0 R14: ffffc90002077c04 R15: ffff88810be5cabc\n[ 4070.575016] FS:  00007f1ed50c0780(0000) GS:ffff88885ec80000(0000) knlGS:0000000000000000\n[ 4070.575021] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 4070.575025] CR2: 00007f1ed5590280 CR3: 000000010ef6f005 CR4: 00000000003706e0\n[ 4070.575029] Call Trace:\n[ 4070.575033]  <TASK>\n[ 4070.575037]  lrc_configure_all_contexts+0x13e/0x150 [i915]\n[ 4070.575103]  gen8_enable_metric_set+0x4d/0x90 [i915]\n[ 4070.575164]  i915_perf_open_ioctl+0xbc0/0x1500 [i915]\n[ 4070.575224]  ? asm_common_interrupt+0x1e/0x40\n[ 4070.575232]  ? i915_oa_init_reg_state+0x110/0x110 [i915]\n[ 4070.575290]  drm_ioctl_kernel+0x85/0x110\n[ 4070.575296]  ? update_load_avg+0x5f/0x5e0\n[ 4070.575302]  drm_ioctl+0x1d3/0x370\n[ 4070.575307]  ? i915_oa_init_reg_state+0x110/0x110 [i915]\n[ 4070.575382]  ? gen8_gt_irq_handler+0x46/0x130 [i915]\n[ 4070.575445]  __x64_sys_ioctl+0x3c4/0x8d0\n[ 4070.575451]  ? __do_softirq+0xaa/0x1d2\n[ 4070.575456]  do_syscall_64+0x35/0x80\n[ 4070.575461]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[ 4070.575467] RIP: 0033:0x7f1ed5c10397\n[ 4070.575471] Code: 3c 1c e8 1c ff ff ff 85 c0 79 87 49 c7 c4 ff ff ff ff 5b 5d 4c 89 e0 41 5c c3 66 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d a9 da 0d 00 f7 d8 64 89 01 48\n[ 4070.575478] RSP: 002b:00007ffd65c8d7a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n[ 4070.575484] RAX: ffffffffffffffda RBX: 0000000000000006 RCX: 00007f1ed5c10397\n[ 4070.575488] RDX: 00007ffd65c8d7c0 RSI: 0000000040106476 RDI: 0000000000000006\n[ 4070.575492] RBP: 00005620972f9c60 R08: 000000000000000a R09: 0000000000000005\n[ 4070.575496] R10: 000000000000000d R11: 0000000000000246 R12: 000000000000000a\n[ 4070.575500] R13: 000000000000000d R14: 0000000000000000 R15: 00007ffd65c8d7c0\n[ 4070.575505]  </TASK>\n[ 4070.575507] Modules linked in: nls_ascii(E) nls_cp437(E) vfat(E) fat(E) i915(E) x86_pkg_temp_thermal(E) intel_powerclamp(E) crct10dif_pclmul(E) crc32_pclmul(E) crc32c_intel(E) aesni_intel(E) crypto_simd(E) intel_gtt(E) cryptd(E) ttm(E) rapl(E) intel_cstate(E) drm_kms_helper(E) cfbfillrect(E) syscopyarea(E) cfbimgblt(E) intel_uncore(E) sysfillrect(E) mei_me(E) sysimgblt(E) i2c_i801(E) fb_sys_fops(E) mei(E) intel_pch_thermal(E) i2c_smbus\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48662",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-44932",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nidpf: fix UAFs when destroying the queues\n\nThe second tagged commit started sometimes (very rarely, but possible)\nthrowing WARNs from\nnet/core/page_pool.c:page_pool_disable_direct_recycling().\nTurned out idpf frees interrupt vectors with embedded NAPIs *before*\nfreeing the queues making page_pools' NAPI pointers lead to freed\nmemory before these pools are destroyed by libeth.\nIt's not clear whether there are other accesses to the freed vectors\nwhen destroying the queues, but anyway, we usually free queue/interrupt\nvectors only when the queues are destroyed and the NAPIs are guaranteed\nto not be referenced anywhere.\n\nInvert the allocation and freeing logic making queue/interrupt vectors\nbe allocated first and freed last. Vectors don't require queues to be\npresent, so this is safe. Additionally, this change allows to remove\nthat useless queue->q_vector pointer cleanup, as vectors are still\nvalid when freeing the queues (+ both are freed within one function,\nso it's not clear why nullify the pointers at all).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44932",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-26",
                    "modification_date": "2024-08-27",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21671",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nzram: fix potential UAF of zram table\n\nIf zram_meta_alloc failed early, it frees allocated zram->table without\nsetting it NULL.  Which will potentially cause zram_meta_free to access\nthe table if user reset an failed and uninitialized device.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21671",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-31",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53053",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nerspan: do not use skb_mac_header() in ndo_start_xmit()\n\nDrivers should not assume skb_mac_header(skb) == skb->data in their\nndo_start_xmit().\n\nUse skb_network_offset() and skb_transport_offset() which\nbetter describe what is needed in erspan_fb_xmit() and\nip6erspan_tunnel_xmit()\n\nsyzbot reported:\nWARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 skb_mac_header include/linux/skbuff.h:2873 [inline]\nWARNING: CPU: 0 PID: 5083 at include/linux/skbuff.h:2873 ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962\nModules linked in:\nCPU: 0 PID: 5083 Comm: syz-executor406 Not tainted 6.3.0-rc2-syzkaller-00866-gd4671cb96fa3 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/02/2023\nRIP: 0010:skb_mac_header include/linux/skbuff.h:2873 [inline]\nRIP: 0010:ip6erspan_tunnel_xmit+0x1d9c/0x2d90 net/ipv6/ip6_gre.c:962\nCode: 04 02 41 01 de 84 c0 74 08 3c 03 0f 8e 1c 0a 00 00 45 89 b4 24 c8 00 00 00 c6 85 77 fe ff ff 01 e9 33 e7 ff ff e8 b4 27 a1 f8 <0f> 0b e9 b6 e7 ff ff e8 a8 27 a1 f8 49 8d bf f0 0c 00 00 48 b8 00\nRSP: 0018:ffffc90003b2f830 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: 000000000000ffff RCX: 0000000000000000\nRDX: ffff888021273a80 RSI: ffffffff88e1bd4c RDI: 0000000000000003\nRBP: ffffc90003b2f9d8 R08: 0000000000000003 R09: 000000000000ffff\nR10: 000000000000ffff R11: 0000000000000000 R12: ffff88802b28da00\nR13: 00000000000000d0 R14: ffff88807e25b6d0 R15: ffff888023408000\nFS: 0000555556a61300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055e5b11eb6e8 CR3: 0000000027c1b000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n<TASK>\n__netdev_start_xmit include/linux/netdevice.h:4900 [inline]\nnetdev_start_xmit include/linux/netdevice.h:4914 [inline]\n__dev_direct_xmit+0x504/0x730 net/core/dev.c:4300\ndev_direct_xmit include/linux/netdevice.h:3088 [inline]\npacket_xmit+0x20a/0x390 net/packet/af_packet.c:285\npacket_snd net/packet/af_packet.c:3075 [inline]\npacket_sendmsg+0x31a0/0x5150 net/packet/af_packet.c:3107\nsock_sendmsg_nosec net/socket.c:724 [inline]\nsock_sendmsg+0xde/0x190 net/socket.c:747\n__sys_sendto+0x23a/0x340 net/socket.c:2142\n__do_sys_sendto net/socket.c:2154 [inline]\n__se_sys_sendto net/socket.c:2150 [inline]\n__x64_sys_sendto+0xe1/0x1b0 net/socket.c:2150\ndo_syscall_x64 arch/x86/entry/common.c:50 [inline]\ndo_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7f123aaa1039\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffc15d12058 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f123aaa1039\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\nRBP: 0000000000000000 R08: 0000000020000040 R09: 0000000000000014\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f123aa648c0\nR13: 431bde82d7b634db R14: 0000000000000000 R15: 0000000000000000",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53053",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49720",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: Fix handling of offline queues in blk_mq_alloc_request_hctx()\n\nThis patch prevents that test nvme/004 triggers the following:\n\nUBSAN: array-index-out-of-bounds in block/blk-mq.h:135:9\nindex 512 is out of range for type 'long unsigned int [512]'\nCall Trace:\n show_stack+0x52/0x58\n dump_stack_lvl+0x49/0x5e\n dump_stack+0x10/0x12\n ubsan_epilogue+0x9/0x3b\n __ubsan_handle_out_of_bounds.cold+0x44/0x49\n blk_mq_alloc_request_hctx+0x304/0x310\n __nvme_submit_sync_cmd+0x70/0x200 [nvme_core]\n nvmf_connect_io_queue+0x23e/0x2a0 [nvme_fabrics]\n nvme_loop_connect_io_queues+0x8d/0xb0 [nvme_loop]\n nvme_loop_create_ctrl+0x58e/0x7d0 [nvme_loop]\n nvmf_create_ctrl+0x1d7/0x4d0 [nvme_fabrics]\n nvmf_dev_write+0xae/0x111 [nvme_fabrics]\n vfs_write+0x144/0x560\n ksys_write+0xb7/0x140\n __x64_sys_write+0x42/0x50\n do_syscall_64+0x35/0x80\n entry_SYSCALL_64_after_hwframe+0x44/0xae",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49720",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47427",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi: Fix iscsi_task use after free\n\nCommit d39df158518c (\"scsi: iscsi: Have abort handler get ref to conn\")\nadded iscsi_get_conn()/iscsi_put_conn() calls during abort handling but\nthen also changed the handling of the case where we detect an already\ncompleted task where we now end up doing a goto to the common put/cleanup\ncode. This results in a iscsi_task use after free, because the common\ncleanup code will do a put on the iscsi_task.\n\nThis reverts the goto and moves the iscsi_get_conn() to after we've checked\nif the iscsi_task is valid.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47427",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-31",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38676",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/amd: Avoid stack buffer overflow from kernel cmdline\n\nWhile the kernel command line is considered trusted in most environments,\navoid writing 1 byte past the end of \"acpiid\" if the \"str\" argument is\nmaximum length.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38676",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-26",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37882",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: xhci: Fix isochronous Ring Underrun/Overrun event handling\n\nThe TRB pointer of these events points at enqueue at the time of error\noccurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time we\nare handling the event, a new TD may be queued at this ring position.\n\nI can trigger this race by rising interrupt moderation to increase IRQ\nhandling delay. Similar delay may occur naturally due to system load.\n\nIf this ever happens after a Missed Service Error, missed TDs will be\nskipped and the new TD processed as if it matched the event. It could\nbe given back prematurely, risking data loss or buffer UAF by the xHC.\n\nDon't complete TDs on xrun events and don't warn if queued TDs don't\nmatch the event's TRB pointer, which can be NULL or a link/no-op TRB.\nDon't warn if there are no queued TDs at all.\n\nNow that it's safe, also handle xrun events if the skip flag is clear.\nThis ensures completion of any TD stuck in 'error mid TD' state right\nbefore the xrun event, which could happen if a driver submits a finite\nnumber of URBs to a buggy HC and then an error occurs on the last TD.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37882",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-09",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52741",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix use-after-free in rdata->read_into_pages()\n\nWhen the network status is unstable, use-after-free may occur when\nread data from the server.\n\n  BUG: KASAN: use-after-free in readpages_fill_pages+0x14c/0x7e0\n\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x38/0x4c\n   print_report+0x16f/0x4a6\n   kasan_report+0xb7/0x130\n   readpages_fill_pages+0x14c/0x7e0\n   cifs_readv_receive+0x46d/0xa40\n   cifs_demultiplex_thread+0x121c/0x1490\n   kthread+0x16b/0x1a0\n   ret_from_fork+0x2c/0x50\n   </TASK>\n\n  Allocated by task 2535:\n   kasan_save_stack+0x22/0x50\n   kasan_set_track+0x25/0x30\n   __kasan_kmalloc+0x82/0x90\n   cifs_readdata_direct_alloc+0x2c/0x110\n   cifs_readdata_alloc+0x2d/0x60\n   cifs_readahead+0x393/0xfe0\n   read_pages+0x12f/0x470\n   page_cache_ra_unbounded+0x1b1/0x240\n   filemap_get_pages+0x1c8/0x9a0\n   filemap_read+0x1c0/0x540\n   cifs_strict_readv+0x21b/0x240\n   vfs_read+0x395/0x4b0\n   ksys_read+0xb8/0x150\n   do_syscall_64+0x3f/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\n  Freed by task 79:\n   kasan_save_stack+0x22/0x50\n   kasan_set_track+0x25/0x30\n   kasan_save_free_info+0x2e/0x50\n   __kasan_slab_free+0x10e/0x1a0\n   __kmem_cache_free+0x7a/0x1a0\n   cifs_readdata_release+0x49/0x60\n   process_one_work+0x46c/0x760\n   worker_thread+0x2a4/0x6f0\n   kthread+0x16b/0x1a0\n   ret_from_fork+0x2c/0x50\n\n  Last potentially related work creation:\n   kasan_save_stack+0x22/0x50\n   __kasan_record_aux_stack+0x95/0xb0\n   insert_work+0x2b/0x130\n   __queue_work+0x1fe/0x660\n   queue_work_on+0x4b/0x60\n   smb2_readv_callback+0x396/0x800\n   cifs_abort_connection+0x474/0x6a0\n   cifs_reconnect+0x5cb/0xa50\n   cifs_readv_from_socket.cold+0x22/0x6c\n   cifs_read_page_from_socket+0xc1/0x100\n   readpages_fill_pages.cold+0x2f/0x46\n   cifs_readv_receive+0x46d/0xa40\n   cifs_demultiplex_thread+0x121c/0x1490\n   kthread+0x16b/0x1a0\n   ret_from_fork+0x2c/0x50\n\nThe following function calls will cause UAF of the rdata pointer.\n\nreadpages_fill_pages\n cifs_read_page_from_socket\n  cifs_readv_from_socket\n   cifs_reconnect\n    __cifs_reconnect\n     cifs_abort_connection\n      mid->callback() --> smb2_readv_callback\n       queue_work(&rdata->work)  # if the worker completes first,\n                                 # the rdata is freed\n          cifs_readv_complete\n            kref_put\n              cifs_readdata_release\n                kfree(rdata)\n return rdata->...               # UAF in readpages_fill_pages()\n\nSimilarly, this problem also occurs in the uncache_fill_pages().\n\nFix this by adjusts the order of condition judgment in the return\nstatement.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52741",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49789",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: zfcp: Fix double free of FSF request when qdio send fails\n\nWe used to use the wrong type of integer in 'zfcp_fsf_req_send()' to cache\nthe FSF request ID when sending a new FSF request. This is used in case the\nsending fails and we need to remove the request from our internal hash\ntable again (so we don't keep an invalid reference and use it when we free\nthe request again).\n\nIn 'zfcp_fsf_req_send()' we used to cache the ID as 'int' (signed and 32\nbit wide), but the rest of the zfcp code (and the firmware specification)\nhandles the ID as 'unsigned long'/'u64' (unsigned and 64 bit wide [s390x\nELF ABI]).  For one this has the obvious problem that when the ID grows\npast 32 bit (this can happen reasonably fast) it is truncated to 32 bit\nwhen storing it in the cache variable and so doesn't match the original ID\nanymore.  The second less obvious problem is that even when the original ID\nhas not yet grown past 32 bit, as soon as the 32nd bit is set in the\noriginal ID (0x80000000 = 2'147'483'648) we will have a mismatch when we\ncast it back to 'unsigned long'. As the cached variable is of a signed\ntype, the compiler will choose a sign-extending instruction to load the 32\nbit variable into a 64 bit register (e.g.: 'lgf %r11,188(%r15)'). So once\nwe pass the cached variable into 'zfcp_reqlist_find_rm()' to remove the\nrequest again all the leading zeros will be flipped to ones to extend the\nsign and won't match the original ID anymore (this has been observed in\npractice).\n\nIf we can't successfully remove the request from the hash table again after\n'zfcp_qdio_send()' fails (this happens regularly when zfcp cannot notify\nthe adapter about new work because the adapter is already gone during\ne.g. a ChpID toggle) we will end up with a double free.  We unconditionally\nfree the request in the calling function when 'zfcp_fsf_req_send()' fails,\nbut because the request is still in the hash table we end up with a stale\nmemory reference, and once the zfcp adapter is either reset during recovery\nor shutdown we end up freeing the same memory twice.\n\nThe resulting stack traces vary depending on the kernel and have no direct\ncorrelation to the place where the bug occurs. Here are three examples that\nhave been seen in practice:\n\n  list_del corruption. next->prev should be 00000001b9d13800, but was 00000000dead4ead. (next=00000001bd131a00)\n  ------------[ cut here ]------------\n  kernel BUG at lib/list_debug.c:62!\n  monitor event: 0040 ilc:2 [#1] PREEMPT SMP\n  Modules linked in: ...\n  CPU: 9 PID: 1617 Comm: zfcperp0.0.1740 Kdump: loaded\n  Hardware name: ...\n  Krnl PSW : 0704d00180000000 00000003cbeea1f8 (__list_del_entry_valid+0x98/0x140)\n             R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 RI:0 EA:3\n  Krnl GPRS: 00000000916d12f1 0000000080000000 000000000000006d 00000003cb665cd6\n             0000000000000001 0000000000000000 0000000000000000 00000000d28d21e8\n             00000000d3844000 00000380099efd28 00000001bd131a00 00000001b9d13800\n             00000000d3290100 0000000000000000 00000003cbeea1f4 00000380099efc70\n  Krnl Code: 00000003cbeea1e8: c020004f68a7        larl    %r2,00000003cc8d7336\n             00000003cbeea1ee: c0e50027fd65        brasl   %r14,00000003cc3e9cb8\n            #00000003cbeea1f4: af000000            mc      0,0\n            >00000003cbeea1f8: c02000920440        larl    %r2,00000003cd12aa78\n             00000003cbeea1fe: c0e500289c25        brasl   %r14,00000003cc3fda48\n             00000003cbeea204: b9040043            lgr     %r4,%r3\n             00000003cbeea208: b9040051            lgr     %r5,%r1\n             00000003cbeea20c: b9040032            lgr     %r3,%r2\n  Call Trace:\n   [<00000003cbeea1f8>] __list_del_entry_valid+0x98/0x140\n  ([<00000003cbeea1f4>] __list_del_entry_valid+0x94/0x140)\n   [<000003ff7ff502fe>] zfcp_fsf_req_dismiss_all+0xde/0x150 [zfcp]\n   [<000003ff7ff49cd0>] zfcp_erp_strategy_do_action+0x160/0x280 [zfcp]\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49789",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49840",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, test_run: Fix alignment problem in bpf_prog_test_run_skb()\n\nWe got a syzkaller problem because of aarch64 alignment fault\nif KFENCE enabled. When the size from user bpf program is an odd\nnumber, like 399, 407, etc, it will cause the struct skb_shared_info's\nunaligned access. As seen below:\n\n  BUG: KFENCE: use-after-free read in __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032\n\n  Use-after-free read at 0xffff6254fffac077 (in kfence-#213):\n   __lse_atomic_add arch/arm64/include/asm/atomic_lse.h:26 [inline]\n   arch_atomic_add arch/arm64/include/asm/atomic.h:28 [inline]\n   arch_atomic_inc include/linux/atomic-arch-fallback.h:270 [inline]\n   atomic_inc include/asm-generic/atomic-instrumented.h:241 [inline]\n   __skb_clone+0x23c/0x2a0 net/core/skbuff.c:1032\n   skb_clone+0xf4/0x214 net/core/skbuff.c:1481\n   ____bpf_clone_redirect net/core/filter.c:2433 [inline]\n   bpf_clone_redirect+0x78/0x1c0 net/core/filter.c:2420\n   bpf_prog_d3839dd9068ceb51+0x80/0x330\n   bpf_dispatcher_nop_func include/linux/bpf.h:728 [inline]\n   bpf_test_run+0x3c0/0x6c0 net/bpf/test_run.c:53\n   bpf_prog_test_run_skb+0x638/0xa7c net/bpf/test_run.c:594\n   bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline]\n   __do_sys_bpf kernel/bpf/syscall.c:4441 [inline]\n   __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381\n\n  kfence-#213: 0xffff6254fffac000-0xffff6254fffac196, size=407, cache=kmalloc-512\n\n  allocated by task 15074 on cpu 0 at 1342.585390s:\n   kmalloc include/linux/slab.h:568 [inline]\n   kzalloc include/linux/slab.h:675 [inline]\n   bpf_test_init.isra.0+0xac/0x290 net/bpf/test_run.c:191\n   bpf_prog_test_run_skb+0x11c/0xa7c net/bpf/test_run.c:512\n   bpf_prog_test_run kernel/bpf/syscall.c:3148 [inline]\n   __do_sys_bpf kernel/bpf/syscall.c:4441 [inline]\n   __se_sys_bpf+0xad0/0x1634 kernel/bpf/syscall.c:4381\n   __arm64_sys_bpf+0x50/0x60 kernel/bpf/syscall.c:4381\n\nTo fix the problem, we adjust @size so that (@size + @hearoom) is a\nmultiple of SMP_CACHE_BYTES. So we make sure the struct skb_shared_info\nis aligned to a cache line.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49840",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53395",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Add AML_NO_OPERAND_RESOLVE flag to Timer\n\nACPICA commit 90310989a0790032f5a0140741ff09b545af4bc5\n\nAccording to the ACPI specification 19.6.134, no argument is required to be passed for ASL Timer instruction. For taking care of no argument, AML_NO_OPERAND_RESOLVE flag is added to ASL Timer instruction opcode.\n\nWhen ASL timer instruction interpreted by ACPI interpreter, getting error. After adding AML_NO_OPERAND_RESOLVE flag to ASL Timer instruction opcode, issue is not observed.\n\n=============================================================\nUBSAN: array-index-out-of-bounds in acpica/dswexec.c:401:12 index -1 is out of range for type 'union acpi_operand_object *[9]'\nCPU: 37 PID: 1678 Comm: cat Not tainted\n6.0.0-dev-th500-6.0.y-1+bcf8c46459e407-generic-64k\nHW name: NVIDIA BIOS v1.1.1-d7acbfc-dirty 12/19/2022 Call trace:\n dump_backtrace+0xe0/0x130\n show_stack+0x20/0x60\n dump_stack_lvl+0x68/0x84\n dump_stack+0x18/0x34\n ubsan_epilogue+0x10/0x50\n __ubsan_handle_out_of_bounds+0x80/0x90\n acpi_ds_exec_end_op+0x1bc/0x6d8\n acpi_ps_parse_loop+0x57c/0x618\n acpi_ps_parse_aml+0x1e0/0x4b4\n acpi_ps_execute_method+0x24c/0x2b8\n acpi_ns_evaluate+0x3a8/0x4bc\n acpi_evaluate_object+0x15c/0x37c\n acpi_evaluate_integer+0x54/0x15c\n show_power+0x8c/0x12c [acpi_power_meter]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53395",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39863",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info work\n\nThe brcmf_btcoex_detach() only shuts down the btcoex timer, if the\nflag timer_on is false. However, the brcmf_btcoex_timerfunc(), which\nruns as timer handler, sets timer_on to false. This creates critical\nrace conditions:\n\n1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc()\nis executing, it may observe timer_on as false and skip the call to\ntimer_shutdown_sync().\n\n2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_info\nworker after the cancel_work_sync() has been executed, resulting in\nuse-after-free bugs.\n\nThe use-after-free bugs occur in two distinct scenarios, depending on\nthe timing of when the brcmf_btcoex_info struct is freed relative to\nthe execution of its worker thread.\n\nScenario 1: Freed before the worker is scheduled\n\nThe brcmf_btcoex_info is deallocated before the worker is scheduled.\nA race condition can occur when schedule_work(&bt_local->work) is\ncalled after the target memory has been freed. The sequence of events\nis detailed below:\n\nCPU0                           | CPU1\nbrcmf_btcoex_detach            | brcmf_btcoex_timerfunc\n                               |   bt_local->timer_on = false;\n  if (cfg->btcoex->timer_on)   |\n    ...                        |\n  cancel_work_sync();          |\n  ...                          |\n  kfree(cfg->btcoex); // FREE  |\n                               |   schedule_work(&bt_local->work); // USE\n\nScenario 2: Freed after the worker is scheduled\n\nThe brcmf_btcoex_info is freed after the worker has been scheduled\nbut before or during its execution. In this case, statements within\nthe brcmf_btcoex_handler() \u2014 such as the container_of macro and\nsubsequent dereferences of the brcmf_btcoex_info object will cause\na use-after-free access. The following timeline illustrates this\nscenario:\n\nCPU0                            | CPU1\nbrcmf_btcoex_detach             | brcmf_btcoex_timerfunc\n                                |   bt_local->timer_on = false;\n  if (cfg->btcoex->timer_on)    |\n    ...                         |\n  cancel_work_sync();           |\n  ...                           |   schedule_work(); // Reschedule\n                                |\n  kfree(cfg->btcoex); // FREE   |   brcmf_btcoex_handler() // Worker\n  /*                            |     btci = container_of(....); // USE\n   The kfree() above could      |     ...\n   also occur at any point      |     btci-> // USE\n   during the worker's execution|\n   */                           |\n\nTo resolve the race conditions, drop the conditional check and call\ntimer_shutdown_sync() directly. It can deactivate the timer reliably,\nregardless of its current state. Once stopped, the timer_on state is\nthen set to false.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39863",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-19",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47566",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nproc/vmcore: fix clearing user buffer by properly using clear_user()\n\nTo clear a user buffer we cannot simply use memset, we have to use\nclear_user().  With a virtio-mem device that registers a vmcore_cb and\nhas some logically unplugged memory inside an added Linux memory block,\nI can easily trigger a BUG by copying the vmcore via \"cp\":\n\n  systemd[1]: Starting Kdump Vmcore Save Service...\n  kdump[420]: Kdump is using the default log level(3).\n  kdump[453]: saving to /sysroot/var/crash/127.0.0.1-2021-11-11-14:59:22/\n  kdump[458]: saving vmcore-dmesg.txt to /sysroot/var/crash/127.0.0.1-2021-11-11-14:59:22/\n  kdump[465]: saving vmcore-dmesg.txt complete\n  kdump[467]: saving vmcore\n  BUG: unable to handle page fault for address: 00007f2374e01000\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0003) - permissions violation\n  PGD 7a523067 P4D 7a523067 PUD 7a528067 PMD 7a525067 PTE 800000007048f867\n  Oops: 0003 [#1] PREEMPT SMP NOPTI\n  CPU: 0 PID: 468 Comm: cp Not tainted 5.15.0+ #6\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.14.0-27-g64f37cc530f1-prebuilt.qemu.org 04/01/2014\n  RIP: 0010:read_from_oldmem.part.0.cold+0x1d/0x86\n  Code: ff ff ff e8 05 ff fe ff e9 b9 e9 7f ff 48 89 de 48 c7 c7 38 3b 60 82 e8 f1 fe fe ff 83 fd 08 72 3c 49 8d 7d 08 4c 89 e9 89 e8 <49> c7 45 00 00 00 00 00 49 c7 44 05 f8 00 00 00 00 48 83 e7 f81\n  RSP: 0018:ffffc9000073be08 EFLAGS: 00010212\n  RAX: 0000000000001000 RBX: 00000000002fd000 RCX: 00007f2374e01000\n  RDX: 0000000000000001 RSI: 00000000ffffdfff RDI: 00007f2374e01008\n  RBP: 0000000000001000 R08: 0000000000000000 R09: ffffc9000073bc50\n  R10: ffffc9000073bc48 R11: ffffffff829461a8 R12: 000000000000f000\n  R13: 00007f2374e01000 R14: 0000000000000000 R15: ffff88807bd421e8\n  FS:  00007f2374e12140(0000) GS:ffff88807f000000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f2374e01000 CR3: 000000007a4aa000 CR4: 0000000000350eb0\n  Call Trace:\n   read_vmcore+0x236/0x2c0\n   proc_reg_read+0x55/0xa0\n   vfs_read+0x95/0x190\n   ksys_read+0x4f/0xc0\n   do_syscall_64+0x3b/0x90\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nSome x86-64 CPUs have a CPU feature called \"Supervisor Mode Access\nPrevention (SMAP)\", which is used to detect wrong access from the kernel\nto user buffers like this: SMAP triggers a permissions violation on\nwrong access.  In the x86-64 variant of clear_user(), SMAP is properly\nhandled via clac()+stac().\n\nTo fix, properly use clear_user() when we're dealing with a user buffer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47566",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-09-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48694",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/irdma: Fix drain SQ hang with no completion\n\nSW generated completions for outstanding WRs posted on SQ\nafter QP is in error target the wrong CQ. This causes the\nib_drain_sq to hang with no completion.\n\nFix this to generate completions on the right CQ.\n\n[  863.969340] INFO: task kworker/u52:2:671 blocked for more than 122 seconds.\n[  863.979224]       Not tainted 5.14.0-130.el9.x86_64 #1\n[  863.986588] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n[  863.996997] task:kworker/u52:2   state:D stack:    0 pid:  671 ppid:     2 flags:0x00004000\n[  864.007272] Workqueue: xprtiod xprt_autoclose [sunrpc]\n[  864.014056] Call Trace:\n[  864.017575]  __schedule+0x206/0x580\n[  864.022296]  schedule+0x43/0xa0\n[  864.026736]  schedule_timeout+0x115/0x150\n[  864.032185]  __wait_for_common+0x93/0x1d0\n[  864.037717]  ? usleep_range_state+0x90/0x90\n[  864.043368]  __ib_drain_sq+0xf6/0x170 [ib_core]\n[  864.049371]  ? __rdma_block_iter_next+0x80/0x80 [ib_core]\n[  864.056240]  ib_drain_sq+0x66/0x70 [ib_core]\n[  864.062003]  rpcrdma_xprt_disconnect+0x82/0x3b0 [rpcrdma]\n[  864.069365]  ? xprt_prepare_transmit+0x5d/0xc0 [sunrpc]\n[  864.076386]  xprt_rdma_close+0xe/0x30 [rpcrdma]\n[  864.082593]  xprt_autoclose+0x52/0x100 [sunrpc]\n[  864.088718]  process_one_work+0x1e8/0x3c0\n[  864.094170]  worker_thread+0x50/0x3b0\n[  864.099109]  ? rescuer_thread+0x370/0x370\n[  864.104473]  kthread+0x149/0x170\n[  864.109022]  ? set_kthread_struct+0x40/0x40\n[  864.114713]  ret_from_fork+0x22/0x30",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48694",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-52475",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: powermate - fix use-after-free in powermate_config_complete\n\nsyzbot has found a use-after-free bug [1] in the powermate driver. This\nhappens when the device is disconnected, which leads to a memory free from\nthe powermate_device struct.  When an asynchronous control message\ncompletes after the kfree and its callback is invoked, the lock does not\nexist anymore and hence the bug.\n\nUse usb_kill_urb() on pm->config to cancel any in-progress requests upon\ndevice disconnection.\n\n[1] https://syzkaller.appspot.com/bug?extid=0434ac83f907a1dbdd1e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52475",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-29",
                    "modification_date": "2024-12-09",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-37789",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: fix nested key length validation in the set() action\n\nIt's not safe to access nla_len(ovs_key) if the data is smaller than\nthe netlink header.  Check that the attribute is OK first.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37789",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53340",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Collect command failures data only for known commands\n\nDEVX can issue a general command, which is not used by mlx5 driver.\nIn case such command is failed, mlx5 is trying to collect the failure\ndata, However, mlx5 doesn't create a storage for this command, since\nmlx5 doesn't use it. This lead to array-index-out-of-bounds error.\n\nFix it by checking whether the command is known before collecting the\nfailure data.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53340",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-17",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50209",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/bnxt_re: Add a check for memory allocation\n\n__alloc_pbl() can return error when memory allocation fails.\nDriver is not checking the status on one of the instances.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50209",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-08",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47701",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid OOB when system.data xattr changes underneath the filesystem\n\nWhen looking up for an entry in an inlined directory, if e_value_offs is\nchanged underneath the filesystem by some change in the block device, it\nwill lead to an out-of-bounds access that KASAN detects as an UAF.\n\nEXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 r/w without journal. Quota mode: none.\nloop0: detected capacity change from 2048 to 2047\n==================================================================\nBUG: KASAN: use-after-free in ext4_search_dir+0xf2/0x1c0 fs/ext4/namei.c:1500\nRead of size 1 at addr ffff88803e91130f by task syz-executor269/5103\n\nCPU: 0 UID: 0 PID: 5103 Comm: syz-executor269 Not tainted 6.11.0-rc4-syzkaller #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n ext4_search_dir+0xf2/0x1c0 fs/ext4/namei.c:1500\n ext4_find_inline_entry+0x4be/0x5e0 fs/ext4/inline.c:1697\n __ext4_find_entry+0x2b4/0x1b30 fs/ext4/namei.c:1573\n ext4_lookup_entry fs/ext4/namei.c:1727 [inline]\n ext4_lookup+0x15f/0x750 fs/ext4/namei.c:1795\n lookup_one_qstr_excl+0x11f/0x260 fs/namei.c:1633\n filename_create+0x297/0x540 fs/namei.c:3980\n do_symlinkat+0xf9/0x3a0 fs/namei.c:4587\n __do_sys_symlinkat fs/namei.c:4610 [inline]\n __se_sys_symlinkat fs/namei.c:4607 [inline]\n __x64_sys_symlinkat+0x95/0xb0 fs/namei.c:4607\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f3e73ced469\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 21 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fff4d40c258 EFLAGS: 00000246 ORIG_RAX: 000000000000010a\nRAX: ffffffffffffffda RBX: 0032656c69662f2e RCX: 00007f3e73ced469\nRDX: 0000000020000200 RSI: 00000000ffffff9c RDI: 00000000200001c0\nRBP: 0000000000000000 R08: 00007fff4d40c290 R09: 00007fff4d40c290\nR10: 0023706f6f6c2f76 R11: 0000000000000246 R12: 00007fff4d40c27c\nR13: 0000000000000003 R14: 431bde82d7b634db R15: 00007fff4d40c2b0\n </TASK>\n\nCalling ext4_xattr_ibody_find right after reading the inode with\next4_get_inode_loc will lead to a check of the validity of the xattrs,\navoiding this problem.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47701",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40277",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/vmwgfx: Validate command header size against SVGA_CMD_MAX_DATASIZE\n\nThis data originates from userspace and is used in buffer offset\ncalculations which could potentially overflow causing an out-of-bounds\naccess.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-06",
                    "modification_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56604",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc()\n\nbt_sock_alloc() attaches allocated sk object to the provided sock object.\nIf rfcomm_dlc_alloc() fails, we release the sk object, but leave the\ndangling pointer in the sock object, which may cause use-after-free.\n\nFix this by swapping calls to bt_sock_alloc() and rfcomm_dlc_alloc().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56604",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50021",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: block range must be validated before use in ext4_mb_clear_bb()\n\nBlock range to free is validated in ext4_free_blocks() using\next4_inode_block_valid() and then it's passed to ext4_mb_clear_bb().\nHowever in some situations on bigalloc file system the range might be\nadjusted after the validation in ext4_free_blocks() which can lead to\ntroubles on corrupted file systems such as one found by syzkaller that\nresulted in the following BUG\n\nkernel BUG at fs/ext4/ext4.h:3319!\nPREEMPT SMP NOPTI\nCPU: 28 PID: 4243 Comm: repro Kdump: loaded Not tainted 5.19.0-rc6+ #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1.fc35 04/01/2014\nRIP: 0010:ext4_free_blocks+0x95e/0xa90\nCall Trace:\n <TASK>\n ? lock_timer_base+0x61/0x80\n ? __es_remove_extent+0x5a/0x760\n ? __mod_timer+0x256/0x380\n ? ext4_ind_truncate_ensure_credits+0x90/0x220\n ext4_clear_blocks+0x107/0x1b0\n ext4_free_data+0x15b/0x170\n ext4_ind_truncate+0x214/0x2c0\n ? _raw_spin_unlock+0x15/0x30\n ? ext4_discard_preallocations+0x15a/0x410\n ? ext4_journal_check_start+0xe/0x90\n ? __ext4_journal_start_sb+0x2f/0x110\n ext4_truncate+0x1b5/0x460\n ? __ext4_journal_start_sb+0x2f/0x110\n ext4_evict_inode+0x2b4/0x6f0\n evict+0xd0/0x1d0\n ext4_enable_quotas+0x11f/0x1f0\n ext4_orphan_cleanup+0x3de/0x430\n ? proc_create_seq_private+0x43/0x50\n ext4_fill_super+0x295f/0x3ae0\n ? snprintf+0x39/0x40\n ? sget_fc+0x19c/0x330\n ? ext4_reconfigure+0x850/0x850\n get_tree_bdev+0x16d/0x260\n vfs_get_tree+0x25/0xb0\n path_mount+0x431/0xa70\n __x64_sys_mount+0xe2/0x120\n do_syscall_64+0x5b/0x80\n ? do_user_addr_fault+0x1e2/0x670\n ? exc_page_fault+0x70/0x170\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\nRIP: 0033:0x7fdf4e512ace\n\nFix it by making sure that the block range is properly validated before\nused every time it changes in ext4_free_blocks() or ext4_mb_clear_bb().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50021",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-13",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53103",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhv_sock: Initializing vsk->trans to NULL to prevent a dangling pointer\n\nWhen hvs is released, there is a possibility that vsk->trans may not\nbe initialized to NULL, which could lead to a dangling pointer.\nThis issue is resolved by initializing vsk->trans to NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53103",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-02",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-39494",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nima: Fix use-after-free on a dentry's dname.name\n\n->d_name.name can change on rename and the earlier value can be freed;\nthere are conditions sufficient to stabilize it (->d_lock on dentry,\n->d_lock on its parent, ->i_rwsem exclusive on the parent's inode,\nrename_lock), but none of those are met at any of the sites. Take a stable\nsnapshot of the name instead.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-39494",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-12",
                    "modification_date": "2026-01-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40258",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix race condition in mptcp_schedule_work()\n\nsyzbot reported use-after-free in mptcp_schedule_work() [1]\n\nIssue here is that mptcp_schedule_work() schedules a work,\nthen gets a refcount on sk->sk_refcnt if the work was scheduled.\nThis refcount will be released by mptcp_worker().\n\n[A] if (schedule_work(...)) {\n[B]     sock_hold(sk);\n        return true;\n    }\n\nProblem is that mptcp_worker() can run immediately and complete before [B]\n\nWe need instead :\n\n    sock_hold(sk);\n    if (schedule_work(...))\n        return true;\n    sock_put(sk);\n\n[1]\nrefcount_t: addition on 0; use-after-free.\n WARNING: CPU: 1 PID: 29 at lib/refcount.c:25 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:25\nCall Trace:\n <TASK>\n __refcount_add include/linux/refcount.h:-1 [inline]\n  __refcount_inc include/linux/refcount.h:366 [inline]\n  refcount_inc include/linux/refcount.h:383 [inline]\n  sock_hold include/net/sock.h:816 [inline]\n  mptcp_schedule_work+0x164/0x1a0 net/mptcp/protocol.c:943\n  mptcp_tout_timer+0x21/0xa0 net/mptcp/protocol.c:2316\n  call_timer_fn+0x17e/0x5f0 kernel/time/timer.c:1747\n  expire_timers kernel/time/timer.c:1798 [inline]\n  __run_timers kernel/time/timer.c:2372 [inline]\n  __run_timer_base+0x648/0x970 kernel/time/timer.c:2384\n  run_timer_base kernel/time/timer.c:2393 [inline]\n  run_timer_softirq+0xb7/0x180 kernel/time/timer.c:2403\n  handle_softirqs+0x22f/0x710 kernel/softirq.c:622\n  __do_softirq kernel/softirq.c:656 [inline]\n  run_ktimerd+0xcf/0x190 kernel/softirq.c:1138\n  smpboot_thread_fn+0x542/0xa60 kernel/smpboot.c:160\n  kthread+0x711/0x8a0 kernel/kthread.c:463\n  ret_from_fork+0x4bc/0x870 arch/x86/kernel/process.c:158\n  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53095",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: Fix use-after-free of network namespace.\n\nRecently, we got a customer report that CIFS triggers oops while\nreconnecting to a server.  [0]\n\nThe workload runs on Kubernetes, and some pods mount CIFS servers\nin non-root network namespaces.  The problem rarely happened, but\nit was always while the pod was dying.\n\nThe root cause is wrong reference counting for network namespace.\n\nCIFS uses kernel sockets, which do not hold refcnt of the netns that\nthe socket belongs to.  That means CIFS must ensure the socket is\nalways freed before its netns; otherwise, use-after-free happens.\n\nThe repro steps are roughly:\n\n  1. mount CIFS in a non-root netns\n  2. drop packets from the netns\n  3. destroy the netns\n  4. unmount CIFS\n\nWe can reproduce the issue quickly with the script [1] below and see\nthe splat [2] if CONFIG_NET_NS_REFCNT_TRACKER is enabled.\n\nWhen the socket is TCP, it is hard to guarantee the netns lifetime\nwithout holding refcnt due to async timers.\n\nLet's hold netns refcnt for each socket as done for SMC in commit\n9744d2bf1976 (\"smc: Fix use-after-free in tcp_write_timer_handler().\").\n\nNote that we need to move put_net() from cifs_put_tcp_session() to\nclean_demultiplex_info(); otherwise, __sock_create() still could touch a\nfreed netns while cifsd tries to reconnect from cifs_demultiplex_thread().\n\nAlso, maybe_get_net() cannot be put just before __sock_create() because\nthe code is not under RCU and there is a small chance that the same\naddress happened to be reallocated to another netns.\n\n[0]:\nCIFS: VFS: \\\\XXXXXXXXXXX has not responded in 15 seconds. Reconnecting...\nCIFS: Serverclose failed 4 times, giving up\nUnable to handle kernel paging request at virtual address 14de99e461f84a07\nMem abort info:\n  ESR = 0x0000000096000004\n  EC = 0x25: DABT (current EL), IL = 32 bits\n  SET = 0, FnV = 0\n  EA = 0, S1PTW = 0\n  FSC = 0x04: level 0 translation fault\nData abort info:\n  ISV = 0, ISS = 0x00000004\n  CM = 0, WnR = 0\n[14de99e461f84a07] address between user and kernel address ranges\nInternal error: Oops: 0000000096000004 [#1] SMP\nModules linked in: cls_bpf sch_ingress nls_utf8 cifs cifs_arc4 cifs_md4 dns_resolver tcp_diag inet_diag veth xt_state xt_connmark nf_conntrack_netlink xt_nat xt_statistic xt_MASQUERADE xt_mark xt_addrtype ipt_REJECT nf_reject_ipv4 nft_chain_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xt_comment nft_compat nf_tables nfnetlink overlay nls_ascii nls_cp437 sunrpc vfat fat aes_ce_blk aes_ce_cipher ghash_ce sm4_ce_cipher sm4 sm3_ce sm3 sha3_ce sha512_ce sha512_arm64 sha1_ce ena button sch_fq_codel loop fuse configfs dmi_sysfs sha2_ce sha256_arm64 dm_mirror dm_region_hash dm_log dm_mod dax efivarfs\nCPU: 5 PID: 2690970 Comm: cifsd Not tainted 6.1.103-109.184.amzn2023.aarch64 #1\nHardware name: Amazon EC2 r7g.4xlarge/, BIOS 1.0 11/1/2018\npstate: 00400005 (nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : fib_rules_lookup+0x44/0x238\nlr : __fib_lookup+0x64/0xbc\nsp : ffff8000265db790\nx29: ffff8000265db790 x28: 0000000000000000 x27: 000000000000bd01\nx26: 0000000000000000 x25: ffff000b4baf8000 x24: ffff00047b5e4580\nx23: ffff8000265db7e0 x22: 0000000000000000 x21: ffff00047b5e4500\nx20: ffff0010e3f694f8 x19: 14de99e461f849f7 x18: 0000000000000000\nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\nx14: 0000000000000000 x13: 0000000000000000 x12: 3f92800abd010002\nx11: 0000000000000001 x10: ffff0010e3f69420 x9 : ffff800008a6f294\nx8 : 0000000000000000 x7 : 0000000000000006 x6 : 0000000000000000\nx5 : 0000000000000001 x4 : ffff001924354280 x3 : ffff8000265db7e0\nx2 : 0000000000000000 x1 : ffff0010e3f694f8 x0 : ffff00047b5e4500\nCall trace:\n fib_rules_lookup+0x44/0x238\n __fib_lookup+0x64/0xbc\n ip_route_output_key_hash_rcu+0x2c4/0x398\n ip_route_output_key_hash+0x60/0x8c\n tcp_v4_connect+0x290/0x488\n __inet_stream_connect+0x108/0x3d0\n inet_stream_connect+0x50/0x78\n kernel_connect+0x6c/0xac\n generic_ip_conne\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53095",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-21",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21760",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nndisc: extend RCU protection in ndisc_send_skb()\n\nndisc_send_skb() can be called without RTNL or RCU held.\n\nAcquire rcu_read_lock() earlier, so that we can use dev_net_rcu()\nand avoid a potential UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21760",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49647",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncgroup: Use separate src/dst nodes when preloading css_sets for migration\n\nEach cset (css_set) is pinned by its tasks. When we're moving tasks around\nacross csets for a migration, we need to hold the source and destination\ncsets to ensure that they don't go away while we're moving tasks about. This\nis done by linking cset->mg_preload_node on either the\nmgctx->preloaded_src_csets or mgctx->preloaded_dst_csets list. Using the\nsame cset->mg_preload_node for both the src and dst lists was deemed okay as\na cset can't be both the source and destination at the same time.\n\nUnfortunately, this overloading becomes problematic when multiple tasks are\ninvolved in a migration and some of them are identity noop migrations while\nothers are actually moving across cgroups. For example, this can happen with\nthe following sequence on cgroup1:\n\n #1> mkdir -p /sys/fs/cgroup/misc/a/b\n #2> echo $$ > /sys/fs/cgroup/misc/a/cgroup.procs\n #3> RUN_A_COMMAND_WHICH_CREATES_MULTIPLE_THREADS &\n #4> PID=$!\n #5> echo $PID > /sys/fs/cgroup/misc/a/b/tasks\n #6> echo $PID > /sys/fs/cgroup/misc/a/cgroup.procs\n\nthe process including the group leader back into a. In this final migration,\nnon-leader threads would be doing identity migration while the group leader\nis doing an actual one.\n\nAfter #3, let's say the whole process was in cset A, and that after #4, the\nleader moves to cset B. Then, during #6, the following happens:\n\n 1. cgroup_migrate_add_src() is called on B for the leader.\n\n 2. cgroup_migrate_add_src() is called on A for the other threads.\n\n 3. cgroup_migrate_prepare_dst() is called. It scans the src list.\n\n 4. It notices that B wants to migrate to A, so it tries to A to the dst\n    list but realizes that its ->mg_preload_node is already busy.\n\n 5. and then it notices A wants to migrate to A as it's an identity\n    migration, it culls it by list_del_init()'ing its ->mg_preload_node and\n    putting references accordingly.\n\n 6. The rest of migration takes place with B on the src list but nothing on\n    the dst list.\n\nThis means that A isn't held while migration is in progress. If all tasks\nleave A before the migration finishes and the incoming task pins it, the\ncset will be destroyed leading to use-after-free.\n\nThis is caused by overloading cset->mg_preload_node for both src and dst\npreload lists. We wanted to exclude the cset from the src list but ended up\ninadvertently excluding it from the dst list too.\n\nThis patch fixes the issue by separating out cset->mg_preload_node into\n->mg_src_preload_node and ->mg_dst_preload_node, so that the src and dst\npreloadings don't interfere with each other.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49647",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49975",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Don't redirect packets with invalid pkt_len\n\nSyzbot found an issue [1]: fq_codel_drop() try to drop a flow whitout any\nskbs, that is, the flow->head is null.\nThe root cause, as the [2] says, is because that bpf_prog_test_run_skb()\nrun a bpf prog which redirects empty skbs.\nSo we should determine whether the length of the packet modified by bpf\nprog or others like bpf_prog_test is valid before forwarding it directly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49975",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-13",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48783",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: lantiq_gswip: fix use after free in gswip_remove()\n\nof_node_put(priv->ds->slave_mii_bus->dev.of_node) should be\ndone before mdiobus_free(priv->ds->slave_mii_bus).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48783",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21791",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvrf: use RCU protection in l3mdev_l3_out()\n\nl3mdev_l3_out() can be called without RCU being held:\n\nraw_sendmsg()\n ip_push_pending_frames()\n  ip_send_skb()\n   ip_local_out()\n    __ip_local_out()\n     l3mdev_ip_out()\n\nAdd rcu_read_lock() / rcu_read_unlock() pair to avoid\na potential UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21791",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38118",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: MGMT: Fix UAF on mgmt_remove_adv_monitor_complete\n\nThis reworks MGMT_OP_REMOVE_ADV_MONITOR to not use mgmt_pending_add to\navoid crashes like bellow:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_complete+0xe5/0x540 net/bluetooth/mgmt.c:5406\nRead of size 8 at addr ffff88801c53f318 by task kworker/u5:5/5341\n\nCPU: 0 UID: 0 PID: 5341 Comm: kworker/u5:5 Not tainted 6.15.0-syzkaller-10402-g4cb6c8af8591 #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nWorkqueue: hci0 hci_cmd_sync_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xd2/0x2b0 mm/kasan/report.c:521\n kasan_report+0x118/0x150 mm/kasan/report.c:634\n mgmt_remove_adv_monitor_complete+0xe5/0x540 net/bluetooth/mgmt.c:5406\n hci_cmd_sync_work+0x261/0x3a0 net/bluetooth/hci_sync.c:334\n process_one_work kernel/workqueue.c:3238 [inline]\n process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3321\n worker_thread+0x8a0/0xda0 kernel/workqueue.c:3402\n kthread+0x711/0x8a0 kernel/kthread.c:464\n ret_from_fork+0x3fc/0x770 arch/x86/kernel/process.c:148\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n </TASK>\n\nAllocated by task 5987:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4358\n kmalloc_noprof include/linux/slab.h:905 [inline]\n kzalloc_noprof include/linux/slab.h:1039 [inline]\n mgmt_pending_new+0x65/0x240 net/bluetooth/mgmt_util.c:252\n mgmt_pending_add+0x34/0x120 net/bluetooth/mgmt_util.c:279\n remove_adv_monitor+0x103/0x1b0 net/bluetooth/mgmt.c:5454\n hci_mgmt_cmd+0x9c9/0xef0 net/bluetooth/hci_sock.c:1719\n hci_sock_sendmsg+0x6ca/0xef0 net/bluetooth/hci_sock.c:1839\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg+0x219/0x270 net/socket.c:727\n sock_write_iter+0x258/0x330 net/socket.c:1131\n new_sync_write fs/read_write.c:593 [inline]\n vfs_write+0x548/0xa90 fs/read_write.c:686\n ksys_write+0x145/0x250 fs/read_write.c:738\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 5989:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x46/0x50 mm/kasan/generic.c:576\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x62/0x70 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2380 [inline]\n slab_free mm/slub.c:4642 [inline]\n kfree+0x18e/0x440 mm/slub.c:4841\n mgmt_pending_foreach+0xc9/0x120 net/bluetooth/mgmt_util.c:242\n mgmt_index_removed+0x10d/0x2f0 net/bluetooth/mgmt.c:9366\n hci_sock_bind+0xbe9/0x1000 net/bluetooth/hci_sock.c:1314\n __sys_bind_socket net/socket.c:1810 [inline]\n __sys_bind+0x2c3/0x3e0 net/socket.c:1841\n __do_sys_bind net/socket.c:1846 [inline]\n __se_sys_bind net/socket.c:1844 [inline]\n __x64_sys_bind+0x7a/0x90 net/socket.c:1844\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38118",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48943",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/mmu: make apf token non-zero to fix bug\n\nIn current async pagefault logic, when a page is ready, KVM relies on\nkvm_arch_can_dequeue_async_page_present() to determine whether to deliver\na READY event to the Guest. This function test token value of struct\nkvm_vcpu_pv_apf_data, which must be reset to zero by Guest kernel when a\nREADY event is finished by Guest. If value is zero meaning that a READY\nevent is done, so the KVM can deliver another.\nBut the kvm_arch_setup_async_pf() may produce a valid token with zero\nvalue, which is confused with previous mention and may lead the loss of\nthis READY event.\n\nThis bug may cause task blocked forever in Guest:\n INFO: task stress:7532 blocked for more than 1254 seconds.\n       Not tainted 5.10.0 #16\n \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n task:stress          state:D stack:    0 pid: 7532 ppid:  1409\n flags:0x00000080\n Call Trace:\n  __schedule+0x1e7/0x650\n  schedule+0x46/0xb0\n  kvm_async_pf_task_wait_schedule+0xad/0xe0\n  ? exit_to_user_mode_prepare+0x60/0x70\n  __kvm_handle_async_pf+0x4f/0xb0\n  ? asm_exc_page_fault+0x8/0x30\n  exc_page_fault+0x6f/0x110\n  ? asm_exc_page_fault+0x8/0x30\n  asm_exc_page_fault+0x1e/0x30\n RIP: 0033:0x402d00\n RSP: 002b:00007ffd31912500 EFLAGS: 00010206\n RAX: 0000000000071000 RBX: ffffffffffffffff RCX: 00000000021a32b0\n RDX: 000000000007d011 RSI: 000000000007d000 RDI: 00000000021262b0\n RBP: 00000000021262b0 R08: 0000000000000003 R09: 0000000000000086\n R10: 00000000000000eb R11: 00007fefbdf2baa0 R12: 0000000000000000\n R13: 0000000000000002 R14: 000000000007d000 R15: 0000000000001000",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48943",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-40956",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: Fix possible Use-After-Free in irq_process_work_list\n\nUse list_for_each_entry_safe() to allow iterating through the list and\ndeleting the entry in the iteration process. The descriptor is freed via\nidxd_desc_complete() and there's a slight chance may cause issue for\nthe list iterator when the descriptor is reused by another thread\nwithout it being deleted from the list.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-40956",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-12",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21700",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: Disallow replacing of child qdisc from one parent to another\n\nLion Ackermann was able to create a UAF which can be abused for privilege\nescalation with the following script\n\nStep 1. create root qdisc\ntc qdisc add dev lo root handle 1:0 drr\n\nstep2. a class for packet aggregation do demonstrate uaf\ntc class add dev lo classid 1:1 drr\n\nstep3. a class for nesting\ntc class add dev lo classid 1:2 drr\n\nstep4. a class to graft qdisc to\ntc class add dev lo classid 1:3 drr\n\nstep5.\ntc qdisc add dev lo parent 1:1 handle 2:0 plug limit 1024\n\nstep6.\ntc qdisc add dev lo parent 1:2 handle 3:0 drr\n\nstep7.\ntc class add dev lo classid 3:1 drr\n\nstep 8.\ntc qdisc add dev lo parent 3:1 handle 4:0 pfifo\n\nstep 9. Display the class/qdisc layout\n\ntc class ls dev lo\n class drr 1:1 root leaf 2: quantum 64Kb\n class drr 1:2 root leaf 3: quantum 64Kb\n class drr 3:1 root leaf 4: quantum 64Kb\n\ntc qdisc ls\n qdisc drr 1: dev lo root refcnt 2\n qdisc plug 2: dev lo parent 1:1\n qdisc pfifo 4: dev lo parent 3:1 limit 1000p\n qdisc drr 3: dev lo parent 1:2\n\nstep10. trigger the bug <=== prevented by this patch\ntc qdisc replace dev lo parent 1:3 handle 4:0\n\nstep 11. Redisplay again the qdiscs/classes\n\ntc class ls dev lo\n class drr 1:1 root leaf 2: quantum 64Kb\n class drr 1:2 root leaf 3: quantum 64Kb\n class drr 1:3 root leaf 4: quantum 64Kb\n class drr 3:1 root leaf 4: quantum 64Kb\n\ntc qdisc ls\n qdisc drr 1: dev lo root refcnt 2\n qdisc plug 2: dev lo parent 1:1\n qdisc pfifo 4: dev lo parent 3:1 refcnt 2 limit 1000p\n qdisc drr 3: dev lo parent 1:2\n\nObserve that a) parent for 4:0 does not change despite the replace request.\nThere can only be one parent.  b) refcount has gone up by two for 4:0 and\nc) both class 1:3 and 3:1 are pointing to it.\n\nStep 12.  send one packet to plug\necho \"\" | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888,priority=$((0x10001))\nstep13.  send one packet to the grafted fifo\necho \"\" | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888,priority=$((0x10003))\n\nstep14. lets trigger the uaf\ntc class delete dev lo classid 1:3\ntc class delete dev lo classid 1:1\n\nThe semantics of \"replace\" is for a del/add _on the same node_ and not\na delete from one node(3:1) and add to another node (1:3) as in step10.\nWhile we could \"fix\" with a more complex approach there could be\nconsequences to expectations so the patch takes the preventive approach of\n\"disallow such config\".\n\nJoint work with Lion Ackermann <nnamrec@gmail.com>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21700",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-13",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53179",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: fix use-after-free of signing key\n\nCustomers have reported use-after-free in @ses->auth_key.response with\nSMB2.1 + sign mounts which occurs due to following race:\n\ntask A                         task B\ncifs_mount()\n dfs_mount_share()\n  get_session()\n   cifs_mount_get_session()    cifs_send_recv()\n    cifs_get_smb_ses()          compound_send_recv()\n     cifs_setup_session()        smb2_setup_request()\n      kfree_sensitive()           smb2_calc_signature()\n                                   crypto_shash_setkey() *UAF*\n\nFix this by ensuring that we have a valid @ses->auth_key.response by\nchecking whether @ses->ses_status is SES_GOOD or SES_EXITING with\n@ses->ses_lock held.  After commit 24a9799aa8ef (\"smb: client: fix UAF\nin smb2_reconnect_server()\"), we made sure to call ->logoff() only\nwhen @ses was known to be good (e.g. valid ->auth_key.response), so\nit's safe to access signing key when @ses->ses_status == SES_EXITING.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53179",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-02-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53111",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nloop: Fix use-after-free issues\n\ndo_req_filebacked() calls blk_mq_complete_request() synchronously or\nasynchronously when using asynchronous I/O unless memory allocation fails.\nHence, modify loop_handle_cmd() such that it does not dereference 'cmd' nor\n'rq' after do_req_filebacked() finished unless we are sure that the request\nhas not yet been completed. This patch fixes the following kernel crash:\n\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000054\nCall trace:\n css_put.42938+0x1c/0x1ac\n loop_process_work+0xc8c/0xfd4\n loop_rootcg_workfn+0x24/0x34\n process_one_work+0x244/0x558\n worker_thread+0x400/0x8fc\n kthread+0x16c/0x1e0\n ret_from_fork+0x10/0x20",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53111",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38403",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock/vmci: Clear the vmci transport packet properly when initializing it\n\nIn vmci_transport_packet_init memset the vmci_transport_packet before\npopulating the fields to avoid any uninitialised data being left in the\nstructure.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38403",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46800",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsch/netem: fix use after free in netem_dequeue\n\nIf netem_dequeue() enqueues packet to inner qdisc and that qdisc\nreturns __NET_XMIT_STOLEN. The packet is dropped but\nqdisc_tree_reduce_backlog() is not called to update the parent's\nq.qlen, leading to the similar use-after-free as Commit\ne04991a48dbaf382 (\"netem: fix return value if duplicate enqueue\nfails\")\n\nCommands to trigger KASAN UaF:\n\nip link add type dummy\nip link set lo up\nip link set dummy0 up\ntc qdisc add dev lo parent root handle 1: drr\ntc filter add dev lo parent 1: basic classid 1:1\ntc class add dev lo classid 1:1 drr\ntc qdisc add dev lo parent 1:1 handle 2: netem\ntc qdisc add dev lo parent 2: handle 3: drr\ntc filter add dev lo parent 3: basic classid 3:1 action mirred egress\nredirect dev dummy0\ntc class add dev lo classid 3:1 drr\nping -c1 -W0.01 localhost # Trigger bug\ntc class del dev lo classid 1:1\ntc class add dev lo classid 1:1 drr\nping -c1 -W0.01 localhost # UaF",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46800",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56642",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Fix use-after-free of kernel socket in cleanup_bearer().\n\nsyzkaller reported a use-after-free of UDP kernel socket\nin cleanup_bearer() without repro. [0][1]\n\nWhen bearer_disable() calls tipc_udp_disable(), cleanup\nof the UDP kernel socket is deferred by work calling\ncleanup_bearer().\n\ntipc_exit_net() waits for such works to finish by checking\ntipc_net(net)->wq_count.  However, the work decrements the\ncount too early before releasing the kernel socket,\nunblocking cleanup_net() and resulting in use-after-free.\n\nLet's move the decrement after releasing the socket in\ncleanup_bearer().\n\n[0]:\nref_tracker: net notrefcnt@000000009b3d1faf has 1/1 users at\n     sk_alloc+0x438/0x608\n     inet_create+0x4c8/0xcb0\n     __sock_create+0x350/0x6b8\n     sock_create_kern+0x58/0x78\n     udp_sock_create4+0x68/0x398\n     udp_sock_create+0x88/0xc8\n     tipc_udp_enable+0x5e8/0x848\n     __tipc_nl_bearer_enable+0x84c/0xed8\n     tipc_nl_bearer_enable+0x38/0x60\n     genl_family_rcv_msg_doit+0x170/0x248\n     genl_rcv_msg+0x400/0x5b0\n     netlink_rcv_skb+0x1dc/0x398\n     genl_rcv+0x44/0x68\n     netlink_unicast+0x678/0x8b0\n     netlink_sendmsg+0x5e4/0x898\n     ____sys_sendmsg+0x500/0x830\n\n[1]:\nBUG: KMSAN: use-after-free in udp_hashslot include/net/udp.h:85 [inline]\nBUG: KMSAN: use-after-free in udp_lib_unhash+0x3b8/0x930 net/ipv4/udp.c:1979\n udp_hashslot include/net/udp.h:85 [inline]\n udp_lib_unhash+0x3b8/0x930 net/ipv4/udp.c:1979\n sk_common_release+0xaf/0x3f0 net/core/sock.c:3820\n inet_release+0x1e0/0x260 net/ipv4/af_inet.c:437\n inet6_release+0x6f/0xd0 net/ipv6/af_inet6.c:489\n __sock_release net/socket.c:658 [inline]\n sock_release+0xa0/0x210 net/socket.c:686\n cleanup_bearer+0x42d/0x4c0 net/tipc/udp_media.c:819\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xcaf/0x1c90 kernel/workqueue.c:3310\n worker_thread+0xf6c/0x1510 kernel/workqueue.c:3391\n kthread+0x531/0x6b0 kernel/kthread.c:389\n ret_from_fork+0x60/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:244\n\nUninit was created at:\n slab_free_hook mm/slub.c:2269 [inline]\n slab_free mm/slub.c:4580 [inline]\n kmem_cache_free+0x207/0xc40 mm/slub.c:4682\n net_free net/core/net_namespace.c:454 [inline]\n cleanup_net+0x16f2/0x19d0 net/core/net_namespace.c:647\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xcaf/0x1c90 kernel/workqueue.c:3310\n worker_thread+0xf6c/0x1510 kernel/workqueue.c:3391\n kthread+0x531/0x6b0 kernel/kthread.c:389\n ret_from_fork+0x60/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:244\n\nCPU: 0 UID: 0 PID: 54 Comm: kworker/0:2 Not tainted 6.12.0-rc1-00131-gf66ebf37d69c #7 91723d6f74857f70725e1583cba3cf4adc716cfa\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nWorkqueue: events cleanup_bearer",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56642",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47261",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/mlx5: Fix initializing CQ fragments buffer\n\nThe function init_cq_frag_buf() can be called to initialize the current CQ\nfragments buffer cq->buf, or the temporary cq->resize_buf that is filled\nduring CQ resize operation.\n\nHowever, the offending commit started to use function get_cqe() for\ngetting the CQEs, the issue with this change is that get_cqe() always\nreturns CQEs from cq->buf, which leads us to initialize the wrong buffer,\nand in case of enlarging the CQ we try to access elements beyond the size\nof the current cq->buf and eventually hit a kernel panic.\n\n [exception RIP: init_cq_frag_buf+103]\n  [ffff9f799ddcbcd8] mlx5_ib_resize_cq at ffffffffc0835d60 [mlx5_ib]\n  [ffff9f799ddcbdb0] ib_resize_cq at ffffffffc05270df [ib_core]\n  [ffff9f799ddcbdc0] llt_rdma_setup_qp at ffffffffc0a6a712 [llt]\n  [ffff9f799ddcbe10] llt_rdma_cc_event_action at ffffffffc0a6b411 [llt]\n  [ffff9f799ddcbe98] llt_rdma_client_conn_thread at ffffffffc0a6bb75 [llt]\n  [ffff9f799ddcbec8] kthread at ffffffffa66c5da1\n  [ffff9f799ddcbf50] ret_from_fork_nospec_begin at ffffffffa6d95ddd\n\nFix it by getting the needed CQE by calling mlx5_frag_buf_get_wqe() that\ntakes the correct source buffer as a parameter.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47261",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50241",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: fix use-after-free on source server when doing inter-server copy\n\nUse-after-free occurred when the laundromat tried to free expired\ncpntf_state entry on the s2s_cp_stateids list after inter-server\ncopy completed. The sc_cp_list that the expired copy state was\ninserted on was already freed.\n\nWhen COPY completes, the Linux client normally sends LOCKU(lock_state x),\nFREE_STATEID(lock_state x) and CLOSE(open_state y) to the source server.\nThe nfs4_put_stid call from nfsd4_free_stateid cleans up the copy state\nfrom the s2s_cp_stateids list before freeing the lock state's stid.\n\nHowever, sometimes the CLOSE was sent before the FREE_STATEID request.\nWhen this happens, the nfsd4_close_open_stateid call from nfsd4_close\nfrees all lock states on its st_locks list without cleaning up the copy\nstate on the sc_cp_list list. When the time the FREE_STATEID arrives the\nserver returns BAD_STATEID since the lock state was freed. This causes\nthe use-after-free error to occur when the laundromat tries to free\nthe expired cpntf_state.\n\nThis patch adds a call to nfs4_free_cpntf_statelist in\nnfsd4_close_open_stateid to clean up the copy state before calling\nfree_ol_stateid_reaplist to free the lock state's stid on the reaplist.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50241",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39689",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Also allocate and copy hash for reading of filter files\n\nCurrently the reader of set_ftrace_filter and set_ftrace_notrace just adds\nthe pointer to the global tracer hash to its iterator. Unlike the writer\nthat allocates a copy of the hash, the reader keeps the pointer to the\nfilter hashes. This is problematic because this pointer is static across\nfunction calls that release the locks that can update the global tracer\nhashes. This can cause UAF and similar bugs.\n\nAllocate and copy the hash for reading the filter files like it is done\nfor the writers. This not only fixes UAF bugs, but also makes the code a\nbit simpler as it doesn't have to differentiate when to free the\niterator's hash between writers and readers.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39689",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-05",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-58240",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntls: separate no-async decryption request handling from async\n\nIf we're not doing async, the handling is much simpler. There's no\nreference counting, we just need to wait for the completion to wake us\nup and return its result.\n\nWe should preferably also use a separate crypto_wait. I'm not seeing a\nUAF as I did in the past, I think aec7961916f3 (\"tls: fix race between\nasync notify and socket close\") took care of it.\n\nThis will make the next fix easier.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-58240",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-28",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53075",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix invalid address access in lookup_rec() when index is 0\n\nKASAN reported follow problem:\n\n BUG: KASAN: use-after-free in lookup_rec\n Read of size 8 at addr ffff000199270ff0 by task modprobe\n CPU: 2 Comm: modprobe\n Call trace:\n  kasan_report\n  __asan_load8\n  lookup_rec\n  ftrace_location\n  arch_check_ftrace_location\n  check_kprobe_address_safe\n  register_kprobe\n\nWhen checking pg->records[pg->index - 1].ip in lookup_rec(), it can get a\npg which is newly added to ftrace_pages_start in ftrace_process_locs().\nBefore the first pg->index++, index is 0 and accessing pg->records[-1].ip\nwill cause this problem.\n\nDon't check the ip when pg->index is 0.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53075",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38584",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: Fix pd UAF once and for all\n\nThere is a race condition/UAF in padata_reorder that goes back\nto the initial commit.  A reference count is taken at the start\nof the process in padata_do_parallel, and released at the end in\npadata_serial_worker.\n\nThis reference count is (and only is) required for padata_replace\nto function correctly.  If padata_replace is never called then\nthere is no issue.\n\nIn the function padata_reorder which serves as the core of padata,\nas soon as padata is added to queue->serial.list, and the associated\nspin lock released, that padata may be processed and the reference\ncount on pd would go away.\n\nFix this by getting the next padata before the squeue->serial lock\nis released.\n\nIn order to make this possible, simplify padata_reorder by only\ncalling it once the next padata arrives.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38584",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2025-11-26",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21726",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npadata: avoid UAF for reorder_work\n\nAlthough the previous patch can avoid ps and ps UAF for _do_serial, it\ncan not avoid potential UAF issue for reorder_work. This issue can\nhappen just as below:\n\ncrypto_request\t\t\tcrypto_request\t\tcrypto_del_alg\npadata_do_serial\n  ...\n  padata_reorder\n    // processes all remaining\n    // requests then breaks\n    while (1) {\n      if (!padata)\n        break;\n      ...\n    }\n\n\t\t\t\tpadata_do_serial\n\t\t\t\t  // new request added\n\t\t\t\t  list_add\n    // sees the new request\n    queue_work(reorder_work)\n\t\t\t\t  padata_reorder\n\t\t\t\t    queue_work_on(squeue->work)\n...\n\n\t\t\t\t<kworker context>\n\t\t\t\tpadata_serial_worker\n\t\t\t\t// completes new request,\n\t\t\t\t// no more outstanding\n\t\t\t\t// requests\n\n\t\t\t\t\t\t\tcrypto_del_alg\n\t\t\t\t\t\t\t  // free pd\n\n<kworker context>\ninvoke_padata_reorder\n  // UAF of pd\n\nTo avoid UAF for 'reorder_work', get 'pd' ref before put 'reorder_work'\ninto the 'serial_wq' and put 'pd' ref until the 'serial_wq' finish.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21726",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-42271",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/iucv: fix use after free in iucv_sock_close()\n\niucv_sever_path() is called from process context and from bh context.\niucv->path is used as indicator whether somebody else is taking care of\nsevering the path (or it is already removed / never existed).\nThis needs to be done with atomic compare and swap, otherwise there is a\nsmall window where iucv_sock_close() will try to work with a path that has\nalready been severed and freed by iucv_callback_connrej() called by\niucv_tasklet_fn().\n\nExample:\n[452744.123844] Call Trace:\n[452744.123845] ([<0000001e87f03880>] 0x1e87f03880)\n[452744.123966]  [<00000000d593001e>] iucv_path_sever+0x96/0x138\n[452744.124330]  [<000003ff801ddbca>] iucv_sever_path+0xc2/0xd0 [af_iucv]\n[452744.124336]  [<000003ff801e01b6>] iucv_sock_close+0xa6/0x310 [af_iucv]\n[452744.124341]  [<000003ff801e08cc>] iucv_sock_release+0x3c/0xd0 [af_iucv]\n[452744.124345]  [<00000000d574794e>] __sock_release+0x5e/0xe8\n[452744.124815]  [<00000000d5747a0c>] sock_close+0x34/0x48\n[452744.124820]  [<00000000d5421642>] __fput+0xba/0x268\n[452744.124826]  [<00000000d51b382c>] task_work_run+0xbc/0xf0\n[452744.124832]  [<00000000d5145710>] do_notify_resume+0x88/0x90\n[452744.124841]  [<00000000d5978096>] system_call+0xe2/0x2c8\n[452744.125319] Last Breaking-Event-Address:\n[452744.125321]  [<00000000d5930018>] iucv_path_sever+0x90/0x138\n[452744.125324]\n[452744.125325] Kernel panic - not syncing: Fatal exception in interrupt\n\nNote that bh_lock_sock() is not serializing the tasklet context against\nprocess context, because the check for sock_owned_by_user() and\ncorresponding handling is missing.\n\nIdeas for a future clean-up patch:\nA) Correct usage of bh_lock_sock() in tasklet context, as described in\nRe-enqueue, if needed. This may require adding return values to the\ntasklet functions and thus changes to all users of iucv.\n\nB) Change iucv tasklet into worker and use only lock_sock() in af_iucv.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42271",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-17",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-3444",
                    "description": "The bpf verifier in the Linux kernel did not properly handle mod32 destination register truncation when the source register was known to be 0. A local attacker with the ability to load bpf programs could use this gain out-of-bounds reads in kernel memory leading to information disclosure (kernel memory), and possibly out-of-bounds writes that could potentially lead to code execution. This issue was addressed in the upstream kernel in commit 9b00f1b78809 (\"bpf: Fix truncation handling for mod32 dst reg wrt zero\") and in Linux stable kernels 5.11.2, 5.10.19, and 5.4.101.",
                    "nvd_score": 4.6,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3444",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-03-23",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52818",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd: Fix UBSAN array-index-out-of-bounds for SMU7\n\nFor pptable structs that use flexible array sizes, use flexible arrays.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52818",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-52906",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_mpls: Fix warning during failed attribute validation\n\nThe 'TCA_MPLS_LABEL' attribute is of 'NLA_U32' type, but has a\nvalidation type of 'NLA_VALIDATE_FUNCTION'. This is an invalid\ncombination according to the comment above 'struct nla_policy':\n\n\"\nMeaning of `validate' field, use via NLA_POLICY_VALIDATE_FN:\n   NLA_BINARY           Validation function called for the attribute.\n   All other            Unused - but note that it's a union\n\"\n\nThis can trigger the warning [1] in nla_get_range_unsigned() when\nvalidation of the attribute fails. Despite being of 'NLA_U32' type, the\nassociated 'min'/'max' fields in the policy are negative as they are\naliased by the 'validate' field.\n\nFix by changing the attribute type to 'NLA_BINARY' which is consistent\nwith the above comment and all other users of NLA_POLICY_VALIDATE_FN().\nAs a result, move the length validation to the validation function.\n\nNo regressions in MPLS tests:\n\n # ./tdc.py -f tc-tests/actions/mpls.json\n [...]\n # echo $?\n 0\n\n[1]\nWARNING: CPU: 0 PID: 17743 at lib/nlattr.c:118\nnla_get_range_unsigned+0x1d8/0x1e0 lib/nlattr.c:117\nModules linked in:\nCPU: 0 PID: 17743 Comm: syz-executor.0 Not tainted 6.1.0-rc8 #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nrel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014\nRIP: 0010:nla_get_range_unsigned+0x1d8/0x1e0 lib/nlattr.c:117\n[...]\nCall Trace:\n <TASK>\n __netlink_policy_dump_write_attr+0x23d/0x990 net/netlink/policy.c:310\n netlink_policy_dump_write_attr+0x22/0x30 net/netlink/policy.c:411\n netlink_ack_tlv_fill net/netlink/af_netlink.c:2454 [inline]\n netlink_ack+0x546/0x760 net/netlink/af_netlink.c:2506\n netlink_rcv_skb+0x1b7/0x240 net/netlink/af_netlink.c:2546\n rtnetlink_rcv+0x18/0x20 net/core/rtnetlink.c:6109\n netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n netlink_unicast+0x5e9/0x6b0 net/netlink/af_netlink.c:1345\n netlink_sendmsg+0x739/0x860 net/netlink/af_netlink.c:1921\n sock_sendmsg_nosec net/socket.c:714 [inline]\n sock_sendmsg net/socket.c:734 [inline]\n ____sys_sendmsg+0x38f/0x500 net/socket.c:2482\n ___sys_sendmsg net/socket.c:2536 [inline]\n __sys_sendmsg+0x197/0x230 net/socket.c:2565\n __do_sys_sendmsg net/socket.c:2574 [inline]\n __se_sys_sendmsg net/socket.c:2572 [inline]\n __x64_sys_sendmsg+0x42/0x50 net/socket.c:2572\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x2b/0x70 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52906",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-21",
                    "modification_date": "2024-09-13",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52975",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi_tcp: Fix UAF during logout when accessing the shost ipaddress\n\nBug report and analysis from Ding Hui.\n\nDuring iSCSI session logout, if another task accesses the shost ipaddress\nattr, we can get a KASAN UAF report like this:\n\n[  276.942144] BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x78/0xe0\n[  276.942535] Write of size 4 at addr ffff8881053b45b8 by task cat/4088\n[  276.943511] CPU: 2 PID: 4088 Comm: cat Tainted: G            E      6.1.0-rc8+ #3\n[  276.943997] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\n[  276.944470] Call Trace:\n[  276.944943]  <TASK>\n[  276.945397]  dump_stack_lvl+0x34/0x48\n[  276.945887]  print_address_description.constprop.0+0x86/0x1e7\n[  276.946421]  print_report+0x36/0x4f\n[  276.947358]  kasan_report+0xad/0x130\n[  276.948234]  kasan_check_range+0x35/0x1c0\n[  276.948674]  _raw_spin_lock_bh+0x78/0xe0\n[  276.949989]  iscsi_sw_tcp_host_get_param+0xad/0x2e0 [iscsi_tcp]\n[  276.951765]  show_host_param_ISCSI_HOST_PARAM_IPADDRESS+0xe9/0x130 [scsi_transport_iscsi]\n[  276.952185]  dev_attr_show+0x3f/0x80\n[  276.953005]  sysfs_kf_seq_show+0x1fb/0x3e0\n[  276.953401]  seq_read_iter+0x402/0x1020\n[  276.954260]  vfs_read+0x532/0x7b0\n[  276.955113]  ksys_read+0xed/0x1c0\n[  276.955952]  do_syscall_64+0x38/0x90\n[  276.956347]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[  276.956769] RIP: 0033:0x7f5d3a679222\n[  276.957161] Code: c0 e9 b2 fe ff ff 50 48 8d 3d 32 c0 0b 00 e8 a5 fe 01 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24\n[  276.958009] RSP: 002b:00007ffc864d16a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000\n[  276.958431] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5d3a679222\n[  276.958857] RDX: 0000000000020000 RSI: 00007f5d3a4fe000 RDI: 0000000000000003\n[  276.959281] RBP: 00007f5d3a4fe000 R08: 00000000ffffffff R09: 0000000000000000\n[  276.959682] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000020000\n[  276.960126] R13: 0000000000000003 R14: 0000000000000000 R15: 0000557a26dada58\n[  276.960536]  </TASK>\n[  276.961357] Allocated by task 2209:\n[  276.961756]  kasan_save_stack+0x1e/0x40\n[  276.962170]  kasan_set_track+0x21/0x30\n[  276.962557]  __kasan_kmalloc+0x7e/0x90\n[  276.962923]  __kmalloc+0x5b/0x140\n[  276.963308]  iscsi_alloc_session+0x28/0x840 [scsi_transport_iscsi]\n[  276.963712]  iscsi_session_setup+0xda/0xba0 [libiscsi]\n[  276.964078]  iscsi_sw_tcp_session_create+0x1fd/0x330 [iscsi_tcp]\n[  276.964431]  iscsi_if_create_session.isra.0+0x50/0x260 [scsi_transport_iscsi]\n[  276.964793]  iscsi_if_recv_msg+0xc5a/0x2660 [scsi_transport_iscsi]\n[  276.965153]  iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi]\n[  276.965546]  netlink_unicast+0x4d5/0x7b0\n[  276.965905]  netlink_sendmsg+0x78d/0xc30\n[  276.966236]  sock_sendmsg+0xe5/0x120\n[  276.966576]  ____sys_sendmsg+0x5fe/0x860\n[  276.966923]  ___sys_sendmsg+0xe0/0x170\n[  276.967300]  __sys_sendmsg+0xc8/0x170\n[  276.967666]  do_syscall_64+0x38/0x90\n[  276.968028]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[  276.968773] Freed by task 2209:\n[  276.969111]  kasan_save_stack+0x1e/0x40\n[  276.969449]  kasan_set_track+0x21/0x30\n[  276.969789]  kasan_save_free_info+0x2a/0x50\n[  276.970146]  __kasan_slab_free+0x106/0x190\n[  276.970470]  __kmem_cache_free+0x133/0x270\n[  276.970816]  device_release+0x98/0x210\n[  276.971145]  kobject_cleanup+0x101/0x360\n[  276.971462]  iscsi_session_teardown+0x3fb/0x530 [libiscsi]\n[  276.971775]  iscsi_sw_tcp_session_destroy+0xd8/0x130 [iscsi_tcp]\n[  276.972143]  iscsi_if_recv_msg+0x1bf1/0x2660 [scsi_transport_iscsi]\n[  276.972485]  iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi]\n[  276.972808]  netlink_unicast+0x4d5/0x7b0\n[  276.973201]  netlink_sendmsg+0x78d/0xc30\n[  276.973544]  sock_sendmsg+0xe5/0x120\n[  276.973864]  ____sys_sendmsg+0x5fe/0x860\n[  276.974248]  ___sys_\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52975",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53057",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: stop qdisc_tree_reduce_backlog on TC_H_ROOT\n\nIn qdisc_tree_reduce_backlog, Qdiscs with major handle ffff: are assumed\nto be either root or ingress. This assumption is bogus since it's valid\nto create egress qdiscs with major handle ffff:\nBudimir Markovic found that for qdiscs like DRR that maintain an active\nclass list, it will cause a UAF with a dangling class pointer.\n\nIn 066a3b5b2346, the concern was to avoid iterating over the ingress\nqdisc since its parent is itself. The proper fix is to stop when parent\nTC_H_ROOT is reached because the only way to retrieve ingress is when a\nhierarchy which does not contain a ffff: major handle call into\nqdisc_lookup with TC_H_MAJ(TC_H_ROOT).\n\nIn the scenario where major ffff: is an egress qdisc in any of the tree\nlevels, the updates will also propagate to TC_H_ROOT, which then the\niteration must stop.\n\n\n net/sched/sch_api.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53057",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47251",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix skb length check in ieee80211_scan_rx()\n\nReplace hard-coded compile-time constants for header length check\nwith dynamic determination based on the frame type. Otherwise, we\nhit a validation WARN_ON in cfg80211 later.\n\n[style fixes, reword commit message]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47251",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37798",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncodel: remove sch->q.qlen check before qdisc_tree_reduce_backlog()\n\nAfter making all ->qlen_notify() callbacks idempotent, now it is safe to\nremove the check of qlen!=0 from both fq_codel_dequeue() and\ncodel_qdisc_dequeue().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37798",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49548",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix potential array overflow in bpf_trampoline_get_progs()\n\nThe cnt value in the 'cnt >= BPF_MAX_TRAMP_PROGS' check does not\ninclude BPF_TRAMP_MODIFY_RETURN bpf programs, so the number of\nthe attached BPF_TRAMP_MODIFY_RETURN bpf programs in a trampoline\ncan exceed BPF_MAX_TRAMP_PROGS.\n\nWhen this happens, the assignment '*progs++ = aux->prog' in\nbpf_trampoline_get_progs() will cause progs array overflow as the\nprogs field in the bpf_tramp_progs struct can only hold at most\nBPF_MAX_TRAMP_PROGS bpf programs.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49548",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50051",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: debug: Fix potential buffer overflow by snprintf()\n\nsnprintf() returns the would-be-filled size when the string overflows\nthe given buffer size, hence using this value may result in the buffer\noverflow (although it's unrealistic).\n\nThis patch replaces with a safer version, scnprintf() for papering\nover such a potential issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50051",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-13",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26883",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash buckets, and contains an overflow check by checking if the\nresulting value is 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not account for the UB, so the fix only works on CPUs where an\noverflow does result in a neat truncation to zero, which is not\nguaranteed. Checking the value before rounding does not have this\nproblem.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26883",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-17",
                    "modification_date": "2025-03-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38146",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: Fix the dead loop of MPLS parse\n\nThe unexpected MPLS packet may not end with the bottom label stack.\nWhen there are many stacks, The label count value has wrapped around.\nA dead loop occurs, soft lockup/CPU stuck finally.\n\nstack backtrace:\nUBSAN: array-index-out-of-bounds in /build/linux-0Pa0xK/linux-5.15.0/net/openvswitch/flow.c:662:26\nindex -1 is out of range for type '__be32 [3]'\nCPU: 34 PID: 0 Comm: swapper/34 Kdump: loaded Tainted: G           OE   5.15.0-121-generic #131-Ubuntu\nHardware name: Dell Inc. PowerEdge C6420/0JP9TF, BIOS 2.12.2 07/14/2021\nCall Trace:\n <IRQ>\n show_stack+0x52/0x5c\n dump_stack_lvl+0x4a/0x63\n dump_stack+0x10/0x16\n ubsan_epilogue+0x9/0x36\n __ubsan_handle_out_of_bounds.cold+0x44/0x49\n key_extract_l3l4+0x82a/0x840 [openvswitch]\n ? kfree_skbmem+0x52/0xa0\n key_extract+0x9c/0x2b0 [openvswitch]\n ovs_flow_key_extract+0x124/0x350 [openvswitch]\n ovs_vport_receive+0x61/0xd0 [openvswitch]\n ? kernel_init_free_pages.part.0+0x4a/0x70\n ? get_page_from_freelist+0x353/0x540\n netdev_port_receive+0xc4/0x180 [openvswitch]\n ? netdev_port_receive+0x180/0x180 [openvswitch]\n netdev_frame_hook+0x1f/0x40 [openvswitch]\n __netif_receive_skb_core.constprop.0+0x23a/0xf00\n __netif_receive_skb_list_core+0xfa/0x240\n netif_receive_skb_list_internal+0x18e/0x2a0\n napi_complete_done+0x7a/0x1c0\n bnxt_poll+0x155/0x1c0 [bnxt_en]\n __napi_poll+0x30/0x180\n net_rx_action+0x126/0x280\n ? bnxt_msix+0x67/0x80 [bnxt_en]\n handle_softirqs+0xda/0x2d0\n irq_exit_rcu+0x96/0xc0\n common_interrupt+0x8e/0xa0\n </IRQ>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38146",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49612",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npower: supply: core: Fix boundary conditions in interpolation\n\nThe functions power_supply_temp2resist_simple and power_supply_ocv2cap_simple\nhandle boundary conditions incorrectly.\nThe change was introduced in a4585ba2050f460f749bbaf2b67bd56c41e30283\n(\"power: supply: core: Use library interpolation\").\nThere are two issues: First, the lines \"high = i - 1\" and \"high = i\" in ocv2cap\nhave the wrong order compared to temp2resist. As a consequence, ocv2cap\nsets high=-1 if ocv>table[0].ocv, which causes an out-of-bounds read.\nSecond, the logic of temp2resist is also not correct.\nConsider the case table[] = {{20, 100}, {10, 80}, {0, 60}}.\nFor temp=5, we expect a resistance of 70% by interpolation.\nHowever, temp2resist sets high=low=2 and returns 60.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49612",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-42280",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmISDN: Fix a use after free in hfcmulti_tx()\n\nDon't dereference *sp after calling dev_kfree_skb(*sp).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42280",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-17",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-3424",
                    "description": "A use-after-free flaw was found in the Linux kernel\u2019s SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-3424",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-03-06",
                    "modification_date": "2025-03-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50267",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: serial: io_edgeport: fix use after free in debug printk\n\nThe \"dev_dbg(&urb->dev->dev, ...\" which happens after usb_free_urb(urb)\nis a use after free of the \"urb\" pointer.  Store the \"dev\" pointer at the\nstart of the function to avoid this issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50267",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48789",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-tcp: fix possible use-after-free in transport error_recovery work\n\nWhile nvme_tcp_submit_async_event_work is checking the ctrl and queue\nstate before preparing the AER command and scheduling io_work, in order\nto fully prevent a race where this check is not reliable the error\nrecovery work must flush async_event_work before continuing to destroy\nthe admin queue after setting the ctrl state to RESETTING such that\nthere is no race .submit_async_event and the error recovery handler\nitself changing the ctrl state.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48789",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56614",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxsk: fix OOB map writes when deleting elements\n\nJordy says:\n\n\"\nIn the xsk_map_delete_elem function an unsigned integer\n(map->max_entries) is compared with a user-controlled signed integer\n(k). Due to implicit type conversion, a large unsigned value for\nmap->max_entries can bypass the intended bounds check:\n\n\tif (k >= map->max_entries)\n\t\treturn -EINVAL;\n\nThis allows k to hold a negative value (between -2147483648 and -2),\nwhich is then used as an array index in m->xsk_map[k], which results\nin an out-of-bounds access.\n\n\tspin_lock_bh(&m->lock);\n\tmap_entry = &m->xsk_map[k]; // Out-of-bounds map_entry\n\told_xs = unrcu_pointer(xchg(map_entry, NULL));  // Oob write\n\tif (old_xs)\n\t\txsk_map_sock_delete(old_xs, map_entry);\n\tspin_unlock_bh(&m->lock);\n\nThe xchg operation can then be used to cause an out-of-bounds write.\nMoreover, the invalid map_entry passed to xsk_map_sock_delete can lead\nto further memory corruption.\n\"\n\nIt indeed results in following splat:\n\n[76612.897343] BUG: unable to handle page fault for address: ffffc8fc2e461108\n[76612.904330] #PF: supervisor write access in kernel mode\n[76612.909639] #PF: error_code(0x0002) - not-present page\n[76612.914855] PGD 0 P4D 0\n[76612.917431] Oops: Oops: 0002 [#1] PREEMPT SMP\n[76612.921859] CPU: 11 UID: 0 PID: 10318 Comm: a.out Not tainted 6.12.0-rc1+ #470\n[76612.929189] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019\n[76612.939781] RIP: 0010:xsk_map_delete_elem+0x2d/0x60\n[76612.944738] Code: 00 00 41 54 55 53 48 63 2e 3b 6f 24 73 38 4c 8d a7 f8 00 00 00 48 89 fb 4c 89 e7 e8 2d bf 05 00 48 8d b4 eb 00 01 00 00 31 ff <48> 87 3e 48 85 ff 74 05 e8 16 ff ff ff 4c 89 e7 e8 3e bc 05 00 31\n[76612.963774] RSP: 0018:ffffc9002e407df8 EFLAGS: 00010246\n[76612.969079] RAX: 0000000000000000 RBX: ffffc9002e461000 RCX: 0000000000000000\n[76612.976323] RDX: 0000000000000001 RSI: ffffc8fc2e461108 RDI: 0000000000000000\n[76612.983569] RBP: ffffffff80000001 R08: 0000000000000000 R09: 0000000000000007\n[76612.990812] R10: ffffc9002e407e18 R11: ffff888108a38858 R12: ffffc9002e4610f8\n[76612.998060] R13: ffff888108a38858 R14: 00007ffd1ae0ac78 R15: ffffc9002e4610c0\n[76613.005303] FS:  00007f80b6f59740(0000) GS:ffff8897e0ec0000(0000) knlGS:0000000000000000\n[76613.013517] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[76613.019349] CR2: ffffc8fc2e461108 CR3: 000000011e3ef001 CR4: 00000000007726f0\n[76613.026595] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[76613.033841] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[76613.041086] PKRU: 55555554\n[76613.043842] Call Trace:\n[76613.046331]  <TASK>\n[76613.048468]  ? __die+0x20/0x60\n[76613.051581]  ? page_fault_oops+0x15a/0x450\n[76613.055747]  ? search_extable+0x22/0x30\n[76613.059649]  ? search_bpf_extables+0x5f/0x80\n[76613.063988]  ? exc_page_fault+0xa9/0x140\n[76613.067975]  ? asm_exc_page_fault+0x22/0x30\n[76613.072229]  ? xsk_map_delete_elem+0x2d/0x60\n[76613.076573]  ? xsk_map_delete_elem+0x23/0x60\n[76613.080914]  __sys_bpf+0x19b7/0x23c0\n[76613.084555]  __x64_sys_bpf+0x1a/0x20\n[76613.088194]  do_syscall_64+0x37/0xb0\n[76613.091832]  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n[76613.096962] RIP: 0033:0x7f80b6d1e88d\n[76613.100592] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48\n[76613.119631] RSP: 002b:00007ffd1ae0ac68 EFLAGS: 00000206 ORIG_RAX: 0000000000000141\n[76613.131330] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f80b6d1e88d\n[76613.142632] RDX: 0000000000000098 RSI: 00007ffd1ae0ad20 RDI: 0000000000000003\n[76613.153967] RBP: 00007ffd1ae0adc0 R08: 0000000000000000 R09: 0000000000000000\n[76613.166030] R10: 00007f80b6f77040 R11: 0000000000000206 R12: 00007ffd1ae0aed8\n[76613.177130] R13: 000055ddf42ce1e9 R14: 000055ddf42d0d98 R15: 00\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56614",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48796",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu: Fix potential use-after-free during probe\n\nKasan has reported the following use after free on dev->iommu.\nwhen a device probe fails and it is in process of freeing dev->iommu\nin dev_iommu_free function, a deferred_probe_work_func runs in parallel\nand tries to access dev->iommu->fwspec in of_iommu_configure path thus\ncausing use after free.\n\nBUG: KASAN: use-after-free in of_iommu_configure+0xb4/0x4a4\nRead of size 8 at addr ffffff87a2f1acb8 by task kworker/u16:2/153\n\nWorkqueue: events_unbound deferred_probe_work_func\nCall trace:\n dump_backtrace+0x0/0x33c\n show_stack+0x18/0x24\n dump_stack_lvl+0x16c/0x1e0\n print_address_description+0x84/0x39c\n __kasan_report+0x184/0x308\n kasan_report+0x50/0x78\n __asan_load8+0xc0/0xc4\n of_iommu_configure+0xb4/0x4a4\n of_dma_configure_id+0x2fc/0x4d4\n platform_dma_configure+0x40/0x5c\n really_probe+0x1b4/0xb74\n driver_probe_device+0x11c/0x228\n __device_attach_driver+0x14c/0x304\n bus_for_each_drv+0x124/0x1b0\n __device_attach+0x25c/0x334\n device_initial_probe+0x24/0x34\n bus_probe_device+0x78/0x134\n deferred_probe_work_func+0x130/0x1a8\n process_one_work+0x4c8/0x970\n worker_thread+0x5c8/0xaec\n kthread+0x1f8/0x220\n ret_from_fork+0x10/0x18\n\nAllocated by task 1:\n ____kasan_kmalloc+0xd4/0x114\n __kasan_kmalloc+0x10/0x1c\n kmem_cache_alloc_trace+0xe4/0x3d4\n __iommu_probe_device+0x90/0x394\n probe_iommu_group+0x70/0x9c\n bus_for_each_dev+0x11c/0x19c\n bus_iommu_probe+0xb8/0x7d4\n bus_set_iommu+0xcc/0x13c\n arm_smmu_bus_init+0x44/0x130 [arm_smmu]\n arm_smmu_device_probe+0xb88/0xc54 [arm_smmu]\n platform_drv_probe+0xe4/0x13c\n really_probe+0x2c8/0xb74\n driver_probe_device+0x11c/0x228\n device_driver_attach+0xf0/0x16c\n __driver_attach+0x80/0x320\n bus_for_each_dev+0x11c/0x19c\n driver_attach+0x38/0x48\n bus_add_driver+0x1dc/0x3a4\n driver_register+0x18c/0x244\n __platform_driver_register+0x88/0x9c\n init_module+0x64/0xff4 [arm_smmu]\n do_one_initcall+0x17c/0x2f0\n do_init_module+0xe8/0x378\n load_module+0x3f80/0x4a40\n __se_sys_finit_module+0x1a0/0x1e4\n __arm64_sys_finit_module+0x44/0x58\n el0_svc_common+0x100/0x264\n do_el0_svc+0x38/0xa4\n el0_svc+0x20/0x30\n el0_sync_handler+0x68/0xac\n el0_sync+0x160/0x180\n\nFreed by task 1:\n kasan_set_track+0x4c/0x84\n kasan_set_free_info+0x28/0x4c\n ____kasan_slab_free+0x120/0x15c\n __kasan_slab_free+0x18/0x28\n slab_free_freelist_hook+0x204/0x2fc\n kfree+0xfc/0x3a4\n __iommu_probe_device+0x284/0x394\n probe_iommu_group+0x70/0x9c\n bus_for_each_dev+0x11c/0x19c\n bus_iommu_probe+0xb8/0x7d4\n bus_set_iommu+0xcc/0x13c\n arm_smmu_bus_init+0x44/0x130 [arm_smmu]\n arm_smmu_device_probe+0xb88/0xc54 [arm_smmu]\n platform_drv_probe+0xe4/0x13c\n really_probe+0x2c8/0xb74\n driver_probe_device+0x11c/0x228\n device_driver_attach+0xf0/0x16c\n __driver_attach+0x80/0x320\n bus_for_each_dev+0x11c/0x19c\n driver_attach+0x38/0x48\n bus_add_driver+0x1dc/0x3a4\n driver_register+0x18c/0x244\n __platform_driver_register+0x88/0x9c\n init_module+0x64/0xff4 [arm_smmu]\n do_one_initcall+0x17c/0x2f0\n do_init_module+0xe8/0x378\n load_module+0x3f80/0x4a40\n __se_sys_finit_module+0x1a0/0x1e4\n __arm64_sys_finit_module+0x44/0x58\n el0_svc_common+0x100/0x264\n do_el0_svc+0x38/0xa4\n el0_svc+0x20/0x30\n el0_sync_handler+0x68/0xac\n el0_sync+0x160/0x180\n\nFix this by setting dev->iommu to NULL first and\nthen freeing dev_iommu structure in dev_iommu_free\nfunction.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48796",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50234",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring/af_unix: defer registered files gc to io_uring release\n\nInstead of putting io_uring's registered files in unix_gc() we want it\nto be done by io_uring itself. The trick here is to consider io_uring\nregistered files for cycle detection but not actually putting them down.\nBecause io_uring can't register other ring instances, this will remove\nall refs to the ring file triggering the ->release path and clean up\nwith io_ring_ctx_free().\n\n[axboe: add kerneldoc comment to skb, fold in skb leak fix]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50234",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-11-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46725",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix out-of-bounds write warning\n\nCheck the ring type value to fix the out-of-bounds\nwrite warning",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46725",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38000",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue()\n\nWhen enqueuing the first packet to an HFSC class, hfsc_enqueue() calls the\nchild qdisc's peek() operation before incrementing sch->q.qlen and\nsch->qstats.backlog. If the child qdisc uses qdisc_peek_dequeued(), this may\ntrigger an immediate dequeue and potential packet drop. In such cases,\nqdisc_tree_reduce_backlog() is called, but the HFSC qdisc's qlen and backlog\nhave not yet been updated, leading to inconsistent queue accounting. This\ncan leave an empty HFSC class in the active list, causing further\nconsequences like use-after-free.\n\nThis patch fixes the bug by moving the increment of sch->q.qlen and\nsch->qstats.backlog before the call to the child qdisc's peek() operation.\nThis ensures that queue length and backlog are always accurate when packet\ndrops or dequeues are triggered during the peek.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38000",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-06",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49842",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: core: Fix use-after-free in snd_soc_exit()\n\nKASAN reports a use-after-free:\n\nBUG: KASAN: use-after-free in device_del+0xb5b/0xc60\nRead of size 8 at addr ffff888008655050 by task rmmod/387\nCPU: 2 PID: 387 Comm: rmmod\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996)\nCall Trace:\n<TASK>\ndump_stack_lvl+0x79/0x9a\nprint_report+0x17f/0x47b\nkasan_report+0xbb/0xf0\ndevice_del+0xb5b/0xc60\nplatform_device_del.part.0+0x24/0x200\nplatform_device_unregister+0x2e/0x40\nsnd_soc_exit+0xa/0x22 [snd_soc_core]\n__do_sys_delete_module.constprop.0+0x34f/0x5b0\ndo_syscall_64+0x3a/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n...\n</TASK>\n\nIt's bacause in snd_soc_init(), snd_soc_util_init() is possble to fail,\nbut its ret is ignored, which makes soc_dummy_dev unregistered twice.\n\nsnd_soc_init()\n    snd_soc_util_init()\n        platform_device_register_simple(soc_dummy_dev)\n        platform_driver_register() # fail\n    \tplatform_device_unregister(soc_dummy_dev)\n    platform_driver_register() # success\n...\nsnd_soc_exit()\n    snd_soc_util_exit()\n    # soc_dummy_dev will be unregistered for second time\n\nTo fix it, handle error and stop snd_soc_init() when util_init() fail.\nAlso clean debugfs when util_init() or driver_register() fail.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49842",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21855",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Don't reference skb after sending to VIOS\n\nPreviously, after successfully flushing the xmit buffer to VIOS,\nthe tx_bytes stat was incremented by the length of the skb.\n\nIt is invalid to access the skb memory after sending the buffer to\nthe VIOS because, at any point after sending, the VIOS can trigger\nan interrupt to free this memory. A race between reading skb->len\nand freeing the skb is possible (especially during LPM) and will\nresult in use-after-free:\n ==================================================================\n BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic]\n Read of size 4 at addr c00000024eb48a70 by task hxecom/14495\n <...>\n Call Trace:\n [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable)\n [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0\n [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8\n [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0\n [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic]\n [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358\n <...>\n Freed by task 0:\n kasan_save_stack+0x34/0x68\n kasan_save_track+0x2c/0x50\n kasan_save_free_info+0x64/0x108\n __kasan_mempool_poison_object+0x148/0x2d4\n napi_skb_cache_put+0x5c/0x194\n net_tx_action+0x154/0x5b8\n handle_softirqs+0x20c/0x60c\n do_softirq_own_stack+0x6c/0x88\n <...>\n The buggy address belongs to the object at c00000024eb48a00 which\n  belongs to the cache skbuff_head_cache of size 224\n==================================================================",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21855",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-12",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53252",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: use RCU for hci_conn_params and iterate safely in hci_sync\n\nhci_update_accept_list_sync iterates over hdev->pend_le_conns and\nhdev->pend_le_reports, and waits for controller events in the loop body,\nwithout holding hdev lock.\n\nMeanwhile, these lists and the items may be modified e.g. by\nle_scan_cleanup. This can invalidate the list cursor or any other item\nin the list, resulting to invalid behavior (eg use-after-free).\n\nUse RCU for the hci_conn_params action lists. Since the loop bodies in\nhci_sync block and we cannot use RCU or hdev->lock for the whole loop,\ncopy list items first and then iterate on the copy. Only the flags field\nis written from elsewhere, so READ_ONCE/WRITE_ONCE should guarantee we\nread valid values.\n\nFree params everywhere with hci_conn_params_free so the cleanup is\nguaranteed to be done properly.\n\nThis fixes the following, which can be triggered e.g. by BlueZ new\nmgmt-tester case \"Add + Remove Device Nowait - Success\", or by changing\nhci_le_set_cig_params to always return false, and running iso-tester:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841)\nRead of size 8 at addr ffff888001265018 by task kworker/u3:0/32\n\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014\nWorkqueue: hci0 hci_cmd_sync_work\nCall Trace:\n<TASK>\ndump_stack_lvl (./arch/x86/include/asm/irqflags.h:134 lib/dump_stack.c:107)\nprint_report (mm/kasan/report.c:320 mm/kasan/report.c:430)\n? __virt_addr_valid (./include/linux/mmzone.h:1915 ./include/linux/mmzone.h:2011 arch/x86/mm/physaddr.c:65)\n? hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841)\nkasan_report (mm/kasan/report.c:538)\n? hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841)\nhci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2536 net/bluetooth/hci_sync.c:2723 net/bluetooth/hci_sync.c:2841)\n? __pfx_hci_update_passive_scan_sync (net/bluetooth/hci_sync.c:2780)\n? mutex_lock (kernel/locking/mutex.c:282)\n? __pfx_mutex_lock (kernel/locking/mutex.c:282)\n? __pfx_mutex_unlock (kernel/locking/mutex.c:538)\n? __pfx_update_passive_scan_sync (net/bluetooth/hci_sync.c:2861)\nhci_cmd_sync_work (net/bluetooth/hci_sync.c:306)\nprocess_one_work (./arch/x86/include/asm/preempt.h:27 kernel/workqueue.c:2399)\nworker_thread (./include/linux/list.h:292 kernel/workqueue.c:2538)\n? __pfx_worker_thread (kernel/workqueue.c:2480)\nkthread (kernel/kthread.c:376)\n? __pfx_kthread (kernel/kthread.c:331)\nret_from_fork (arch/x86/entry/entry_64.S:314)\n</TASK>\n\nAllocated by task 31:\nkasan_save_stack (mm/kasan/common.c:46)\nkasan_set_track (mm/kasan/common.c:52)\n__kasan_kmalloc (mm/kasan/common.c:374 mm/kasan/common.c:383)\nhci_conn_params_add (./include/linux/slab.h:580 ./include/linux/slab.h:720 net/bluetooth/hci_core.c:2277)\nhci_connect_le_scan (net/bluetooth/hci_conn.c:1419 net/bluetooth/hci_conn.c:1589)\nhci_connect_cis (net/bluetooth/hci_conn.c:2266)\niso_connect_cis (net/bluetooth/iso.c:390)\niso_sock_connect (net/bluetooth/iso.c:899)\n__sys_connect (net/socket.c:2003 net/socket.c:2020)\n__x64_sys_connect (net/socket.c:2027)\ndo_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)\n\nFreed by task 15:\nkasan_save_stack (mm/kasan/common.c:46)\nkasan_set_track (mm/kasan/common.c:52)\nkasan_save_free_info (mm/kasan/generic.c:523)\n__kasan_slab_free (mm/kasan/common.c:238 mm/kasan/common.c:200 mm/kasan/common.c:244)\n__kmem_cache_free (mm/slub.c:1807 mm/slub.c:3787 mm/slub.c:3800)\nhci_conn_params_del (net/bluetooth/hci_core.c:2323)\nle_scan_cleanup (net/bluetooth/hci_conn.c:202)\nprocess_one_work (./arch/x86/include/asm/preempt.\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53252",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53153",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: Fix use after free for wext\n\nKey information in wext.connect is not reset on (re)connect and can hold\ndata from a previous connection.\n\nReset key data to avoid that drivers or mac80211 incorrectly detect a\nWEP connection request and access the freed or already reused memory.\n\nAdditionally optimize cfg80211_sme_connect() and avoid an useless\nschedule of conn_work.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53153",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-11-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21762",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narp: use RCU protection in arp_xmit()\n\narp_xmit() can be called without RTNL or RCU protection.\n\nUse RCU protection to avoid potential UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21762",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-54456",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix potential buffer overflowin nfs_sysfs_link_rpc_client()\n\nname is char[64] where the size of clnt->cl_program->name remains\nunknown. Invoking strcat() directly will also lead to potential buffer\noverflow. Change them to strscpy() and strncat() to fix potential\nissues.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-54456",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-10-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47222",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix vlan tunnel dst refcnt when egressing\n\nThe egress tunnel code uses dst_clone() and directly sets the result\nwhich is wrong because the entry might have 0 refcnt or be already deleted,\ncausing number of problems. It also triggers the WARN_ON() in dst_hold()[1]\nwhen a refcnt couldn't be taken. Fix it by using dst_hold_safe() and\nchecking if a reference was actually taken before setting the dst.\n\n[1] dmesg WARN_ON log and following refcnt errors\n WARNING: CPU: 5 PID: 38 at include/net/dst.h:230 br_handle_egress_vlan_tunnel+0x10b/0x134 [bridge]\n Modules linked in: 8021q garp mrp bridge stp llc bonding ipv6 virtio_net\n CPU: 5 PID: 38 Comm: ksoftirqd/5 Kdump: loaded Tainted: G        W         5.13.0-rc3+ #360\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 04/01/2014\n RIP: 0010:br_handle_egress_vlan_tunnel+0x10b/0x134 [bridge]\n Code: e8 85 bc 01 e1 45 84 f6 74 90 45 31 f6 85 db 48 c7 c7 a0 02 19 a0 41 0f 94 c6 31 c9 31 d2 44 89 f6 e8 64 bc 01 e1 85 db 75 02 <0f> 0b 31 c9 31 d2 44 89 f6 48 c7 c7 70 02 19 a0 e8 4b bc 01 e1 49\n RSP: 0018:ffff8881003d39e8 EFLAGS: 00010246\n RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffffa01902a0\n RBP: ffff8881040c6700 R08: 0000000000000000 R09: 0000000000000001\n R10: 2ce93d0054fe0d00 R11: 54fe0d00000e0000 R12: ffff888109515000\n R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000401\n FS:  0000000000000000(0000) GS:ffff88822bf40000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f42ba70f030 CR3: 0000000109926000 CR4: 00000000000006e0\n Call Trace:\n  br_handle_vlan+0xbc/0xca [bridge]\n  __br_forward+0x23/0x164 [bridge]\n  deliver_clone+0x41/0x48 [bridge]\n  br_handle_frame_finish+0x36f/0x3aa [bridge]\n  ? skb_dst+0x2e/0x38 [bridge]\n  ? br_handle_ingress_vlan_tunnel+0x3e/0x1c8 [bridge]\n  ? br_handle_frame_finish+0x3aa/0x3aa [bridge]\n  br_handle_frame+0x2c3/0x377 [bridge]\n  ? __skb_pull+0x33/0x51\n  ? vlan_do_receive+0x4f/0x36a\n  ? br_handle_frame_finish+0x3aa/0x3aa [bridge]\n  __netif_receive_skb_core+0x539/0x7c6\n  ? __list_del_entry_valid+0x16e/0x1c2\n  __netif_receive_skb_list_core+0x6d/0xd6\n  netif_receive_skb_list_internal+0x1d9/0x1fa\n  gro_normal_list+0x22/0x3e\n  dev_gro_receive+0x55b/0x600\n  ? detach_buf_split+0x58/0x140\n  napi_gro_receive+0x94/0x12e\n  virtnet_poll+0x15d/0x315 [virtio_net]\n  __napi_poll+0x2c/0x1c9\n  net_rx_action+0xe6/0x1fb\n  __do_softirq+0x115/0x2d8\n  run_ksoftirqd+0x18/0x20\n  smpboot_thread_fn+0x183/0x19c\n  ? smpboot_unregister_percpu_thread+0x66/0x66\n  kthread+0x10a/0x10f\n  ? kthread_mod_delayed_work+0xb6/0xb6\n  ret_from_fork+0x22/0x30\n ---[ end trace 49f61b07f775fd2b ]---\n dst_release: dst:00000000c02d677a refcnt:-1\n dst_release underflow",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47222",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-29",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47342",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix possible UAF when remounting r/o a mmp-protected file system\n\nAfter commit 618f003199c6 (\"ext4: fix memory leak in\next4_fill_super\"), after the file system is remounted read-only, there\nis a race where the kmmpd thread can exit, causing sbi->s_mmp_tsk to\npoint at freed memory, which the call to ext4_stop_mmpd() can trip\nover.\n\nFix this by only allowing kmmpd() to exit when it is stopped via\next4_stop_mmpd().\n\nBug-Report-Link: <20210629143603.2166962-1-yebin10@huawei.com>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47342",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-26",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47668",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: dev: can_restart: fix use after free bug\n\nAfter calling netif_rx_ni(skb), dereferencing skb is unsafe.\nEspecially, the can_frame cf which aliases skb memory is accessed\nafter the netif_rx_ni() in:\n      stats->rx_bytes += cf->len;\n\nReordering the lines solves the issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47668",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-17",
                    "modification_date": "2025-04-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49349",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix use-after-free in ext4_rename_dir_prepare\n\nWe got issue as follows:\nEXT4-fs (loop0): mounted filesystem without journal. Opts: ,errors=continue\next4_get_first_dir_block: bh->b_data=0xffff88810bee6000 len=34478\next4_get_first_dir_block: *parent_de=0xffff88810beee6ae bh->b_data=0xffff88810bee6000\next4_rename_dir_prepare: [1] parent_de=0xffff88810beee6ae\n==================================================================\nBUG: KASAN: use-after-free in ext4_rename_dir_prepare+0x152/0x220\nRead of size 4 at addr ffff88810beee6ae by task rep/1895\n\nCPU: 13 PID: 1895 Comm: rep Not tainted 5.10.0+ #241\nCall Trace:\n dump_stack+0xbe/0xf9\n print_address_description.constprop.0+0x1e/0x220\n kasan_report.cold+0x37/0x7f\n ext4_rename_dir_prepare+0x152/0x220\n ext4_rename+0xf44/0x1ad0\n ext4_rename2+0x11c/0x170\n vfs_rename+0xa84/0x1440\n do_renameat2+0x683/0x8f0\n __x64_sys_renameat+0x53/0x60\n do_syscall_64+0x33/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\nRIP: 0033:0x7f45a6fc41c9\nRSP: 002b:00007ffc5a470218 EFLAGS: 00000246 ORIG_RAX: 0000000000000108\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f45a6fc41c9\nRDX: 0000000000000005 RSI: 0000000020000180 RDI: 0000000000000005\nRBP: 00007ffc5a470240 R08: 00007ffc5a470160 R09: 0000000020000080\nR10: 00000000200001c0 R11: 0000000000000246 R12: 0000000000400bb0\nR13: 00007ffc5a470320 R14: 0000000000000000 R15: 0000000000000000\n\nThe buggy address belongs to the page:\npage:00000000440015ce refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x10beee\nflags: 0x200000000000000()\nraw: 0200000000000000 ffffea00043ff4c8 ffffea0004325608 0000000000000000\nraw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88810beee580: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88810beee600: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n>ffff88810beee680: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n                                  ^\n ffff88810beee700: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88810beee780: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n==================================================================\nDisabling lock debugging due to kernel taint\next4_rename_dir_prepare: [2] parent_de->inode=3537895424\next4_rename_dir_prepare: [3] dir=0xffff888124170140\next4_rename_dir_prepare: [4] ino=2\next4_rename_dir_prepare: ent->dir->i_ino=2 parent=-757071872\n\nReason is first directory entry which 'rec_len' is 34478, then will get illegal\nparent entry. Now, we do not check directory entry after read directory block\nin 'ext4_get_first_dir_block'.\nTo solve this issue, check directory entry in 'ext4_get_first_dir_block'.\n\n[ Trigger an ext4_error() instead of just warning if the directory is\n  missing a '.' or '..' entry.   Also make sure we return an error code\n  if the file system is corrupted.  -TYT ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49349",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46713",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/aux: Fix AUX buffer serialization\n\nOle reported that event->mmap_mutex is strictly insufficient to\nserialize the AUX buffer, add a per RB mutex to fully serialize it.\n\nNote that in the lock order comment the perf_event::mmap_mutex order\nwas already wrong, that is, it nesting under mmap_lock is not new with\nthis patch.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46713",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-13",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52867",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/radeon: possible buffer overflow\n\nBuffer 'afmt_status' of size 6 could overflow, since index 'afmt_idx' is\nchecked after access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52867",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-09-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56600",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: inet6: do not leave a dangling sk pointer in inet6_create()\n\nsock_init_data() attaches the allocated sk pointer to the provided sock\nobject. If inet6_create() fails later, the sk object is released, but the\nsock object retains the dangling sk pointer, which may cause use-after-free\nlater.\n\nClear the sock sk pointer on error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56600",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38198",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbcon: Make sure modelist not set on unregistered console\n\nIt looks like attempting to write to the \"store_modes\" sysfs node will\nrun afoul of unregistered consoles:\n\nUBSAN: array-index-out-of-bounds in drivers/video/fbdev/core/fbcon.c:122:28\nindex -1 is out of range for type 'fb_info *[32]'\n...\n fbcon_info_from_console+0x192/0x1a0 drivers/video/fbdev/core/fbcon.c:122\n fbcon_new_modelist+0xbf/0x2d0 drivers/video/fbdev/core/fbcon.c:3048\n fb_new_modelist+0x328/0x440 drivers/video/fbdev/core/fbmem.c:673\n store_modes+0x1c9/0x3e0 drivers/video/fbdev/core/fbsysfs.c:113\n dev_attr_store+0x55/0x80 drivers/base/core.c:2439\n\nstatic struct fb_info *fbcon_registered_fb[FB_MAX];\n...\nstatic signed char con2fb_map[MAX_NR_CONSOLES];\n...\nstatic struct fb_info *fbcon_info_from_console(int console)\n...\n        return fbcon_registered_fb[con2fb_map[console]];\n\nIf con2fb_map contains a -1 things go wrong here. Instead, return NULL,\nas callers of fbcon_info_from_console() are trying to compare against\nexisting \"info\" pointers, so error handling should kick in correctly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38198",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-04",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50063",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Prevent tail call between progs attached to different hooks\n\nbpf progs can be attached to kernel functions, and the attached functions\ncan take different parameters or return different return values. If\nprog attached to one kernel function tail calls prog attached to another\nkernel function, the ctx access or return value verification could be\nbypassed.\n\nFor example, if prog1 is attached to func1 which takes only 1 parameter\nand prog2 is attached to func2 which takes two parameters. Since verifier\nassumes the bpf ctx passed to prog2 is constructed based on func2's\nprototype, verifier allows prog2 to access the second parameter from\nthe bpf ctx passed to it. The problem is that verifier does not prevent\nprog1 from passing its bpf ctx to prog2 via tail call. In this case,\nthe bpf ctx passed to prog2 is constructed from func1 instead of func2,\nthat is, the assumption for ctx access verification is bypassed.\n\nAnother example, if BPF LSM prog1 is attached to hook file_alloc_security,\nand BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifier\nknows the return value rules for these two hooks, e.g. it is legal for\nbpf_lsm_audit_rule_known to return positive number 1, and it is illegal\nfor file_alloc_security to return positive number. So verifier allows\nprog2 to return positive number 1, but does not allow prog1 to return\npositive number. The problem is that verifier does not prevent prog1\nfrom calling prog2 via tail call. In this case, prog2's return value 1\nwill be used as the return value for prog1's hook file_alloc_security.\nThat is, the return value rule is bypassed.\n\nThis patch adds restriction for tail call to prevent such bypasses.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50063",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-23142",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: detect and prevent references to a freed transport in sendmsg\n\nsctp_sendmsg() re-uses associations and transports when possible by\ndoing a lookup based on the socket endpoint and the message destination\naddress, and then sctp_sendmsg_to_asoc() sets the selected transport in\nall the message chunks to be sent.\n\nThere's a possible race condition if another thread triggers the removal\nof that selected transport, for instance, by explicitly unbinding an\naddress with setsockopt(SCTP_SOCKOPT_BINDX_REM), after the chunks have\nbeen set up and before the message is sent. This can happen if the send\nbuffer is full, during the period when the sender thread temporarily\nreleases the socket lock in sctp_wait_for_sndbuf().\n\nThis causes the access to the transport data in\nsctp_outq_select_transport(), when the association outqueue is flushed,\nto result in a use-after-free read.\n\nThis change avoids this scenario by having sctp_transport_free() signal\nthe freeing of the transport, tagging it as \"dead\". In order to do this,\nthe patch restores the \"dead\" bit in struct sctp_transport, which was\nremoved in\ncommit 47faa1e4c50e (\"sctp: remove the dead field of sctp_transport\").\n\nThen, in the scenario where the sender thread has released the socket\nlock in sctp_wait_for_sndbuf(), the bit is checked again after\nre-acquiring the socket lock to detect the deletion. This is done while\nholding a reference to the transport to prevent it from being freed in\nthe process.\n\nIf the transport was deleted while the socket lock was relinquished,\nsctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry the\nsend.\n\nThe bug was found by a private syzbot instance (see the error report [1]\nand the C reproducer that triggers it [2]).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-23142",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-05",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57849",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/cpum_sf: Handle CPU hotplug remove during sampling\n\nCPU hotplug remove handling triggers the following function\ncall sequence:\n\n   CPUHP_AP_PERF_S390_SF_ONLINE  --> s390_pmu_sf_offline_cpu()\n   ...\n   CPUHP_AP_PERF_ONLINE          --> perf_event_exit_cpu()\n\nThe s390 CPUMF sampling CPU hotplug handler invokes:\n\n s390_pmu_sf_offline_cpu()\n +-->  cpusf_pmu_setup()\n       +--> setup_pmc_cpu()\n            +--> deallocate_buffers()\n\nThis function de-allocates all sampling data buffers (SDBs) allocated\nfor that CPU at event initialization. It also clears the\nPMU_F_RESERVED bit. The CPU is gone and can not be sampled.\n\nWith the event still being active on the removed CPU, the CPU event\nhotplug support in kernel performance subsystem triggers the\nfollowing function calls on the removed CPU:\n\n  perf_event_exit_cpu()\n  +--> perf_event_exit_cpu_context()\n       +--> __perf_event_exit_context()\n\t    +--> __perf_remove_from_context()\n\t         +--> event_sched_out()\n\t              +--> cpumsf_pmu_del()\n\t                   +--> cpumsf_pmu_stop()\n                                +--> hw_perf_event_update()\n\nto stop and remove the event. During removal of the event, the\nsampling device driver tries to read out the remaining samples from\nthe sample data buffers (SDBs). But they have already been freed\n(and may have been re-assigned). This may lead to a use after free\nsituation in which case the samples are most likely invalid. In the\nbest case the memory has not been reassigned and still contains\nvalid data.\n\nRemedy this situation and check if the CPU is still in reserved\nstate (bit PMU_F_RESERVED set). In this case the SDBs have not been\nreleased an contain valid data. This is always the case when\nthe event is removed (and no CPU hotplug off occured).\nIf the PMU_F_RESERVED bit is not set, the SDB buffers are gone.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57849",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49889",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid use-after-free in ext4_ext_show_leaf()\n\nIn ext4_find_extent(), path may be freed by error or be reallocated, so\nusing a previously saved *ppath may have been freed and thus may trigger\nuse-after-free, as follows:\n\next4_split_extent\n  path = *ppath;\n  ext4_split_extent_at(ppath)\n  path = ext4_find_extent(ppath)\n  ext4_split_extent_at(ppath)\n    // ext4_find_extent fails to free path\n    // but zeroout succeeds\n  ext4_ext_show_leaf(inode, path)\n    eh = path[depth].p_hdr\n    // path use-after-free !!!\n\nSimilar to ext4_split_extent_at(), we use *ppath directly as an input to\next4_ext_show_leaf(). Fix a spelling error by the way.\n\nSame problem in ext4_ext_handle_unwritten_extents(). Since 'path' is only\nused in ext4_ext_show_leaf(), remove 'path' and use *ppath directly.\n\nThis issue is triggered only when EXT_DEBUG is defined and therefore does\nnot affect functionality.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49889",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49390",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmacsec: fix UAF bug for real_dev\n\nCreate a new macsec device but not get reference to real_dev. That can\nnot ensure that real_dev is freed after macsec. That will trigger the\nUAF bug for real_dev as following:\n\n==================================================================\nBUG: KASAN: use-after-free in macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662\nCall Trace:\n ...\n macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662\n dev_get_iflink+0x73/0xe0 net/core/dev.c:637\n default_operstate net/core/link_watch.c:42 [inline]\n rfc2863_policy+0x233/0x2d0 net/core/link_watch.c:54\n linkwatch_do_dev+0x2a/0x150 net/core/link_watch.c:161\n\nAllocated by task 22209:\n ...\n alloc_netdev_mqs+0x98/0x1100 net/core/dev.c:10549\n rtnl_create_link+0x9d7/0xc00 net/core/rtnetlink.c:3235\n veth_newlink+0x20e/0xa90 drivers/net/veth.c:1748\n\nFreed by task 8:\n ...\n kfree+0xd6/0x4d0 mm/slub.c:4552\n kvfree+0x42/0x50 mm/util.c:615\n device_release+0x9f/0x240 drivers/base/core.c:2229\n kobject_cleanup lib/kobject.c:673 [inline]\n kobject_release lib/kobject.c:704 [inline]\n kref_put include/linux/kref.h:65 [inline]\n kobject_put+0x1c8/0x540 lib/kobject.c:721\n netdev_run_todo+0x72e/0x10b0 net/core/dev.c:10327\n\nAfter commit faab39f63c1f (\"net: allow out-of-order netdev unregistration\")\nand commit e5f80fcf869a (\"ipv6: give an IPv6 dev to blackhole_netdev\"), we\ncan add dev_hold_track() in macsec_dev_init() and dev_put_track() in\nmacsec_free_netdev() to fix the problem.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49390",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52851",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/mlx5: Fix init stage error handling to avoid double free of same QP and UAF\n\nIn the unlikely event that workqueue allocation fails and returns NULL in\nmlx5_mkey_cache_init(), delete the call to\nmlx5r_umr_resource_cleanup() (which frees the QP) in\nmlx5_ib_stage_post_ib_reg_umr_init().  This will avoid attempted double\nfree of the same QP when __mlx5_ib_add() does its cleanup.\n\nResolves a splat:\n\n   Syzkaller reported a UAF in ib_destroy_qp_user\n\n   workqueue: Failed to create a rescuer kthread for wq \"mkey_cache\": -EINTR\n   infiniband mlx5_0: mlx5_mkey_cache_init:981:(pid 1642):\n   failed to create work queue\n   infiniband mlx5_0: mlx5_ib_stage_post_ib_reg_umr_init:4075:(pid 1642):\n   mr cache init failed -12\n   ==================================================================\n   BUG: KASAN: slab-use-after-free in ib_destroy_qp_user (drivers/infiniband/core/verbs.c:2073)\n   Read of size 8 at addr ffff88810da310a8 by task repro_upstream/1642\n\n   Call Trace:\n   <TASK>\n   kasan_report (mm/kasan/report.c:590)\n   ib_destroy_qp_user (drivers/infiniband/core/verbs.c:2073)\n   mlx5r_umr_resource_cleanup (drivers/infiniband/hw/mlx5/umr.c:198)\n   __mlx5_ib_add (drivers/infiniband/hw/mlx5/main.c:4178)\n   mlx5r_probe (drivers/infiniband/hw/mlx5/main.c:4402)\n   ...\n   </TASK>\n\n   Allocated by task 1642:\n   __kmalloc (./include/linux/kasan.h:198 mm/slab_common.c:1026\n   mm/slab_common.c:1039)\n   create_qp (./include/linux/slab.h:603 ./include/linux/slab.h:720\n   ./include/rdma/ib_verbs.h:2795 drivers/infiniband/core/verbs.c:1209)\n   ib_create_qp_kernel (drivers/infiniband/core/verbs.c:1347)\n   mlx5r_umr_resource_init (drivers/infiniband/hw/mlx5/umr.c:164)\n   mlx5_ib_stage_post_ib_reg_umr_init (drivers/infiniband/hw/mlx5/main.c:4070)\n   __mlx5_ib_add (drivers/infiniband/hw/mlx5/main.c:4168)\n   mlx5r_probe (drivers/infiniband/hw/mlx5/main.c:4402)\n   ...\n\n   Freed by task 1642:\n   __kmem_cache_free (mm/slub.c:1826 mm/slub.c:3809 mm/slub.c:3822)\n   ib_destroy_qp_user (drivers/infiniband/core/verbs.c:2112)\n   mlx5r_umr_resource_cleanup (drivers/infiniband/hw/mlx5/umr.c:198)\n   mlx5_ib_stage_post_ib_reg_umr_init (drivers/infiniband/hw/mlx5/main.c:4076\n   drivers/infiniband/hw/mlx5/main.c:4065)\n   __mlx5_ib_add (drivers/infiniband/hw/mlx5/main.c:4168)\n   mlx5r_probe (drivers/infiniband/hw/mlx5/main.c:4402)\n   ...",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52851",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49696",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: fix use-after-free Read in tipc_named_reinit\n\nsyzbot found the following issue on:\n==================================================================\nBUG: KASAN: use-after-free in tipc_named_reinit+0x94f/0x9b0\nnet/tipc/name_distr.c:413\nRead of size 8 at addr ffff88805299a000 by task kworker/1:9/23764\n\nCPU: 1 PID: 23764 Comm: kworker/1:9 Not tainted\n5.18.0-rc4-syzkaller-00878-g17d49e6e8012 #0\nHardware name: Google Compute Engine/Google Compute Engine,\nBIOS Google 01/01/2011\nWorkqueue: events tipc_net_finalize_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0xeb/0x495\nmm/kasan/report.c:313\n print_report mm/kasan/report.c:429 [inline]\n kasan_report.cold+0xf4/0x1c6 mm/kasan/report.c:491\n tipc_named_reinit+0x94f/0x9b0 net/tipc/name_distr.c:413\n tipc_net_finalize+0x234/0x3d0 net/tipc/net.c:138\n process_one_work+0x996/0x1610 kernel/workqueue.c:2289\n worker_thread+0x665/0x1080 kernel/workqueue.c:2436\n kthread+0x2e9/0x3a0 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:298\n </TASK>\n[...]\n==================================================================\n\nIn the commit\nd966ddcc3821 (\"tipc: fix a deadlock when flushing scheduled work\"),\nthe cancel_work_sync() function just to make sure ONLY the work\ntipc_net_finalize_work() is executing/pending on any CPU completed before\ntipc namespace is destroyed through tipc_exit_net(). But this function\nis not guaranteed the work is the last queued. So, the destroyed instance\nmay be accessed in the work which will try to enqueue later.\n\nIn order to completely fix, we re-order the calling of cancel_work_sync()\nto make sure the work tipc_net_finalize_work() was last queued and it\nmust be completed by calling cancel_work_sync().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49696",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49287",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntpm: fix reference counting for struct tpm_chip\n\nThe following sequence of operations results in a refcount warning:\n\n1. Open device /dev/tpmrm.\n2. Remove module tpm_tis_spi.\n3. Write a TPM command to the file descriptor opened at step 1.\n\n------------[ cut here ]------------\nWARNING: CPU: 3 PID: 1161 at lib/refcount.c:25 kobject_get+0xa0/0xa4\nrefcount_t: addition on 0; use-after-free.\nModules linked in: tpm_tis_spi tpm_tis_core tpm mdio_bcm_unimac brcmfmac\nsha256_generic libsha256 sha256_arm hci_uart btbcm bluetooth cfg80211 vc4\nbrcmutil ecdh_generic ecc snd_soc_core crc32_arm_ce libaes\nraspberrypi_hwmon ac97_bus snd_pcm_dmaengine bcm2711_thermal snd_pcm\nsnd_timer genet snd phy_generic soundcore [last unloaded: spi_bcm2835]\nCPU: 3 PID: 1161 Comm: hold_open Not tainted 5.10.0ls-main-dirty #2\nHardware name: BCM2711\n[<c0410c3c>] (unwind_backtrace) from [<c040b580>] (show_stack+0x10/0x14)\n[<c040b580>] (show_stack) from [<c1092174>] (dump_stack+0xc4/0xd8)\n[<c1092174>] (dump_stack) from [<c0445a30>] (__warn+0x104/0x108)\n[<c0445a30>] (__warn) from [<c0445aa8>] (warn_slowpath_fmt+0x74/0xb8)\n[<c0445aa8>] (warn_slowpath_fmt) from [<c08435d0>] (kobject_get+0xa0/0xa4)\n[<c08435d0>] (kobject_get) from [<bf0a715c>] (tpm_try_get_ops+0x14/0x54 [tpm])\n[<bf0a715c>] (tpm_try_get_ops [tpm]) from [<bf0a7d6c>] (tpm_common_write+0x38/0x60 [tpm])\n[<bf0a7d6c>] (tpm_common_write [tpm]) from [<c05a7ac0>] (vfs_write+0xc4/0x3c0)\n[<c05a7ac0>] (vfs_write) from [<c05a7ee4>] (ksys_write+0x58/0xcc)\n[<c05a7ee4>] (ksys_write) from [<c04001a0>] (ret_fast_syscall+0x0/0x4c)\nException stack(0xc226bfa8 to 0xc226bff0)\nbfa0:                   00000000 000105b4 00000003 beafe664 00000014 00000000\nbfc0: 00000000 000105b4 000103f8 00000004 00000000 00000000 b6f9c000 beafe684\nbfe0: 0000006c beafe648 0001056c b6eb6944\n---[ end trace d4b8409def9b8b1f ]---\n\nThe reason for this warning is the attempt to get the chip->dev reference\nin tpm_common_write() although the reference counter is already zero.\n\nSince commit 8979b02aaf1d (\"tpm: Fix reference count to main device\") the\nextra reference used to prevent a premature zero counter is never taken,\nbecause the required TPM_CHIP_FLAG_TPM2 flag is never set.\n\nFix this by moving the TPM 2 character device handling from\ntpm_chip_alloc() to tpm_add_char_device() which is called at a later point\nin time when the flag has been set in case of TPM2.\n\nCommit fdc915f7f719 (\"tpm: expose spaces via a device link /dev/tpmrm<n>\")\nalready introduced function tpm_devs_release() to release the extra\nreference but did not implement the required put on chip->devs that results\nin the call of this function.\n\nFix this by putting chip->devs in tpm_chip_unregister().\n\nFinally move the new implementation for the TPM 2 handling into a new\nfunction to avoid multiple checks for the TPM_CHIP_FLAG_TPM2 flag in the\ngood case and error cases.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49287",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47012",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/siw: Fix a use after free in siw_alloc_mr\n\nOur code analyzer reported a UAF.\n\nIn siw_alloc_mr(), it calls siw_mr_add_mem(mr,..). In the implementation of\nsiw_mr_add_mem(), mem is assigned to mr->mem and then mem is freed via\nkfree(mem) if xa_alloc_cyclic() failed. Here, mr->mem still point to a\nfreed object. After, the execution continue up to the err_out branch of\nsiw_alloc_mr, and the freed mr->mem is used in siw_mr_drop_mem(mr).\n\nMy patch moves \"mr->mem = mem\" behind the if (xa_alloc_cyclic(..)<0) {}\nsection, to avoid the uaf.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47012",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2024-12-09",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47247",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix use-after-free of encap entry in neigh update handler\n\nFunction mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl lock\nremoval from TC filter update path and properly handle concurrent encap\nentry insertion/deletion which can lead to following use-after-free:\n\n [23827.464923] ==================================================================\n [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker/u20:6/21635\n [23827.472251]\n [23827.472615] CPU: 9 PID: 21635 Comm: kworker/u20:6 Not tainted 5.13.0-rc3+ #5\n [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core]\n [23827.476731] Call Trace:\n [23827.477260]  dump_stack+0xbb/0x107\n [23827.477906]  print_address_description.constprop.0+0x18/0x140\n [23827.478896]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.479879]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.480905]  kasan_report.cold+0x7c/0xd8\n [23827.481701]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.482744]  kasan_check_range+0x145/0x1a0\n [23827.493112]  mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.494054]  ? mlx5e_tc_tun_encap_info_equal_generic+0x140/0x140 [mlx5_core]\n [23827.495296]  mlx5e_rep_neigh_update+0x41e/0x5e0 [mlx5_core]\n [23827.496338]  ? mlx5e_rep_neigh_entry_release+0xb80/0xb80 [mlx5_core]\n [23827.497486]  ? read_word_at_a_time+0xe/0x20\n [23827.498250]  ? strscpy+0xa0/0x2a0\n [23827.498889]  process_one_work+0x8ac/0x14e0\n [23827.499638]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n [23827.500537]  ? pwq_dec_nr_in_flight+0x2c0/0x2c0\n [23827.501359]  ? rwlock_bug.part.0+0x90/0x90\n [23827.502116]  worker_thread+0x53b/0x1220\n [23827.502831]  ? process_one_work+0x14e0/0x14e0\n [23827.503627]  kthread+0x328/0x3f0\n [23827.504254]  ? _raw_spin_unlock_irq+0x24/0x40\n [23827.505065]  ? __kthread_bind_mask+0x90/0x90\n [23827.505912]  ret_from_fork+0x1f/0x30\n [23827.506621]\n [23827.506987] Allocated by task 28248:\n [23827.507694]  kasan_save_stack+0x1b/0x40\n [23827.508476]  __kasan_kmalloc+0x7c/0x90\n [23827.509197]  mlx5e_attach_encap+0xde1/0x1d40 [mlx5_core]\n [23827.510194]  mlx5e_tc_add_fdb_flow+0x397/0xc40 [mlx5_core]\n [23827.511218]  __mlx5e_add_fdb_flow+0x519/0xb30 [mlx5_core]\n [23827.512234]  mlx5e_configure_flower+0x191c/0x4870 [mlx5_core]\n [23827.513298]  tc_setup_cb_add+0x1d5/0x420\n [23827.514023]  fl_hw_replace_filter+0x382/0x6a0 [cls_flower]\n [23827.514975]  fl_change+0x2ceb/0x4a51 [cls_flower]\n [23827.515821]  tc_new_tfilter+0x89a/0x2070\n [23827.516548]  rtnetlink_rcv_msg+0x644/0x8c0\n [23827.517300]  netlink_rcv_skb+0x11d/0x340\n [23827.518021]  netlink_unicast+0x42b/0x700\n [23827.518742]  netlink_sendmsg+0x743/0xc20\n [23827.519467]  sock_sendmsg+0xb2/0xe0\n [23827.520131]  ____sys_sendmsg+0x590/0x770\n [23827.520851]  ___sys_sendmsg+0xd8/0x160\n [23827.521552]  __sys_sendmsg+0xb7/0x140\n [23827.522238]  do_syscall_64+0x3a/0x70\n [23827.522907]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n [23827.523797]\n [23827.524163] Freed by task 25948:\n [23827.524780]  kasan_save_stack+0x1b/0x40\n [23827.525488]  kasan_set_track+0x1c/0x30\n [23827.526187]  kasan_set_free_info+0x20/0x30\n [23827.526968]  __kasan_slab_free+0xed/0x130\n [23827.527709]  slab_free_freelist_hook+0xcf/0x1d0\n [23827.528528]  kmem_cache_free_bulk+0x33a/0x6e0\n [23827.529317]  kfree_rcu_work+0x55f/0xb70\n [23827.530024]  process_one_work+0x8ac/0x14e0\n [23827.530770]  worker_thread+0x53b/0x1220\n [23827.531480]  kthread+0x328/0x3f0\n [23827.532114]  ret_from_fork+0x1f/0x30\n [23827.532785]\n [23827.533147] Last potentially related work creation:\n [23827.534007]  kasan_save_stack+0x1b/0x40\n [23827.534710]  kasan_record_aux_stack+0xab/0xc0\n [23827.535492]  kvfree_call_rcu+0x31/0x7b0\n [23827.536206]  mlx5e_tc_del\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47247",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48805",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: ax88179_178a: Fix out-of-bounds accesses in RX fixup\n\nax88179_rx_fixup() contains several out-of-bounds accesses that can be\ntriggered by a malicious (or defective) USB device, in particular:\n\n - The metadata array (hdr_off..hdr_off+2*pkt_cnt) can be out of bounds,\n   causing OOB reads and (on big-endian systems) OOB endianness flips.\n - A packet can overlap the metadata array, causing a later OOB\n   endianness flip to corrupt data used by a cloned SKB that has already\n   been handed off into the network stack.\n - A packet SKB can be constructed whose tail is far beyond its end,\n   causing out-of-bounds heap data to be considered part of the SKB's\n   data.\n\nI have tested that this can be used by a malicious USB device to send a\nbogus ICMPv6 Echo Request and receive an ICMPv6 Echo Reply in response\nthat contains random kernel heap data.\nIt's probably also possible to get OOB writes from this on a\nlittle-endian system somehow - maybe by triggering skb_cow() via IP\noptions processing -, but I haven't tested that.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48805",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-03-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47010",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: Only allow init netns to set default tcp cong to a restricted algo\n\ntcp_set_default_congestion_control() is netns-safe in that it writes\nto &net->ipv4.tcp_congestion_control, but it also sets\nca->flags |= TCP_CONG_NON_RESTRICTED which is not namespaced.\nThis has the unintended side-effect of changing the global\nnet.ipv4.tcp_allowed_congestion_control sysctl, despite the fact that it\nis read-only: 97684f0970f6 (\"net: Make tcp_allowed_congestion_control\nreadonly in non-init netns\")\n\nResolve this netns \"leak\" by only allowing the init netns to set the\ndefault algorithm to one that is restricted. This restriction could be\nremoved if tcp_allowed_congestion_control were namespace-ified in the\nfuture.\n\nThis bug was uncovered with\nhttps://github.com/JonathonReinhart/linux-netns-sysctl-verify",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47010",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-03-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38248",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbridge: mcast: Fix use-after-free during router port configuration\n\nThe bridge maintains a global list of ports behind which a multicast\nrouter resides. The list is consulted during forwarding to ensure\nmulticast packets are forwarded to these ports even if the ports are not\nmember in the matching MDB entry.\n\nWhen per-VLAN multicast snooping is enabled, the per-port multicast\ncontext is disabled on each port and the port is removed from the global\nrouter port list:\n\n # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1\n # ip link add name dummy1 up master br1 type dummy\n # ip link set dev dummy1 type bridge_slave mcast_router 2\n $ bridge -d mdb show | grep router\n router ports on br1: dummy1\n # ip link set dev br1 type bridge mcast_vlan_snooping 1\n $ bridge -d mdb show | grep router\n\nHowever, the port can be re-added to the global list even when per-VLAN\nmulticast snooping is enabled:\n\n # ip link set dev dummy1 type bridge_slave mcast_router 0\n # ip link set dev dummy1 type bridge_slave mcast_router 2\n $ bridge -d mdb show | grep router\n router ports on br1: dummy1\n\nSince commit 4b30ae9adb04 (\"net: bridge: mcast: re-implement\nbr_multicast_{enable, disable}_port functions\"), when per-VLAN multicast\nsnooping is enabled, multicast disablement on a port will disable the\nper-{port, VLAN} multicast contexts and not the per-port one. As a\nresult, a port will remain in the global router port list even after it\nis deleted. This will lead to a use-after-free [1] when the list is\ntraversed (when adding a new port to the list, for example):\n\n # ip link del dev dummy1\n # ip link add name dummy2 up master br1 type dummy\n # ip link set dev dummy2 type bridge_slave mcast_router 2\n\nSimilarly, stale entries can also be found in the per-VLAN router port\nlist. When per-VLAN multicast snooping is disabled, the per-{port, VLAN}\ncontexts are disabled on each port and the port is removed from the\nper-VLAN router port list:\n\n # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1 mcast_vlan_snooping 1\n # ip link add name dummy1 up master br1 type dummy\n # bridge vlan add vid 2 dev dummy1\n # bridge vlan global set vid 2 dev br1 mcast_snooping 1\n # bridge vlan set vid 2 dev dummy1 mcast_router 2\n $ bridge vlan global show dev br1 vid 2 | grep router\n       router ports: dummy1\n # ip link set dev br1 type bridge mcast_vlan_snooping 0\n $ bridge vlan global show dev br1 vid 2 | grep router\n\nHowever, the port can be re-added to the per-VLAN list even when\nper-VLAN multicast snooping is disabled:\n\n # bridge vlan set vid 2 dev dummy1 mcast_router 0\n # bridge vlan set vid 2 dev dummy1 mcast_router 2\n $ bridge vlan global show dev br1 vid 2 | grep router\n       router ports: dummy1\n\nWhen the VLAN is deleted from the port, the per-{port, VLAN} multicast\ncontext will not be disabled since multicast snooping is not enabled\non the VLAN. As a result, the port will remain in the per-VLAN router\nport list even after it is no longer member in the VLAN. This will lead\nto a use-after-free [2] when the list is traversed (when adding a new\nport to the list, for example):\n\n # ip link add name dummy2 up master br1 type dummy\n # bridge vlan add vid 2 dev dummy2\n # bridge vlan del vid 2 dev dummy1\n # bridge vlan set vid 2 dev dummy2 mcast_router 2\n\nFix these issues by removing the port from the relevant (global or\nper-VLAN) router port list in br_multicast_port_ctx_deinit(). The\nfunction is invoked during port deletion with the per-port multicast\ncontext and during VLAN deletion with the per-{port, VLAN} multicast\ncontext.\n\nNote that deleting the multicast router timer is not enough as it only\ntakes care of the temporary multicast router states (1 or 3) and not the\npermanent one (2).\n\n[1]\nBUG: KASAN: slab-out-of-bounds in br_multicast_add_router.part.0+0x3f1/0x560\nWrite of size 8 at addr ffff888004a67328 by task ip/384\n[...]\nCall Trace:\n <TASK>\n dump_stack\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38248",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-09",
                    "modification_date": "2025-11-19",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53282",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix use-after-free KFENCE violation during sysfs firmware write\n\nDuring the sysfs firmware write process, a use-after-free read warning is\nlogged from the lpfc_wr_object() routine:\n\n  BUG: KFENCE: use-after-free read in lpfc_wr_object+0x235/0x310 [lpfc]\n  Use-after-free read at 0x0000000000cf164d (in kfence-#111):\n  lpfc_wr_object+0x235/0x310 [lpfc]\n  lpfc_write_firmware.cold+0x206/0x30d [lpfc]\n  lpfc_sli4_request_firmware_update+0xa6/0x100 [lpfc]\n  lpfc_request_firmware_upgrade_store+0x66/0xb0 [lpfc]\n  kernfs_fop_write_iter+0x121/0x1b0\n  new_sync_write+0x11c/0x1b0\n  vfs_write+0x1ef/0x280\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x59/0x90\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe driver accessed wr_object pointer data, which was initialized into\nmailbox payload memory, after the mailbox object was released back to the\nmailbox pool.\n\nFix by moving the mailbox free calls to the end of the routine ensuring\nthat we don't reference internal mailbox memory after release.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53282",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38618",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: Do not allow binding to VMADDR_PORT_ANY\n\nIt is possible for a vsock to autobind to VMADDR_PORT_ANY. This can\ncause a use-after-free when a connection is made to the bound socket.\nThe socket returned by accept() also has port VMADDR_PORT_ANY but is not\non the list of unbound sockets. Binding it will result in an extra\nrefcount decrement similar to the one fixed in fcdd2242c023 (vsock: Keep\nthe binding until socket destruction).\n\nModify the check in __vsock_bind_connectible() to also prevent binding\nto VMADDR_PORT_ANY.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38618",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-40940",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Fix tainted pointer delete is case of flow rules creation fail\n\nIn case of flow rule creation fail in mlx5_lag_create_port_sel_table(),\ninstead of previously created rules, the tainted pointer is deleted\ndeveral times.\nFix this bug by using correct flow rules pointers.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-40940",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-12",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-26882",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ip_tunnel: make sure to pull inner header in ip_tunnel_rcv()\n\nApply the same fix than ones found in :\n\n8d975c15c0cd (\"ip6_tunnel: make sure to pull inner header in __ip6_tnl_rcv()\")\n1ca1ba465e55 (\"geneve: make sure to pull inner header in geneve_rx()\")\n\nWe have to save skb->network_header in a temporary variable\nin order to be able to recompute the network_header pointer\nafter a pskb_inet_may_pull() call.\n\npskb_inet_may_pull() makes sure the needed headers are in skb->head.\n\nsyzbot reported:\nBUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n BUG: KMSAN: uninit-value in INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n BUG: KMSAN: uninit-value in IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n BUG: KMSAN: uninit-value in ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __INET_ECN_decapsulate include/net/inet_ecn.h:253 [inline]\n  INET_ECN_decapsulate include/net/inet_ecn.h:275 [inline]\n  IP_ECN_decapsulate include/net/inet_ecn.h:302 [inline]\n  ip_tunnel_rcv+0xed9/0x2ed0 net/ipv4/ip_tunnel.c:409\n  __ipgre_rcv+0x9bc/0xbc0 net/ipv4/ip_gre.c:389\n  ipgre_rcv net/ipv4/ip_gre.c:411 [inline]\n  gre_rcv+0x423/0x19f0 net/ipv4/ip_gre.c:447\n  gre_rcv+0x2a4/0x390 net/ipv4/gre_demux.c:163\n  ip_protocol_deliver_rcu+0x264/0x1300 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x2b8/0x440 net/ipv4/ip_input.c:233\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254\n  dst_input include/net/dst.h:461 [inline]\n  ip_rcv_finish net/ipv4/ip_input.c:449 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip_rcv+0x46f/0x760 net/ipv4/ip_input.c:569\n  __netif_receive_skb_one_core net/core/dev.c:5534 [inline]\n  __netif_receive_skb+0x1a6/0x5a0 net/core/dev.c:5648\n  netif_receive_skb_internal net/core/dev.c:5734 [inline]\n  netif_receive_skb+0x58/0x660 net/core/dev.c:5793\n  tun_rx_batched+0x3ee/0x980 drivers/net/tun.c:1556\n  tun_get_user+0x53b9/0x66e0 drivers/net/tun.c:2009\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n  __alloc_pages+0x9a6/0xe00 mm/page_alloc.c:4590\n  alloc_pages_mpol+0x62b/0x9d0 mm/mempolicy.c:2133\n  alloc_pages+0x1be/0x1e0 mm/mempolicy.c:2204\n  skb_page_frag_refill+0x2bf/0x7c0 net/core/sock.c:2909\n  tun_build_skb drivers/net/tun.c:1686 [inline]\n  tun_get_user+0xe0a/0x66e0 drivers/net/tun.c:1826\n  tun_chr_write_iter+0x3af/0x5d0 drivers/net/tun.c:2055\n  call_write_iter include/linux/fs.h:2087 [inline]\n  new_sync_write fs/read_write.c:497 [inline]\n  vfs_write+0xb6b/0x1520 fs/read_write.c:590\n  ksys_write+0x20f/0x4c0 fs/read_write.c:643\n  __do_sys_write fs/read_write.c:655 [inline]\n  __se_sys_write fs/read_write.c:652 [inline]\n  __x64_sys_write+0x93/0xd0 fs/read_write.c:652\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26882",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-17",
                    "modification_date": "2024-12-20",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49196",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/pseries: Fix use after free in remove_phb_dynamic()\n\nIn remove_phb_dynamic() we use &phb->io_resource, after we've called\ndevice_unregister(&host_bridge->dev). But the unregister may have freed\nphb, because pcibios_free_controller_deferred() is the release function\nfor the host_bridge.\n\nIf there are no outstanding references when we call device_unregister()\nthen phb will be freed out from under us.\n\nThis has gone mainly unnoticed, but with slub_debug and page_poison\nenabled it can lead to a crash:\n\n  PID: 7574   TASK: c0000000d492cb80  CPU: 13  COMMAND: \"drmgr\"\n   #0 [c0000000e4f075a0] crash_kexec at c00000000027d7dc\n   #1 [c0000000e4f075d0] oops_end at c000000000029608\n   #2 [c0000000e4f07650] __bad_page_fault at c0000000000904b4\n   #3 [c0000000e4f076c0] do_bad_slb_fault at c00000000009a5a8\n   #4 [c0000000e4f076f0] data_access_slb_common_virt at c000000000008b30\n   Data SLB Access [380] exception frame:\n   R0:  c000000000167250    R1:  c0000000e4f07a00    R2:  c000000002a46100\n   R3:  c000000002b39ce8    R4:  00000000000000c0    R5:  00000000000000a9\n   R6:  3894674d000000c0    R7:  0000000000000000    R8:  00000000000000ff\n   R9:  0000000000000100    R10: 6b6b6b6b6b6b6b6b    R11: 0000000000008000\n   R12: c00000000023da80    R13: c0000009ffd38b00    R14: 0000000000000000\n   R15: 000000011c87f0f0    R16: 0000000000000006    R17: 0000000000000003\n   R18: 0000000000000002    R19: 0000000000000004    R20: 0000000000000005\n   R21: 000000011c87ede8    R22: 000000011c87c5a8    R23: 000000011c87d3a0\n   R24: 0000000000000000    R25: 0000000000000001    R26: c0000000e4f07cc8\n   R27: c00000004d1cc400    R28: c0080000031d00e8    R29: c00000004d23d800\n   R30: c00000004d1d2400    R31: c00000004d1d2540\n   NIP: c000000000167258    MSR: 8000000000009033    OR3: c000000000e9f474\n   CTR: 0000000000000000    LR:  c000000000167250    XER: 0000000020040003\n   CCR: 0000000024088420    MQ:  0000000000000000    DAR: 6b6b6b6b6b6b6ba3\n   DSISR: c0000000e4f07920     Syscall Result: fffffffffffffff2\n   [NIP  : release_resource+56]\n   [LR   : release_resource+48]\n   #5 [c0000000e4f07a00] release_resource at c000000000167258  (unreliable)\n   #6 [c0000000e4f07a30] remove_phb_dynamic at c000000000105648\n   #7 [c0000000e4f07ab0] dlpar_remove_slot at c0080000031a09e8 [rpadlpar_io]\n   #8 [c0000000e4f07b50] remove_slot_store at c0080000031a0b9c [rpadlpar_io]\n   #9 [c0000000e4f07be0] kobj_attr_store at c000000000817d8c\n  #10 [c0000000e4f07c00] sysfs_kf_write at c00000000063e504\n  #11 [c0000000e4f07c20] kernfs_fop_write_iter at c00000000063d868\n  #12 [c0000000e4f07c70] new_sync_write at c00000000054339c\n  #13 [c0000000e4f07d10] vfs_write at c000000000546624\n  #14 [c0000000e4f07d60] ksys_write at c0000000005469f4\n  #15 [c0000000e4f07db0] system_call_exception at c000000000030840\n  #16 [c0000000e4f07e10] system_call_vectored_common at c00000000000c168\n\nTo avoid it, we can take a reference to the host_bridge->dev until we're\ndone using phb. Then when we drop the reference the phb will be freed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49196",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50630",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: hugetlb: fix UAF in hugetlb_handle_userfault\n\nThe vma_lock and hugetlb_fault_mutex are dropped before handling userfault\nand reacquire them again after handle_userfault(), but reacquire the\nvma_lock could lead to UAF[1,2] due to the following race,\n\nhugetlb_fault\n  hugetlb_no_page\n    /*unlock vma_lock */\n    hugetlb_handle_userfault\n      handle_userfault\n        /* unlock mm->mmap_lock*/\n                                           vm_mmap_pgoff\n                                             do_mmap\n                                               mmap_region\n                                                 munmap_vma_range\n                                                   /* clean old vma */\n        /* lock vma_lock again  <--- UAF */\n    /* unlock vma_lock */\n\nSince the vma_lock will unlock immediately after\nhugetlb_handle_userfault(), let's drop the unneeded lock and unlock in\nhugetlb_handle_userfault() to fix the issue.\n\n[1] https://lore.kernel.org/linux-mm/000000000000d5e00a05e834962e@google.com/\n[2] https://lore.kernel.org/linux-mm/20220921014457.1668-1-liuzixian4@huawei.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46759",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (adc128d818) Fix underflows seen when writing limit attributes\n\nDIV_ROUND_CLOSEST() after kstrtol() results in an underflow if a large\nnegative number such as -9223372036854775808 is provided by the user.\nFix it by reordering clamp_val() and DIV_ROUND_CLOSEST() operations.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46759",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50328",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: fix potential use-after-free in jbd2_fc_wait_bufs\n\nIn 'jbd2_fc_wait_bufs' use 'bh' after put buffer head reference count\nwhich may lead to use-after-free.\nSo judge buffer if uptodate before put buffer head reference count.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50328",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21999",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nproc: fix UAF in proc_get_inode()\n\nFix race between rmmod and /proc/XXX's inode instantiation.\n\nThe bug is that pde->proc_ops don't belong to /proc, it belongs to a\nmodule, therefore dereferencing it after /proc entry has been registered\nis a bug unless use_pde/unuse_pde() pair has been used.\n\nuse_pde/unuse_pde can be avoided (2 atomic ops!) because pde->proc_ops\nnever changes so information necessary for inode instantiation can be\nsaved _before_ proc_register() in PDE itself and used later, avoiding\npde->proc_ops->...  dereference.\n\n      rmmod                         lookup\nsys_delete_module\n                         proc_lookup_de\n\t\t\t   pde_get(de);\n\t\t\t   proc_get_inode(dir->i_sb, de);\n  mod->exit()\n    proc_remove\n      remove_proc_subtree\n       proc_entry_rundown(de);\n  free_module(mod);\n\n                               if (S_ISREG(inode->i_mode))\n\t                         if (de->proc_ops->proc_read_iter)\n                           --> As module is already freed, will trigger UAF\n\nBUG: unable to handle page fault for address: fffffbfff80a702b\nPGD 817fc4067 P4D 817fc4067 PUD 817fc0067 PMD 102ef4067 PTE 0\nOops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 26 UID: 0 PID: 2667 Comm: ls Tainted: G\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996)\nRIP: 0010:proc_get_inode+0x302/0x6e0\nRSP: 0018:ffff88811c837998 EFLAGS: 00010a06\nRAX: dffffc0000000000 RBX: ffffffffc0538140 RCX: 0000000000000007\nRDX: 1ffffffff80a702b RSI: 0000000000000001 RDI: ffffffffc0538158\nRBP: ffff8881299a6000 R08: 0000000067bbe1e5 R09: 1ffff11023906f20\nR10: ffffffffb560ca07 R11: ffffffffb2b43a58 R12: ffff888105bb78f0\nR13: ffff888100518048 R14: ffff8881299a6004 R15: 0000000000000001\nFS:  00007f95b9686840(0000) GS:ffff8883af100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: fffffbfff80a702b CR3: 0000000117dd2000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n proc_lookup_de+0x11f/0x2e0\n __lookup_slow+0x188/0x350\n walk_component+0x2ab/0x4f0\n path_lookupat+0x120/0x660\n filename_lookup+0x1ce/0x560\n vfs_statx+0xac/0x150\n __do_sys_newstat+0x96/0x110\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n[adobriyan@gmail.com: don't do 2 atomic ops on the common path]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21999",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-03",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49826",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nata: libata-transport: fix double ata_host_put() in ata_tport_add()\n\nIn the error path in ata_tport_add(), when calling put_device(),\nata_tport_release() is called, it will put the refcount of 'ap->host'.\n\nAnd then ata_host_put() is called again, the refcount is decreased\nto 0, ata_host_release() is called, all ports are freed and set to\nnull.\n\nWhen unbinding the device after failure, ata_host_stop() is called\nto release the resources, it leads a null-ptr-deref(), because all\nthe ports all freed and null.\n\nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000008\nCPU: 7 PID: 18671 Comm: modprobe Kdump: loaded Tainted: G            E      6.1.0-rc3+ #8\npstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : ata_host_stop+0x3c/0x84 [libata]\nlr : release_nodes+0x64/0xd0\nCall trace:\n ata_host_stop+0x3c/0x84 [libata]\n release_nodes+0x64/0xd0\n devres_release_all+0xbc/0x1b0\n device_unbind_cleanup+0x20/0x70\n really_probe+0x158/0x320\n __driver_probe_device+0x84/0x120\n driver_probe_device+0x44/0x120\n __driver_attach+0xb4/0x220\n bus_for_each_dev+0x78/0xdc\n driver_attach+0x2c/0x40\n bus_add_driver+0x184/0x240\n driver_register+0x80/0x13c\n __pci_register_driver+0x4c/0x60\n ahci_pci_driver_init+0x30/0x1000 [ahci]\n\nFix this by removing redundant ata_host_put() in the error path.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49826",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48951",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: ops: Check bounds for second channel in snd_soc_put_volsw_sx()\n\nThe bounds checks in snd_soc_put_volsw_sx() are only being applied to the\nfirst channel, meaning it is possible to write out of bounds values to the\nsecond channel in stereo controls. Add appropriate checks.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48951",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56616",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/dp_mst: Fix MST sideband message body length check\n\nFix the MST sideband message body length check, which must be at least 1\nbyte accounting for the message body CRC (aka message data CRC) at the\nend of the message.\n\nThis fixes a case where an MST branch device returns a header with a\ncorrect header CRC (indicating a correctly received body length), with\nthe body length being incorrectly set to 0. This will later lead to a\nmemory corruption in drm_dp_sideband_append_payload() and the following\nerrors in dmesg:\n\n   UBSAN: array-index-out-of-bounds in drivers/gpu/drm/display/drm_dp_mst_topology.c:786:25\n   index -1 is out of range for type 'u8 [48]'\n   Call Trace:\n    drm_dp_sideband_append_payload+0x33d/0x350 [drm_display_helper]\n    drm_dp_get_one_sb_msg+0x3ce/0x5f0 [drm_display_helper]\n    drm_dp_mst_hpd_irq_handle_event+0xc8/0x1580 [drm_display_helper]\n\n   memcpy: detected field-spanning write (size 18446744073709551615) of single field \"&msg->msg[msg->curlen]\" at drivers/gpu/drm/display/drm_dp_mst_topology.c:791 (size 256)\n   Call Trace:\n    drm_dp_sideband_append_payload+0x324/0x350 [drm_display_helper]\n    drm_dp_get_one_sb_msg+0x3ce/0x5f0 [drm_display_helper]\n    drm_dp_mst_hpd_irq_handle_event+0xc8/0x1580 [drm_display_helper]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56616",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47639",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/mmu: Zap _all_ roots when unmapping gfn range in TDP MMU\n\nZap both valid and invalid roots when zapping/unmapping a gfn range, as\nKVM must ensure it holds no references to the freed page after returning\nfrom the unmap operation.  Most notably, the TDP MMU doesn't zap invalid\nroots in mmu_notifier callbacks.  This leads to use-after-free and other\nissues if the mmu_notifier runs to completion while an invalid root\nzapper yields as KVM fails to honor the requirement that there must be\n_no_ references to the page after the mmu_notifier returns.\n\nThe bug is most easily reproduced by hacking KVM to cause a collision\nbetween set_nx_huge_pages() and kvm_mmu_notifier_release(), but the bug\nexists between kvm_mmu_notifier_invalidate_range_start() and memslot\nupdates as well.  Invalidating a root ensures pages aren't accessible by\nthe guest, and KVM won't read or write page data itself, but KVM will\ntrigger e.g. kvm_set_pfn_dirty() when zapping SPTEs, and thus completing\na zap of an invalid root _after_ the mmu_notifier returns is fatal.\n\n  WARNING: CPU: 24 PID: 1496 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:173 [kvm]\n  RIP: 0010:kvm_is_zone_device_pfn+0x96/0xa0 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_set_pfn_dirty+0xa8/0xe0 [kvm]\n   __handle_changed_spte+0x2ab/0x5e0 [kvm]\n   __handle_changed_spte+0x2ab/0x5e0 [kvm]\n   __handle_changed_spte+0x2ab/0x5e0 [kvm]\n   zap_gfn_range+0x1f3/0x310 [kvm]\n   kvm_tdp_mmu_zap_invalidated_roots+0x50/0x90 [kvm]\n   kvm_mmu_zap_all_fast+0x177/0x1a0 [kvm]\n   set_nx_huge_pages+0xb4/0x190 [kvm]\n   param_attr_store+0x70/0x100\n   module_attr_store+0x19/0x30\n   kernfs_fop_write_iter+0x119/0x1b0\n   new_sync_write+0x11c/0x1b0\n   vfs_write+0x1cc/0x270\n   ksys_write+0x5f/0xe0\n   do_syscall_64+0x38/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n   </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47639",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49385",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver: base: fix UAF when driver_attach failed\n\nWhen driver_attach(drv); failed, the driver_private will be freed.\nBut it has been added to the bus, which caused a UAF.\n\nTo fix it, we need to delete it from the bus when failed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49385",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53446",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free\n\nStruct pcie_link_state->downstream is a pointer to the pci_dev of function\n0.  Previously we retained that pointer when removing function 0, and\nsubsequent ASPM policy changes dereferenced it, resulting in a\nuse-after-free warning from KASAN, e.g.:\n\n  # echo 1 > /sys/bus/pci/devices/0000:03:00.0/remove\n  # echo powersave > /sys/module/pcie_aspm/parameters/policy\n\n  BUG: KASAN: slab-use-after-free in pcie_config_aspm_link+0x42d/0x500\n  Call Trace:\n   kasan_report+0xae/0xe0\n   pcie_config_aspm_link+0x42d/0x500\n   pcie_aspm_set_policy+0x8e/0x1a0\n   param_attr_store+0x162/0x2c0\n   module_attr_store+0x3e/0x80\n\nPCIe spec r6.0, sec 7.5.3.7, recommends that software program the same ASPM\nControl value in all functions of multi-function devices.\n\nDisable ASPM and free the pcie_link_state when any child function is\nremoved so we can discard the dangling pcie_link_state->downstream pointer\nand maintain the same ASPM Control configuration for all functions.\n\n[bhelgaas: commit log and comment]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53446",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48801",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: buffer: Fix file related error handling in IIO_BUFFER_GET_FD_IOCTL\n\nIf we fail to copy the just created file descriptor to userland, we\ntry to clean up by putting back 'fd' and freeing 'ib'. The code uses\nput_unused_fd() for the former which is wrong, as the file descriptor\nwas already published by fd_install() which gets called internally by\nanon_inode_getfd().\n\nThis makes the error handling code leaving a half cleaned up file\ndescriptor table around and a partially destructed 'file' object,\nallowing userland to play use-after-free tricks on us, by abusing\nthe still usable fd and making the code operate on a dangling\n'file->private_data' pointer.\n\nInstead of leaving the kernel in a partially corrupted state, don't\nattempt to explicitly clean up and leave this to the process exit\npath that'll release any still valid fds, including the one created\nby the previous call to anon_inode_getfd(). Simply return -EFAULT to\nindicate the error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48801",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-09-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48848",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/osnoise: Do not unregister events twice\n\nNicolas reported that using:\n\n # trace-cmd record -e all -M 10 -p osnoise --poll\n\nResulted in the following kernel warning:\n\n ------------[ cut here ]------------\n WARNING: CPU: 0 PID: 1217 at kernel/tracepoint.c:404 tracepoint_probe_unregister+0x280/0x370\n [...]\n CPU: 0 PID: 1217 Comm: trace-cmd Not tainted 5.17.0-rc6-next-20220307-nico+ #19\n RIP: 0010:tracepoint_probe_unregister+0x280/0x370\n [...]\n CR2: 00007ff919b29497 CR3: 0000000109da4005 CR4: 0000000000170ef0\n Call Trace:\n  <TASK>\n  osnoise_workload_stop+0x36/0x90\n  tracing_set_tracer+0x108/0x260\n  tracing_set_trace_write+0x94/0xd0\n  ? __check_object_size.part.0+0x10a/0x150\n  ? selinux_file_permission+0x104/0x150\n  vfs_write+0xb5/0x290\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7ff919a18127\n [...]\n ---[ end trace 0000000000000000 ]---\n\nThe warning complains about an attempt to unregister an\nunregistered tracepoint.\n\nThis happens on trace-cmd because it first stops tracing, and\nthen switches the tracer to nop. Which is equivalent to:\n\n  # cd /sys/kernel/tracing/\n  # echo osnoise > current_tracer\n  # echo 0 > tracing_on\n  # echo nop > current_tracer\n\nThe osnoise tracer stops the workload when no trace instance\nis actually collecting data. This can be caused both by\ndisabling tracing or disabling the tracer itself.\n\nTo avoid unregistering events twice, use the existing\ntrace_osnoise_callback_enabled variable to check if the events\n(and the workload) are actually active before trying to\ndeactivate them.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48848",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50186",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: explicitly clear the sk pointer, when pf->create fails\n\nWe have recently noticed the exact same KASAN splat as in commit\n6cd4a78d962b (\"net: do not leave a dangling sk pointer, when socket\ncreation fails\"). The problem is that commit did not fully address the\nproblem, as some pf->create implementations do not use sk_common_release\nin their error paths.\n\nFor example, we can use the same reproducer as in the above commit, but\nchanging ping to arping. arping uses AF_PACKET socket and if packet_create\nfails, it will just sk_free the allocated sk object.\n\nWhile we could chase all the pf->create implementations and make sure they\nNULL the freed sk object on error from the socket, we can't guarantee\nfuture protocols will not make the same mistake.\n\nSo it is easier to just explicitly NULL the sk pointer upon return from\npf->create in __sock_create. We do know that pf->create always releases the\nallocated sk object on error, so if the pointer is not NULL, it is\ndefinitely dangling.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50186",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-08",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50329",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock, bfq: fix uaf for bfqq in bfq_exit_icq_bfqq\n\nCommit 64dc8c732f5c (\"block, bfq: fix possible uaf for 'bfqq->bic'\")\nwill access 'bic->bfqq' in bic_set_bfqq(), however, bfq_exit_icq_bfqq()\ncan free bfqq first, and then call bic_set_bfqq(), which will cause uaf.\n\nFix the problem by moving bfq_exit_bfqq() behind bic_set_bfqq().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50329",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47748",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvhost_vdpa: assign irq bypass producer token correctly\n\nWe used to call irq_bypass_unregister_producer() in\nvhost_vdpa_setup_vq_irq() which is problematic as we don't know if the\ntoken pointer is still valid or not.\n\nActually, we use the eventfd_ctx as the token so the life cycle of the\ntoken should be bound to the VHOST_SET_VRING_CALL instead of\nvhost_vdpa_setup_vq_irq() which could be called by set_status().\n\nFixing this by setting up irq bypass producer's token when handling\nVHOST_SET_VRING_CALL and un-registering the producer before calling\nvhost_vring_ioctl() to prevent a possible use after free as eventfd\ncould have been released in vhost_vring_ioctl(). And such registering\nand unregistering will only be done if DRIVER_OK is set.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47748",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47017",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nath10k: Fix a use after free in ath10k_htc_send_bundle\n\nIn ath10k_htc_send_bundle, the bundle_skb could be freed by\ndev_kfree_skb_any(bundle_skb). But the bundle_skb is used later\nby bundle_skb->len.\n\nAs skb_len = bundle_skb->len, my patch replaces bundle_skb->len to\nskb_len after the bundle_skb was freed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47017",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2024-12-09",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52642",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: rc: bpf attach/detach requires write permission\n\nNote that bpf attach/detach also requires CAP_NET_ADMIN.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52642",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-17",
                    "modification_date": "2025-03-27",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38415",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: check return result of sb_min_blocksize\n\nSyzkaller reports an \"UBSAN: shift-out-of-bounds in squashfs_bio_read\" bug.\n\nSyzkaller forks multiple processes which after mounting the Squashfs\nfilesystem, issues an ioctl(\"/dev/loop0\", LOOP_SET_BLOCK_SIZE, 0x8000). \nNow if this ioctl occurs at the same time another process is in the\nprocess of mounting a Squashfs filesystem on /dev/loop0, the failure\noccurs.  When this happens the following code in squashfs_fill_super()\nfails.\n\n----\nmsblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);\nmsblk->devblksize_log2 = ffz(~msblk->devblksize);\n----\n\nsb_min_blocksize() returns 0, which means msblk->devblksize is set to 0.\n\nAs a result, ffz(~msblk->devblksize) returns 64, and msblk->devblksize_log2\nis set to 64.\n\nThis subsequently causes the\n\nUBSAN: shift-out-of-bounds in fs/squashfs/block.c:195:36\nshift exponent 64 is too large for 64-bit type 'u64' (aka\n'unsigned long long')\n\nThis commit adds a check for a 0 return by sb_min_blocksize().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38415",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49022",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac8021: fix possible oob access in ieee80211_get_rate_duration\n\nFix possible out-of-bound access in ieee80211_get_rate_duration routine\nas reported by the following UBSAN report:\n\nUBSAN: array-index-out-of-bounds in net/mac80211/airtime.c:455:47\nindex 15 is out of range for type 'u16 [12]'\nCPU: 2 PID: 217 Comm: kworker/u32:10 Not tainted 6.1.0-060100rc3-generic\nHardware name: Acer Aspire TC-281/Aspire TC-281, BIOS R01-A2 07/18/2017\nWorkqueue: mt76 mt76u_tx_status_data [mt76_usb]\nCall Trace:\n <TASK>\n show_stack+0x4e/0x61\n dump_stack_lvl+0x4a/0x6f\n dump_stack+0x10/0x18\n ubsan_epilogue+0x9/0x43\n __ubsan_handle_out_of_bounds.cold+0x42/0x47\nieee80211_get_rate_duration.constprop.0+0x22f/0x2a0 [mac80211]\n ? ieee80211_tx_status_ext+0x32e/0x640 [mac80211]\n ieee80211_calc_rx_airtime+0xda/0x120 [mac80211]\n ieee80211_calc_tx_airtime+0xb4/0x100 [mac80211]\n mt76x02_send_tx_status+0x266/0x480 [mt76x02_lib]\n mt76x02_tx_status_data+0x52/0x80 [mt76x02_lib]\n mt76u_tx_status_data+0x67/0xd0 [mt76_usb]\n process_one_work+0x225/0x400\n worker_thread+0x50/0x3e0\n ? process_one_work+0x400/0x400\n kthread+0xe9/0x110\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x22/0x30",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49022",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49388",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: ubi_create_volume: Fix use-after-free when volume creation failed\n\nThere is an use-after-free problem for 'eba_tbl' in ubi_create_volume()'s\nerror handling path:\n\n  ubi_eba_replace_table(vol, eba_tbl)\n    vol->eba_tbl = tbl\nout_mapping:\n  ubi_eba_destroy_table(eba_tbl)   // Free 'eba_tbl'\nout_unlock:\n  put_device(&vol->dev)\n    vol_release\n      kfree(tbl->entries)\t  // UAF\n\nFix it by removing redundant 'eba_tbl' releasing.\nFetch a reproducer in [Link].",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49388",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26782",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix double-free on socket dismantle\n\nwhen MPTCP server accepts an incoming connection, it clones its listener\nsocket. However, the pointer to 'inet_opt' for the new socket has the same\nvalue as the original one: as a consequence, on program exit it's possible\nto observe the following splat:\n\n  BUG: KASAN: double-free in inet_sock_destruct+0x54f/0x8b0\n  Free of addr ffff888485950880 by task swapper/25/0\n\n  CPU: 25 PID: 0 Comm: swapper/25 Kdump: loaded Not tainted 6.8.0-rc1+ #609\n  Hardware name: Supermicro SYS-6027R-72RF/X9DRH-7TF/7F/iTF/iF, BIOS 3.0  07/26/2013\n  Call Trace:\n   <IRQ>\n   dump_stack_lvl+0x32/0x50\n   print_report+0xca/0x620\n   kasan_report_invalid_free+0x64/0x90\n   __kasan_slab_free+0x1aa/0x1f0\n   kfree+0xed/0x2e0\n   inet_sock_destruct+0x54f/0x8b0\n   __sk_destruct+0x48/0x5b0\n   rcu_do_batch+0x34e/0xd90\n   rcu_core+0x559/0xac0\n   __do_softirq+0x183/0x5a4\n   irq_exit_rcu+0x12d/0x170\n   sysvec_apic_timer_interrupt+0x6b/0x80\n   </IRQ>\n   <TASK>\n   asm_sysvec_apic_timer_interrupt+0x16/0x20\n  RIP: 0010:cpuidle_enter_state+0x175/0x300\n  Code: 30 00 0f 84 1f 01 00 00 83 e8 01 83 f8 ff 75 e5 48 83 c4 18 44 89 e8 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc fb 45 85 ed <0f> 89 60 ff ff ff 48 c1 e5 06 48 c7 43 18 00 00 00 00 48 83 44 2b\n  RSP: 0018:ffff888481cf7d90 EFLAGS: 00000202\n  RAX: 0000000000000000 RBX: ffff88887facddc8 RCX: 0000000000000000\n  RDX: 1ffff1110ff588b1 RSI: 0000000000000019 RDI: ffff88887fac4588\n  RBP: 0000000000000004 R08: 0000000000000002 R09: 0000000000043080\n  R10: 0009b02ea273363f R11: ffff88887fabf42b R12: ffffffff932592e0\n  R13: 0000000000000004 R14: 0000000000000000 R15: 00000022c880ec80\n   cpuidle_enter+0x4a/0xa0\n   do_idle+0x310/0x410\n   cpu_startup_entry+0x51/0x60\n   start_secondary+0x211/0x270\n   secondary_startup_64_no_verify+0x184/0x18b\n   </TASK>\n\n  Allocated by task 6853:\n   kasan_save_stack+0x1c/0x40\n   kasan_save_track+0x10/0x30\n   __kasan_kmalloc+0xa6/0xb0\n   __kmalloc+0x1eb/0x450\n   cipso_v4_sock_setattr+0x96/0x360\n   netlbl_sock_setattr+0x132/0x1f0\n   selinux_netlbl_socket_post_create+0x6c/0x110\n   selinux_socket_post_create+0x37b/0x7f0\n   security_socket_post_create+0x63/0xb0\n   __sock_create+0x305/0x450\n   __sys_socket_create.part.23+0xbd/0x130\n   __sys_socket+0x37/0xb0\n   __x64_sys_socket+0x6f/0xb0\n   do_syscall_64+0x83/0x160\n   entry_SYSCALL_64_after_hwframe+0x6e/0x76\n\n  Freed by task 6858:\n   kasan_save_stack+0x1c/0x40\n   kasan_save_track+0x10/0x30\n   kasan_save_free_info+0x3b/0x60\n   __kasan_slab_free+0x12c/0x1f0\n   kfree+0xed/0x2e0\n   inet_sock_destruct+0x54f/0x8b0\n   __sk_destruct+0x48/0x5b0\n   subflow_ulp_release+0x1f0/0x250\n   tcp_cleanup_ulp+0x6e/0x110\n   tcp_v4_destroy_sock+0x5a/0x3a0\n   inet_csk_destroy_sock+0x135/0x390\n   tcp_fin+0x416/0x5c0\n   tcp_data_queue+0x1bc8/0x4310\n   tcp_rcv_state_process+0x15a3/0x47b0\n   tcp_v4_do_rcv+0x2c1/0x990\n   tcp_v4_rcv+0x41fb/0x5ed0\n   ip_protocol_deliver_rcu+0x6d/0x9f0\n   ip_local_deliver_finish+0x278/0x360\n   ip_local_deliver+0x182/0x2c0\n   ip_rcv+0xb5/0x1c0\n   __netif_receive_skb_one_core+0x16e/0x1b0\n   process_backlog+0x1e3/0x650\n   __napi_poll+0xa6/0x500\n   net_rx_action+0x740/0xbb0\n   __do_softirq+0x183/0x5a4\n\n  The buggy address belongs to the object at ffff888485950880\n   which belongs to the cache kmalloc-64 of size 64\n  The buggy address is located 0 bytes inside of\n   64-byte region [ffff888485950880, ffff8884859508c0)\n\n  The buggy address belongs to the physical page:\n  page:0000000056d1e95e refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888485950700 pfn:0x485950\n  flags: 0x57ffffc0000800(slab|node=1|zone=2|lastcpupid=0x1fffff)\n  page_type: 0xffffffff()\n  raw: 0057ffffc0000800 ffff88810004c640 ffffea00121b8ac0 dead000000000006\n  raw: ffff888485950700 0000000000200019 00000001ffffffff 0000000000000000\n  page dumped because: kasan: bad access detected\n\n  Memory state around the buggy address:\n   ffff888485950780: fa fb fb\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26782",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-04",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56605",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create()\n\nbt_sock_alloc() allocates the sk object and attaches it to the provided\nsock object. On error l2cap_sock_alloc() frees the sk object, but the\ndangling pointer is still attached to the sock object, which may create\nuse-after-free in other code.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56605",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52624",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Wake DMCUB before executing GPINT commands\n\n[Why]\nDMCUB can be in idle when we attempt to interface with the HW through\nthe GPINT mailbox resulting in a system hang.\n\n[How]\nAdd dc_wake_and_execute_gpint() to wrap the wake, execute, sleep\nsequence.\n\nIf the GPINT executes successfully then DMCUB will be put back into\nsleep after the optional response is returned.\n\nIt functions similar to the inbox command interface.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52624",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-26",
                    "modification_date": "2025-03-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49524",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: pci: cx23885: Fix the error handling in cx23885_initdev()\n\nWhen the driver fails to call the dma_set_mask(), the driver will get\nthe following splat:\n\n[   55.853884] BUG: KASAN: use-after-free in __process_removed_driver+0x3c/0x240\n[   55.854486] Read of size 8 at addr ffff88810de60408 by task modprobe/590\n[   55.856822] Call Trace:\n[   55.860327]  __process_removed_driver+0x3c/0x240\n[   55.861347]  bus_for_each_dev+0x102/0x160\n[   55.861681]  i2c_del_driver+0x2f/0x50\n\nThis is because the driver has initialized the i2c related resources\nin cx23885_dev_setup() but not released them in error handling, fix this\nbug by modifying the error path that jumps after failing to call the\ndma_set_mask().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49524",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46798",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: dapm: Fix UAF for snd_soc_pcm_runtime object\n\nWhen using kernel with the following extra config,\n\n  - CONFIG_KASAN=y\n  - CONFIG_KASAN_GENERIC=y\n  - CONFIG_KASAN_INLINE=y\n  - CONFIG_KASAN_VMALLOC=y\n  - CONFIG_FRAME_WARN=4096\n\nkernel detects that snd_pcm_suspend_all() access a freed\n'snd_soc_pcm_runtime' object when the system is suspended, which\nleads to a use-after-free bug:\n\n[   52.047746] BUG: KASAN: use-after-free in snd_pcm_suspend_all+0x1a8/0x270\n[   52.047765] Read of size 1 at addr ffff0000b9434d50 by task systemd-sleep/2330\n\n[   52.047785] Call trace:\n[   52.047787]  dump_backtrace+0x0/0x3c0\n[   52.047794]  show_stack+0x34/0x50\n[   52.047797]  dump_stack_lvl+0x68/0x8c\n[   52.047802]  print_address_description.constprop.0+0x74/0x2c0\n[   52.047809]  kasan_report+0x210/0x230\n[   52.047815]  __asan_report_load1_noabort+0x3c/0x50\n[   52.047820]  snd_pcm_suspend_all+0x1a8/0x270\n[   52.047824]  snd_soc_suspend+0x19c/0x4e0\n\nThe snd_pcm_sync_stop() has a NULL check on 'substream->runtime' before\nmaking any access. So we need to always set 'substream->runtime' to NULL\neverytime we kfree() it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46798",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47536",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix wrong list_del in smc_lgr_cleanup_early\n\nsmc_lgr_cleanup_early() meant to delete the link\ngroup from the link group list, but it deleted\nthe list head by mistake.\n\nThis may cause memory corruption since we didn't\nremove the real link group from the list and later\nmemseted the link group structure.\nWe got a list corruption panic when testing:\n\n[ \u00a0231.277259] list_del corruption. prev->next should be ffff8881398a8000, but was 0000000000000000\n[ \u00a0231.278222] ------------[ cut here ]------------\n[ \u00a0231.278726] kernel BUG at lib/list_debug.c:53!\n[ \u00a0231.279326] invalid opcode: 0000 [#1] SMP NOPTI\n[ \u00a0231.279803] CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.10.46+ #435\n[ \u00a0231.280466] Hardware name: Alibaba Cloud ECS, BIOS 8c24b4c 04/01/2014\n[ \u00a0231.281248] Workqueue: events smc_link_down_work\n[ \u00a0231.281732] RIP: 0010:__list_del_entry_valid+0x70/0x90\n[ \u00a0231.282258] Code: 4c 60 82 e8 7d cc 6a 00 0f 0b 48 89 fe 48 c7 c7 88 4c\n60 82 e8 6c cc 6a 00 0f 0b 48 89 fe 48 c7 c7 c0 4c 60 82 e8 5b cc 6a 00 <0f>\n0b 48 89 fe 48 c7 c7 00 4d 60 82 e8 4a cc 6a 00 0f 0b cc cc cc\n[ \u00a0231.284146] RSP: 0018:ffffc90000033d58 EFLAGS: 00010292\n[ \u00a0231.284685] RAX: 0000000000000054 RBX: ffff8881398a8000 RCX: 0000000000000000\n[ \u00a0231.285415] RDX: 0000000000000001 RSI: ffff88813bc18040 RDI: ffff88813bc18040\n[ \u00a0231.286141] RBP: ffffffff8305ad40 R08: 0000000000000003 R09: 0000000000000001\n[ \u00a0231.286873] R10: ffffffff82803da0 R11: ffffc90000033b90 R12: 0000000000000001\n[ \u00a0231.287606] R13: 0000000000000000 R14: ffff8881398a8000 R15: 0000000000000003\n[ \u00a0231.288337] FS: \u00a00000000000000000(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n[ \u00a0231.289160] CS: \u00a00010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ \u00a0231.289754] CR2: 0000000000e72058 CR3: 000000010fa96006 CR4: 00000000003706f0\n[ \u00a0231.290485] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ \u00a0231.291211] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ \u00a0231.291940] Call Trace:\n[ \u00a0231.292211] \u00a0smc_lgr_terminate_sched+0x53/0xa0\n[ \u00a0231.292677] \u00a0smc_switch_conns+0x75/0x6b0\n[ \u00a0231.293085] \u00a0? update_load_avg+0x1a6/0x590\n[ \u00a0231.293517] \u00a0? ttwu_do_wakeup+0x17/0x150\n[ \u00a0231.293907] \u00a0? update_load_avg+0x1a6/0x590\n[ \u00a0231.294317] \u00a0? newidle_balance+0xca/0x3d0\n[ \u00a0231.294716] \u00a0smcr_link_down+0x50/0x1a0\n[ \u00a0231.295090] \u00a0? __wake_up_common_lock+0x77/0x90\n[ \u00a0231.295534] \u00a0smc_link_down_work+0x46/0x60\n[ \u00a0231.295933] \u00a0process_one_work+0x18b/0x350",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47536",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-09-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49205",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Fix double uncharge the mem of sk_msg\n\nIf tcp_bpf_sendmsg is running during a tear down operation, psock may be\nfreed.\n\ntcp_bpf_sendmsg()\n tcp_bpf_send_verdict()\n  sk_msg_return()\n  tcp_bpf_sendmsg_redir()\n   unlikely(!psock))\n     sk_msg_free()\n\nThe mem of msg has been uncharged in tcp_bpf_send_verdict() by\nsk_msg_return(), and would be uncharged by sk_msg_free() again. When psock\nis null, we can simply returning an error code, this would then trigger\nthe sk_msg_free_nocharge in the error path of __SK_REDIRECT and would have\nthe side effect of throwing an error up to user space. This would be a\nslight change in behavior from user side but would look the same as an\nerror if the redirect on the socket threw an error.\n\nThis issue can cause the following info:\nWARNING: CPU: 0 PID: 2136 at net/ipv4/af_inet.c:155 inet_sock_destruct+0x13c/0x260\nCall Trace:\n <TASK>\n __sk_destruct+0x24/0x1f0\n sk_psock_destroy+0x19b/0x1c0\n process_one_work+0x1b3/0x3c0\n worker_thread+0x30/0x350\n ? process_one_work+0x3c0/0x3c0\n kthread+0xe6/0x110\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x22/0x30\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49205",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39797",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: Duplicate SPI Handling\n\nThe issue originates when Strongswan initiates an XFRM_MSG_ALLOCSPI\nNetlink message, which triggers the kernel function xfrm_alloc_spi().\nThis function is expected to ensure uniqueness of the Security Parameter\nIndex (SPI) for inbound Security Associations (SAs). However, it can\nreturn success even when the requested SPI is already in use, leading\nto duplicate SPIs assigned to multiple inbound SAs, differentiated\nonly by their destination addresses.\n\nThis behavior causes inconsistencies during SPI lookups for inbound packets.\nSince the lookup may return an arbitrary SA among those with the same SPI,\npacket processing can fail, resulting in packet drops.\n\nAccording to RFC 4301 section 4.4.2 , for inbound processing a unicast SA\nis uniquely identified by the SPI and optionally protocol.\n\nReproducing the Issue Reliably:\nTo consistently reproduce the problem, restrict the available SPI range in\ncharon.conf : spi_min = 0x10000000 spi_max = 0x10000002\nThis limits the system to only 2 usable SPI values.\nNext, create more than 2 Child SA. each using unique pair of src/dst address.\nAs soon as the 3rd Child SA is initiated, it will be assigned a duplicate\nSPI, since the SPI pool is already exhausted.\nWith a narrow SPI range, the issue is consistently reproducible.\nWith a broader/default range, it becomes rare and unpredictable.\n\nCurrent implementation:\nxfrm_spi_hash() lookup function computes hash using daddr, proto, and family.\nSo if two SAs have the same SPI but different destination addresses, then\nthey will:\na. Hash into different buckets\nb. Be stored in different linked lists (byspi + h)\nc. Not be seen in the same hlist_for_each_entry_rcu() iteration.\nAs a result, the lookup will result in NULL and kernel allows that Duplicate SPI\n\nProposed Change:\nxfrm_state_lookup_spi_proto() does a truly global search - across all states,\nregardless of hash bucket and matches SPI and proto.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39797",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-12",
                    "modification_date": "2025-11-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48686",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-tcp: fix UAF when detecting digest errors\n\nWe should also bail from the io_work loop when we set rd_enabled to true,\nso we don't attempt to read data from the socket when the TCP stream is\nalready out-of-sync or corrupted.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48686",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49416",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix use-after-free in chanctx code\n\nIn ieee80211_vif_use_reserved_context(), when we have an\nold context and the new context's replace_state is set to\nIEEE80211_CHANCTX_REPLACE_NONE, we free the old context\nin ieee80211_vif_use_reserved_reassign(). Therefore, we\ncannot check the old_ctx anymore, so we should set it to\nNULL after this point.\n\nHowever, since the new_ctx replace state is clearly not\nIEEE80211_CHANCTX_REPLACES_OTHER, we're not going to do\nanything else in this function and can just return to\navoid accessing the freed old_ctx.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49416",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50125",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: SCO: Fix UAF on sco_sock_timeout\n\nconn->sk maybe have been unlinked/freed while waiting for sco_conn_lock\nso this checks if the conn->sk is still valid by checking if it part of\nsco_sk_list.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50125",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-05",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47404",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: betop: fix slab-out-of-bounds Write in betop_probe\n\nSyzbot reported slab-out-of-bounds Write bug in hid-betopff driver.\nThe problem is the driver assumes the device must have an input report but\nsome malicious devices violate this assumption.\n\nSo this patch checks hid_device's input is non empty before it's been used.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47404",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47303",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Track subprog poke descriptors correctly and fix use-after-free\n\nSubprograms are calling map_poke_track(), but on program release there is no\nhook to call map_poke_untrack(). However, on program release, the aux memory\n(and poke descriptor table) is freed even though we still have a reference to\nit in the element list of the map aux data. When we run map_poke_run(), we then\nend up accessing free'd memory, triggering KASAN in prog_array_map_poke_run():\n\n  [...]\n  [  402.824689] BUG: KASAN: use-after-free in prog_array_map_poke_run+0xc2/0x34e\n  [  402.824698] Read of size 4 at addr ffff8881905a7940 by task hubble-fgs/4337\n  [  402.824705] CPU: 1 PID: 4337 Comm: hubble-fgs Tainted: G          I       5.12.0+ #399\n  [  402.824715] Call Trace:\n  [  402.824719]  dump_stack+0x93/0xc2\n  [  402.824727]  print_address_description.constprop.0+0x1a/0x140\n  [  402.824736]  ? prog_array_map_poke_run+0xc2/0x34e\n  [  402.824740]  ? prog_array_map_poke_run+0xc2/0x34e\n  [  402.824744]  kasan_report.cold+0x7c/0xd8\n  [  402.824752]  ? prog_array_map_poke_run+0xc2/0x34e\n  [  402.824757]  prog_array_map_poke_run+0xc2/0x34e\n  [  402.824765]  bpf_fd_array_map_update_elem+0x124/0x1a0\n  [...]\n\nThe elements concerned are walked as follows:\n\n    for (i = 0; i < elem->aux->size_poke_tab; i++) {\n           poke = &elem->aux->poke_tab[i];\n    [...]\n\nThe access to size_poke_tab is a 4 byte read, verified by checking offsets\nin the KASAN dump:\n\n  [  402.825004] The buggy address belongs to the object at ffff8881905a7800\n                 which belongs to the cache kmalloc-1k of size 1024\n  [  402.825008] The buggy address is located 320 bytes inside of\n                 1024-byte region [ffff8881905a7800, ffff8881905a7c00)\n\nThe pahole output of bpf_prog_aux:\n\n  struct bpf_prog_aux {\n    [...]\n    /* --- cacheline 5 boundary (320 bytes) --- */\n    u32                        size_poke_tab;        /*   320     4 */\n    [...]\n\nIn general, subprograms do not necessarily manage their own data structures.\nFor example, BTF func_info and linfo are just pointers to the main program\nstructure. This allows reference counting and cleanup to be done on the latter\nwhich simplifies their management a bit. The aux->poke_tab struct, however,\ndid not follow this logic. The initial proposed fix for this use-after-free\nbug further embedded poke data tracking into the subprogram with proper\nreference counting. However, Daniel and Alexei questioned why we were treating\nthese objects special; I agree, its unnecessary. The fix here removes the per\nsubprogram poke table allocation and map tracking and instead simply points\nthe aux->poke_tab pointer at the main programs poke table. This way, map\ntracking is simplified to the main program and we do not need to manage them\nper subprogram.\n\nThis also means, bpf_prog_free_deferred(), which unwinds the program reference\ncounting and kfrees objects, needs to ensure that we don't try to double free\nthe poke_tab when free'ing the subprog structures. This is easily solved by\nNULL'ing the poke_tab pointer. The second detail is to ensure that per\nsubprogram JIT logic only does fixups on poke_tab[] entries it owns. To do\nthis, we add a pointer in the poke structure to point at the subprogram value\nso JITs can easily check while walking the poke_tab structure if the current\nentry belongs to the current program. The aux pointer is stable and therefore\nsuitable for such comparison. On the jit_subprogs() error path, we omit\ncleaning up the poke->aux field because these are only ever referenced from\nthe JIT side, but on error we will never make it to the JIT, so its fine to\nleave them dangling. Removing these pointers would complicate the error path\nfor no reason. However, we do need to untrack all poke descriptors from the\nmain program as otherwise they could race with the freeing of JIT memory from\nthe subprograms. Lastly, a748c6975dea3 (\"bpf: propagate poke des\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47303",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-26",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53052",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix use-after-free bug in refresh_cache_worker()\n\nThe UAF bug occurred because we were putting DFS root sessions in\ncifs_umount() while DFS cache refresher was being executed.\n\nMake DFS root sessions have same lifetime as DFS tcons so we can avoid\nthe use-after-free bug is DFS cache refresher and other places that\nrequire IPCs to get new DFS referrals on.  Also, get rid of mount\ngroup handling in DFS cache as we no longer need it.\n\nThis fixes below use-after-free bug catched by KASAN\n\n[ 379.946955] BUG: KASAN: use-after-free in __refresh_tcon.isra.0+0x10b/0xc10 [cifs]\n[ 379.947642] Read of size 8 at addr ffff888018f57030 by task kworker/u4:3/56\n[ 379.948096]\n[ 379.948208] CPU: 0 PID: 56 Comm: kworker/u4:3 Not tainted 6.2.0-rc7-lku #23\n[ 379.948661] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\nrel-1.16.0-0-gd239552-rebuilt.opensuse.org 04/01/2014\n[ 379.949368] Workqueue: cifs-dfscache refresh_cache_worker [cifs]\n[ 379.949942] Call Trace:\n[ 379.950113] <TASK>\n[ 379.950260] dump_stack_lvl+0x50/0x67\n[ 379.950510] print_report+0x16a/0x48e\n[ 379.950759] ? __virt_addr_valid+0xd8/0x160\n[ 379.951040] ? __phys_addr+0x41/0x80\n[ 379.951285] kasan_report+0xdb/0x110\n[ 379.951533] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs]\n[ 379.952056] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs]\n[ 379.952585] __refresh_tcon.isra.0+0x10b/0xc10 [cifs]\n[ 379.953096] ? __pfx___refresh_tcon.isra.0+0x10/0x10 [cifs]\n[ 379.953637] ? __pfx___mutex_lock+0x10/0x10\n[ 379.953915] ? lock_release+0xb6/0x720\n[ 379.954167] ? __pfx_lock_acquire+0x10/0x10\n[ 379.954443] ? refresh_cache_worker+0x34e/0x6d0 [cifs]\n[ 379.954960] ? __pfx_wb_workfn+0x10/0x10\n[ 379.955239] refresh_cache_worker+0x4ad/0x6d0 [cifs]\n[ 379.955755] ? __pfx_refresh_cache_worker+0x10/0x10 [cifs]\n[ 379.956323] ? __pfx_lock_acquired+0x10/0x10\n[ 379.956615] ? read_word_at_a_time+0xe/0x20\n[ 379.956898] ? lockdep_hardirqs_on_prepare+0x12/0x220\n[ 379.957235] process_one_work+0x535/0x990\n[ 379.957509] ? __pfx_process_one_work+0x10/0x10\n[ 379.957812] ? lock_acquired+0xb7/0x5f0\n[ 379.958069] ? __list_add_valid+0x37/0xd0\n[ 379.958341] ? __list_add_valid+0x37/0xd0\n[ 379.958611] worker_thread+0x8e/0x630\n[ 379.958861] ? __pfx_worker_thread+0x10/0x10\n[ 379.959148] kthread+0x17d/0x1b0\n[ 379.959369] ? __pfx_kthread+0x10/0x10\n[ 379.959630] ret_from_fork+0x2c/0x50\n[ 379.959879] </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53052",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49991",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: amdkfd_free_gtt_mem clear the correct pointer\n\nPass pointer reference to amdgpu_bo_unref to clear the correct pointer,\notherwise amdgpu_bo_unref clear the local variable, the original pointer\nnot set to NULL, this could cause use-after-free bug.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49991",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53194",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: Fix use-after-free of slot->bus on hot remove\n\nDennis reports a boot crash on recent Lenovo laptops with a USB4 dock.\n\nSince commit 0fc70886569c (\"thunderbolt: Reset USB4 v2 host router\") and\ncommit 59a54c5f3dbd (\"thunderbolt: Reset topology created by the boot\nfirmware\"), USB4 v2 and v1 Host Routers are reset on probe of the\nthunderbolt driver.\n\nThe reset clears the Presence Detect State and Data Link Layer Link Active\nbits at the USB4 Host Router's Root Port and thus causes hot removal of the\ndock.\n\nThe crash occurs when pciehp is unbound from one of the dock's Downstream\nPorts:  pciehp creates a pci_slot on bind and destroys it on unbind.  The\npci_slot contains a pointer to the pci_bus below the Downstream Port, but\na reference on that pci_bus is never acquired.  The pci_bus is destroyed\nbefore the pci_slot, so a use-after-free ensues when pci_slot_release()\naccesses slot->bus.\n\nIn principle this should not happen because pci_stop_bus_device() unbinds\npciehp (and therefore destroys the pci_slot) before the pci_bus is\ndestroyed by pci_remove_bus_device().\n\nHowever the stacktrace provided by Dennis shows that pciehp is unbound from\npci_remove_bus_device() instead of pci_stop_bus_device().  To understand\nthe significance of this, one needs to know that the PCI core uses a two\nstep process to remove a portion of the hierarchy:  It first unbinds all\ndrivers in the sub-hierarchy in pci_stop_bus_device() and then actually\nremoves the devices in pci_remove_bus_device().  There is no precaution to\nprevent driver binding in-between pci_stop_bus_device() and\npci_remove_bus_device().\n\nIn Dennis' case, it seems removal of the hierarchy by pciehp races with\ndriver binding by pci_bus_add_devices().  pciehp is bound to the\nDownstream Port after pci_stop_bus_device() has run, so it is unbound by\npci_remove_bus_device() instead of pci_stop_bus_device().  Because the\npci_bus has already been destroyed at that point, accesses to it result in\na use-after-free.\n\nOne might conclude that driver binding needs to be prevented after\npci_stop_bus_device() has run.  However it seems risky that pci_slot points\nto pci_bus without holding a reference.  Solely relying on correct ordering\nof driver unbind versus pci_bus destruction is certainly not defensive\nprogramming.\n\nIf pci_slot has a need to access data in pci_bus, it ought to acquire a\nreference.  Amend pci_create_slot() accordingly.  Dennis reports that the\ncrash is not reproducible with this change.\n\nAbridged stacktrace:\n\n  pcieport 0000:00:07.0: PME: Signaling with IRQ 156\n  pcieport 0000:00:07.0: pciehp: Slot #12 AttnBtn- PwrCtrl- MRL- AttnInd- PwrInd- HotPlug+ Surprise+ Interlock- NoCompl+ IbPresDis- LLActRep+\n  pci_bus 0000:20: dev 00, created physical slot 12\n  pcieport 0000:00:07.0: pciehp: Slot(12): Card not present\n  ...\n  pcieport 0000:21:02.0: pciehp: pcie_disable_notification: SLOTCTRL d8 write cmd 0\n  Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 13 UID: 0 PID: 134 Comm: irq/156-pciehp Not tainted 6.11.0-devel+ #1\n  RIP: 0010:dev_driver_string+0x12/0x40\n  pci_destroy_slot\n  pciehp_remove\n  pcie_port_remove_service\n  device_release_driver_internal\n  bus_remove_device\n  device_del\n  device_unregister\n  remove_iter\n  device_for_each_child\n  pcie_portdrv_remove\n  pci_device_remove\n  device_release_driver_internal\n  bus_remove_device\n  device_del\n  pci_remove_bus_device (recursive invocation)\n  pci_remove_bus_device\n  pciehp_unconfigure_device\n  pciehp_disable_slot\n  pciehp_handle_presence_or_link_change\n  pciehp_ist",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53194",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21731",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: don't allow reconnect after disconnect\n\nFollowing process can cause nbd_config UAF:\n\n1) grab nbd_config temporarily;\n\n2) nbd_genl_disconnect() flush all recv_work() and release the\ninitial reference:\n\n  nbd_genl_disconnect\n   nbd_disconnect_and_put\n    nbd_disconnect\n     flush_workqueue(nbd->recv_workq)\n    if (test_and_clear_bit(NBD_RT_HAS_CONFIG_REF, ...))\n     nbd_config_put\n     -> due to step 1), reference is still not zero\n\n3) nbd_genl_reconfigure() queue recv_work() again;\n\n  nbd_genl_reconfigure\n   config = nbd_get_config_unlocked(nbd)\n   if (!config)\n   -> succeed\n   if (!test_bit(NBD_RT_BOUND, ...))\n   -> succeed\n   nbd_reconnect_socket\n    queue_work(nbd->recv_workq, &args->work)\n\n4) step 1) release the reference;\n\n5) Finially, recv_work() will trigger UAF:\n\n  recv_work\n   nbd_config_put(nbd)\n   -> nbd_config is freed\n   atomic_dec(&config->recv_threads)\n   -> UAF\n\nFix the problem by clearing NBD_RT_BOUND in nbd_genl_disconnect(), so\nthat nbd_genl_reconfigure() will fail.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21731",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46744",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSquashfs: sanity check symbolic link size\n\nSyzkiller reports a \"KMSAN: uninit-value in pick_link\" bug.\n\nThis is caused by an uninitialised page, which is ultimately caused\nby a corrupted symbolic link size read from disk.\n\nThe reason why the corrupted symlink size causes an uninitialised\npage is due to the following sequence of events:\n\n1. squashfs_read_inode() is called to read the symbolic\n   link from disk.  This assigns the corrupted value\n   3875536935 to inode->i_size.\n\n2. Later squashfs_symlink_read_folio() is called, which assigns\n   this corrupted value to the length variable, which being a\n   signed int, overflows producing a negative number.\n\n3. The following loop that fills in the page contents checks that\n   the copied bytes is less than length, which being negative means\n   the loop is skipped, producing an uninitialised page.\n\nThis patch adds a sanity check which checks that the symbolic\nlink size is not larger than expected.\n\n--\n\nV2: fix spelling mistake.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46744",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53216",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: release svc_expkey/svc_export with rcu_work\n\nThe last reference for `cache_head` can be reduced to zero in `c_show`\nand `e_show`(using `rcu_read_lock` and `rcu_read_unlock`). Consequently,\n`svc_export_put` and `expkey_put` will be invoked, leading to two\nissues:\n\n1. The `svc_export_put` will directly free ex_uuid. However,\n   `e_show`/`c_show` will access `ex_uuid` after `cache_put`, which can\n   trigger a use-after-free issue, shown below.\n\n   ==================================================================\n   BUG: KASAN: slab-use-after-free in svc_export_show+0x362/0x430 [nfsd]\n   Read of size 1 at addr ff11000010fdc120 by task cat/870\n\n   CPU: 1 UID: 0 PID: 870 Comm: cat Not tainted 6.12.0-rc3+ #1\n   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n   1.16.1-2.fc37 04/01/2014\n   Call Trace:\n    <TASK>\n    dump_stack_lvl+0x53/0x70\n    print_address_description.constprop.0+0x2c/0x3a0\n    print_report+0xb9/0x280\n    kasan_report+0xae/0xe0\n    svc_export_show+0x362/0x430 [nfsd]\n    c_show+0x161/0x390 [sunrpc]\n    seq_read_iter+0x589/0x770\n    seq_read+0x1e5/0x270\n    proc_reg_read+0xe1/0x140\n    vfs_read+0x125/0x530\n    ksys_read+0xc1/0x160\n    do_syscall_64+0x5f/0x170\n    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n   Allocated by task 830:\n    kasan_save_stack+0x20/0x40\n    kasan_save_track+0x14/0x30\n    __kasan_kmalloc+0x8f/0xa0\n    __kmalloc_node_track_caller_noprof+0x1bc/0x400\n    kmemdup_noprof+0x22/0x50\n    svc_export_parse+0x8a9/0xb80 [nfsd]\n    cache_do_downcall+0x71/0xa0 [sunrpc]\n    cache_write_procfs+0x8e/0xd0 [sunrpc]\n    proc_reg_write+0xe1/0x140\n    vfs_write+0x1a5/0x6d0\n    ksys_write+0xc1/0x160\n    do_syscall_64+0x5f/0x170\n    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n   Freed by task 868:\n    kasan_save_stack+0x20/0x40\n    kasan_save_track+0x14/0x30\n    kasan_save_free_info+0x3b/0x60\n    __kasan_slab_free+0x37/0x50\n    kfree+0xf3/0x3e0\n    svc_export_put+0x87/0xb0 [nfsd]\n    cache_purge+0x17f/0x1f0 [sunrpc]\n    nfsd_destroy_serv+0x226/0x2d0 [nfsd]\n    nfsd_svc+0x125/0x1e0 [nfsd]\n    write_threads+0x16a/0x2a0 [nfsd]\n    nfsctl_transaction_write+0x74/0xa0 [nfsd]\n    vfs_write+0x1a5/0x6d0\n    ksys_write+0xc1/0x160\n    do_syscall_64+0x5f/0x170\n    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n2. We cannot sleep while using `rcu_read_lock`/`rcu_read_unlock`.\n   However, `svc_export_put`/`expkey_put` will call path_put, which\n   subsequently triggers a sleeping operation due to the following\n   `dput`.\n\n   =============================\n   WARNING: suspicious RCU usage\n   5.10.0-dirty #141 Not tainted\n   -----------------------------\n   ...\n   Call Trace:\n   dump_stack+0x9a/0xd0\n   ___might_sleep+0x231/0x240\n   dput+0x39/0x600\n   path_put+0x1b/0x30\n   svc_export_put+0x17/0x80\n   e_show+0x1c9/0x200\n   seq_read_iter+0x63f/0x7c0\n   seq_read+0x226/0x2d0\n   vfs_read+0x113/0x2c0\n   ksys_read+0xc9/0x170\n   do_syscall_64+0x33/0x40\n   entry_SYSCALL_64_after_hwframe+0x67/0xd1\n\nFix these issues by using `rcu_work` to help release\n`svc_expkey`/`svc_export`. This approach allows for an asynchronous\ncontext to invoke `path_put` and also facilitates the freeing of\n`uuid/exp/key` after an RCU grace period.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53216",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-27075",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: dvb-frontends: avoid stack overflow warnings with clang\n\nA previous patch worked around a KASAN issue in stv0367, now a similar\nproblem showed up with clang:\n\ndrivers/media/dvb-frontends/stv0367.c:1222:12: error: stack frame size (3624) exceeds limit (2048) in 'stv0367ter_set_frontend' [-Werror,-Wframe-larger-than]\n 1214 | static int stv0367ter_set_frontend(struct dvb_frontend *fe)\n\nRework the stv0367_writereg() function to be simpler and mark both\nregister access functions as noinline_for_stack so the temporary\ni2c_msg structures do not get duplicated on the stack when KASAN_STACK\nis enabled.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-27075",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-01",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-42148",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnx2x: Fix multiple UBSAN array-index-out-of-bounds\n\nFix UBSAN warnings that occur when using a system with 32 physical\ncpu cores or more, or when the user defines a number of Ethernet\nqueues greater than or equal to FP_SB_MAX_E1x using the num_queues\nmodule parameter.\n\nCurrently there is a read/write out of bounds that occurs on the array\n\"struct stats_query_entry query\" present inside the \"bnx2x_fw_stats_req\"\nstruct in \"drivers/net/ethernet/broadcom/bnx2x/bnx2x.h\".\nLooking at the definition of the \"struct stats_query_entry query\" array:\n\nstruct stats_query_entry query[FP_SB_MAX_E1x+\n         BNX2X_FIRST_QUEUE_QUERY_IDX];\n\nFP_SB_MAX_E1x is defined as the maximum number of fast path interrupts and\nhas a value of 16, while BNX2X_FIRST_QUEUE_QUERY_IDX has a value of 3\nmeaning the array has a total size of 19.\nSince accesses to \"struct stats_query_entry query\" are offset-ted by\nBNX2X_FIRST_QUEUE_QUERY_IDX, that means that the total number of Ethernet\nqueues should not exceed FP_SB_MAX_E1x (16). However one of these queues\nis reserved for FCOE and thus the number of Ethernet queues should be set\nto [FP_SB_MAX_E1x -1] (15) if FCOE is enabled or [FP_SB_MAX_E1x] (16) if\nit is not.\n\nThis is also described in a comment in the source code in\ndrivers/net/ethernet/broadcom/bnx2x/bnx2x.h just above the Macro definition\nof FP_SB_MAX_E1x. Below is the part of this explanation that it important\nfor this patch\n\n/*\n  * The total number of L2 queues, MSIX vectors and HW contexts (CIDs) is\n  * control by the number of fast-path status blocks supported by the\n  * device (HW/FW). Each fast-path status block (FP-SB) aka non-default\n  * status block represents an independent interrupts context that can\n  * serve a regular L2 networking queue. However special L2 queues such\n  * as the FCoE queue do not require a FP-SB and other components like\n  * the CNIC may consume FP-SB reducing the number of possible L2 queues\n  *\n  * If the maximum number of FP-SB available is X then:\n  * a. If CNIC is supported it consumes 1 FP-SB thus the max number of\n  *    regular L2 queues is Y=X-1\n  * b. In MF mode the actual number of L2 queues is Y= (X-1/MF_factor)\n  * c. If the FCoE L2 queue is supported the actual number of L2 queues\n  *    is Y+1\n  * d. The number of irqs (MSIX vectors) is either Y+1 (one extra for\n  *    slow-path interrupts) or Y+2 if CNIC is supported (one additional\n  *    FP interrupt context for the CNIC).\n  * e. The number of HW context (CID count) is always X or X+1 if FCoE\n  *    L2 queue is supported. The cid for the FCoE L2 queue is always X.\n  */\n\nHowever this driver also supports NICs that use the E2 controller which can\nhandle more queues due to having more FP-SB represented by FP_SB_MAX_E2.\nLooking at the commits when the E2 support was added, it was originally\nusing the E1x parameters: commit f2e0899f0f27 (\"bnx2x: Add 57712 support\").\nBack then FP_SB_MAX_E2 was set to 16 the same as E1x. However the driver\nwas later updated to take full advantage of the E2 instead of having it be\nlimited to the capabilities of the E1x. But as far as we can tell, the\narray \"stats_query_entry query\" was still limited to using the FP-SB\navailable to the E1x cards as part of an oversignt when the driver was\nupdated to take full advantage of the E2, and now with the driver being\naware of the greater queue size supported by E2 NICs, it causes the UBSAN\nwarnings seen in the stack traces below.\n\nThis patch increases the size of the \"stats_query_entry query\" array by\nreplacing FP_SB_MAX_E1x with FP_SB_MAX_E2 to be large enough to handle\nboth types of NICs.\n\nStack traces:\n\nUBSAN: array-index-out-of-bounds in\n       drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c:1529:11\nindex 20 is out of range for type 'stats_query_entry [19]'\nCPU: 12 PID: 858 Comm: systemd-network Not tainted 6.9.0-060900rc7-generic\n\t     #202405052133\nHardware name: HP ProLiant DL360 Gen9/ProLiant DL360 \n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42148",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-30",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50168",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, x86: fix freeing of not-finalized bpf_prog_pack\n\nsyzbot reported a few issues with bpf_prog_pack [1], [2]. This only happens\nwith multiple subprogs. In jit_subprogs(), we first call bpf_int_jit_compile()\non each sub program. And then, we call it on each sub program again. jit_data\nis not freed in the first call of bpf_int_jit_compile(). Similarly we don't\ncall bpf_jit_binary_pack_finalize() in the first call of bpf_int_jit_compile().\n\nIf bpf_int_jit_compile() failed for one sub program, we will call\nbpf_jit_binary_pack_finalize() for this sub program. However, we don't have a\nchance to call it for other sub programs. Then we will hit \"goto out_free\" in\njit_subprogs(), and call bpf_jit_free on some subprograms that haven't got\nbpf_jit_binary_pack_finalize() yet.\n\nAt this point, bpf_jit_binary_pack_free() is called and the whole 2MB page is\nfreed erroneously.\n\nFix this with a custom bpf_jit_free() for x86_64, which calls\nbpf_jit_binary_pack_finalize() if necessary. Also, with custom\nbpf_jit_free(), bpf_prog_aux->use_bpf_prog_pack is not needed any more,\nremove it.\n\n[1] https://syzkaller.appspot.com/bug?extid=2f649ec6d2eea1495a8f\n[2] https://syzkaller.appspot.com/bug?extid=87f65c75f4a72db05445",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50168",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-12-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46871",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Correct the defined value for AMDGPU_DMUB_NOTIFICATION_MAX\n\n[Why & How]\nIt actually exposes '6' types in enum dmub_notification_type. Not 5. Using smaller\nnumber to create array dmub_callback & dmub_thread_offload has potential to access\nitem out of array bound. Fix it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46871",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-09",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53214",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvfio/pci: Properly hide first-in-list PCIe extended capability\n\nThere are cases where a PCIe extended capability should be hidden from\nthe user. For example, an unknown capability (i.e., capability with ID\ngreater than PCI_EXT_CAP_ID_MAX) or a capability that is intentionally\nchosen to be hidden from the user.\n\nHiding a capability is done by virtualizing and modifying the 'Next\nCapability Offset' field of the previous capability so it points to the\ncapability after the one that should be hidden.\n\nThe special case where the first capability in the list should be hidden\nis handled differently because there is no previous capability that can\nbe modified. In this case, the capability ID and version are zeroed\nwhile leaving the next pointer intact. This hides the capability and\nleaves an anchor for the rest of the capability list.\n\nHowever, today, hiding the first capability in the list is not done\nproperly if the capability is unknown, as struct\nvfio_pci_core_device->pci_config_map is set to the capability ID during\ninitialization but the capability ID is not properly checked later when\nused in vfio_config_do_rw(). This leads to the following warning [1] and\nto an out-of-bounds access to ecap_perms array.\n\nFix it by checking cap_id in vfio_config_do_rw(), and if it is greater\nthan PCI_EXT_CAP_ID_MAX, use an alternative struct perm_bits for direct\nread only access instead of the ecap_perms array.\n\nNote that this is safe since the above is the only case where cap_id can\nexceed PCI_EXT_CAP_ID_MAX (except for the special capabilities, which\nare already checked before).\n\n[1]\n\nWARNING: CPU: 118 PID: 5329 at drivers/vfio/pci/vfio_pci_config.c:1900 vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]\nCPU: 118 UID: 0 PID: 5329 Comm: simx-qemu-syste Not tainted 6.12.0+ #1\n(snip)\nCall Trace:\n <TASK>\n ? show_regs+0x69/0x80\n ? __warn+0x8d/0x140\n ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]\n ? report_bug+0x18f/0x1a0\n ? handle_bug+0x63/0xa0\n ? exc_invalid_op+0x19/0x70\n ? asm_exc_invalid_op+0x1b/0x20\n ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]\n ? vfio_pci_config_rw+0x244/0x430 [vfio_pci_core]\n vfio_pci_rw+0x101/0x1b0 [vfio_pci_core]\n vfio_pci_core_read+0x1d/0x30 [vfio_pci_core]\n vfio_device_fops_read+0x27/0x40 [vfio]\n vfs_read+0xbd/0x340\n ? vfio_device_fops_unl_ioctl+0xbb/0x740 [vfio]\n ? __rseq_handle_notify_resume+0xa4/0x4b0\n __x64_sys_pread64+0x96/0xc0\n x64_sys_call+0x1c3d/0x20d0\n do_syscall_64+0x4d/0x120\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53214",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38443",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: fix uaf in nbd_genl_connect() error path\n\nThere is a use-after-free issue in nbd:\n\nblock nbd6: Receive control failed (result -104)\nblock nbd6: shutting down sockets\n==================================================================\nBUG: KASAN: slab-use-after-free in recv_work+0x694/0xa80 drivers/block/nbd.c:1022\nWrite of size 4 at addr ffff8880295de478 by task kworker/u33:0/67\n\nCPU: 2 UID: 0 PID: 67 Comm: kworker/u33:0 Not tainted 6.15.0-rc5-syzkaller-00123-g2c89c1b655c0 #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nWorkqueue: nbd6-recv recv_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xc3/0x670 mm/kasan/report.c:521\n kasan_report+0xe0/0x110 mm/kasan/report.c:634\n check_region_inline mm/kasan/generic.c:183 [inline]\n kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189\n instrument_atomic_read_write include/linux/instrumented.h:96 [inline]\n atomic_dec include/linux/atomic/atomic-instrumented.h:592 [inline]\n recv_work+0x694/0xa80 drivers/block/nbd.c:1022\n process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238\n process_scheduled_works kernel/workqueue.c:3319 [inline]\n worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400\n kthread+0x3c2/0x780 kernel/kthread.c:464\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n </TASK>\n\nnbd_genl_connect() does not properly stop the device on certain\nerror paths after nbd_start_device() has been called. This causes\nthe error path to put nbd->config while recv_work continue to use\nthe config after putting it, leading to use-after-free in recv_work.\n\nThis patch moves nbd_start_device() after the backend file creation.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38443",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26598",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: vgic-its: Avoid potential UAF in LPI translation cache\n\nThere is a potential UAF scenario in the case of an LPI translation\ncache hit racing with an operation that invalidates the cache, such\nas a DISCARD ITS command. The root of the problem is that\nvgic_its_check_cache() does not elevate the refcount on the vgic_irq\nbefore dropping the lock that serializes refcount changes.\n\nHave vgic_its_check_cache() raise the refcount on the returned vgic_irq\nand add the corresponding decrement after queueing the interrupt.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26598",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-23",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-35886",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix infinite recursion in fib6_dump_done().\n\nsyzkaller reported infinite recursive calls of fib6_dump_done() during\nnetlink socket destruction.  [1]\n\nFrom the log, syzkaller sent an AF_UNSPEC RTM_GETROUTE message, and then\nthe response was generated.  The following recvmmsg() resumed the dump\nfor IPv6, but the first call of inet6_dump_fib() failed at kzalloc() due\nto the fault injection.  [0]\n\n  12:01:34 executing program 3:\n  r0 = socket$nl_route(0x10, 0x3, 0x0)\n  sendmsg$nl_route(r0, ... snip ...)\n  recvmmsg(r0, ... snip ...) (fail_nth: 8)\n\nHere, fib6_dump_done() was set to nlk_sk(sk)->cb.done, and the next call\nof inet6_dump_fib() set it to nlk_sk(sk)->cb.args[3].  syzkaller stopped\nreceiving the response halfway through, and finally netlink_sock_destruct()\ncalled nlk_sk(sk)->cb.done().\n\nfib6_dump_done() calls fib6_dump_end() and nlk_sk(sk)->cb.done() if it\nis still not NULL.  fib6_dump_end() rewrites nlk_sk(sk)->cb.done() by\nnlk_sk(sk)->cb.args[3], but it has the same function, not NULL, calling\nitself recursively and hitting the stack guard page.\n\nTo avoid the issue, let's set the destructor after kzalloc().\n\n[0]:\nFAULT_INJECTION: forcing a failure.\nname failslab, interval 1, probability 0, space 0, times 0\nCPU: 1 PID: 432110 Comm: syz-executor.3 Not tainted 6.8.0-12821-g537c2e91d354-dirty #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl (lib/dump_stack.c:117)\n should_fail_ex (lib/fault-inject.c:52 lib/fault-inject.c:153)\n should_failslab (mm/slub.c:3733)\n kmalloc_trace (mm/slub.c:3748 mm/slub.c:3827 mm/slub.c:3992)\n inet6_dump_fib (./include/linux/slab.h:628 ./include/linux/slab.h:749 net/ipv6/ip6_fib.c:662)\n rtnl_dump_all (net/core/rtnetlink.c:4029)\n netlink_dump (net/netlink/af_netlink.c:2269)\n netlink_recvmsg (net/netlink/af_netlink.c:1988)\n ____sys_recvmsg (net/socket.c:1046 net/socket.c:2801)\n ___sys_recvmsg (net/socket.c:2846)\n do_recvmmsg (net/socket.c:2943)\n __x64_sys_recvmmsg (net/socket.c:3041 net/socket.c:3034 net/socket.c:3034)\n\n[1]:\nBUG: TASK stack guard page was hit at 00000000f2fa9af1 (stack is 00000000b7912430..000000009a436beb)\nstack guard page: 0000 [#1] PREEMPT SMP KASAN\nCPU: 1 PID: 223719 Comm: kworker/1:3 Not tainted 6.8.0-12821-g537c2e91d354-dirty #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nWorkqueue: events netlink_sock_destruct_work\nRIP: 0010:fib6_dump_done (net/ipv6/ip6_fib.c:570)\nCode: 3c 24 e8 f3 e9 51 fd e9 28 fd ff ff 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 41 57 41 56 41 55 41 54 55 48 89 fd <53> 48 8d 5d 60 e8 b6 4d 07 fd 48 89 da 48 b8 00 00 00 00 00 fc ff\nRSP: 0018:ffffc9000d980000 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: ffffffff84405990 RCX: ffffffff844059d3\nRDX: ffff8881028e0000 RSI: ffffffff84405ac2 RDI: ffff88810c02f358\nRBP: ffff88810c02f358 R08: 0000000000000007 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000224 R12: 0000000000000000\nR13: ffff888007c82c78 R14: ffff888007c82c68 R15: ffff888007c82c68\nFS:  0000000000000000(0000) GS:ffff88811b100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000d97fff8 CR3: 0000000102309002 CR4: 0000000000770ef0\nPKRU: 55555554\nCall Trace:\n <#DF>\n </#DF>\n <TASK>\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n ...\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n netlink_sock_destruct (net/netlink/af_netlink.c:401)\n __sk_destruct (net/core/sock.c:2177 (discriminator 2))\n sk_destruct (net/core/sock.c:2224)\n __sk_free (net/core/sock.c:2235)\n sk_free (net/core/sock.c:2246)\n process_one_work (kernel/workqueue.c:3259)\n worker_thread (kernel/workqueue.c:3329 kernel/workqueue.\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35886",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-19",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-53173",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSv4.0: Fix a use-after-free problem in the asynchronous open()\n\nYang Erkun reports that when two threads are opening files at the same\ntime, and are forced to abort before a reply is seen, then the call to\nnfs_release_seqid() in nfs4_opendata_free() can result in a\nuse-after-free of the pointer to the defunct rpc task of the other\nthread.\nThe fix is to ensure that if the RPC call is aborted before the call to\nnfs_wait_on_sequence() is complete, then we must call nfs_release_seqid()\nin nfs4_open_release() before the rpc_task is freed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53173",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56551",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix usage slab after free\n\n[  +0.000021] BUG: KASAN: slab-use-after-free in drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000027] Read of size 8 at addr ffff8881b8605f88 by task amd_pci_unplug/2147\n\n[  +0.000023] CPU: 6 PID: 2147 Comm: amd_pci_unplug Not tainted 6.10.0+ #1\n[  +0.000016] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020\n[  +0.000016] Call Trace:\n[  +0.000008]  <TASK>\n[  +0.000009]  dump_stack_lvl+0x76/0xa0\n[  +0.000017]  print_report+0xce/0x5f0\n[  +0.000017]  ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000019]  ? srso_return_thunk+0x5/0x5f\n[  +0.000015]  ? kasan_complete_mode_report_info+0x72/0x200\n[  +0.000016]  ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000019]  kasan_report+0xbe/0x110\n[  +0.000015]  ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000023]  __asan_report_load8_noabort+0x14/0x30\n[  +0.000014]  drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]\n[  +0.000020]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? __kasan_check_write+0x14/0x30\n[  +0.000016]  ? __pfx_drm_sched_entity_flush+0x10/0x10 [gpu_sched]\n[  +0.000020]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? __kasan_check_write+0x14/0x30\n[  +0.000013]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? enable_work+0x124/0x220\n[  +0.000015]  ? __pfx_enable_work+0x10/0x10\n[  +0.000013]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? free_large_kmalloc+0x85/0xf0\n[  +0.000016]  drm_sched_entity_destroy+0x18/0x30 [gpu_sched]\n[  +0.000020]  amdgpu_vce_sw_fini+0x55/0x170 [amdgpu]\n[  +0.000735]  ? __kasan_check_read+0x11/0x20\n[  +0.000016]  vce_v4_0_sw_fini+0x80/0x110 [amdgpu]\n[  +0.000726]  amdgpu_device_fini_sw+0x331/0xfc0 [amdgpu]\n[  +0.000679]  ? mutex_unlock+0x80/0xe0\n[  +0.000017]  ? __pfx_amdgpu_device_fini_sw+0x10/0x10 [amdgpu]\n[  +0.000662]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? __kasan_check_write+0x14/0x30\n[  +0.000013]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? mutex_unlock+0x80/0xe0\n[  +0.000016]  amdgpu_driver_release_kms+0x16/0x80 [amdgpu]\n[  +0.000663]  drm_minor_release+0xc9/0x140 [drm]\n[  +0.000081]  drm_release+0x1fd/0x390 [drm]\n[  +0.000082]  __fput+0x36c/0xad0\n[  +0.000018]  __fput_sync+0x3c/0x50\n[  +0.000014]  __x64_sys_close+0x7d/0xe0\n[  +0.000014]  x64_sys_call+0x1bc6/0x2680\n[  +0.000014]  do_syscall_64+0x70/0x130\n[  +0.000014]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? irqentry_exit_to_user_mode+0x60/0x190\n[  +0.000015]  ? srso_return_thunk+0x5/0x5f\n[  +0.000014]  ? irqentry_exit+0x43/0x50\n[  +0.000012]  ? srso_return_thunk+0x5/0x5f\n[  +0.000013]  ? exc_page_fault+0x7c/0x110\n[  +0.000015]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  +0.000014] RIP: 0033:0x7ffff7b14f67\n[  +0.000013] Code: ff e8 0d 16 02 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 73 ba f7 ff\n[  +0.000026] RSP: 002b:00007fffffffe378 EFLAGS: 00000246 ORIG_RAX: 0000000000000003\n[  +0.000019] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffff7b14f67\n[  +0.000014] RDX: 0000000000000000 RSI: 00007ffff7f6f47a RDI: 0000000000000003\n[  +0.000014] RBP: 00007fffffffe3a0 R08: 0000555555569890 R09: 0000000000000000\n[  +0.000014] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fffffffe5c8\n[  +0.000013] R13: 00005555555552a9 R14: 0000555555557d48 R15: 00007ffff7ffd040\n[  +0.000020]  </TASK>\n\n[  +0.000016] Allocated by task 383 on cpu 7 at 26.880319s:\n[  +0.000014]  kasan_save_stack+0x28/0x60\n[  +0.000008]  kasan_save_track+0x18/0x70\n[  +0.000007]  kasan_save_alloc_info+0x38/0x60\n[  +0.000007]  __kasan_kmalloc+0xc1/0xd0\n[  +0.000007]  kmalloc_trace_noprof+0x180/0x380\n[  +0.000007]  drm_sched_init+0x411/0xec0 [gpu_sched]\n[  +0.000012]  amdgpu_device_init+0x695f/0xa610 [amdgpu]\n[  +0.000658]  amdgpu_driver_load_kms+0x1a/0x120 [amdgpu]\n[  +0.000662]  amdgpu_pci_p\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56551",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52468",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nclass: fix use-after-free in class_register()\n\nThe lock_class_key is still registered and can be found in\nlock_keys_hash hlist after subsys_private is freed in error\nhandler path.A task who iterate over the lock_keys_hash\nlater may cause use-after-free.So fix that up and unregister\nthe lock_class_key before kfree(cp).\n\nOn our platform, a driver fails to kset_register because of\ncreating duplicate filename '/class/xxx'.With Kasan enabled,\nit prints a invalid-access bug report.\n\nKASAN bug report:\n\nBUG: KASAN: invalid-access in lockdep_register_key+0x19c/0x1bc\nWrite of size 8 at addr 15ffff808b8c0368 by task modprobe/252\nPointer tag: [15], memory tag: [fe]\n\nCPU: 7 PID: 252 Comm: modprobe Tainted: G        W\n 6.6.0-mainline-maybe-dirty #1\n\nCall trace:\ndump_backtrace+0x1b0/0x1e4\nshow_stack+0x2c/0x40\ndump_stack_lvl+0xac/0xe0\nprint_report+0x18c/0x4d8\nkasan_report+0xe8/0x148\n__hwasan_store8_noabort+0x88/0x98\nlockdep_register_key+0x19c/0x1bc\nclass_register+0x94/0x1ec\ninit_module+0xbc/0xf48 [rfkill]\ndo_one_initcall+0x17c/0x72c\ndo_init_module+0x19c/0x3f8\n...\nMemory state around the buggy address:\nffffff808b8c0100: 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a 8a\nffffff808b8c0200: 8a 8a 8a 8a 8a 8a 8a 8a fe fe fe fe fe fe fe fe\n>ffffff808b8c0300: fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe fe\n                                     ^\nffffff808b8c0400: 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03 03\n\nAs CONFIG_KASAN_GENERIC is not set, Kasan reports invalid-access\nnot use-after-free here.In this case, modprobe is manipulating\nthe corrupted lock_keys_hash hlish where lock_class_key is already\nfreed before.\n\nIt's worth noting that this only can happen if lockdep is enabled,\nwhich is not true for normal system.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52468",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-26",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-57795",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Remove the direct link to net_device\n\nThe similar patch in siw is in the link:\nhttps://git.kernel.org/rdma/rdma/c/16b87037b48889\n\nThis problem also occurred in RXE. The following analyze this problem.\nIn the following Call Traces:\n\"\nBUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 net/core/dev.c:8782\nRead of size 4 at addr ffff8880554640b0 by task kworker/1:4/5295\n\nCPU: 1 UID: 0 PID: 5295 Comm: kworker/1:4 Not tainted\n6.12.0-rc3-syzkaller-00399-g9197b73fd7bb #0\nHardware name: Google Compute Engine/Google Compute Engine,\nBIOS Google 09/13/2024\nWorkqueue: infiniband ib_cache_event_task\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n dev_get_flags+0x188/0x1d0 net/core/dev.c:8782\n rxe_query_port+0x12d/0x260 drivers/infiniband/sw/rxe/rxe_verbs.c:60\n __ib_query_port drivers/infiniband/core/device.c:2111 [inline]\n ib_query_port+0x168/0x7d0 drivers/infiniband/core/device.c:2143\n ib_cache_update+0x1a9/0xb80 drivers/infiniband/core/cache.c:1494\n ib_cache_event_task+0xf3/0x1e0 drivers/infiniband/core/cache.c:1568\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f2/0x390 kernel/kthread.c:389\n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\"\n\n1). In the link [1],\n\n\"\n infiniband syz2: set down\n\"\n\nThis means that on 839.350575, the event ib_cache_event_task was sent andi\nqueued in ib_wq.\n\n2). In the link [1],\n\n\"\n team0 (unregistering): Port device team_slave_0 removed\n\"\n\nIt indicates that before 843.251853, the net device should be freed.\n\n3). In the link [1],\n\n\"\n BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0\n\"\n\nThis means that on 850.559070, this slab-use-after-free problem occurred.\n\nIn all, on 839.350575, the event ib_cache_event_task was sent and queued\nin ib_wq,\n\nbefore 843.251853, the net device veth was freed.\n\non 850.559070, this event was executed, and the mentioned freed net device\nwas called. Thus, the above call trace occurred.\n\n[1] https://syzkaller.appspot.com/x/log.txt?x=12e7025f980000",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57795",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-15",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-44987",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: prevent UAF in ip6_send_skb()\n\nsyzbot reported an UAF in ip6_send_skb() [1]\n\nAfter ip6_local_out() has returned, we no longer can safely\ndereference rt, unless we hold rcu_read_lock().\n\nA similar issue has been fixed in commit\na688caa34beb (\"ipv6: take rcu lock in rawv6_send_hdrinc()\")\n\nAnother potential issue in ip6_finish_output2() is handled in a\nseparate patch.\n\n[1]\n BUG: KASAN: slab-use-after-free in ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964\nRead of size 8 at addr ffff88806dde4858 by task syz.1.380/6530\n\nCPU: 1 UID: 0 PID: 6530 Comm: syz.1.380 Not tainted 6.11.0-rc3-syzkaller-00306-gdf6cbc62cc9b #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:93 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  ip6_send_skb+0x18d/0x230 net/ipv6/ip6_output.c:1964\n  rawv6_push_pending_frames+0x75c/0x9e0 net/ipv6/raw.c:588\n  rawv6_sendmsg+0x19c7/0x23c0 net/ipv6/raw.c:926\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x1a6/0x270 net/socket.c:745\n  sock_write_iter+0x2dd/0x400 net/socket.c:1160\n do_iter_readv_writev+0x60a/0x890\n  vfs_writev+0x37c/0xbb0 fs/read_write.c:971\n  do_writev+0x1b1/0x350 fs/read_write.c:1018\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f936bf79e79\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f936cd7f038 EFLAGS: 00000246 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: 00007f936c115f80 RCX: 00007f936bf79e79\nRDX: 0000000000000001 RSI: 0000000020000040 RDI: 0000000000000004\nRBP: 00007f936bfe7916 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007f936c115f80 R15: 00007fff2860a7a8\n </TASK>\n\nAllocated by task 6530:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  unpoison_slab_object mm/kasan/common.c:312 [inline]\n  __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:338\n  kasan_slab_alloc include/linux/kasan.h:201 [inline]\n  slab_post_alloc_hook mm/slub.c:3988 [inline]\n  slab_alloc_node mm/slub.c:4037 [inline]\n  kmem_cache_alloc_noprof+0x135/0x2a0 mm/slub.c:4044\n  dst_alloc+0x12b/0x190 net/core/dst.c:89\n  ip6_blackhole_route+0x59/0x340 net/ipv6/route.c:2670\n  make_blackhole net/xfrm/xfrm_policy.c:3120 [inline]\n  xfrm_lookup_route+0xd1/0x1c0 net/xfrm/xfrm_policy.c:3313\n  ip6_dst_lookup_flow+0x13e/0x180 net/ipv6/ip6_output.c:1257\n  rawv6_sendmsg+0x1283/0x23c0 net/ipv6/raw.c:898\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x1a6/0x270 net/socket.c:745\n  ____sys_sendmsg+0x525/0x7d0 net/socket.c:2597\n  ___sys_sendmsg net/socket.c:2651 [inline]\n  __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2680\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 45:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n  poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n  __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256\n  kasan_slab_free include/linux/kasan.h:184 [inline]\n  slab_free_hook mm/slub.c:2252 [inline]\n  slab_free mm/slub.c:4473 [inline]\n  kmem_cache_free+0x145/0x350 mm/slub.c:4548\n  dst_destroy+0x2ac/0x460 net/core/dst.c:124\n  rcu_do_batch kernel/rcu/tree.c:2569 [inline]\n  rcu_core+0xafd/0x1830 kernel/rcu/tree.\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44987",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47646",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRevert \"Revert \"block, bfq: honor already-setup queue merges\"\"\n\nA crash [1] happened to be triggered in conjunction with commit\n2d52c58b9c9b (\"block, bfq: honor already-setup queue merges\"). The\nlatter was then reverted by commit ebc69e897e17 (\"Revert \"block, bfq:\nhonor already-setup queue merges\"\"). Yet, the reverted commit was not\nthe one introducing the bug. In fact, it actually triggered a UAF\nintroduced by a different commit, and now fixed by commit d29bd41428cf\n(\"block, bfq: reset last_bfqq_created on group change\").\n\nSo, there is no point in keeping commit 2d52c58b9c9b (\"block, bfq:\nhonor already-setup queue merges\") out. This commit restores it.\n\n[1] https://bugzilla.kernel.org/show_bug.cgi?id=214503",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47646",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48990",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix use-after-free during gpu recovery\n\n[Why]\n    [  754.862560] refcount_t: underflow; use-after-free.\n    [  754.862898] Call Trace:\n    [  754.862903]  <TASK>\n    [  754.862913]  amdgpu_job_free_cb+0xc2/0xe1 [amdgpu]\n    [  754.863543]  drm_sched_main.cold+0x34/0x39 [amd_sched]\n\n[How]\n    The fw_fence may be not init, check whether dma_fence_init\n    is performed before job free",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48990",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56601",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: inet: do not leave a dangling sk pointer in inet_create()\n\nsock_init_data() attaches the allocated sk object to the provided sock\nobject. If inet_create() fails later, the sk object is freed, but the\nsock object retains the dangling pointer, which may create use-after-free\nlater.\n\nClear the sk pointer in the sock object on error.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56601",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47565",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpt3sas: Fix kernel panic during drive powercycle test\n\nWhile looping over shost's sdev list it is possible that one\nof the drives is getting removed and its sas_target object is\nfreed but its sdev object remains intact.\n\nConsequently, a kernel panic can occur while the driver is trying to access\nthe sas_address field of sas_target object without also checking the\nsas_target object for NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47565",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-09-18",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46830",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Acquire kvm->srcu when handling KVM_SET_VCPU_EVENTS\n\nGrab kvm->srcu when processing KVM_SET_VCPU_EVENTS, as KVM will forcibly\nleave nested VMX/SVM if SMM mode is being toggled, and leaving nested VMX\nreads guest memory.\n\nNote, kvm_vcpu_ioctl_x86_set_vcpu_events() can also be called from KVM_RUN\nvia sync_regs(), which already holds SRCU.  I.e. trying to precisely use\nkvm_vcpu_srcu_read_lock() around the problematic SMM code would cause\nproblems.  Acquiring SRCU isn't all that expensive, so for simplicity,\ngrab it unconditionally for KVM_SET_VCPU_EVENTS.\n\n =============================\n WARNING: suspicious RCU usage\n 6.10.0-rc7-332d2c1d713e-next-vm #552 Not tainted\n -----------------------------\n include/linux/kvm_host.h:1027 suspicious rcu_dereference_check() usage!\n\n other info that might help us debug this:\n\n rcu_scheduler_active = 2, debug_locks = 1\n 1 lock held by repro/1071:\n  #0: ffff88811e424430 (&vcpu->mutex){+.+.}-{3:3}, at: kvm_vcpu_ioctl+0x7d/0x970 [kvm]\n\n stack backtrace:\n CPU: 15 PID: 1071 Comm: repro Not tainted 6.10.0-rc7-332d2c1d713e-next-vm #552\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x7f/0x90\n  lockdep_rcu_suspicious+0x13f/0x1a0\n  kvm_vcpu_gfn_to_memslot+0x168/0x190 [kvm]\n  kvm_vcpu_read_guest+0x3e/0x90 [kvm]\n  nested_vmx_load_msr+0x6b/0x1d0 [kvm_intel]\n  load_vmcs12_host_state+0x432/0xb40 [kvm_intel]\n  vmx_leave_nested+0x30/0x40 [kvm_intel]\n  kvm_vcpu_ioctl_x86_set_vcpu_events+0x15d/0x2b0 [kvm]\n  kvm_arch_vcpu_ioctl+0x1107/0x1750 [kvm]\n  ? mark_held_locks+0x49/0x70\n  ? kvm_vcpu_ioctl+0x7d/0x970 [kvm]\n  ? kvm_vcpu_ioctl+0x497/0x970 [kvm]\n  kvm_vcpu_ioctl+0x497/0x970 [kvm]\n  ? lock_acquire+0xba/0x2d0\n  ? find_held_lock+0x2b/0x80\n  ? do_user_addr_fault+0x40c/0x6f0\n  ? lock_release+0xb7/0x270\n  __x64_sys_ioctl+0x82/0xb0\n  do_syscall_64+0x6c/0x170\n  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n RIP: 0033:0x7ff11eb1b539\n  </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46830",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52973",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvc_screen: move load of struct vc_data pointer in vcs_read() to avoid UAF\n\nAfter a call to console_unlock() in vcs_read() the vc_data struct can be\nfreed by vc_deallocate(). Because of that, the struct vc_data pointer\nload must be done at the top of while loop in vcs_read() to avoid a UAF\nwhen vcs_size() is called.\n\nSyzkaller reported a UAF in vcs_size().\n\nBUG: KASAN: use-after-free in vcs_size (drivers/tty/vt/vc_screen.c:215)\nRead of size 4 at addr ffff8881137479a8 by task 4a005ed81e27e65/1537\n\nCPU: 0 PID: 1537 Comm: 4a005ed81e27e65 Not tainted 6.2.0-rc5 #1\nHardware name: Red Hat KVM, BIOS 1.15.0-2.module\nCall Trace:\n  <TASK>\n__asan_report_load4_noabort (mm/kasan/report_generic.c:350)\nvcs_size (drivers/tty/vt/vc_screen.c:215)\nvcs_read (drivers/tty/vt/vc_screen.c:415)\nvfs_read (fs/read_write.c:468 fs/read_write.c:450)\n...\n  </TASK>\n\nAllocated by task 1191:\n...\nkmalloc_trace (mm/slab_common.c:1069)\nvc_allocate (./include/linux/slab.h:580 ./include/linux/slab.h:720\n     drivers/tty/vt/vt.c:1128 drivers/tty/vt/vt.c:1108)\ncon_install (drivers/tty/vt/vt.c:3383)\ntty_init_dev (drivers/tty/tty_io.c:1301 drivers/tty/tty_io.c:1413\n     drivers/tty/tty_io.c:1390)\ntty_open (drivers/tty/tty_io.c:2080 drivers/tty/tty_io.c:2126)\nchrdev_open (fs/char_dev.c:415)\ndo_dentry_open (fs/open.c:883)\nvfs_open (fs/open.c:1014)\n...\n\nFreed by task 1548:\n...\nkfree (mm/slab_common.c:1021)\nvc_port_destruct (drivers/tty/vt/vt.c:1094)\ntty_port_destructor (drivers/tty/tty_port.c:296)\ntty_port_put (drivers/tty/tty_port.c:312)\nvt_disallocate_all (drivers/tty/vt/vt_ioctl.c:662 (discriminator 2))\nvt_ioctl (drivers/tty/vt/vt_ioctl.c:903)\ntty_ioctl (drivers/tty/tty_io.c:2776)\n...\n\nThe buggy address belongs to the object at ffff888113747800\n  which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 424 bytes inside of\n  1024-byte region [ffff888113747800, ffff888113747c00)\n\nThe buggy address belongs to the physical page:\npage:00000000b3fe6c7c refcount:1 mapcount:0 mapping:0000000000000000\n     index:0x0 pfn:0x113740\nhead:00000000b3fe6c7c order:3 compound_mapcount:0 subpages_mapcount:0\n     compound_pincount:0\nanon flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff)\nraw: 0017ffffc0010200 ffff888100042dc0 0000000000000000 dead000000000001\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n  ffff888113747880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff888113747900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n> ffff888113747980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                   ^\n  ffff888113747a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff888113747a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\nDisabling lock debugging due to kernel taint",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52973",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53237",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: fix use-after-free in device_for_each_child()\n\nSyzbot has reported the following KASAN splat:\n\nBUG: KASAN: slab-use-after-free in device_for_each_child+0x18f/0x1a0\nRead of size 8 at addr ffff88801f605308 by task kbnepd bnep0/4980\n\nCPU: 0 UID: 0 PID: 4980 Comm: kbnepd bnep0 Not tainted 6.12.0-rc4-00161-gae90f6a6170d #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x100/0x190\n ? device_for_each_child+0x18f/0x1a0\n print_report+0x13a/0x4cb\n ? __virt_addr_valid+0x5e/0x590\n ? __phys_addr+0xc6/0x150\n ? device_for_each_child+0x18f/0x1a0\n kasan_report+0xda/0x110\n ? device_for_each_child+0x18f/0x1a0\n ? __pfx_dev_memalloc_noio+0x10/0x10\n device_for_each_child+0x18f/0x1a0\n ? __pfx_device_for_each_child+0x10/0x10\n pm_runtime_set_memalloc_noio+0xf2/0x180\n netdev_unregister_kobject+0x1ed/0x270\n unregister_netdevice_many_notify+0x123c/0x1d80\n ? __mutex_trylock_common+0xde/0x250\n ? __pfx_unregister_netdevice_many_notify+0x10/0x10\n ? trace_contention_end+0xe6/0x140\n ? __mutex_lock+0x4e7/0x8f0\n ? __pfx_lock_acquire.part.0+0x10/0x10\n ? rcu_is_watching+0x12/0xc0\n ? unregister_netdev+0x12/0x30\n unregister_netdevice_queue+0x30d/0x3f0\n ? __pfx_unregister_netdevice_queue+0x10/0x10\n ? __pfx_down_write+0x10/0x10\n unregister_netdev+0x1c/0x30\n bnep_session+0x1fb3/0x2ab0\n ? __pfx_bnep_session+0x10/0x10\n ? __pfx_lock_release+0x10/0x10\n ? __pfx_woken_wake_function+0x10/0x10\n ? __kthread_parkme+0x132/0x200\n ? __pfx_bnep_session+0x10/0x10\n ? kthread+0x13a/0x370\n ? __pfx_bnep_session+0x10/0x10\n kthread+0x2b7/0x370\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x48/0x80\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 4974:\n kasan_save_stack+0x30/0x50\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0xaa/0xb0\n __kmalloc_noprof+0x1d1/0x440\n hci_alloc_dev_priv+0x1d/0x2820\n __vhci_create_device+0xef/0x7d0\n vhci_write+0x2c7/0x480\n vfs_write+0x6a0/0xfc0\n ksys_write+0x12f/0x260\n do_syscall_64+0xc7/0x250\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 4979:\n kasan_save_stack+0x30/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n __kasan_slab_free+0x4f/0x70\n kfree+0x141/0x490\n hci_release_dev+0x4d9/0x600\n bt_host_release+0x6a/0xb0\n device_release+0xa4/0x240\n kobject_put+0x1ec/0x5a0\n put_device+0x1f/0x30\n vhci_release+0x81/0xf0\n __fput+0x3f6/0xb30\n task_work_run+0x151/0x250\n do_exit+0xa79/0x2c30\n do_group_exit+0xd5/0x2a0\n get_signal+0x1fcd/0x2210\n arch_do_signal_or_restart+0x93/0x780\n syscall_exit_to_user_mode+0x140/0x290\n do_syscall_64+0xd4/0x250\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nIn 'hci_conn_del_sysfs()', 'device_unregister()' may be called when\nan underlying (kobject) reference counter is greater than 1. This\nmeans that reparenting (happened when the device is actually freed)\nis delayed and, during that delay, parent controller device (hciX)\nmay be deleted. Since the latter may create a dangling pointer to\nfreed parent, avoid that scenario by reparenting to NULL explicitly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53237",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47698",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrivers: media: dvb-frontends/rtl2832: fix an out-of-bounds write error\n\nEnsure index in rtl2832_pid_filter does not exceed 31 to prevent\nout-of-bounds access.\n\ndev->filters is a 32-bit value, so set_bit and clear_bit functions should\nonly operate on indices from 0 to 31. If index is 32, it will attempt to\naccess a non-existent 33rd bit, leading to out-of-bounds access.\nChange the boundary check from index > 32 to index >= 32 to resolve this\nissue.\n\n[hverkuil: added fixes tag, rtl2830_pid_filter -> rtl2832_pid_filter in logmsg]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47698",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49779",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkprobes: Skip clearing aggrprobe's post_handler in kprobe-on-ftrace case\n\nIn __unregister_kprobe_top(), if the currently unregistered probe has\npost_handler but other child probes of the aggrprobe do not have\npost_handler, the post_handler of the aggrprobe is cleared. If this is\na ftrace-based probe, there is a problem. In later calls to\ndisarm_kprobe(), we will use kprobe_ftrace_ops because post_handler is\nNULL. But we're armed with kprobe_ipmodify_ops. This triggers a WARN in\n__disarm_kprobe_ftrace() and may even cause use-after-free:\n\n  Failed to disarm kprobe-ftrace at kernel_clone+0x0/0x3c0 (error -2)\n  WARNING: CPU: 5 PID: 137 at kernel/kprobes.c:1135 __disarm_kprobe_ftrace.isra.21+0xcf/0xe0\n  Modules linked in: testKprobe_007(-)\n  CPU: 5 PID: 137 Comm: rmmod Not tainted 6.1.0-rc4-dirty #18\n  [...]\n  Call Trace:\n   <TASK>\n   __disable_kprobe+0xcd/0xe0\n   __unregister_kprobe_top+0x12/0x150\n   ? mutex_lock+0xe/0x30\n   unregister_kprobes.part.23+0x31/0xa0\n   unregister_kprobe+0x32/0x40\n   __x64_sys_delete_module+0x15e/0x260\n   ? do_user_addr_fault+0x2cd/0x6b0\n   do_syscall_64+0x3a/0x90\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n   [...]\n\nFor the kprobe-on-ftrace case, we keep the post_handler setting to\nidentify this aggrprobe armed with kprobe_ipmodify_ops. This way we\ncan disarm it correctly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49779",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49651",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsrcu: Tighten cleanup_srcu_struct() GP checks\n\nCurrently, cleanup_srcu_struct() checks for a grace period in progress,\nbut it does not check for a grace period that has not yet started but\nwhich might start at any time.  Such a situation could result in a\nuse-after-free bug, so this commit adds a check for a grace period that\nis needed but not yet started to cleanup_srcu_struct().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49651",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53432",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirewire: net: fix use after free in fwnet_finish_incoming_packet()\n\nThe netif_rx() function frees the skb so we can't dereference it to\nsave the skb->len.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53432",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47483",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nregmap: Fix possible double-free in regcache_rbtree_exit()\n\nIn regcache_rbtree_insert_to_block(), when 'present' realloc failed,\nthe 'blk' which is supposed to assign to 'rbnode->block' will be freed,\nso 'rbnode->block' points a freed memory, in the error handling path of\nregcache_rbtree_init(), 'rbnode->block' will be freed again in\nregcache_rbtree_exit(), KASAN will report double-free as follows:\n\nBUG: KASAN: double-free or invalid-free in kfree+0xce/0x390\nCall Trace:\n slab_free_freelist_hook+0x10d/0x240\n kfree+0xce/0x390\n regcache_rbtree_exit+0x15d/0x1a0\n regcache_rbtree_init+0x224/0x2c0\n regcache_init+0x88d/0x1310\n __regmap_init+0x3151/0x4a80\n __devm_regmap_init+0x7d/0x100\n madera_spi_probe+0x10f/0x333 [madera_spi]\n spi_probe+0x183/0x210\n really_probe+0x285/0xc30\n\nTo fix this, moving up the assignment of rbnode->block to immediately after\nthe reallocation has succeeded so that the data structure stays valid even\nif the second reallocation fails.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47483",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48778",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: rawnand: gpmi: don't leak PM reference in error path\n\nIf gpmi_nfc_apply_timings() fails, the PM runtime usage counter must be\ndropped.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48778",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46746",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: amd_sfh: free driver_data after destroying hid device\n\nHID driver callbacks aren't called anymore once hid_destroy_device() has\nbeen called. Hence, hid driver_data should be freed only after the\nhid_destroy_device() function returned as driver_data is used in several\ncallbacks.\n\nI observed a crash with kernel 6.10.0 on my T14s Gen 3, after enabling\nKASAN to debug memory allocation, I got this output:\n\n  [   13.050438] ==================================================================\n  [   13.054060] BUG: KASAN: slab-use-after-free in amd_sfh_get_report+0x3ec/0x530 [amd_sfh]\n  [   13.054809] psmouse serio1: trackpoint: Synaptics TrackPoint firmware: 0x02, buttons: 3/3\n  [   13.056432] Read of size 8 at addr ffff88813152f408 by task (udev-worker)/479\n\n  [   13.060970] CPU: 5 PID: 479 Comm: (udev-worker) Not tainted 6.10.0-arch1-2 #1 893bb55d7f0073f25c46adbb49eb3785fefd74b0\n  [   13.063978] Hardware name: LENOVO 21CQCTO1WW/21CQCTO1WW, BIOS R22ET70W (1.40 ) 03/21/2024\n  [   13.067860] Call Trace:\n  [   13.069383] input: TPPS/2 Synaptics TrackPoint as /devices/platform/i8042/serio1/input/input8\n  [   13.071486]  <TASK>\n  [   13.071492]  dump_stack_lvl+0x5d/0x80\n  [   13.074870] snd_hda_intel 0000:33:00.6: enabling device (0000 -> 0002)\n  [   13.078296]  ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.082199]  print_report+0x174/0x505\n  [   13.085776]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n  [   13.089367]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.093255]  ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.097464]  kasan_report+0xc8/0x150\n  [   13.101461]  ? amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.105802]  amd_sfh_get_report+0x3ec/0x530 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.110303]  amdtp_hid_request+0xb8/0x110 [amd_sfh 05f43221435b5205f734cd9da29399130f398a38]\n  [   13.114879]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.119450]  sensor_hub_get_feature+0x1d3/0x540 [hid_sensor_hub 3f13be3016ff415bea03008d45d99da837ee3082]\n  [   13.124097]  hid_sensor_parse_common_attributes+0x4d0/0xad0 [hid_sensor_iio_common c3a5cbe93969c28b122609768bbe23efe52eb8f5]\n  [   13.127404]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.131925]  ? __pfx_hid_sensor_parse_common_attributes+0x10/0x10 [hid_sensor_iio_common c3a5cbe93969c28b122609768bbe23efe52eb8f5]\n  [   13.136455]  ? _raw_spin_lock_irqsave+0x96/0xf0\n  [   13.140197]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n  [   13.143602]  ? devm_iio_device_alloc+0x34/0x50 [industrialio 3d261d5e5765625d2b052be40e526d62b1d2123b]\n  [   13.147234]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.150446]  ? __devm_add_action+0x167/0x1d0\n  [   13.155061]  hid_gyro_3d_probe+0x120/0x7f0 [hid_sensor_gyro_3d 63da36a143b775846ab2dbb86c343b401b5e3172]\n  [   13.158581]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.161814]  platform_probe+0xa2/0x150\n  [   13.165029]  really_probe+0x1e3/0x8a0\n  [   13.168243]  __driver_probe_device+0x18c/0x370\n  [   13.171500]  driver_probe_device+0x4a/0x120\n  [   13.175000]  __driver_attach+0x190/0x4a0\n  [   13.178521]  ? __pfx___driver_attach+0x10/0x10\n  [   13.181771]  bus_for_each_dev+0x106/0x180\n  [   13.185033]  ? __pfx__raw_spin_lock+0x10/0x10\n  [   13.188229]  ? __pfx_bus_for_each_dev+0x10/0x10\n  [   13.191446]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.194382]  bus_add_driver+0x29e/0x4d0\n  [   13.197328]  driver_register+0x1a5/0x360\n  [   13.200283]  ? __pfx_hid_gyro_3d_platform_driver_init+0x10/0x10 [hid_sensor_gyro_3d 63da36a143b775846ab2dbb86c343b401b5e3172]\n  [   13.203362]  do_one_initcall+0xa7/0x380\n  [   13.206432]  ? __pfx_do_one_initcall+0x10/0x10\n  [   13.210175]  ? srso_alias_return_thunk+0x5/0xfbef5\n  [   13.213211]  ? kasan_unpoison+0x44/0x70\n  [   13.216688]  do_init_module+0x238/0x750\n  [   13.2196\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46746",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49236",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix UAF due to race between btf_try_get_module and load_module\n\nWhile working on code to populate kfunc BTF ID sets for module BTF from\nits initcall, I noticed that by the time the initcall is invoked, the\nmodule BTF can already be seen by userspace (and the BPF verifier). The\nexisting btf_try_get_module calls try_module_get which only fails if\nmod->state == MODULE_STATE_GOING, i.e. it can increment module reference\nwhen module initcall is happening in parallel.\n\nCurrently, BTF parsing happens from MODULE_STATE_COMING notifier\ncallback. At this point, the module initcalls have not been invoked.\nThe notifier callback parses and prepares the module BTF, allocates an\nID, which publishes it to userspace, and then adds it to the btf_modules\nlist allowing the kernel to invoke btf_try_get_module for the BTF.\n\nHowever, at this point, the module has not been fully initialized (i.e.\nits initcalls have not finished). The code in module.c can still fail\nand free the module, without caring for other users. However, nothing\nstops btf_try_get_module from succeeding between the state transition\nfrom MODULE_STATE_COMING to MODULE_STATE_LIVE.\n\nThis leads to a use-after-free issue when BPF program loads\nsuccessfully in the state transition, load_module's do_init_module call\nfails and frees the module, and BPF program fd on close calls module_put\nfor the freed module. Future patch has test case to verify we don't\nregress in this area in future.\n\nThere are multiple points after prepare_coming_module (in load_module)\nwhere failure can occur and module loading can return error. We\nillustrate and test for the race using the last point where it can\npractically occur (in module __init function).\n\nAn illustration of the race:\n\nCPU 0                           CPU 1\n\t\t\t  load_module\n\t\t\t    notifier_call(MODULE_STATE_COMING)\n\t\t\t      btf_parse_module\n\t\t\t      btf_alloc_id\t// Published to userspace\n\t\t\t      list_add(&btf_mod->list, btf_modules)\n\t\t\t    mod->init(...)\n...\t\t\t\t^\nbpf_check\t\t        |\ncheck_pseudo_btf_id             |\n  btf_try_get_module            |\n    returns true                |  ...\n...                             |  module __init in progress\nreturn prog_fd                  |  ...\n...                             V\n\t\t\t    if (ret < 0)\n\t\t\t      free_module(mod)\n\t\t\t    ...\nclose(prog_fd)\n ...\n bpf_prog_free_deferred\n  module_put(used_btf.mod) // use-after-free\n\nWe fix this issue by setting a flag BTF_MODULE_F_LIVE, from the notifier\ncallback when MODULE_STATE_LIVE state is reached for the module, so that\nwe return NULL from btf_try_get_module for modules that are not fully\nformed. Since try_module_get already checks that module is not in\nMODULE_STATE_GOING state, and that is the only transition a live module\ncan make before being removed from btf_modules list, this is enough to\nclose the race and prevent the bug.\n\nA later selftest patch crafts the race condition artifically to verify\nthat it has been fixed, and that verifier fails to load program (with\nENXIO).\n\nLastly, a couple of comments:\n\n 1. Even if this race didn't exist, it seems more appropriate to only\n    access resources (ksyms and kfuncs) of a fully formed module which\n    has been initialized completely.\n\n 2. This patch was born out of need for synchronization against module\n    initcall for the next patch, so it is needed for correctness even\n    without the aforementioned race condition. The BTF resources\n    initialized by module initcall are set up once and then only looked\n    up, so just waiting until the initcall has finished ensures correct\n    behavior.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49236",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-35979",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nraid1: fix use-after-free for original bio in raid1_write_request()\n\nr1_bio->bios[] is used to record new bios that will be issued to\nunderlying disks, however, in raid1_write_request(), r1_bio->bios[]\nwill set to the original bio temporarily. Meanwhile, if blocked rdev\nis set, free_r1bio() will be called causing that all r1_bio->bios[]\nto be freed:\n\nraid1_write_request()\n r1_bio = alloc_r1bio(mddev, bio); -> r1_bio->bios[] is NULL\n for (i = 0;  i < disks; i++) -> for each rdev in conf\n  // first rdev is normal\n  r1_bio->bios[0] = bio; -> set to original bio\n  // second rdev is blocked\n  if (test_bit(Blocked, &rdev->flags))\n   break\n\n if (blocked_rdev)\n  free_r1bio()\n   put_all_bios()\n    bio_put(r1_bio->bios[0]) -> original bio is freed\n\nTest scripts:\n\nmdadm -CR /dev/md0 -l1 -n4 /dev/sd[abcd] --assume-clean\nfio -filename=/dev/md0 -ioengine=libaio -rw=write -bs=4k -numjobs=1 \\\n    -iodepth=128 -name=test -direct=1\necho blocked > /sys/block/md0/md/rd2/state\n\nTest result:\n\nBUG bio-264 (Not tainted): Object already free\n-----------------------------------------------------------------------------\n\nAllocated in mempool_alloc_slab+0x24/0x50 age=1 cpu=1 pid=869\n kmem_cache_alloc+0x324/0x480\n mempool_alloc_slab+0x24/0x50\n mempool_alloc+0x6e/0x220\n bio_alloc_bioset+0x1af/0x4d0\n blkdev_direct_IO+0x164/0x8a0\n blkdev_write_iter+0x309/0x440\n aio_write+0x139/0x2f0\n io_submit_one+0x5ca/0xb70\n __do_sys_io_submit+0x86/0x270\n __x64_sys_io_submit+0x22/0x30\n do_syscall_64+0xb1/0x210\n entry_SYSCALL_64_after_hwframe+0x6c/0x74\nFreed in mempool_free_slab+0x1f/0x30 age=1 cpu=1 pid=869\n kmem_cache_free+0x28c/0x550\n mempool_free_slab+0x1f/0x30\n mempool_free+0x40/0x100\n bio_free+0x59/0x80\n bio_put+0xf0/0x220\n free_r1bio+0x74/0xb0\n raid1_make_request+0xadf/0x1150\n md_handle_request+0xc7/0x3b0\n md_submit_bio+0x76/0x130\n __submit_bio+0xd8/0x1d0\n submit_bio_noacct_nocheck+0x1eb/0x5c0\n submit_bio_noacct+0x169/0xd40\n submit_bio+0xee/0x1d0\n blkdev_direct_IO+0x322/0x8a0\n blkdev_write_iter+0x309/0x440\n aio_write+0x139/0x2f0\n\nSince that bios for underlying disks are not allocated yet, fix this\nproblem by using mempool_free() directly to free the r1_bio.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35979",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-20",
                    "modification_date": "2025-01-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-46845",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/timerlat: Only clear timer if a kthread exists\n\nThe timerlat tracer can use user space threads to check for osnoise and\ntimer latency. If the program using this is killed via a SIGTERM, the\nthreads are shutdown one at a time and another tracing instance can start\nup resetting the threads before they are fully closed. That causes the\nhrtimer assigned to the kthread to be shutdown and freed twice when the\ndying thread finally closes the file descriptors, causing a use-after-free\nbug.\n\nOnly cancel the hrtimer if the associated thread is still around. Also add\nthe interface_lock around the resetting of the tlat_var->kthread.\n\nNote, this is just a quick fix that can be backported to stable. A real\nfix is to have a better synchronization between the shutdown of old\nthreads and the starting of new ones.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46845",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-27",
                    "modification_date": "2024-10-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53142",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: copy last block omitted in ice_get_module_eeprom()\n\nice_get_module_eeprom() is broken since commit e9c9692c8a81 (\"ice:\nReimplement module reads used by ethtool\") In this refactor,\nice_get_module_eeprom() reads the eeprom in blocks of size 8.\nBut the condition that should protect the buffer overflow\nignores the last block. The last block always contains zeros.\n\nBug uncovered by ethtool upstream commit 9538f384b535\n(\"netlink: eeprom: Defer page requests to individual parsers\")\nAfter this commit, ethtool reads a block with length = 1;\nto read the SFF-8024 identifier value.\n\nunpatched driver:\n$ ethtool -m enp65s0f0np0 offset 0x90 length 8\nOffset          Values\n------          ------\n0x0090:         00 00 00 00 00 00 00 00\n$ ethtool -m enp65s0f0np0 offset 0x90 length 12\nOffset          Values\n------          ------\n0x0090:         00 00 01 a0 4d 65 6c 6c 00 00 00 00\n$\n\n$ ethtool -m enp65s0f0np0\nOffset          Values\n------          ------\n0x0000:         11 06 06 00 00 00 00 00 00 00 00 00 00 00 00 00\n0x0010:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0x0020:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0x0030:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0x0040:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0x0050:         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0x0060:         00 00 00 00 00 00 00 00 00 00 00 00 00 01 08 00\n0x0070:         00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\npatched driver:\n$ ethtool -m enp65s0f0np0 offset 0x90 length 8\nOffset          Values\n------          ------\n0x0090:         00 00 01 a0 4d 65 6c 6c\n$ ethtool -m enp65s0f0np0 offset 0x90 length 12\nOffset          Values\n------          ------\n0x0090:         00 00 01 a0 4d 65 6c 6c 61 6e 6f 78\n$ ethtool -m enp65s0f0np0\n    Identifier                                : 0x11 (QSFP28)\n    Extended identifier                       : 0x00\n    Extended identifier description           : 1.5W max. Power consumption\n    Extended identifier description           : No CDR in TX, No CDR in RX\n    Extended identifier description           : High Power Class (> 3.5 W) not enabled\n    Connector                                 : 0x23 (No separable connector)\n    Transceiver codes                         : 0x88 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n    Transceiver type                          : 40G Ethernet: 40G Base-CR4\n    Transceiver type                          : 25G Ethernet: 25G Base-CR CA-N\n    Encoding                                  : 0x05 (64B/66B)\n    BR, Nominal                               : 25500Mbps\n    Rate identifier                           : 0x00\n    Length (SMF,km)                           : 0km\n    Length (OM3 50um)                         : 0m\n    Length (OM2 50um)                         : 0m\n    Length (OM1 62.5um)                       : 0m\n    Length (Copper or Active cable)           : 1m\n    Transmitter technology                    : 0xa0 (Copper cable unequalized)\n    Attenuation at 2.5GHz                     : 4db\n    Attenuation at 5.0GHz                     : 5db\n    Attenuation at 7.0GHz                     : 7db\n    Attenuation at 12.9GHz                    : 10db\n    ........\n    ....",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53142",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-35911",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix memory corruption bug with suspend and rebuild\n\nThe ice driver would previously panic after suspend. This is caused\nfrom the driver *only* calling the ice_vsi_free_q_vectors() function by\nitself, when it is suspending. Since commit b3e7b3a6ee92 (\"ice: prevent\nNULL pointer deref during reload\") the driver has zeroed out\nnum_q_vectors, and only restored it in ice_vsi_cfg_def().\n\nThis further causes the ice_rebuild() function to allocate a zero length\nbuffer, after which num_q_vectors is updated, and then the new value of\nnum_q_vectors is used to index into the zero length buffer, which\ncorrupts memory.\n\nThe fix entails making sure all the code referencing num_q_vectors only\ndoes so after it has been reset via ice_vsi_cfg_def().\n\nI didn't perform a full bisect, but I was able to test against 6.1.77\nkernel and that ice driver works fine for suspend/resume with no panic,\nso sometime since then, this problem was introduced.\n\nAlso clean up an un-needed init of a local variable in the function\nbeing modified.\n\nPANIC from 6.8.0-rc1:\n\n[1026674.915596] PM: suspend exit\n[1026675.664697] ice 0000:17:00.1: PTP reset successful\n[1026675.664707] ice 0000:17:00.1: 2755 msecs passed between update to cached PHC time\n[1026675.667660] ice 0000:b1:00.0: PTP reset successful\n[1026675.675944] ice 0000:b1:00.0: 2832 msecs passed between update to cached PHC time\n[1026677.137733] ixgbe 0000:31:00.0 ens787: NIC Link is Up 1 Gbps, Flow Control: None\n[1026677.190201] BUG: kernel NULL pointer dereference, address: 0000000000000010\n[1026677.192753] ice 0000:17:00.0: PTP reset successful\n[1026677.192764] ice 0000:17:00.0: 4548 msecs passed between update to cached PHC time\n[1026677.197928] #PF: supervisor read access in kernel mode\n[1026677.197933] #PF: error_code(0x0000) - not-present page\n[1026677.197937] PGD 1557a7067 P4D 0\n[1026677.212133] ice 0000:b1:00.1: PTP reset successful\n[1026677.212143] ice 0000:b1:00.1: 4344 msecs passed between update to cached PHC time\n[1026677.212575]\n[1026677.243142] Oops: 0000 [#1] PREEMPT SMP NOPTI\n[1026677.247918] CPU: 23 PID: 42790 Comm: kworker/23:0 Kdump: loaded Tainted: G        W          6.8.0-rc1+ #1\n[1026677.257989] Hardware name: Intel Corporation M50CYP2SBSTD/M50CYP2SBSTD, BIOS SE5C620.86B.01.01.0005.2202160810 02/16/2022\n[1026677.269367] Workqueue: ice ice_service_task [ice]\n[1026677.274592] RIP: 0010:ice_vsi_rebuild_set_coalesce+0x130/0x1e0 [ice]\n[1026677.281421] Code: 0f 84 3a ff ff ff 41 0f b7 74 ec 02 66 89 b0 22 02 00 00 81 e6 ff 1f 00 00 e8 ec fd ff ff e9 35 ff ff ff 48 8b 43 30 49 63 ed <41> 0f b7 34 24 41 83 c5 01 48 8b 3c e8 66 89 b7 aa 02 00 00 81 e6\n[1026677.300877] RSP: 0018:ff3be62a6399bcc0 EFLAGS: 00010202\n[1026677.306556] RAX: ff28691e28980828 RBX: ff28691e41099828 RCX: 0000000000188000\n[1026677.314148] RDX: 0000000000000000 RSI: 0000000000000010 RDI: ff28691e41099828\n[1026677.321730] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\n[1026677.329311] R10: 0000000000000007 R11: ffffffffffffffc0 R12: 0000000000000010\n[1026677.336896] R13: 0000000000000000 R14: 0000000000000000 R15: ff28691e0eaa81a0\n[1026677.344472] FS:  0000000000000000(0000) GS:ff28693cbffc0000(0000) knlGS:0000000000000000\n[1026677.353000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[1026677.359195] CR2: 0000000000000010 CR3: 0000000128df4001 CR4: 0000000000771ef0\n[1026677.366779] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[1026677.374369] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[1026677.381952] PKRU: 55555554\n[1026677.385116] Call Trace:\n[1026677.388023]  <TASK>\n[1026677.390589]  ? __die+0x20/0x70\n[1026677.394105]  ? page_fault_oops+0x82/0x160\n[1026677.398576]  ? do_user_addr_fault+0x65/0x6a0\n[1026677.403307]  ? exc_page_fault+0x6a/0x150\n[1026677.407694]  ? asm_exc_page_fault+0x22/0x30\n[1026677.412349]  ? ice_vsi_rebuild_set_coalesce+0x130/0x1e0 [ice]\n[1026677.4186\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35911",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-19",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52664",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atlantic: eliminate double free in error handling logic\n\nDriver has a logic leak in ring data allocation/free,\nwhere aq_ring_free could be called multiple times on same ring,\nif system is under stress and got memory allocation error.\n\nRing pointer was used as an indicator of failure, but this is\nnot correct since only ring data is allocated/deallocated.\nRing itself is an array member.\n\nChanging ring allocation functions to return error code directly.\nThis simplifies error handling and eliminates aq_ring_free\non higher layer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52664",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-17",
                    "modification_date": "2025-01-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53145",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btsdio: fix use after free bug in btsdio_remove due to race condition\n\nIn btsdio_probe, the data->work is bound with btsdio_work. It will be\nstarted in btsdio_send_frame.\n\nIf the btsdio_remove runs with a unfinished work, there may be a race\ncondition that hdev is freed but used in btsdio_work. Fix it by\ncanceling the work before do cleanup in btsdio_remove.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53145",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-10",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38129",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npage_pool: Fix use-after-free in page_pool_recycle_in_ring\n\nsyzbot reported a uaf in page_pool_recycle_in_ring:\n\nBUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862\nRead of size 8 at addr ffff8880286045a0 by task syz.0.284/6943\n\nCPU: 0 UID: 0 PID: 6943 Comm: syz.0.284 Not tainted 6.13.0-rc3-syzkaller-gdfa94ce54f41 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:489\n kasan_report+0x143/0x180 mm/kasan/report.c:602\n lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862\n __raw_spin_unlock_bh include/linux/spinlock_api_smp.h:165 [inline]\n _raw_spin_unlock_bh+0x1b/0x40 kernel/locking/spinlock.c:210\n spin_unlock_bh include/linux/spinlock.h:396 [inline]\n ptr_ring_produce_bh include/linux/ptr_ring.h:164 [inline]\n page_pool_recycle_in_ring net/core/page_pool.c:707 [inline]\n page_pool_put_unrefed_netmem+0x748/0xb00 net/core/page_pool.c:826\n page_pool_put_netmem include/net/page_pool/helpers.h:323 [inline]\n page_pool_put_full_netmem include/net/page_pool/helpers.h:353 [inline]\n napi_pp_put_page+0x149/0x2b0 net/core/skbuff.c:1036\n skb_pp_recycle net/core/skbuff.c:1047 [inline]\n skb_free_head net/core/skbuff.c:1094 [inline]\n skb_release_data+0x6c4/0x8a0 net/core/skbuff.c:1125\n skb_release_all net/core/skbuff.c:1190 [inline]\n __kfree_skb net/core/skbuff.c:1204 [inline]\n sk_skb_reason_drop+0x1c9/0x380 net/core/skbuff.c:1242\n kfree_skb_reason include/linux/skbuff.h:1263 [inline]\n __skb_queue_purge_reason include/linux/skbuff.h:3343 [inline]\n\nroot cause is:\n\npage_pool_recycle_in_ring\n  ptr_ring_produce\n    spin_lock(&r->producer_lock);\n    WRITE_ONCE(r->queue[r->producer++], ptr)\n      //recycle last page to pool\n\t\t\t\tpage_pool_release\n\t\t\t\t  page_pool_scrub\n\t\t\t\t    page_pool_empty_ring\n\t\t\t\t      ptr_ring_consume\n\t\t\t\t      page_pool_return_page  //release all page\n\t\t\t\t  __page_pool_destroy\n\t\t\t\t     free_percpu(pool->recycle_stats);\n\t\t\t\t     free(pool) //free\n\n     spin_unlock(&r->producer_lock); //pool->ring uaf read\n  recycle_stat_inc(pool, ring);\n\npage_pool can be free while page pool recycle the last page in ring.\nAdd producer-lock barrier to page_pool_release to prevent the page\npool from being free before all pages have been recycled.\n\nrecycle_stat_inc() is empty when CONFIG_PAGE_POOL_STATS is not\nenabled, which will trigger Wempty-body build warning. Add definition\nfor pool stat macro to fix warning.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38129",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50007",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: asihpi: Fix potential OOB array access\n\nASIHPI driver stores some values in the static array upon a response\nfrom the driver, and its index depends on the firmware.  We shouldn't\ntrust it blindly.\n\nThis patch adds a sanity check of the array index to fit in the array\nsize.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50007",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53215",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/fair: Don't balance task to its current running CPU\n\nWe've run into the case that the balancer tries to balance a migration\ndisabled task and trigger the warning in set_task_cpu() like below:\n\n ------------[ cut here ]------------\n WARNING: CPU: 7 PID: 0 at kernel/sched/core.c:3115 set_task_cpu+0x188/0x240\n Modules linked in: hclgevf xt_CHECKSUM ipt_REJECT nf_reject_ipv4 <...snip>\n CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G           O       6.1.0-rc4+ #1\n Hardware name: Huawei TaiShan 2280 V2/BC82AMDC, BIOS 2280-V2 CS V5.B221.01 12/09/2021\n pstate: 604000c9 (nZCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : set_task_cpu+0x188/0x240\n lr : load_balance+0x5d0/0xc60\n sp : ffff80000803bc70\n x29: ffff80000803bc70 x28: ffff004089e190e8 x27: ffff004089e19040\n x26: ffff007effcabc38 x25: 0000000000000000 x24: 0000000000000001\n x23: ffff80000803be84 x22: 000000000000000c x21: ffffb093e79e2a78\n x20: 000000000000000c x19: ffff004089e19040 x18: 0000000000000000\n x17: 0000000000001fad x16: 0000000000000030 x15: 0000000000000000\n x14: 0000000000000003 x13: 0000000000000000 x12: 0000000000000000\n x11: 0000000000000001 x10: 0000000000000400 x9 : ffffb093e4cee530\n x8 : 00000000fffffffe x7 : 0000000000ce168a x6 : 000000000000013e\n x5 : 00000000ffffffe1 x4 : 0000000000000001 x3 : 0000000000000b2a\n x2 : 0000000000000b2a x1 : ffffb093e6d6c510 x0 : 0000000000000001\n Call trace:\n  set_task_cpu+0x188/0x240\n  load_balance+0x5d0/0xc60\n  rebalance_domains+0x26c/0x380\n  _nohz_idle_balance.isra.0+0x1e0/0x370\n  run_rebalance_domains+0x6c/0x80\n  __do_softirq+0x128/0x3d8\n  ____do_softirq+0x18/0x24\n  call_on_irq_stack+0x2c/0x38\n  do_softirq_own_stack+0x24/0x3c\n  __irq_exit_rcu+0xcc/0xf4\n  irq_exit_rcu+0x18/0x24\n  el1_interrupt+0x4c/0xe4\n  el1h_64_irq_handler+0x18/0x2c\n  el1h_64_irq+0x74/0x78\n  arch_cpu_idle+0x18/0x4c\n  default_idle_call+0x58/0x194\n  do_idle+0x244/0x2b0\n  cpu_startup_entry+0x30/0x3c\n  secondary_start_kernel+0x14c/0x190\n  __secondary_switched+0xb0/0xb4\n ---[ end trace 0000000000000000 ]---\n\nFurther investigation shows that the warning is superfluous, the migration\ndisabled task is just going to be migrated to its current running CPU.\nThis is because that on load balance if the dst_cpu is not allowed by the\ntask, we'll re-select a new_dst_cpu as a candidate. If no task can be\nbalanced to dst_cpu we'll try to balance the task to the new_dst_cpu\ninstead. In this case when the migration disabled task is not on CPU it\nonly allows to run on its current CPU, load balance will select its\ncurrent CPU as new_dst_cpu and later triggers the warning above.\n\nThe new_dst_cpu is chosen from the env->dst_grpmask. Currently it\ncontains CPUs in sched_group_span() and if we have overlapped groups it's\npossible to run into this case. This patch makes env->dst_grpmask of\ngroup_balance_mask() which exclude any CPUs from the busiest group and\nsolve the issue. For balancing in a domain with no overlapped groups\nthe behaviour keeps same as before.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53215",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "modification_date": "2025-12-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49474",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: fix dangling sco_conn and use-after-free in sco_sock_timeout\n\nConnecting the same socket twice consecutively in sco_sock_connect()\ncould lead to a race condition where two sco_conn objects are created\nbut only one is associated with the socket. If the socket is closed\nbefore the SCO connection is established, the timer associated with the\ndangling sco_conn object won't be canceled. As the sock object is being\nfreed, the use-after-free problem happens when the timer callback\nfunction sco_sock_timeout() accesses the socket. Here's the call trace:\n\ndump_stack+0x107/0x163\n? refcount_inc+0x1c/\nprint_address_description.constprop.0+0x1c/0x47e\n? refcount_inc+0x1c/0x7b\nkasan_report+0x13a/0x173\n? refcount_inc+0x1c/0x7b\ncheck_memory_region+0x132/0x139\nrefcount_inc+0x1c/0x7b\nsco_sock_timeout+0xb2/0x1ba\nprocess_one_work+0x739/0xbd1\n? cancel_delayed_work+0x13f/0x13f\n? __raw_spin_lock_init+0xf0/0xf0\n? to_kthread+0x59/0x85\nworker_thread+0x593/0x70e\nkthread+0x346/0x35a\n? drain_workqueue+0x31a/0x31a\n? kthread_bind+0x4b/0x4b\nret_from_fork+0x1f/0x30",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49474",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-4439",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nisdn: cpai: check ctr->cnr to avoid array index out of bound\n\nThe cmtp_add_connection() would add a cmtp session to a controller\nand run a kernel thread to process cmtp.\n\n\t__module_get(THIS_MODULE);\n\tsession->task = kthread_run(cmtp_session, session, \"kcmtpd_ctr_%d\",\n\t\t\t\t\t\t\t\tsession->num);\n\nDuring this process, the kernel thread would call detach_capi_ctr()\nto detach a register controller. if the controller\nwas not attached yet, detach_capi_ctr() would\ntrigger an array-index-out-bounds bug.\n\n[   46.866069][ T6479] UBSAN: array-index-out-of-bounds in\ndrivers/isdn/capi/kcapi.c:483:21\n[   46.867196][ T6479] index -1 is out of range for type 'capi_ctr *[32]'\n[   46.867982][ T6479] CPU: 1 PID: 6479 Comm: kcmtpd_ctr_0 Not tainted\n5.15.0-rc2+ #8\n[   46.869002][ T6479] Hardware name: QEMU Standard PC (i440FX + PIIX,\n1996), BIOS 1.14.0-2 04/01/2014\n[   46.870107][ T6479] Call Trace:\n[   46.870473][ T6479]  dump_stack_lvl+0x57/0x7d\n[   46.870974][ T6479]  ubsan_epilogue+0x5/0x40\n[   46.871458][ T6479]  __ubsan_handle_out_of_bounds.cold+0x43/0x48\n[   46.872135][ T6479]  detach_capi_ctr+0x64/0xc0\n[   46.872639][ T6479]  cmtp_session+0x5c8/0x5d0\n[   46.873131][ T6479]  ? __init_waitqueue_head+0x60/0x60\n[   46.873712][ T6479]  ? cmtp_add_msgpart+0x120/0x120\n[   46.874256][ T6479]  kthread+0x147/0x170\n[   46.874709][ T6479]  ? set_kthread_struct+0x40/0x40\n[   46.875248][ T6479]  ret_from_fork+0x1f/0x30\n[   46.875773][ T6479]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4439",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53000",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetlink: prevent potential spectre v1 gadgets\n\nMost netlink attributes are parsed and validated from\n__nla_validate_parse() or validate_nla()\n\n    u16 type = nla_type(nla);\n\n    if (type == 0 || type > maxtype) {\n        /* error or continue */\n    }\n\n@type is then used as an array index and can be used\nas a Spectre v1 gadget.\n\narray_index_nospec() can be used to prevent leaking\ncontent of kernel memory to malicious users.\n\nThis should take care of vast majority of netlink uses,\nbut an audit is needed to take care of others where\nvalidation is not yet centralized in core netlink functions.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53000",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21763",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nneighbour: use RCU protection in __neigh_notify()\n\n__neigh_notify() can be called without RTNL or RCU protection.\n\nUse RCU protection to avoid potential UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21763",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52482",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/srso: Add SRSO mitigation for Hygon processors\n\nAdd mitigation for the speculative return stack overflow vulnerability\nwhich exists on Hygon processors too.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52482",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-29",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37839",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: remove wrong sb->s_sequence check\n\nJournal emptiness is not determined by sb->s_sequence == 0 but rather by\nsb->s_start == 0 (which is set a few lines above). Furthermore 0 is a\nvalid transaction ID so the check can spuriously trigger. Remove the\ninvalid WARN_ON.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37839",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-09",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48787",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niwlwifi: fix use-after-free\n\nIf no firmware was present at all (or, presumably, all of the\nfirmware files failed to parse), we end up unbinding by calling\ndevice_release_driver(), which calls remove(), which then in\niwlwifi calls iwl_drv_stop(), freeing the 'drv' struct. However\nthe new code I added will still erroneously access it after it\nwas freed.\n\nSet 'failure=false' in this case to avoid the access, all data\nwas already freed anyway.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48787",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49888",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: entry: avoid kprobe recursion\n\nThe cortex_a76_erratum_1463225_debug_handler() function is called when\nhandling debug exceptions (and synchronous exceptions from BRK\ninstructions), and so is called when a probed function executes. If the\ncompiler does not inline cortex_a76_erratum_1463225_debug_handler(), it\ncan be probed.\n\nIf cortex_a76_erratum_1463225_debug_handler() is probed, any debug\nexception or software breakpoint exception will result in recursive\nexceptions leading to a stack overflow. This can be triggered with the\nftrace multiple_probes selftest, and as per the example splat below.\n\nThis is a regression caused by commit:\n\n  6459b8469753e9fe (\"arm64: entry: consolidate Cortex-A76 erratum 1463225 workaround\")\n\n... which removed the NOKPROBE_SYMBOL() annotation associated with the\nfunction.\n\nMy intent was that cortex_a76_erratum_1463225_debug_handler() would be\ninlined into its caller, el1_dbg(), which is marked noinstr and cannot\nbe probed. Mark cortex_a76_erratum_1463225_debug_handler() as\n__always_inline to ensure this.\n\nExample splat prior to this patch (with recursive entries elided):\n\n| # echo p cortex_a76_erratum_1463225_debug_handler > /sys/kernel/debug/tracing/kprobe_events\n| # echo p do_el0_svc >> /sys/kernel/debug/tracing/kprobe_events\n| # echo 1 > /sys/kernel/debug/tracing/events/kprobes/enable\n| Insufficient stack space to handle exception!\n| ESR: 0x0000000096000047 -- DABT (current EL)\n| FAR: 0xffff800009cefff0\n| Task stack:     [0xffff800009cf0000..0xffff800009cf4000]\n| IRQ stack:      [0xffff800008000000..0xffff800008004000]\n| Overflow stack: [0xffff00007fbc00f0..0xffff00007fbc10f0]\n| CPU: 0 PID: 145 Comm: sh Not tainted 6.0.0 #2\n| Hardware name: linux,dummy-virt (DT)\n| pstate: 604003c5 (nZCv DAIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n| pc : arm64_enter_el1_dbg+0x4/0x20\n| lr : el1_dbg+0x24/0x5c\n| sp : ffff800009cf0000\n| x29: ffff800009cf0000 x28: ffff000002c74740 x27: 0000000000000000\n| x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000\n| x23: 00000000604003c5 x22: ffff80000801745c x21: 0000aaaac95ac068\n| x20: 00000000f2000004 x19: ffff800009cf0040 x18: 0000000000000000\n| x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n| x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\n| x11: 0000000000000010 x10: ffff800008c87190 x9 : ffff800008ca00d0\n| x8 : 000000000000003c x7 : 0000000000000000 x6 : 0000000000000000\n| x5 : 0000000000000000 x4 : 0000000000000000 x3 : 00000000000043a4\n| x2 : 00000000f2000004 x1 : 00000000f2000004 x0 : ffff800009cf0040\n| Kernel panic - not syncing: kernel stack overflow\n| CPU: 0 PID: 145 Comm: sh Not tainted 6.0.0 #2\n| Hardware name: linux,dummy-virt (DT)\n| Call trace:\n|  dump_backtrace+0xe4/0x104\n|  show_stack+0x18/0x4c\n|  dump_stack_lvl+0x64/0x7c\n|  dump_stack+0x18/0x38\n|  panic+0x14c/0x338\n|  test_taint+0x0/0x2c\n|  panic_bad_stack+0x104/0x118\n|  handle_bad_stack+0x34/0x48\n|  __bad_stack+0x78/0x7c\n|  arm64_enter_el1_dbg+0x4/0x20\n|  el1h_64_sync_handler+0x40/0x98\n|  el1h_64_sync+0x64/0x68\n|  cortex_a76_erratum_1463225_debug_handler+0x0/0x34\n...\n|  el1h_64_sync_handler+0x40/0x98\n|  el1h_64_sync+0x64/0x68\n|  cortex_a76_erratum_1463225_debug_handler+0x0/0x34\n...\n|  el1h_64_sync_handler+0x40/0x98\n|  el1h_64_sync+0x64/0x68\n|  cortex_a76_erratum_1463225_debug_handler+0x0/0x34\n|  el1h_64_sync_handler+0x40/0x98\n|  el1h_64_sync+0x64/0x68\n|  do_el0_svc+0x0/0x28\n|  el0t_64_sync_handler+0x84/0xf0\n|  el0t_64_sync+0x18c/0x190\n| Kernel Offset: disabled\n| CPU features: 0x0080,00005021,19001080\n| Memory Limit: none\n| ---[ end Kernel panic - not syncing: kernel stack overflow ]---\n\nWith this patch, cortex_a76_erratum_1463225_debug_handler() is inlined\ninto el1_dbg(), and el1_dbg() cannot be probed:\n\n| # echo p cortex_a76_erratum_1463225_debug_handler > /sys/kernel/debug/tracing/kprobe_events\n| sh: write error: No such file or directory\n| # grep -w cortex_a76_errat\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49888",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-05-07",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-44964",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nidpf: fix memory leaks and crashes while performing a soft reset\n\nThe second tagged commit introduced a UAF, as it removed restoring\nq_vector->vport pointers after reinitializating the structures.\nThis is due to that all queue allocation functions are performed here\nwith the new temporary vport structure and those functions rewrite\nthe backpointers to the vport. Then, this new struct is freed and\nthe pointers start leading to nowhere.\n\nBut generally speaking, the current logic is very fragile. It claims\nto be more reliable when the system is low on memory, but in fact, it\nconsumes two times more memory as at the moment of running this\nfunction, there are two vports allocated with their queues and vectors.\nMoreover, it claims to prevent the driver from running into \"bad state\",\nbut in fact, any error during the rebuild leaves the old vport in the\npartially allocated state.\nFinally, if the interface is down when the function is called, it always\nallocates a new queue set, but when the user decides to enable the\ninterface later on, vport_open() allocates them once again, IOW there's\na clear memory leak here.\n\nJust don't allocate a new queue set when performing a reset, that solves\ncrashes and memory leaks. Readd the old queue number and reopen the\ninterface on rollback - that solves limbo states when the device is left\ndisabled and/or without HW queues enabled.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44964",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-04",
                    "modification_date": "2024-09-06",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53307",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrbd: avoid use-after-free in do_rbd_add() when rbd_dev_create() fails\n\nIf getting an ID or setting up a work queue in rbd_dev_create() fails,\nuse-after-free on rbd_dev->rbd_client, rbd_dev->spec and rbd_dev->opts\nis triggered in do_rbd_add().  The root cause is that the ownership of\nthese structures is transfered to rbd_dev prematurely and they all end\nup getting freed when rbd_dev_create() calls rbd_dev_free() prior to\nreturning to do_rbd_add().\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE, an\nincomplete patch submitted by Natalia Petrova <n.petrova@fintech.ru>.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53307",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-47745",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: call the security_mmap_file() LSM hook in remap_file_pages()\n\nThe remap_file_pages syscall handler calls do_mmap() directly, which\ndoesn't contain the LSM security check. And if the process has called\npersonality(READ_IMPLIES_EXEC) before and remap_file_pages() is called for\nRW pages, this will actually result in remapping the pages to RWX,\nbypassing a W^X policy enforced by SELinux.\n\nSo we should check prot by security_mmap_file LSM hook in the\nremap_file_pages syscall handler before do_mmap() is called. Otherwise, it\npotentially permits an attacker to bypass a W^X policy enforced by\nSELinux.\n\nThe bypass is similar to CVE-2016-10044, which bypass the same thing via\nAIO and can be found in [1].\n\nThe PoC:\n\n$ cat > test.c\n\nint main(void) {\n\tsize_t pagesz = sysconf(_SC_PAGE_SIZE);\n\tint mfd = syscall(SYS_memfd_create, \"test\", 0);\n\tconst char *buf = mmap(NULL, 4 * pagesz, PROT_READ | PROT_WRITE,\n\t\tMAP_SHARED, mfd, 0);\n\tunsigned int old = syscall(SYS_personality, 0xffffffff);\n\tsyscall(SYS_personality, READ_IMPLIES_EXEC | old);\n\tsyscall(SYS_remap_file_pages, buf, pagesz, 0, 2, 0);\n\tsyscall(SYS_personality, old);\n\t// show the RWX page exists even if W^X policy is enforced\n\tint fd = open(\"/proc/self/maps\", O_RDONLY);\n\tunsigned char buf2[1024];\n\twhile (1) {\n\t\tint ret = read(fd, buf2, 1024);\n\t\tif (ret <= 0) break;\n\t\twrite(1, buf2, ret);\n\t}\n\tclose(fd);\n}\n\n$ gcc test.c -o test\n$ ./test | grep rwx\n7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted)\n\n[PM: subject line tweaks]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47745",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-42136",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncdrom: rearrange last_media_change check to avoid unintentional overflow\n\nWhen running syzkaller with the newly reintroduced signed integer wrap\nsanitizer we encounter this splat:\n\n[  366.015950] UBSAN: signed-integer-overflow in ../drivers/cdrom/cdrom.c:2361:33\n[  366.021089] -9223372036854775808 - 346321 cannot be represented in type '__s64' (aka 'long long')\n[  366.025894] program syz-executor.4 is using a deprecated SCSI ioctl, please convert it to SG_IO\n[  366.027502] CPU: 5 PID: 28472 Comm: syz-executor.7 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1\n[  366.027512] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[  366.027518] Call Trace:\n[  366.027523]  <TASK>\n[  366.027533]  dump_stack_lvl+0x93/0xd0\n[  366.027899]  handle_overflow+0x171/0x1b0\n[  366.038787] ata1.00: invalid multi_count 32 ignored\n[  366.043924]  cdrom_ioctl+0x2c3f/0x2d10\n[  366.063932]  ? __pm_runtime_resume+0xe6/0x130\n[  366.071923]  sr_block_ioctl+0x15d/0x1d0\n[  366.074624]  ? __pfx_sr_block_ioctl+0x10/0x10\n[  366.077642]  blkdev_ioctl+0x419/0x500\n[  366.080231]  ? __pfx_blkdev_ioctl+0x10/0x10\n...\n\nHistorically, the signed integer overflow sanitizer did not work in the\nkernel due to its interaction with `-fwrapv` but this has since been\nchanged [1] in the newest version of Clang. It was re-enabled in the\nkernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow\nsanitizer\").\n\nLet's rearrange the check to not perform any arithmetic, thus not\ntripping the sanitizer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42136",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-30",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21796",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: clear acl_access/acl_default after releasing them\n\nIf getting acl_default fails, acl_access and acl_default will be released\nsimultaneously. However, acl_access will still retain a pointer pointing\nto the released posix_acl, which will trigger a WARNING in\nnfs3svc_release_getacl like this:\n\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 26 PID: 3199 at lib/refcount.c:28\nrefcount_warn_saturate+0xb5/0x170\nModules linked in:\nCPU: 26 UID: 0 PID: 3199 Comm: nfsd Not tainted\n6.12.0-rc6-00079-g04ae226af01f-dirty #8\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb5/0x170\nCode: cc cc 0f b6 1d b3 20 a5 03 80 fb 01 0f 87 65 48 d8 00 83 e3 01 75\ne4 48 c7 c7 c0 3b 9b 85 c6 05 97 20 a5 03 01 e8 fb 3e 30 ff <0f> 0b eb\ncd 0f b6 1d 8a3\nRSP: 0018:ffffc90008637cd8 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff83904fde\nRDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88871ed36380\nRBP: ffff888158beeb40 R08: 0000000000000001 R09: fffff520010c6f56\nR10: ffffc90008637ab7 R11: 0000000000000001 R12: 0000000000000001\nR13: ffff888140e77400 R14: ffff888140e77408 R15: ffffffff858b42c0\nFS:  0000000000000000(0000) GS:ffff88871ed00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000562384d32158 CR3: 000000055cc6a000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ? refcount_warn_saturate+0xb5/0x170\n ? __warn+0xa5/0x140\n ? refcount_warn_saturate+0xb5/0x170\n ? report_bug+0x1b1/0x1e0\n ? handle_bug+0x53/0xa0\n ? exc_invalid_op+0x17/0x40\n ? asm_exc_invalid_op+0x1a/0x20\n ? tick_nohz_tick_stopped+0x1e/0x40\n ? refcount_warn_saturate+0xb5/0x170\n ? refcount_warn_saturate+0xb5/0x170\n nfs3svc_release_getacl+0xc9/0xe0\n svc_process_common+0x5db/0xb60\n ? __pfx_svc_process_common+0x10/0x10\n ? __rcu_read_unlock+0x69/0xa0\n ? __pfx_nfsd_dispatch+0x10/0x10\n ? svc_xprt_received+0xa1/0x120\n ? xdr_init_decode+0x11d/0x190\n svc_process+0x2a7/0x330\n svc_handle_xprt+0x69d/0x940\n svc_recv+0x180/0x2d0\n nfsd+0x168/0x200\n ? __pfx_nfsd+0x10/0x10\n kthread+0x1a2/0x1e0\n ? kthread+0xf4/0x1e0\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x34/0x60\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\nKernel panic - not syncing: kernel: panic_on_warn set ...\n\nClear acl_access/acl_default after posix_acl_release is called to prevent\nUAF from being triggered.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21796",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53168",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsunrpc: fix one UAF issue caused by sunrpc kernel tcp socket\n\nBUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0\nRead of size 1 at addr ffff888111f322cd by task swapper/0/0\n\nCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x68/0xa0\n print_address_description.constprop.0+0x2c/0x3d0\n print_report+0xb4/0x270\n kasan_report+0xbd/0xf0\n tcp_write_timer_handler+0x156/0x3e0\n tcp_write_timer+0x66/0x170\n call_timer_fn+0xfb/0x1d0\n __run_timers+0x3f8/0x480\n run_timer_softirq+0x9b/0x100\n handle_softirqs+0x153/0x390\n __irq_exit_rcu+0x103/0x120\n irq_exit_rcu+0xe/0x20\n sysvec_apic_timer_interrupt+0x76/0x90\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1a/0x20\nRIP: 0010:default_idle+0xf/0x20\nCode: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90\n 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 <fa> c3 cc cc cc\n cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90\nRSP: 0018:ffffffffa2007e28 EFLAGS: 00000242\nRAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590f\nRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835d\nR10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000\nR13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0\n default_idle_call+0x6b/0xa0\n cpuidle_idle_call+0x1af/0x1f0\n do_idle+0xbc/0x130\n cpu_startup_entry+0x33/0x40\n rest_init+0x11f/0x210\n start_kernel+0x39a/0x420\n x86_64_start_reservations+0x18/0x30\n x86_64_start_kernel+0x97/0xa0\n common_startup_64+0x13e/0x141\n </TASK>\n\nAllocated by task 595:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n __kasan_slab_alloc+0x87/0x90\n kmem_cache_alloc_noprof+0x12b/0x3f0\n copy_net_ns+0x94/0x380\n create_new_namespaces+0x24c/0x500\n unshare_nsproxy_namespaces+0x75/0xf0\n ksys_unshare+0x24e/0x4f0\n __x64_sys_unshare+0x1f/0x30\n do_syscall_64+0x70/0x180\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 100:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n __kasan_slab_free+0x54/0x70\n kmem_cache_free+0x156/0x5d0\n cleanup_net+0x5d3/0x670\n process_one_work+0x776/0xa90\n worker_thread+0x2e2/0x560\n kthread+0x1a8/0x1f0\n ret_from_fork+0x34/0x60\n ret_from_fork_asm+0x1a/0x30\n\nReproduction script:\n\nmkdir -p /mnt/nfsshare\nmkdir -p /mnt/nfs/netns_1\nmkfs.ext4 /dev/sdb\nmount /dev/sdb /mnt/nfsshare\nsystemctl restart nfs-server\nchmod 777 /mnt/nfsshare\nexportfs -i -o rw,no_root_squash *:/mnt/nfsshare\n\nip netns add netns_1\nip link add name veth_1_peer type veth peer veth_1\nifconfig veth_1_peer 11.11.0.254 up\nip link set veth_1 netns netns_1\nip netns exec netns_1 ifconfig veth_1 11.11.0.1\n\nip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp \\\n\t--tcp-flags FIN FIN  -j DROP\n\n(note: In my environment, a DESTROY_CLIENTID operation is always sent\n immediately, breaking the nfs tcp connection.)\nip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1 \\\n\t11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1\n\nip netns del netns_1\n\nThe reason here is that the tcp socket in netns_1 (nfs side) has been\nshutdown and closed (done in xs_destroy), but the FIN message (with ack)\nis discarded, and the nfsd side keeps sending retransmission messages.\nAs a result, when the tcp sock in netns_1 processes the received message,\nit sends the message (FIN message) in the sending queue, and the tcp timer\nis re-established. When the network namespace is deleted, the net structure\naccessed by tcp's timer handler function causes problems.\n\nTo fix this problem, let's hold netns refcnt for the tcp kernel socket as\ndone in other modules. This is an ugly hack which can easily be backported\nto earlier kernels. A proper fix which cleans up the interfaces will\nfollow, but may not be so easy to backport.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53168",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-02-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52974",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi_tcp: Fix UAF during login when accessing the shost ipaddress\n\nIf during iscsi_sw_tcp_session_create() iscsi_tcp_r2tpool_alloc() fails,\nuserspace could be accessing the host's ipaddress attr. If we then free the\nsession via iscsi_session_teardown() while userspace is still accessing the\nsession we will hit a use after free bug.\n\nSet the tcp_sw_host->session after we have completed session creation and\ncan no longer fail.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52974",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37823",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: hfsc: Fix a potential UAF in hfsc_dequeue() too\n\nSimilarly to the previous patch, we need to safe guard hfsc_dequeue()\ntoo. But for this one, we don't have a reliable reproducer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37823",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-08",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47194",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncfg80211: call cfg80211_stop_ap when switch from P2P_GO type\n\nIf the userspace tools switch from NL80211_IFTYPE_P2P_GO to\nNL80211_IFTYPE_ADHOC via send_msg(NL80211_CMD_SET_INTERFACE), it\ndoes not call the cleanup cfg80211_stop_ap(), this leads to the\ninitialization of in-use data. For example, this path re-init the\nsdata->assigned_chanctx_list while it is still an element of\nassigned_vifs list, and makes that linked list corrupt.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47194",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-10",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48913",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblktrace: fix use after free for struct blk_trace\n\nWhen tracing the whole disk, 'dropped' and 'msg' will be created\nunder 'q->debugfs_dir' and 'bt->dir' is NULL, thus blk_trace_free()\nwon't remove those files. What's worse, the following UAF can be\ntriggered because of accessing stale 'dropped' and 'msg':\n\n==================================================================\nBUG: KASAN: use-after-free in blk_dropped_read+0x89/0x100\nRead of size 4 at addr ffff88816912f3d8 by task blktrace/1188\n\nCPU: 27 PID: 1188 Comm: blktrace Not tainted 5.17.0-rc4-next-20220217+ #469\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-4\nCall Trace:\n <TASK>\n dump_stack_lvl+0x34/0x44\n print_address_description.constprop.0.cold+0xab/0x381\n ? blk_dropped_read+0x89/0x100\n ? blk_dropped_read+0x89/0x100\n kasan_report.cold+0x83/0xdf\n ? blk_dropped_read+0x89/0x100\n kasan_check_range+0x140/0x1b0\n blk_dropped_read+0x89/0x100\n ? blk_create_buf_file_callback+0x20/0x20\n ? kmem_cache_free+0xa1/0x500\n ? do_sys_openat2+0x258/0x460\n full_proxy_read+0x8f/0xc0\n vfs_read+0xc6/0x260\n ksys_read+0xb9/0x150\n ? vfs_write+0x3d0/0x3d0\n ? fpregs_assert_state_consistent+0x55/0x60\n ? exit_to_user_mode_prepare+0x39/0x1e0\n do_syscall_64+0x35/0x80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7fbc080d92fd\nCode: ce 20 00 00 75 10 b8 00 00 00 00 0f 05 48 3d 01 f0 ff ff 73 31 c3 48 83 1\nRSP: 002b:00007fbb95ff9cb0 EFLAGS: 00000293 ORIG_RAX: 0000000000000000\nRAX: ffffffffffffffda RBX: 00007fbb95ff9dc0 RCX: 00007fbc080d92fd\nRDX: 0000000000000100 RSI: 00007fbb95ff9cc0 RDI: 0000000000000045\nRBP: 0000000000000045 R08: 0000000000406299 R09: 00000000fffffffd\nR10: 000000000153afa0 R11: 0000000000000293 R12: 00007fbb780008c0\nR13: 00007fbb78000938 R14: 0000000000608b30 R15: 00007fbb780029c8\n </TASK>\n\nAllocated by task 1050:\n kasan_save_stack+0x1e/0x40\n __kasan_kmalloc+0x81/0xa0\n do_blk_trace_setup+0xcb/0x410\n __blk_trace_setup+0xac/0x130\n blk_trace_ioctl+0xe9/0x1c0\n blkdev_ioctl+0xf1/0x390\n __x64_sys_ioctl+0xa5/0xe0\n do_syscall_64+0x35/0x80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nFreed by task 1050:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n kasan_set_free_info+0x20/0x30\n __kasan_slab_free+0x103/0x180\n kfree+0x9a/0x4c0\n __blk_trace_remove+0x53/0x70\n blk_trace_ioctl+0x199/0x1c0\n blkdev_common_ioctl+0x5e9/0xb30\n blkdev_ioctl+0x1a5/0x390\n __x64_sys_ioctl+0xa5/0xe0\n do_syscall_64+0x35/0x80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe buggy address belongs to the object at ffff88816912f380\n which belongs to the cache kmalloc-96 of size 96\nThe buggy address is located 88 bytes inside of\n 96-byte region [ffff88816912f380, ffff88816912f3e0)\nThe buggy address belongs to the page:\npage:000000009a1b4e7c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0f\nflags: 0x17ffffc0000200(slab|node=0|zone=2|lastcpupid=0x1fffff)\nraw: 0017ffffc0000200 ffffea00044f1100 dead000000000002 ffff88810004c780\nraw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88816912f280: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc\n ffff88816912f300: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc\n>ffff88816912f380: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc\n                                                    ^\n ffff88816912f400: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc\n ffff88816912f480: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc\n==================================================================",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48913",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-08-27",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53286",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx5: Return the firmware result upon destroying QP/RQ\n\nPreviously when destroying a QP/RQ, the result of the firmware\ndestruction function was ignored and upper layers weren't informed\nabout the failure.\nWhich in turn could lead to various problems since when upper layer\nisn't aware of the failure it continues its operation thinking that the\nrelated QP/RQ was successfully destroyed while it actually wasn't,\nwhich could lead to the below kernel WARN.\n\nCurrently, we return the correct firmware destruction status to upper\nlayers which in case of the RQ would be mlx5_ib_destroy_wq() which\nwas already capable of handling RQ destruction failure or in case of\na QP to destroy_qp_common(), which now would actually warn upon qp\ndestruction failure.\n\nWARNING: CPU: 3 PID: 995 at drivers/infiniband/core/rdma_core.c:940 uverbs_destroy_ufile_hw+0xcb/0xe0 [ib_uverbs]\nModules linked in: xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_umad ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core overlay mlx5_core fuse\nCPU: 3 PID: 995 Comm: python3 Not tainted 5.16.0-rc5+ #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\nRIP: 0010:uverbs_destroy_ufile_hw+0xcb/0xe0 [ib_uverbs]\nCode: 41 5c 41 5d 41 5e e9 44 34 f0 e0 48 89 df e8 4c 77 ff ff 49 8b 86 10 01 00 00 48 85 c0 74 a1 4c 89 e7 ff d0 eb 9a 0f 0b eb c1 <0f> 0b be 04 00 00 00 48 89 df e8 b6 f6 ff ff e9 75 ff ff ff 90 0f\nRSP: 0018:ffff8881533e3e78 EFLAGS: 00010287\nRAX: ffff88811b2cf3e0 RBX: ffff888106209700 RCX: 0000000000000000\nRDX: ffff888106209780 RSI: ffff8881533e3d30 RDI: ffff888109b101a0\nRBP: 0000000000000001 R08: ffff888127cb381c R09: 0de9890000000009\nR10: ffff888127cb3800 R11: 0000000000000000 R12: ffff888106209780\nR13: ffff888106209750 R14: ffff888100f20660 R15: 0000000000000000\nFS:  00007f8be353b740(0000) GS:ffff88852c980000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f8bd5b117c0 CR3: 000000012cd8a004 CR4: 0000000000370ea0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ib_uverbs_close+0x1a/0x90 [ib_uverbs]\n __fput+0x82/0x230\n task_work_run+0x59/0x90\n exit_to_user_mode_prepare+0x138/0x140\n syscall_exit_to_user_mode+0x1d/0x50\n ? __x64_sys_close+0xe/0x40\n do_syscall_64+0x4a/0x90\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f8be3ae0abb\nCode: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 83 43 f9 ff 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 c1 43 f9 ff 8b 44\nRSP: 002b:00007ffdb51909c0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003\nRAX: 0000000000000000 RBX: 0000557bb7f7c020 RCX: 00007f8be3ae0abb\nRDX: 0000557bb7c74010 RSI: 0000557bb7f14ca0 RDI: 0000000000000005\nRBP: 0000557bb7fbd598 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000293 R12: 0000557bb7fbd5b8\nR13: 0000557bb7fbd5a8 R14: 0000000000001000 R15: 0000557bb7f7c020\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53286",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47242",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix soft lookup in subflow_error_report()\n\nMaxim reported a soft lookup in subflow_error_report():\n\n watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [swapper/0:0]\n RIP: 0010:native_queued_spin_lock_slowpath\n RSP: 0018:ffffa859c0003bc0 EFLAGS: 00000202\n RAX: 0000000000000101 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: ffff9195c2772d88 RSI: 0000000000000000 RDI: ffff9195c2772d88\n RBP: ffff9195c2772d00 R08: 00000000000067b0 R09: c6e31da9eb1e44f4\n R10: ffff9195ef379700 R11: ffff9195edb50710 R12: ffff9195c2772d88\n R13: ffff9195f500e3d0 R14: ffff9195ef379700 R15: ffff9195ef379700\n FS:  0000000000000000(0000) GS:ffff91961f400000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000000c000407000 CR3: 0000000002988000 CR4: 00000000000006f0\n Call Trace:\n  <IRQ>\n _raw_spin_lock_bh\n subflow_error_report\n mptcp_subflow_data_available\n __mptcp_move_skbs_from_subflow\n mptcp_data_ready\n tcp_data_queue\n tcp_rcv_established\n tcp_v4_do_rcv\n tcp_v4_rcv\n ip_protocol_deliver_rcu\n ip_local_deliver_finish\n __netif_receive_skb_one_core\n netif_receive_skb\n rtl8139_poll 8139too\n __napi_poll\n net_rx_action\n __do_softirq\n __irq_exit_rcu\n common_interrupt\n  </IRQ>\n\nThe calling function - mptcp_subflow_data_available() - can be invoked\nfrom different contexts:\n- plain ssk socket lock\n- ssk socket lock + mptcp_data_lock\n- ssk socket lock + mptcp_data_lock + msk socket lock.\n\nSince subflow_error_report() tries to acquire the mptcp_data_lock, the\nlatter two call chains will cause soft lookup.\n\nThis change addresses the issue moving the error reporting call to\nouter functions, where the held locks list is known and the we can\nacquire only the needed one.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47242",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-04",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47198",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix use-after-free in lpfc_unreg_rpi() routine\n\nAn error is detected with the following report when unloading the driver:\n  \"KASAN: use-after-free in lpfc_unreg_rpi+0x1b1b\"\n\nThe NLP_REG_LOGIN_SEND nlp_flag is set in lpfc_reg_fab_ctrl_node(), but the\nflag is not cleared upon completion of the login.\n\nThis allows a second call to lpfc_unreg_rpi() to proceed with nlp_rpi set\nto LPFC_RPI_ALLOW_ERROR.  This results in a use after free access when used\nas an rpi_ids array index.\n\nFix by clearing the NLP_REG_LOGIN_SEND nlp_flag in\nlpfc_mbx_cmpl_fc_reg_login().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47198",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-10",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-37913",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: qfq: Fix double list add in class with netem as child qdisc\n\nAs described in Gerrard's report [1], there are use cases where a netem\nchild qdisc will make the parent qdisc's enqueue callback reentrant.\nIn the case of qfq, there won't be a UAF, but the code will add the same\nclassifier to the list twice, which will cause memory corruption.\n\nThis patch checks whether the class was already added to the agg->active\nlist (cl_is_active) before doing the addition to cater for the reentrant\ncase.\n\n[1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37913",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-20",
                    "modification_date": "2025-11-17",
                    "nvd_score_v3": 7.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.8,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36955",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda: intel-sdw-acpi: fix usage of device_get_named_child_node()\n\nThe documentation for device_get_named_child_node() mentions this\nimportant point:\n\n\"\nThe caller is responsible for calling fwnode_handle_put() on the\nreturned fwnode pointer.\n\"\n\nAdd fwnode_handle_put() to avoid a leaked reference.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36955",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-30",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 7.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-3056",
                    "description": "A flaw was found in Podman. This issue may allow an attacker to create a specially crafted container that, when configured to share the same IPC with at least one other container, can create a large number of IPC resources in /dev/shm. The malicious container will continue to exhaust resources until it is out-of-memory (OOM) killed. While the malicious container's cgroup will be removed, the IPC resources it created are not. Those resources are tied to the IPC namespace that will not be removed until all containers using it are stopped, and one non-malicious container is holding the namespace open. The malicious container is restarted, either automatically or by attacker control, repeating the process and increasing the amount of memory consumed. With a container configured to restart always, such as `podman run --restart=always`, this can result in a memory-based denial of service of the system.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-3056",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-02",
                    "modification_date": "2024-12-27",
                    "nvd_score_v3": 7.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48651",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipvlan: Fix out-of-bound bugs caused by unset skb->mac_header\n\nIf an AF_PACKET socket is used to send packets through ipvlan and the\ndefault xmit function of the AF_PACKET socket is changed from\ndev_queue_xmit() to packet_direct_xmit() via setsockopt() with the option\nname of PACKET_QDISC_BYPASS, the skb->mac_header may not be reset and\nremains as the initial value of 65535, this may trigger slab-out-of-bounds\nbugs as following:\n\n=================================================================\nUG: KASAN: slab-out-of-bounds in ipvlan_xmit_mode_l2+0xdb/0x330 [ipvlan]\nPU: 2 PID: 1768 Comm: raw_send Kdump: loaded Not tainted 6.0.0-rc4+ #6\nardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33\nall Trace:\nprint_address_description.constprop.0+0x1d/0x160\nprint_report.cold+0x4f/0x112\nkasan_report+0xa3/0x130\nipvlan_xmit_mode_l2+0xdb/0x330 [ipvlan]\nipvlan_start_xmit+0x29/0xa0 [ipvlan]\n__dev_direct_xmit+0x2e2/0x380\npacket_direct_xmit+0x22/0x60\npacket_snd+0x7c9/0xc40\nsock_sendmsg+0x9a/0xa0\n__sys_sendto+0x18a/0x230\n__x64_sys_sendto+0x74/0x90\ndo_syscall_64+0x3b/0x90\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe root cause is:\n  1. packet_snd() only reset skb->mac_header when sock->type is SOCK_RAW\n     and skb->protocol is not specified as in packet_parse_headers()\n\n  2. packet_direct_xmit() doesn't reset skb->mac_header as dev_queue_xmit()\n\nIn this case, skb->mac_header is 65535 when ipvlan_xmit_mode_l2() is\ncalled. So when ipvlan_xmit_mode_l2() gets mac header with eth_hdr() which\nuse \"skb->head + skb->mac_header\", out-of-bound access occurs.\n\nThis patch replaces eth_hdr() with skb_eth_hdr() in ipvlan_xmit_mode_l2()\nand reset mac header in multicast to solve this out-of-bound bug.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48651",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-03-20",
                    "nvd_score_v3": 7.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50865",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: fix a signed-integer-overflow bug in tcp_add_backlog()\n\nThe type of sk_rcvbuf and sk_sndbuf in struct sock is int, and\nin tcp_add_backlog(), the variable limit is caculated by adding\nsk_rcvbuf, sk_sndbuf and 64 * 1024, it may exceed the max value\nof int and overflow. This patch reduces the limit budget by\nhalving the sndbuf to solve this issue since ACK packets are much\nsmaller than the payload.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68349",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSv4/pNFS: Clear NFS_INO_LAYOUTCOMMIT in pnfs_mark_layout_stateid_invalid\n\nFixes a crash when layout is null during this call stack:\n\nwrite_inode\n    -> nfs4_write_inode\n        -> pnfs_layoutcommit_inode\n\npnfs_set_layoutcommit relies on the lseg refcount to keep the layout\naround. Need to clear NFS_INO_LAYOUTCOMMIT otherwise we might attempt\nto reference a null layout.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39828",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: atmtcp: Prevent arbitrary write in atmtcp_recv_control().\n\nsyzbot reported the splat below. [0]\n\nWhen atmtcp_v_open() or atmtcp_v_close() is called via connect()\nor close(), atmtcp_send_control() is called to send an in-kernel\nspecial message.\n\nThe message has ATMTCP_HDR_MAGIC in atmtcp_control.hdr.length.\nAlso, a pointer of struct atm_vcc is set to atmtcp_control.vcc.\n\nThe notable thing is struct atmtcp_control is uAPI but has a\nspace for an in-kernel pointer.\n\n  struct atmtcp_control {\n  \tstruct atmtcp_hdr hdr;\t/* must be first */\n  ...\n  \tatm_kptr_t vcc;\t\t/* both directions */\n  ...\n  } __ATM_API_ALIGN;\n\n  typedef struct { unsigned char _[8]; } __ATM_API_ALIGN atm_kptr_t;\n\nThe special message is processed in atmtcp_recv_control() called\nfrom atmtcp_c_send().\n\natmtcp_c_send() is vcc->dev->ops->send() and called from 2 paths:\n\n  1. .ndo_start_xmit() (vcc->send() == atm_send_aal0())\n  2. vcc_sendmsg()\n\nThe problem is sendmsg() does not validate the message length and\nuserspace can abuse atmtcp_recv_control() to overwrite any kptr\nby atmtcp_control.\n\nLet's add a new ->pre_send() hook to validate messages from sendmsg().\n\n[0]:\nOops: general protection fault, probably for non-canonical address 0xdffffc00200000ab: 0000 [#1] SMP KASAN PTI\nKASAN: probably user-memory-access in range [0x0000000100000558-0x000000010000055f]\nCPU: 0 UID: 0 PID: 5865 Comm: syz-executor331 Not tainted 6.17.0-rc1-syzkaller-00215-gbab3ce404553 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/12/2025\nRIP: 0010:atmtcp_recv_control drivers/atm/atmtcp.c:93 [inline]\nRIP: 0010:atmtcp_c_send+0x1da/0x950 drivers/atm/atmtcp.c:297\nCode: 4d 8d 75 1a 4c 89 f0 48 c1 e8 03 42 0f b6 04 20 84 c0 0f 85 15 06 00 00 41 0f b7 1e 4d 8d b7 60 05 00 00 4c 89 f0 48 c1 e8 03 <42> 0f b6 04 20 84 c0 0f 85 13 06 00 00 66 41 89 1e 4d 8d 75 1c 4c\nRSP: 0018:ffffc90003f5f810 EFLAGS: 00010203\nRAX: 00000000200000ab RBX: 0000000000000000 RCX: 0000000000000000\nRDX: ffff88802a510000 RSI: 00000000ffffffff RDI: ffff888030a6068c\nRBP: ffff88802699fb40 R08: ffff888030a606eb R09: 1ffff1100614c0dd\nR10: dffffc0000000000 R11: ffffffff8718fc40 R12: dffffc0000000000\nR13: ffff888030a60680 R14: 000000010000055f R15: 00000000ffffffff\nFS:  00007f8d7e9236c0(0000) GS:ffff888125c1c000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000000045ad50 CR3: 0000000075bde000 CR4: 00000000003526f0\nCall Trace:\n <TASK>\n vcc_sendmsg+0xa10/0xc60 net/atm/common.c:645\n sock_sendmsg_nosec net/socket.c:714 [inline]\n __sock_sendmsg+0x219/0x270 net/socket.c:729\n ____sys_sendmsg+0x505/0x830 net/socket.c:2614\n ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2668\n __sys_sendmsg net/socket.c:2700 [inline]\n __do_sys_sendmsg net/socket.c:2705 [inline]\n __se_sys_sendmsg net/socket.c:2703 [inline]\n __x64_sys_sendmsg+0x19b/0x260 net/socket.c:2703\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f8d7e96a4a9\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f8d7e923198 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f8d7e9f4308 RCX: 00007f8d7e96a4a9\nRDX: 0000000000000000 RSI: 0000200000000240 RDI: 0000000000000005\nRBP: 00007f8d7e9f4300 R08: 65732f636f72702f R09: 65732f636f72702f\nR10: 65732f636f72702f R11: 0000000000000246 R12: 00007f8d7e9c10ac\nR13: 00007f8d7e9231a0 R14: 0000200000000200 R15: 0000200000000250\n </TASK>\nModules linked in:",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53827",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix use-after-free in l2cap_disconnect_{req,rsp}\n\nSimilar to commit d0be8347c623 (\"Bluetooth: L2CAP: Fix use-after-free\ncaused by l2cap_chan_put\"), just use l2cap_chan_hold_unless_zero to\nprevent referencing a channel that is about to be destroyed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39949",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nqed: Don't collect too many protection override GRC elements\n\nIn the protection override dump path, the firmware can return far too\nmany GRC elements, resulting in attempting to write past the end of the\npreviously-kmalloc'ed dump buffer.\n\nThis will result in a kernel panic with reason:\n\n BUG: unable to handle kernel paging request at ADDRESS\n\nwhere \"ADDRESS\" is just past the end of the protection override dump\nbuffer. The start address of the buffer is:\n p_hwfn->cdev->dbg_features[DBG_FEATURE_PROTECTION_OVERRIDE].dump_buf\nand the size of the buffer is buf_size in the same data structure.\n\nThe panic can be arrived at from either the qede Ethernet driver path:\n\n    [exception RIP: qed_grc_dump_addr_range+0x108]\n qed_protection_override_dump at ffffffffc02662ed [qed]\n qed_dbg_protection_override_dump at ffffffffc0267792 [qed]\n qed_dbg_feature at ffffffffc026aa8f [qed]\n qed_dbg_all_data at ffffffffc026b211 [qed]\n qed_fw_fatal_reporter_dump at ffffffffc027298a [qed]\n devlink_health_do_dump at ffffffff82497f61\n devlink_health_report at ffffffff8249cf29\n qed_report_fatal_error at ffffffffc0272baf [qed]\n qede_sp_task at ffffffffc045ed32 [qede]\n process_one_work at ffffffff81d19783\n\nor the qedf storage driver path:\n\n    [exception RIP: qed_grc_dump_addr_range+0x108]\n qed_protection_override_dump at ffffffffc068b2ed [qed]\n qed_dbg_protection_override_dump at ffffffffc068c792 [qed]\n qed_dbg_feature at ffffffffc068fa8f [qed]\n qed_dbg_all_data at ffffffffc0690211 [qed]\n qed_fw_fatal_reporter_dump at ffffffffc069798a [qed]\n devlink_health_do_dump at ffffffff8aa95e51\n devlink_health_report at ffffffff8aa9ae19\n qed_report_fatal_error at ffffffffc0697baf [qed]\n qed_hw_err_notify at ffffffffc06d32d7 [qed]\n qed_spq_post at ffffffffc06b1011 [qed]\n qed_fcoe_destroy_conn at ffffffffc06b2e91 [qed]\n qedf_cleanup_fcport at ffffffffc05e7597 [qedf]\n qedf_rport_event_handler at ffffffffc05e7bf7 [qedf]\n fc_rport_work at ffffffffc02da715 [libfc]\n process_one_work at ffffffff8a319663\n\nResolve this by clamping the firmware's return value to the maximum\nnumber of legal elements the firmware should return.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-25645",
                    "description": "A flaw was found in the Linux kernel in versions before 5.9-rc7. Traffic between two Geneve endpoints may be unencrypted when IPsec is configured to encrypt traffic for the specific UDP port used by the GENEVE tunnel allowing anyone between the two endpoints to read the traffic unencrypted. The main threat from this vulnerability is to data confidentiality.",
                    "nvd_score": 5,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-25645",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2020-10-13",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50083",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: fix mptcp DSS corruption due to large pmtu xmit\n\nSyzkaller was able to trigger a DSS corruption:\n\n  TCP: request_sock_subflow_v4: Possible SYN flooding on port [::]:20002. Sending cookies.\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 5227 at net/mptcp/protocol.c:695 __mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695\n  Modules linked in:\n  CPU: 0 UID: 0 PID: 5227 Comm: syz-executor350 Not tainted 6.11.0-syzkaller-08829-gaf9c191ac2a0 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\n  RIP: 0010:__mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695\n  Code: 0f b6 dc 31 ff 89 de e8 b5 dd ea f5 89 d8 48 81 c4 50 01 00 00 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc e8 98 da ea f5 90 <0f> 0b 90 e9 47 ff ff ff e8 8a da ea f5 90 0f 0b 90 e9 99 e0 ff ff\n  RSP: 0018:ffffc90000006db8 EFLAGS: 00010246\n  RAX: ffffffff8ba9df18 RBX: 00000000000055f0 RCX: ffff888030023c00\n  RDX: 0000000000000100 RSI: 00000000000081e5 RDI: 00000000000055f0\n  RBP: 1ffff110062bf1ae R08: ffffffff8ba9cf12 R09: 1ffff110062bf1b8\n  R10: dffffc0000000000 R11: ffffed10062bf1b9 R12: 0000000000000000\n  R13: dffffc0000000000 R14: 00000000700cec61 R15: 00000000000081e5\n  FS:  000055556679c380(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000020287000 CR3: 0000000077892000 CR4: 00000000003506f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   <IRQ>\n   move_skbs_to_msk net/mptcp/protocol.c:811 [inline]\n   mptcp_data_ready+0x29c/0xa90 net/mptcp/protocol.c:854\n   subflow_data_ready+0x34a/0x920 net/mptcp/subflow.c:1490\n   tcp_data_queue+0x20fd/0x76c0 net/ipv4/tcp_input.c:5283\n   tcp_rcv_established+0xfba/0x2020 net/ipv4/tcp_input.c:6237\n   tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915\n   tcp_v4_rcv+0x2dc0/0x37f0 net/ipv4/tcp_ipv4.c:2350\n   ip_protocol_deliver_rcu+0x22e/0x440 net/ipv4/ip_input.c:205\n   ip_local_deliver_finish+0x341/0x5f0 net/ipv4/ip_input.c:233\n   NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314\n   NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314\n   __netif_receive_skb_one_core net/core/dev.c:5662 [inline]\n   __netif_receive_skb+0x2bf/0x650 net/core/dev.c:5775\n   process_backlog+0x662/0x15b0 net/core/dev.c:6107\n   __napi_poll+0xcb/0x490 net/core/dev.c:6771\n   napi_poll net/core/dev.c:6840 [inline]\n   net_rx_action+0x89b/0x1240 net/core/dev.c:6962\n   handle_softirqs+0x2c5/0x980 kernel/softirq.c:554\n   do_softirq+0x11b/0x1e0 kernel/softirq.c:455\n   </IRQ>\n   <TASK>\n   __local_bh_enable_ip+0x1bb/0x200 kernel/softirq.c:382\n   local_bh_enable include/linux/bottom_half.h:33 [inline]\n   rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline]\n   __dev_queue_xmit+0x1764/0x3e80 net/core/dev.c:4451\n   dev_queue_xmit include/linux/netdevice.h:3094 [inline]\n   neigh_hh_output include/net/neighbour.h:526 [inline]\n   neigh_output include/net/neighbour.h:540 [inline]\n   ip_finish_output2+0xd41/0x1390 net/ipv4/ip_output.c:236\n   ip_local_out net/ipv4/ip_output.c:130 [inline]\n   __ip_queue_xmit+0x118c/0x1b80 net/ipv4/ip_output.c:536\n   __tcp_transmit_skb+0x2544/0x3b30 net/ipv4/tcp_output.c:1466\n   tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n   tcp_mtu_probe net/ipv4/tcp_output.c:2547 [inline]\n   tcp_write_xmit+0x641d/0x6bf0 net/ipv4/tcp_output.c:2752\n   __tcp_push_pending_frames+0x9b/0x360 net/ipv4/tcp_output.c:3015\n   tcp_push_pending_frames include/net/tcp.h:2107 [inline]\n   tcp_data_snd_check net/ipv4/tcp_input.c:5714 [inline]\n   tcp_rcv_established+0x1026/0x2020 net/ipv4/tcp_input.c:6239\n   tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915\n   sk_backlog_rcv include/net/sock.h:1113 [inline]\n   __release_sock+0x214/0x350 net/core/sock.c:3072\n   release_sock+0x61/0x1f0 net/core/sock.c:3626\n   mptcp_push_\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50083",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-29",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47241",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nethtool: strset: fix message length calculation\n\nOuter nest for ETHTOOL_A_STRSET_STRINGSETS is not accounted for.\nThis may result in ETHTOOL_MSG_STRSET_GET producing a warning like:\n\n    calculated message payload length (684) not sufficient\n    WARNING: CPU: 0 PID: 30967 at net/ethtool/netlink.c:369 ethnl_default_doit+0x87a/0xa20\n\nand a splat.\n\nAs usually with such warnings three conditions must be met for the warning\nto trigger:\n - there must be no skb size rounding up (e.g. reply_size of 684);\n - string set must be per-device (so that the header gets populated);\n - the device name must be at least 12 characters long.\n\nall in all with current user space it looks like reading priv flags\nis the only place this could potentially happen. Or with syzbot :)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47241",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-04",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47295",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix memory leak in tcindex_partial_destroy_work\n\nSyzbot reported memory leak in tcindex_set_parms(). The problem was in\nnon-freed perfect hash in tcindex_partial_destroy_work().\n\nIn tcindex_set_parms() new tcindex_data is allocated and some fields from\nold one are copied to new one, but not the perfect hash. Since\ntcindex_partial_destroy_work() is the destroy function for old\ntcindex_data, we need to free perfect hash to avoid memory leak.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47295",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-52883",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix possible null pointer dereference\n\nabo->tbo.resource may be NULL in amdgpu_vm_bo_update.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52883",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-39973",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: add validation for ring_len param\n\nThe `ring_len` parameter provided by the virtual function (VF)\nis assigned directly to the hardware memory context (HMC) without\nany validation.\n\nTo address this, introduce an upper boundary check for both Tx and Rx\nqueue lengths. The maximum number of descriptors supported by the\nhardware is 8k-32.\nAdditionally, enforce alignment constraints: Tx rings must be a multiple\nof 8, and Rx rings must be a multiple of 32.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-16",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57791",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: check return value of sock_recvmsg when draining clc data\n\nWhen receiving clc msg, the field length in smc_clc_msg_hdr indicates the\nlength of msg should be received from network and the value should not be\nfully trusted as it is from the network. Once the value of length exceeds\nthe value of buflen in function smc_clc_wait_msg it may run into deadloop\nwhen trying to drain the remaining data exceeding buflen.\n\nThis patch checks the return value of sock_recvmsg when draining data in\ncase of deadloop in draining.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57791",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-0045",
                    "description": "The current implementation of the prctl syscall does not issue an IBPB immediately during the syscall. The ib_prctl_set \u00a0function updates the Thread Information Flags (TIFs) for the task and updates the SPEC_CTRL MSR on the function __speculation_ctrl_update, but the IBPB is only issued on the next schedule, when the TIF bits are checked. This leaves the victim vulnerable to values already injected on the BTB, prior to the prctl syscall. \u00a0The patch that added the support for the conditional mitigation via prctl (ib_prctl_set) dates back to the kernel 4.9.176.\n\nWe recommend upgrading past commit\u00a0a664ec9158eeddd75121d39c9a0758016097fa96",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-0045",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-04-25",
                    "modification_date": "2025-02-13",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47259",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix use-after-free in nfs4_init_client()\n\nKASAN reports a use-after-free when attempting to mount two different\nexports through two different NICs that belong to the same server.\n\nOlga was able to hit this with kernels starting somewhere between 5.7\nand 5.10, but I traced the patch that introduced the clear_bit() call to\n4.13. So something must have changed in the refcounting of the clp\npointer to make this call to nfs_put_client() the very last one.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47259",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-04",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48748",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: vlan: fix memory leak in __allowed_ingress\n\nWhen using per-vlan state, if vlan snooping and stats are disabled,\nuntagged or priority-tagged ingress frame will go to check pvid state.\nIf the port state is forwarding and the pvid state is not\nlearning/forwarding, untagged or priority-tagged frame will be dropped\nbut skb memory is not freed.\nShould free skb when __allowed_ingress returns false.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48748",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2025-03-24",
                    "nvd_score_v3": 7.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.5,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53680",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Avoid calling OPDESC() with ops->opnum == OP_ILLEGAL\n\nOPDESC() simply indexes into nfsd4_ops[] by the op's operation\nnumber, without range checking that value. It assumes callers are\ncareful to avoid calling it with an out-of-bounds opnum value.\n\nnfsd4_decode_compound() is not so careful, and can invoke OPDESC()\nwith opnum set to OP_ILLEGAL, which is 10044 -- well beyond the end\nof nfsd4_ops[].",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-29657",
                    "description": "arch/x86/kvm/svm/nested.c in the Linux kernel before 5.11.12 has a use-after-free in which an AMD KVM guest can bypass access control on host OS MSRs when there are nested guests, aka CID-a58d9166a756. This occurs because of a TOCTOU race condition associated with a VMCB12 double fetch in nested_svm_vmrun.",
                    "nvd_score": 6.9,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-29657",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-07-22",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.4,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40170",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: use dst_dev_rcu() in sk_setup_caps()\n\nUse RCU to protect accesses to dst->dev from sk_setup_caps()\nand sk_dst_gso_max_size().\n\nAlso use dst_dev_rcu() in ip6_dst_mtu_maybe_forward(),\nand ip_dst_mtu_maybe_forward().\n\nip4_dst_hoplimit() can use dst_dev_net_rcu().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47464",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naudit: fix possible null-pointer dereference in audit_filter_rules\n\nFix  possible null-pointer dereference in audit_filter_rules.\n\naudit_filter_rules() error: we previously assumed 'ctx' could be null",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47464",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 7.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.4,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-40269",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Fix potential overflow of PCM transfer buffer\n\nThe PCM stream data in USB-audio driver is transferred over USB URB\npacket buffers, and each packet size is determined dynamically.  The\npacket sizes are limited by some factors such as wMaxPacketSize USB\ndescriptor.  OTOH, in the current code, the actually used packet sizes\nare determined only by the rate and the PPS, which may be bigger than\nthe size limit above.  This results in a buffer overflow, as reported\nby syzbot.\n\nBasically when the limit is smaller than the calculated packet size,\nit implies that something is wrong, most likely a weird USB\ndescriptor.  So the best option would be just to return an error at\nthe parameter setup time before doing any further operations.\n\nThis patch introduces such a sanity check, and returns -EINVAL when\nthe packet size is greater than maxpacksize.  The comparison with\nep->packsize[1] alone should suffice since it's always equal or\ngreater than ep->packsize[0].",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-06",
                    "modification_date": "2026-01-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40304",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: Add bounds checking in bit_putcs to fix vmalloc-out-of-bounds\n\nAdd bounds checking to prevent writes past framebuffer boundaries when\nrendering text near screen edges. Return early if the Y position is off-screen\nand clip image height to screen boundary. Break from the rendering loop if the\nX position is off-screen. When clipping image width to fit the screen, update\nthe character count to match the clipped width to prevent buffer size\nmismatches.\n\nWithout the character count update, bit_putcs_aligned and bit_putcs_unaligned\nreceive mismatched parameters where the buffer is allocated for the clipped\nwidth but cnt reflects the original larger count, causing out-of-bounds writes.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39981",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: MGMT: Fix possible UAFs\n\nThis attemps to fix possible UAFs caused by struct mgmt_pending being\nfreed while still being processed like in the following trace, in order\nto fix mgmt_pending_valid is introduce and use to check if the\nmgmt_pending hasn't been removed from the pending list, on the complete\ncallbacks it is used to check and in addtion remove the cmd from the list\nwhile holding mgmt_pending_lock to avoid TOCTOU problems since if the cmd\nis left on the list it can still be accessed and freed.\n\nBUG: KASAN: slab-use-after-free in mgmt_add_adv_patterns_monitor_sync+0x35/0x50 net/bluetooth/mgmt.c:5223\nRead of size 8 at addr ffff8880709d4dc0 by task kworker/u11:0/55\n\nCPU: 0 UID: 0 PID: 55 Comm: kworker/u11:0 Not tainted 6.16.4 #2 PREEMPT(full)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nWorkqueue: hci0 hci_cmd_sync_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x240 mm/kasan/report.c:482\n kasan_report+0x118/0x150 mm/kasan/report.c:595\n mgmt_add_adv_patterns_monitor_sync+0x35/0x50 net/bluetooth/mgmt.c:5223\n hci_cmd_sync_work+0x210/0x3a0 net/bluetooth/hci_sync.c:332\n process_one_work kernel/workqueue.c:3238 [inline]\n process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3321\n worker_thread+0x8a0/0xda0 kernel/workqueue.c:3402\n kthread+0x711/0x8a0 kernel/kthread.c:464\n ret_from_fork+0x3fc/0x770 arch/x86/kernel/process.c:148\n ret_from_fork_asm+0x1a/0x30 home/kwqcheii/source/fuzzing/kernel/kasan/linux-6.16.4/arch/x86/entry/entry_64.S:245\n </TASK>\n\nAllocated by task 12210:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4364\n kmalloc_noprof include/linux/slab.h:905 [inline]\n kzalloc_noprof include/linux/slab.h:1039 [inline]\n mgmt_pending_new+0x65/0x1e0 net/bluetooth/mgmt_util.c:269\n mgmt_pending_add+0x35/0x140 net/bluetooth/mgmt_util.c:296\n __add_adv_patterns_monitor+0x130/0x200 net/bluetooth/mgmt.c:5247\n add_adv_patterns_monitor+0x214/0x360 net/bluetooth/mgmt.c:5364\n hci_mgmt_cmd+0x9c9/0xef0 net/bluetooth/hci_sock.c:1719\n hci_sock_sendmsg+0x6ca/0xef0 net/bluetooth/hci_sock.c:1839\n sock_sendmsg_nosec net/socket.c:714 [inline]\n __sock_sendmsg+0x219/0x270 net/socket.c:729\n sock_write_iter+0x258/0x330 net/socket.c:1133\n new_sync_write fs/read_write.c:593 [inline]\n vfs_write+0x5c9/0xb30 fs/read_write.c:686\n ksys_write+0x145/0x250 fs/read_write.c:738\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 12221:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x46/0x50 mm/kasan/generic.c:576\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x62/0x70 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2381 [inline]\n slab_free mm/slub.c:4648 [inline]\n kfree+0x18e/0x440 mm/slub.c:4847\n mgmt_pending_free net/bluetooth/mgmt_util.c:311 [inline]\n mgmt_pending_foreach+0x30d/0x380 net/bluetooth/mgmt_util.c:257\n __mgmt_power_off+0x169/0x350 net/bluetooth/mgmt.c:9444\n hci_dev_close_sync+0x754/0x1330 net/bluetooth/hci_sync.c:5290\n hci_dev_do_close net/bluetooth/hci_core.c:501 [inline]\n hci_dev_close+0x108/0x200 net/bluetooth/hci_core.c:526\n sock_do_ioctl+0xd9/0x300 net/socket.c:1192\n sock_ioctl+0x576/0x790 net/socket.c:1313\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xf\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-11-24",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49948",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvt: Clear selection before changing the font\n\nWhen changing the console font with ioctl(KDFONTOP) the new font size\ncan be bigger than the previous font. A previous selection may thus now\nbe outside of the new screen size and thus trigger out-of-bounds\naccesses to graphics memory if the selection is removed in\nvc_do_resize().\n\nPrevent such out-of-memory accesses by dropping the selection before the\nvarious con_font_set() console handlers are called.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49948",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-35966",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: RFCOMM: Fix not validating setsockopt user input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\nchecking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\ninclude/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\ninclude/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\nnet/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\nnet/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task syz-executor632/5064",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35966",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-20",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46743",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nof/irq: Prevent device address out-of-bounds read in interrupt map walk\n\nWhen of_irq_parse_raw() is invoked with a device address smaller than\nthe interrupt parent node (from #address-cells property), KASAN detects\nthe following out-of-bounds read when populating the initial match table\n(dyndbg=\"func of_irq_parse_* +p\"):\n\n  OF: of_irq_parse_one: dev=/soc@0/picasso/watchdog, index=0\n  OF:  parent=/soc@0/pci@878000000000/gpio0@17,0, intsize=2\n  OF:  intspec=4\n  OF: of_irq_parse_raw: ipar=/soc@0/pci@878000000000/gpio0@17,0, size=2\n  OF:  -> addrsize=3\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in of_irq_parse_raw+0x2b8/0x8d0\n  Read of size 4 at addr ffffff81beca5608 by task bash/764\n\n  CPU: 1 PID: 764 Comm: bash Tainted: G           O       6.1.67-484c613561-nokia_sm_arm64 #1\n  Hardware name: Unknown Unknown Product/Unknown Product, BIOS 2023.01-12.24.03-dirty 01/01/2023\n  Call trace:\n   dump_backtrace+0xdc/0x130\n   show_stack+0x1c/0x30\n   dump_stack_lvl+0x6c/0x84\n   print_report+0x150/0x448\n   kasan_report+0x98/0x140\n   __asan_load4+0x78/0xa0\n   of_irq_parse_raw+0x2b8/0x8d0\n   of_irq_parse_one+0x24c/0x270\n   parse_interrupts+0xc0/0x120\n   of_fwnode_add_links+0x100/0x2d0\n   fw_devlink_parse_fwtree+0x64/0xc0\n   device_add+0xb38/0xc30\n   of_device_add+0x64/0x90\n   of_platform_device_create_pdata+0xd0/0x170\n   of_platform_bus_create+0x244/0x600\n   of_platform_notify+0x1b0/0x254\n   blocking_notifier_call_chain+0x9c/0xd0\n   __of_changeset_entry_notify+0x1b8/0x230\n   __of_changeset_apply_notify+0x54/0xe4\n   of_overlay_fdt_apply+0xc04/0xd94\n   ...\n\n  The buggy address belongs to the object at ffffff81beca5600\n   which belongs to the cache kmalloc-128 of size 128\n  The buggy address is located 8 bytes inside of\n   128-byte region [ffffff81beca5600, ffffff81beca5680)\n\n  The buggy address belongs to the physical page:\n  page:00000000230d3d03 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1beca4\n  head:00000000230d3d03 order:1 compound_mapcount:0 compound_pincount:0\n  flags: 0x8000000000010200(slab|head|zone=2)\n  raw: 8000000000010200 0000000000000000 dead000000000122 ffffff810000c300\n  raw: 0000000000000000 0000000000200020 00000001ffffffff 0000000000000000\n  page dumped because: kasan: bad access detected\n\n  Memory state around the buggy address:\n   ffffff81beca5500: 04 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n   ffffff81beca5580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n  >ffffff81beca5600: 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                        ^\n   ffffff81beca5680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n   ffffff81beca5700: 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc\n  ==================================================================\n  OF:  -> got it !\n\nPrevent the out-of-bounds read by copying the device address into a\nbuffer of sufficient size.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46743",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52697",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: Intel: sof_sdw_rt_sdca_jack_common: ctx->headset_codec_dev = NULL\n\nsof_sdw_rt_sdca_jack_exit() are used by different codecs, and some of\nthem use the same dai name.\nFor example, rt712 and rt713 both use \"rt712-sdca-aif1\" and\nsof_sdw_rt_sdca_jack_exit().\nAs a result, sof_sdw_rt_sdca_jack_exit() will be called twice by\nmc_dailink_exit_loop(). Set ctx->headset_codec_dev = NULL; after\nput_device(ctx->headset_codec_dev); to avoid ctx->headset_codec_dev\nbeing put twice.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52697",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-17",
                    "modification_date": "2025-09-25",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53751",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix potential use-after-free bugs in TCP_Server_Info::hostname\n\nTCP_Server_Info::hostname may be updated once or many times during\nreconnect, so protect its access outside reconnect path as well and\nthen prevent any potential use-after-free bugs.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-1380",
                    "description": "A slab-out-of-bound read problem was found in brcmf_get_assoc_ies in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux Kernel. This issue could occur when assoc_info->req_len data is bigger than the size of the buffer, defined as WL_EXTRA_BUF_MAX, leading to a denial of service.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-1380",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-03-27",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49094",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/tls: fix slab-out-of-bounds bug in decrypt_internal\n\nThe memory size of tls_ctx->rx.iv for AES128-CCM is 12 setting in\ntls_set_sw_offload(). The return value of crypto_aead_ivsize()\nfor \"ccm(aes)\" is 16. So memcpy() require 16 bytes from 12 bytes\nmemory space will trigger slab-out-of-bounds bug as following:\n\n==================================================================\nBUG: KASAN: slab-out-of-bounds in decrypt_internal+0x385/0xc40 [tls]\nRead of size 16 at addr ffff888114e84e60 by task tls/10911\n\nCall Trace:\n <TASK>\n dump_stack_lvl+0x34/0x44\n print_report.cold+0x5e/0x5db\n ? decrypt_internal+0x385/0xc40 [tls]\n kasan_report+0xab/0x120\n ? decrypt_internal+0x385/0xc40 [tls]\n kasan_check_range+0xf9/0x1e0\n memcpy+0x20/0x60\n decrypt_internal+0x385/0xc40 [tls]\n ? tls_get_rec+0x2e0/0x2e0 [tls]\n ? process_rx_list+0x1a5/0x420 [tls]\n ? tls_setup_from_iter.constprop.0+0x2e0/0x2e0 [tls]\n decrypt_skb_update+0x9d/0x400 [tls]\n tls_sw_recvmsg+0x3c8/0xb50 [tls]\n\nAllocated by task 10911:\n kasan_save_stack+0x1e/0x40\n __kasan_kmalloc+0x81/0xa0\n tls_set_sw_offload+0x2eb/0xa20 [tls]\n tls_setsockopt+0x68c/0x700 [tls]\n __sys_setsockopt+0xfe/0x1b0\n\nReplace the crypto_aead_ivsize() with prot->iv_size + prot->salt_size\nwhen memcpy() iv value in TLS_1_3_VERSION scenario.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49094",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-36791",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: keep alloc_hash updated after hash allocation\n\nIn commit 599be01ee567 (\"net_sched: fix an OOB access in cls_tcindex\")\nI moved cp->hash calculation before the first\ntcindex_alloc_perfect_hash(), but cp->alloc_hash is left untouched.\nThis difference could lead to another out of bound access.\n\ncp->alloc_hash should always be the size allocated, we should\nupdate it after this tcindex_alloc_perfect_hash().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-36791",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-07",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-35963",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_sock: Fix not validating setsockopt user input\n\nCheck user input length before copying data.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35963",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-20",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57838",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/entry: Mark IRQ entries to fix stack depot warnings\n\nThe stack depot filters out everything outside of the top interrupt\ncontext as an uninteresting or irrelevant part of the stack traces. This\nhelps with stack trace de-duplication, avoiding an explosion of saved\nstack traces that share the same IRQ context code path but originate\nfrom different randomly interrupted points, eventually exhausting the\nstack depot.\n\nFiltering uses in_irqentry_text() to identify functions within the\n.irqentry.text and .softirqentry.text sections, which then become the\nlast stack trace entries being saved.\n\nWhile __do_softirq() is placed into the .softirqentry.text section by\ncommon code, populating .irqentry.text is architecture-specific.\n\nCurrently, the .irqentry.text section on s390 is empty, which prevents\nstack depot filtering and de-duplication and could result in warnings\nlike:\n\nStack depot reached limit capacity\nWARNING: CPU: 0 PID: 286113 at lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8\n\nwith PREEMPT and KASAN enabled.\n\nFix this by moving the IO/EXT interrupt handlers from .kprobes.text into\nthe .irqentry.text section and updating the kprobes blacklist to include\nthe .irqentry.text section.\n\nThis is done only for asynchronous interrupts and explicitly not for\nprogram checks, which are synchronous and where the context beyond the\nprogram check is important to preserve. Despite machine checks being\nsomewhat in between, they are extremely rare, and preserving context\nwhen possible is also of value.\n\nSVCs and Restart Interrupts are not relevant, one being always at the\nboundary to user space and the other being a one-time thing.\n\nIRQ entries filtering is also optionally used in ftrace function graph,\nwhere the same logic applies.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57838",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-11",
                    "modification_date": "2026-01-05",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50366",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowercap: intel_rapl: fix UBSAN shift-out-of-bounds issue\n\nWhen value < time_unit, the parameter of ilog2() will be zero and\nthe return value is -1. u64(-1) is too large for shift exponent\nand then will trigger shift-out-of-bounds:\n\nshift exponent 18446744073709551615 is too large for 32-bit type 'int'\nCall Trace:\n rapl_compute_time_window_core\n rapl_write_data_raw\n set_time_window\n store_constraint_time_window_us",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50366",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-17",
                    "modification_date": "2025-12-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38249",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usb-audio: Fix out-of-bounds read in snd_usb_get_audioformat_uac3()\n\nIn snd_usb_get_audioformat_uac3(), the length value returned from\nsnd_usb_ctl_msg() is used directly for memory allocation without\nvalidation. This length is controlled by the USB device.\n\nThe allocated buffer is cast to a uac3_cluster_header_descriptor\nand its fields are accessed without verifying that the buffer\nis large enough. If the device returns a smaller than expected\nlength, this leads to an out-of-bounds read.\n\nAdd a length check to ensure the buffer is large enough for\nuac3_cluster_header_descriptor.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38249",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-09",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40322",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: bitblit: bound-check glyph index in bit_putcs*\n\nbit_putcs_aligned()/unaligned() derived the glyph pointer from the\ncharacter value masked by 0xff/0x1ff, which may exceed the actual font's\nglyph count and read past the end of the built-in font array.\nClamp the index to the actual glyph count before computing the address.\n\nThis fixes a global out-of-bounds read reported by syzbot.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50033",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nslip: make slhc_remember() more robust against malicious packets\n\nsyzbot found that slhc_remember() was missing checks against\nmalicious packets [1].\n\nslhc_remember() only checked the size of the packet was at least 20,\nwhich is not good enough.\n\nWe need to make sure the packet includes the IPv4 and TCP header\nthat are supposed to be carried.\n\nAdd iph and th pointers to make the code more readable.\n\n[1]\n\nBUG: KMSAN: uninit-value in slhc_remember+0x2e8/0x7b0 drivers/net/slip/slhc.c:666\n  slhc_remember+0x2e8/0x7b0 drivers/net/slip/slhc.c:666\n  ppp_receive_nonmp_frame+0xe45/0x35e0 drivers/net/ppp/ppp_generic.c:2455\n  ppp_receive_frame drivers/net/ppp/ppp_generic.c:2372 [inline]\n  ppp_do_recv+0x65f/0x40d0 drivers/net/ppp/ppp_generic.c:2212\n  ppp_input+0x7dc/0xe60 drivers/net/ppp/ppp_generic.c:2327\n  pppoe_rcv_core+0x1d3/0x720 drivers/net/ppp/pppoe.c:379\n  sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1113\n  __release_sock+0x1da/0x330 net/core/sock.c:3072\n  release_sock+0x6b/0x250 net/core/sock.c:3626\n  pppoe_sendmsg+0x2b8/0xb90 drivers/net/ppp/pppoe.c:903\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:4091 [inline]\n  slab_alloc_node mm/slub.c:4134 [inline]\n  kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4186\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:587\n  __alloc_skb+0x363/0x7b0 net/core/skbuff.c:678\n  alloc_skb include/linux/skbuff.h:1322 [inline]\n  sock_wmalloc+0xfe/0x1a0 net/core/sock.c:2732\n  pppoe_sendmsg+0x3a7/0xb90 drivers/net/ppp/pppoe.c:867\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCPU: 0 UID: 0 PID: 5460 Comm: syz.2.33 Not tainted 6.12.0-rc2-syzkaller-00006-g87d6aab2389e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50033",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50278",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: fix potential out-of-bounds access on the first resume\n\nOut-of-bounds access occurs if the fast device is expanded unexpectedly\nbefore the first-time resume of the cache table. This happens because\nexpanding the fast device requires reloading the cache table for\ncache_create to allocate new in-core data structures that fit the new\nsize, and the check in cache_preresume is not performed during the\nfirst resume, leading to the issue.\n\nReproduce steps:\n\n1. prepare component devices:\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc 262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct\n\n2. load a cache table of 512 cache blocks, and deliberately expand the\n   fast device before resuming the cache, making the in-core data\n   structures inadequate.\n\ndmsetup create cache --notable\ndmsetup reload cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\ndmsetup reload cdata --table \"0 131072 linear /dev/sdc 8192\"\ndmsetup resume cdata\ndmsetup resume cache\n\n3. suspend the cache to write out the in-core dirty bitset and hint\n   array, leading to out-of-bounds access to the dirty bitset at offset\n   0x40:\n\ndmsetup suspend cache\n\nKASAN reports:\n\n  BUG: KASAN: vmalloc-out-of-bounds in is_dirty_callback+0x2b/0x80\n  Read of size 8 at addr ffffc90000085040 by task dmsetup/90\n\n  (...snip...)\n  The buggy address belongs to the virtual mapping at\n   [ffffc90000085000, ffffc90000087000) created by:\n   cache_ctr+0x176a/0x35f0\n\n  (...snip...)\n  Memory state around the buggy address:\n   ffffc90000084f00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc90000084f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n  >ffffc90000085000: 00 00 00 00 00 00 00 00 f8 f8 f8 f8 f8 f8 f8 f8\n                                             ^\n   ffffc90000085080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc90000085100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n\nFix by checking the size change on the first resume.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50278",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53265",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: ensure that VID header offset + VID header size <= alloc, size\n\nEnsure that the VID header offset + VID header size does not exceed\nthe allocated area to avoid slab OOB.\n\nBUG: KASAN: slab-out-of-bounds in crc32_body lib/crc32.c:111 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_generic lib/crc32.c:179 [inline]\nBUG: KASAN: slab-out-of-bounds in crc32_le_base+0x58c/0x626 lib/crc32.c:197\nRead of size 4 at addr ffff88802bb36f00 by task syz-executor136/1555\n\nCPU: 2 PID: 1555 Comm: syz-executor136 Tainted: G        W\n6.0.0-1868 #1\nHardware name: Red Hat KVM, BIOS 1.13.0-2.module+el8.3.0+7860+a7792d29\n04/01/2014\nCall Trace:\n  <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x85/0xad lib/dump_stack.c:106\n  print_address_description mm/kasan/report.c:317 [inline]\n  print_report.cold.13+0xb6/0x6bb mm/kasan/report.c:433\n  kasan_report+0xa7/0x11b mm/kasan/report.c:495\n  crc32_body lib/crc32.c:111 [inline]\n  crc32_le_generic lib/crc32.c:179 [inline]\n  crc32_le_base+0x58c/0x626 lib/crc32.c:197\n  ubi_io_write_vid_hdr+0x1b7/0x472 drivers/mtd/ubi/io.c:1067\n  create_vtbl+0x4d5/0x9c4 drivers/mtd/ubi/vtbl.c:317\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\nRIP: 0033:0x7f96d5cf753d\nCode:\nRSP: 002b:00007fffd72206f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f96d5cf753d\nRDX: 0000000020000080 RSI: 0000000040186f40 RDI: 0000000000000003\nRBP: 0000000000400cd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400be0\nR13: 00007fffd72207e0 R14: 0000000000000000 R15: 0000000000000000\n  </TASK>\n\nAllocated by task 1555:\n  kasan_save_stack+0x20/0x3d mm/kasan/common.c:38\n  kasan_set_track mm/kasan/common.c:45 [inline]\n  set_alloc_info mm/kasan/common.c:437 [inline]\n  ____kasan_kmalloc mm/kasan/common.c:516 [inline]\n  __kasan_kmalloc+0x88/0xa3 mm/kasan/common.c:525\n  kasan_kmalloc include/linux/kasan.h:234 [inline]\n  __kmalloc+0x138/0x257 mm/slub.c:4429\n  kmalloc include/linux/slab.h:605 [inline]\n  ubi_alloc_vid_buf drivers/mtd/ubi/ubi.h:1093 [inline]\n  create_vtbl+0xcc/0x9c4 drivers/mtd/ubi/vtbl.c:295\n  create_empty_lvol drivers/mtd/ubi/vtbl.c:500 [inline]\n  ubi_read_volume_table+0x67b/0x288a drivers/mtd/ubi/vtbl.c:812\n  ubi_attach+0xf34/0x1603 drivers/mtd/ubi/attach.c:1601\n  ubi_attach_mtd_dev+0x6f3/0x185e drivers/mtd/ubi/build.c:965\n  ctrl_cdev_ioctl+0x2db/0x347 drivers/mtd/ubi/cdev.c:1043\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:870 [inline]\n  __se_sys_ioctl fs/ioctl.c:856 [inline]\n  __x64_sys_ioctl+0x193/0x213 fs/ioctl.c:856\n  do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n  do_syscall_64+0x3e/0x86 arch/x86/entry/common.c:80\n  entry_SYSCALL_64_after_hwframe+0x63/0x0\n\nThe buggy address belongs to the object at ffff88802bb36e00\n  which belongs to the cache kmalloc-256 of size 256\nThe buggy address is located 0 bytes to the right of\n  256-byte region [ffff88802bb36e00, ffff88802bb36f00)\n\nThe buggy address belongs to the physical page:\npage:00000000ea4d1263 refcount:1 mapcount:0 mapping:0000000000000000\nindex:0x0 pfn:0x2bb36\nhead:00000000ea4d1263 order:1 compound_mapcount:0 compound_pincount:0\nflags: 0xfffffc0010200(slab|head|node=0|zone=1|lastcpupid=0x1fffff)\nraw: 000fffffc0010200 ffffea000066c300 dead000000000003 ffff888100042b40\nraw: 0000000000000000 00000000001\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53265",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-02",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-49861",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix helper writes to read-only maps\n\nLonial found an issue that despite user- and BPF-side frozen BPF map\n(like in case of .rodata), it was still possible to write into it from\na BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT}\nas arguments.\n\nIn check_func_arg() when the argument is as mentioned, the meta->raw_mode\nis never set. Later, check_helper_mem_access(), under the case of\nPTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the\nsubsequent call to check_map_access_type() and given the BPF map is\nread-only it succeeds.\n\nThe helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT\nwhen results are written into them as opposed to read out of them. The\nlatter indicates that it's okay to pass a pointer to uninitialized memory\nas the memory is written to anyway.\n\nHowever, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM\njust with additional alignment requirement. So it is better to just get\nrid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the\nfixed size memory types. For this, add MEM_ALIGNED to additionally ensure\nalignment given these helpers write directly into the args via *<ptr> = val.\nThe .arg*_size has been initialized reflecting the actual sizeof(*<ptr>).\n\nMEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated\nargument types, since in !MEM_FIXED_SIZE cases the verifier does not know\nthe buffer size a priori and therefore cannot blindly write *<ptr> = val.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49861",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47219",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: scsi_debug: Fix out-of-bound read in resp_report_tgtpgs()\n\nThe following issue was observed running syzkaller:\n\nBUG: KASAN: slab-out-of-bounds in memcpy include/linux/string.h:377 [inline]\nBUG: KASAN: slab-out-of-bounds in sg_copy_buffer+0x150/0x1c0 lib/scatterlist.c:831\nRead of size 2132 at addr ffff8880aea95dc8 by task syz-executor.0/9815\n\nCPU: 0 PID: 9815 Comm: syz-executor.0 Not tainted 4.19.202-00874-gfc0fe04215a9 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xe4/0x14a lib/dump_stack.c:118\n print_address_description+0x73/0x280 mm/kasan/report.c:253\n kasan_report_error mm/kasan/report.c:352 [inline]\n kasan_report+0x272/0x370 mm/kasan/report.c:410\n memcpy+0x1f/0x50 mm/kasan/kasan.c:302\n memcpy include/linux/string.h:377 [inline]\n sg_copy_buffer+0x150/0x1c0 lib/scatterlist.c:831\n fill_from_dev_buffer+0x14f/0x340 drivers/scsi/scsi_debug.c:1021\n resp_report_tgtpgs+0x5aa/0x770 drivers/scsi/scsi_debug.c:1772\n schedule_resp+0x464/0x12f0 drivers/scsi/scsi_debug.c:4429\n scsi_debug_queuecommand+0x467/0x1390 drivers/scsi/scsi_debug.c:5835\n scsi_dispatch_cmd+0x3fc/0x9b0 drivers/scsi/scsi_lib.c:1896\n scsi_request_fn+0x1042/0x1810 drivers/scsi/scsi_lib.c:2034\n __blk_run_queue_uncond block/blk-core.c:464 [inline]\n __blk_run_queue+0x1a4/0x380 block/blk-core.c:484\n blk_execute_rq_nowait+0x1c2/0x2d0 block/blk-exec.c:78\n sg_common_write.isra.19+0xd74/0x1dc0 drivers/scsi/sg.c:847\n sg_write.part.23+0x6e0/0xd00 drivers/scsi/sg.c:716\n sg_write+0x64/0xa0 drivers/scsi/sg.c:622\n __vfs_write+0xed/0x690 fs/read_write.c:485\nkill_bdev:block_device:00000000e138492c\n vfs_write+0x184/0x4c0 fs/read_write.c:549\n ksys_write+0x107/0x240 fs/read_write.c:599\n do_syscall_64+0xc2/0x560 arch/x86/entry/common.c:293\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nWe get 'alen' from command its type is int. If userspace passes a large\nlength we will get a negative 'alen'.\n\nSwitch n, alen, and rlen to u32.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47219",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-10",
                    "modification_date": "2025-03-04",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26672",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'\n\nFixes the below:\n\ndrivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)\n\n357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev,\n\t\t\t\t     enum amdgpu_mca_error_type type,\n358                                  int idx, struct mca_bank_entry *entry)\n359 {\n360         const struct amdgpu_mca_smu_funcs *mca_funcs =\n\t\t\t\t\t\tadev->mca.mca_funcs;\n361         int count;\n362\n363         switch (type) {\n364         case AMDGPU_MCA_ERROR_TYPE_UE:\n365                 count = mca_funcs->max_ue_count;\n\nmca_funcs is dereferenced here.\n\n366                 break;\n367         case AMDGPU_MCA_ERROR_TYPE_CE:\n368                 count = mca_funcs->max_ce_count;\n\nmca_funcs is dereferenced here.\n\n369                 break;\n370         default:\n371                 return -EINVAL;\n372         }\n373\n374         if (idx >= count)\n375                 return -EINVAL;\n376\n377         if (mca_funcs && mca_funcs->mca_get_mca_entry)\n\t        ^^^^^^^^^\n\nChecked too late!",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26672",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-02",
                    "modification_date": "2025-04-08",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38103",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: usbhid: Eliminate recurrent out-of-bounds bug in usbhid_parse()\n\nUpdate struct hid_descriptor to better reflect the mandatory and\noptional parts of the HID Descriptor as per USB HID 1.11 specification.\nNote: the kernel currently does not parse any optional HID class\ndescriptors, only the mandatory report descriptor.\n\nUpdate all references to member element desc[0] to rpt_desc.\n\nAdd test to verify bLength and bNumDescriptors values are valid.\n\nReplace the for loop with direct access to the mandatory HID class\ndescriptor member for the report descriptor. This eliminates the\npossibility of getting an out-of-bounds fault.\n\nAdd a warning message if the HID descriptor contains any unsupported\noptional HID class descriptors.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38103",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38342",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoftware node: Correct a OOB check in software_node_get_reference_args()\n\nsoftware_node_get_reference_args() wants to get @index-th element, so\nthe property value requires at least '(index + 1) * sizeof(*ref)' bytes\nbut that can not be guaranteed by current OOB check, and may cause OOB\nfor malformed property.\n\nFix by using as OOB check '((index + 1) * sizeof(*ref) > prop->length)'.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38342",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39760",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: core: config: Prevent OOB read in SS endpoint companion parsing\n\nusb_parse_ss_endpoint_companion() checks descriptor type before length,\nenabling a potentially odd read outside of the buffer size.\n\nFix this up by checking the size first before looking at any of the\nfields in the descriptor.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49961",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Do mark_chain_precision for ARG_CONST_ALLOC_SIZE_OR_ZERO\n\nPrecision markers need to be propagated whenever we have an ARG_CONST_*\nstyle argument, as the verifier cannot consider imprecise scalars to be\nequivalent for the purposes of states_equal check when such arguments\nrefine the return value (in this case, set mem_size for PTR_TO_MEM). The\nresultant mem_size for the R0 is derived from the constant value, and if\nthe verifier incorrectly prunes states considering them equivalent where\nsuch arguments exist (by seeing that both registers have reg->precise as\nfalse in regsafe), we can end up with invalid programs passing the\nverifier which can do access beyond what should have been the correct\nmem_size in that explored state.\n\nTo show a concrete example of the problem:\n\n0000000000000000 <prog>:\n       0:       r2 = *(u32 *)(r1 + 80)\n       1:       r1 = *(u32 *)(r1 + 76)\n       2:       r3 = r1\n       3:       r3 += 4\n       4:       if r3 > r2 goto +18 <LBB5_5>\n       5:       w2 = 0\n       6:       *(u32 *)(r1 + 0) = r2\n       7:       r1 = *(u32 *)(r1 + 0)\n       8:       r2 = 1\n       9:       if w1 == 0 goto +1 <LBB5_3>\n      10:       r2 = -1\n\n0000000000000058 <LBB5_3>:\n      11:       r1 = 0 ll\n      13:       r3 = 0\n      14:       call bpf_ringbuf_reserve\n      15:       if r0 == 0 goto +7 <LBB5_5>\n      16:       r1 = r0\n      17:       r1 += 16777215\n      18:       w2 = 0\n      19:       *(u8 *)(r1 + 0) = r2\n      20:       r1 = r0\n      21:       r2 = 0\n      22:       call bpf_ringbuf_submit\n\n00000000000000b8 <LBB5_5>:\n      23:       w0 = 0\n      24:       exit\n\nFor the first case, the single line execution's exploration will prune\nthe search at insn 14 for the branch insn 9's second leg as it will be\nverified first using r2 = -1 (UINT_MAX), while as w1 at insn 9 will\nalways be 0 so at runtime we don't get error for being greater than\nUINT_MAX/4 from bpf_ringbuf_reserve. The verifier during regsafe just\nsees reg->precise as false for both r2 registers in both states, hence\nconsiders them equal for purposes of states_equal.\n\nIf we propagated precise markers using the backtracking support, we\nwould use the precise marking to then ensure that old r2 (UINT_MAX) was\nwithin the new r2 (1) and this would never be true, so the verification\nwould rightfully fail.\n\nThe end result is that the out of bounds access at instruction 19 would\nbe permitted without this fix.\n\nNote that reg->precise is always set to true when user does not have\nCAP_BPF (or when subprog count is greater than 1 (i.e. use of any static\nor global functions)), hence this is only a problem when precision marks\nneed to be explicitly propagated (i.e. privileged users with CAP_BPF).\n\nA simplified test case has been included in the next patch to prevent\nfuture regressions.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49961",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-35965",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix not validating setsockopt user input\n\nCheck user input length before copying data.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35965",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-20",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49674",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm raid: fix accesses beyond end of raid member array\n\nOn dm-raid table load (using raid_ctr), dm-raid allocates an array\nrs->devs[rs->raid_disks] for the raid device members. rs->raid_disks\nis defined by the number of raid metadata and image tupples passed\ninto the target's constructor.\n\nIn the case of RAID layout changes being requested, that number can be\ndifferent from the current number of members for existing raid sets as\ndefined in their superblocks. Example RAID layout changes include:\n- raid1 legs being added/removed\n- raid4/5/6/10 number of stripes changed (stripe reshaping)\n- takeover to higher raid level (e.g. raid5 -> raid6)\n\nWhen accessing array members, rs->raid_disks must be used in control\nloops instead of the potentially larger value in rs->md.raid_disks.\nOtherwise it will cause memory access beyond the end of the rs->devs\narray.\n\nFix this by changing code that is prone to out-of-bounds access.\nAlso fix validate_raid_redundancy() to validate all devices that are\nadded. Also, use braces to help clean up raid_iterate_devices().\n\nThe out-of-bounds memory accesses was discovered using KASAN.\n\nThis commit was verified to pass all LVM2 RAID tests (with KASAN\nenabled).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49674",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-24",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46724",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix out-of-bounds read of df_v1_7_channel_number\n\nCheck the fb_channel_number range to avoid the array out-of-bounds\nread error",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46724",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47255",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkvm: LAPIC: Restore guard to prevent illegal APIC register access\n\nPer the SDM, \"any access that touches bytes 4 through 15 of an APIC\nregister may cause undefined behavior and must not be executed.\"\nWorse, such an access in kvm_lapic_reg_read can result in a leak of\nkernel stack contents. Prior to commit 01402cf81051 (\"kvm: LAPIC:\nwrite down valid APIC registers\"), such an access was explicitly\ndisallowed. Restore the guard that was removed in that commit.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47255",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-30",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-38728",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb3: fix for slab out of bounds on mount to ksmbd\n\nWith KASAN enabled, it is possible to get a slab out of bounds\nduring mount to ksmbd due to missing check in parse_server_interfaces()\n(see below):\n\n BUG: KASAN: slab-out-of-bounds in\n parse_server_interfaces+0x14ee/0x1880 [cifs]\n Read of size 4 at addr ffff8881433dba98 by task mount/9827\n\n CPU: 5 UID: 0 PID: 9827 Comm: mount Tainted: G\n OE       6.16.0-rc2-kasan #2 PREEMPT(voluntary)\n Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\n Hardware name: Dell Inc. Precision Tower 3620/0MWYPT,\n BIOS 2.13.1 06/14/2019\n Call Trace:\n  <TASK>\n dump_stack_lvl+0x9f/0xf0\n print_report+0xd1/0x670\n __virt_addr_valid+0x22c/0x430\n ? parse_server_interfaces+0x14ee/0x1880 [cifs]\n ? kasan_complete_mode_report_info+0x2a/0x1f0\n ? parse_server_interfaces+0x14ee/0x1880 [cifs]\n   kasan_report+0xd6/0x110\n   parse_server_interfaces+0x14ee/0x1880 [cifs]\n   __asan_report_load_n_noabort+0x13/0x20\n   parse_server_interfaces+0x14ee/0x1880 [cifs]\n ? __pfx_parse_server_interfaces+0x10/0x10 [cifs]\n ? trace_hardirqs_on+0x51/0x60\n SMB3_request_interfaces+0x1ad/0x3f0 [cifs]\n ? __pfx_SMB3_request_interfaces+0x10/0x10 [cifs]\n ? SMB2_tcon+0x23c/0x15d0 [cifs]\n smb3_qfs_tcon+0x173/0x2b0 [cifs]\n ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs]\n ? cifs_get_tcon+0x105d/0x2120 [cifs]\n ? do_raw_spin_unlock+0x5d/0x200\n ? cifs_get_tcon+0x105d/0x2120 [cifs]\n ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs]\n cifs_mount_get_tcon+0x369/0xb90 [cifs]\n ? dfs_cache_find+0xe7/0x150 [cifs]\n dfs_mount_share+0x985/0x2970 [cifs]\n ? check_path.constprop.0+0x28/0x50\n ? save_trace+0x54/0x370\n ? __pfx_dfs_mount_share+0x10/0x10 [cifs]\n ? __lock_acquire+0xb82/0x2ba0\n ? __kasan_check_write+0x18/0x20\n cifs_mount+0xbc/0x9e0 [cifs]\n ? __pfx_cifs_mount+0x10/0x10 [cifs]\n ? do_raw_spin_unlock+0x5d/0x200\n ? cifs_setup_cifs_sb+0x29d/0x810 [cifs]\n cifs_smb3_do_mount+0x263/0x1990 [cifs]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38728",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-49870",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncapabilities: fix undefined behavior in bit shift for CAP_TO_MASK\n\nShifting signed 32-bit value by 31 bits is undefined, so changing\nsignificant bit to unsigned. The UBSAN warning calltrace like below:\n\nUBSAN: shift-out-of-bounds in security/commoncap.c:1252:2\nleft shift of 1 by 31 places cannot be represented in type 'int'\nCall Trace:\n <TASK>\n dump_stack_lvl+0x7d/0xa5\n dump_stack+0x15/0x1b\n ubsan_epilogue+0xe/0x4e\n __ubsan_handle_shift_out_of_bounds+0x1e7/0x20c\n cap_task_prctl+0x561/0x6f0\n security_task_prctl+0x5a/0xb0\n __x64_sys_prctl+0x61/0x8f0\n do_syscall_64+0x58/0x80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49870",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53333",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: conntrack: dccp: copy entire header to stack buffer, not just basic one\n\nEric Dumazet says:\n  nf_conntrack_dccp_packet() has an unique:\n\n  dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\n  And nothing more is 'pulled' from the packet, depending on the content.\n  dh->dccph_doff, and/or dh->dccph_x ...)\n  So dccp_ack_seq() is happily reading stuff past the _dh buffer.\n\nBUG: KASAN: stack-out-of-bounds in nf_conntrack_dccp_packet+0x1134/0x11c0\nRead of size 4 at addr ffff000128f66e0c by task syz-executor.2/29371\n[..]\n\nFix this by increasing the stack buffer to also include room for\nthe extra sequence numbers and all the known dccp packet type headers,\nthen pull again after the initial validation of the basic header.\n\nWhile at it, mark packets invalid that lack 48bit sequence bit but\nwhere RFC says the type MUST use them.\n\nCompile tested only.\n\nv2: first skb_header_pointer() now needs to adjust the size to\n    only pull the generic header. (Eric)\n\nHeads-up: I intend to remove dccp conntrack support later this year.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53333",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53357",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid10: check slab-out-of-bounds in md_bitmap_get_counter\n\nIf we write a large number to md/bitmap_set_bits, md_bitmap_checkpage()\nwill return -EINVAL because 'page >= bitmap->pages', but the return value\nwas not checked immediately in md_bitmap_get_counter() in order to set\n*blocks value and slab-out-of-bounds occurs.\n\nMove check of 'page >= bitmap->pages' to md_bitmap_get_counter() and\nreturn directly if true.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53357",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-17",
                    "modification_date": "2025-12-11",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-46722",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix mc_data out-of-bounds read warning\n\nClear warning that read mc_data[i-1] may out-of-bounds.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46722",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39901",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: remove read access to debugfs files\n\nThe 'command' and 'netdev_ops' debugfs files are a legacy debugging\ninterface supported by the i40e driver since its early days by commit\n02e9c290814c (\"i40e: debugfs interface\").\n\nBoth of these debugfs files provide a read handler which is mostly useless,\nand which is implemented with questionable logic. They both use a static\n256 byte buffer which is initialized to the empty string. In the case of\nthe 'command' file this buffer is literally never used and simply wastes\nspace. In the case of the 'netdev_ops' file, the last command written is\nsaved here.\n\nOn read, the files contents are presented as the name of the device\nfollowed by a colon and then the contents of their respective static\nbuffer. For 'command' this will always be \"<device>: \". For 'netdev_ops',\nthis will be \"<device>: <last command written>\". But note the buffer is\nshared between all devices operated by this module. At best, it is mostly\nmeaningless information, and at worse it could be accessed simultaneously\nas there doesn't appear to be any locking mechanism.\n\nWe have also recently received multiple reports for both read functions\nabout their use of snprintf and potential overflow that could result in\nreading arbitrary kernel memory. For the 'command' file, this is definitely\nimpossible, since the static buffer is always zero and never written to.\nFor the 'netdev_ops' file, it does appear to be possible, if the user\ncarefully crafts the command input, it will be copied into the buffer,\nwhich could be large enough to cause snprintf to truncate, which then\ncauses the copy_to_user to read beyond the length of the buffer allocated\nby kzalloc.\n\nA minimal fix would be to replace snprintf() with scnprintf() which would\ncap the return to the number of bytes written, preventing an overflow. A\nmore involved fix would be to drop the mostly useless static buffers,\nsaving 512 bytes and modifying the read functions to stop needing those as\ninput.\n\nInstead, lets just completely drop the read access to these files. These\nare debug interfaces exposed as part of debugfs, and I don't believe that\ndropping read access will break any script, as the provided output is\npretty useless. You can find the netdev name through other more standard\ninterfaces, and the 'netdev_ops' interface can easily result in garbage if\nyou issue simultaneous writes to multiple devices at once.\n\nIn order to properly remove the i40e_dbg_netdev_ops_buf, we need to\nrefactor its write function to avoid using the static buffer. Instead, use\nthe same logic as the i40e_dbg_command_write, with an allocated buffer.\nUpdate the code to use this instead of the static buffer, and ensure we\nfree the buffer on exit. This fixes simultaneous writes to 'netdev_ops' on\nmultiple devices, and allows us to remove the now unused static buffer\nalong with removing the read access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39901",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-46774",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas()\n\nSmatch warns:\n\n  arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potential\n  spectre issue 'args.args' [r] (local cap)\n\nThe 'nargs' and 'nret' locals come directly from a user-supplied\nbuffer and are used as indexes into a small stack-based array and as\ninputs to copy_to_user() after they are subject to bounds checks.\n\nUse array_index_nospec() after the bounds checks to clamp these values\nfor speculative execution.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46774",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-35967",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: SCO: Fix not validating setsockopt user input\n\nsyzbot reported sco_sock_setsockopt() is copying data without\nchecking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\ninclude/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\ninclude/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in sco_sock_setsockopt+0xc0b/0xf90\nnet/bluetooth/sco.c:893\nRead of size 4 at addr ffff88805f7b15a3 by task syz-executor.5/12578",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35967",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-20",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53057",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: HCI: Fix global-out-of-bounds\n\nTo loop a variable-length array, hci_init_stage_sync(stage) considers\nthat stage[i] is valid as long as stage[i-1].func is valid.\nThus, the last element of stage[].func should be intentionally invalid\nas hci_init0[], le_init2[], and others did.\nHowever, amp_init1[] and amp_init2[] have no invalid element, letting\nhci_init_stage_sync() keep accessing amp_init1[] over its valid range.\nThis patch fixes this by adding {} in the last of amp_init1[] and\namp_init2[].\n\n==================================================================\nBUG: KASAN: global-out-of-bounds in hci_dev_open_sync (\n/v6.2-bzimage/net/bluetooth/hci_sync.c:3154\n/v6.2-bzimage/net/bluetooth/hci_sync.c:3343\n/v6.2-bzimage/net/bluetooth/hci_sync.c:4418\n/v6.2-bzimage/net/bluetooth/hci_sync.c:4609\n/v6.2-bzimage/net/bluetooth/hci_sync.c:4689)\nRead of size 8 at addr ffffffffaed1ab70 by task kworker/u5:0/1032\nCPU: 0 PID: 1032 Comm: kworker/u5:0 Not tainted 6.2.0 #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04\nWorkqueue: hci1 hci_power_on\nCall Trace:\n <TASK>\ndump_stack_lvl (/v6.2-bzimage/lib/dump_stack.c:107 (discriminator 1))\nprint_report (/v6.2-bzimage/mm/kasan/report.c:307\n  /v6.2-bzimage/mm/kasan/report.c:417)\n? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:3343\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4418\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4609\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4689)\nkasan_report (/v6.2-bzimage/mm/kasan/report.c:184\n  /v6.2-bzimage/mm/kasan/report.c:519)\n? hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:3343\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4418\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4609\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4689)\nhci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:3154\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:3343\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4418\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4609\n  /v6.2-bzimage/net/bluetooth/hci_sync.c:4689)\n? __pfx_hci_dev_open_sync (/v6.2-bzimage/net/bluetooth/hci_sync.c:4635)\n? mutex_lock (/v6.2-bzimage/./arch/x86/include/asm/atomic64_64.h:190\n  /v6.2-bzimage/./include/linux/atomic/atomic-long.h:443\n  /v6.2-bzimage/./include/linux/atomic/atomic-instrumented.h:1781\n  /v6.2-bzimage/kernel/locking/mutex.c:171\n  /v6.2-bzimage/kernel/locking/mutex.c:285)\n? __pfx_mutex_lock (/v6.2-bzimage/kernel/locking/mutex.c:282)\nhci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:485\n  /v6.2-bzimage/net/bluetooth/hci_core.c:984)\n? __pfx_hci_power_on (/v6.2-bzimage/net/bluetooth/hci_core.c:969)\n? read_word_at_a_time (/v6.2-bzimage/./include/asm-generic/rwonce.h:85)\n? strscpy (/v6.2-bzimage/./arch/x86/include/asm/word-at-a-time.h:62\n  /v6.2-bzimage/lib/string.c:161)\nprocess_one_work (/v6.2-bzimage/kernel/workqueue.c:2294)\nworker_thread (/v6.2-bzimage/./include/linux/list.h:292\n  /v6.2-bzimage/kernel/workqueue.c:2437)\n? __pfx_worker_thread (/v6.2-bzimage/kernel/workqueue.c:2379)\nkthread (/v6.2-bzimage/kernel/kthread.c:376)\n? __pfx_kthread (/v6.2-bzimage/kernel/kthread.c:331)\nret_from_fork (/v6.2-bzimage/arch/x86/entry/entry_64.S:314)\n </TASK>\nThe buggy address belongs to the variable:\namp_init1+0x30/0x60\nThe buggy address belongs to the physical page:\npage:000000003a157ec6 refcount:1 mapcount:0 mapping:0000000000000000 ia\nflags: 0x200000000001000(reserved|node=0|zone=2)\nraw: 0200000000001000 ffffea0005054688 ffffea0005054688 000000000000000\nraw: 0000000000000000 0000000000000000 00000001ffffffff 000000000000000\npage dumped because: kasan: bad access detected\nMemory state around the buggy address:\n ffffffffaed1aa00: f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9 00 00 00 00\n ffffffffaed1aa80: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 00 00 00 00\n>ffffffffaed1ab00: 00 f9 f9 f9 f9 f9 f9 f9 00 00 00 00 00 00 f9 f9\n                  \n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53057",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-12",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38004",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: bcm: add locking for bcm_op runtime updates\n\nThe CAN broadcast manager (CAN BCM) can send a sequence of CAN frames via\nhrtimer. The content and also the length of the sequence can be changed\nresp reduced at runtime where the 'currframe' counter is then set to zero.\n\nAlthough this appeared to be a safe operation the updates of 'currframe'\ncan be triggered from user space and hrtimer context in bcm_can_tx().\nAnderson Nascimento created a proof of concept that triggered a KASAN\nslab-out-of-bounds read access which can be prevented with a spin_lock_bh.\n\nAt the rework of bcm_can_tx() the 'count' variable has been moved into\nthe protected section as this variable can be modified from both contexts\ntoo.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38004",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-08",
                    "modification_date": "2025-12-17",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49883",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: smm: number of GPRs in the SMRAM image depends on the image format\n\nOn 64 bit host, if the guest doesn't have X86_FEATURE_LM, KVM will\naccess 16 gprs to 32-bit smram image, causing out-ouf-bound ram\naccess.\n\nOn 32 bit host, the rsm_load_state_64/enter_smm_save_state_64\nis compiled out, thus access overflow can't happen.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49883",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47327",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/arm-smmu: Fix arm_smmu_device refcount leak when arm_smmu_rpm_get fails\n\narm_smmu_rpm_get() invokes pm_runtime_get_sync(), which increases the\nrefcount of the \"smmu\" even though the return value is less than 0.\n\nThe reference counting issue happens in some error handling paths of\narm_smmu_rpm_get() in its caller functions. When arm_smmu_rpm_get()\nfails, the caller functions forget to decrease the refcount of \"smmu\"\nincreased by arm_smmu_rpm_get(), causing a refcount leak.\n\nFix this issue by calling pm_runtime_resume_and_get() instead of\npm_runtime_get_sync() in arm_smmu_rpm_get(), which can keep the refcount\nbalanced in case of failure.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47327",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21920",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvlan: enforce underlying device type\n\nCurrently, VLAN devices can be created on top of non-ethernet devices.\n\nBesides the fact that it doesn't make much sense, this also causes a\nbug which leaks the address of a kernel function to usermode.\n\nWhen creating a VLAN device, we initialize GARP (garp_init_applicant)\nand MRP (mrp_init_applicant) for the underlying device.\n\nAs part of the initialization process, we add the multicast address of\neach applicant to the underlying device, by calling dev_mc_add.\n\n__dev_mc_add uses dev->addr_len to determine the length of the new\nmulticast address.\n\nThis causes an out-of-bounds read if dev->addr_len is greater than 6,\nsince the multicast addresses provided by GARP and MRP are only 6\nbytes long.\n\nThis behaviour can be reproduced using the following commands:\n\nip tunnel add gretest mode ip6gre local ::1 remote ::2 dev lo\nip l set up dev gretest\nip link add link gretest name vlantest type vlan id 100\n\nThen, the following command will display the address of garp_pdu_rcv:\n\nip maddr show | grep 01:80:c2:00:00:21\n\nFix the bug by enforcing the type of the underlying device during VLAN\ndevice initialization.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21920",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-01",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38680",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Fix 1-byte out-of-bounds read in uvc_parse_format()\n\nThe buffer length check before calling uvc_parse_format() only ensured\nthat the buffer has at least 3 bytes (buflen > 2), buf the function\naccesses buffer[3], requiring at least 4 bytes.\n\nThis can lead to an out-of-bounds read if the buffer has exactly 3 bytes.\n\nFix it by checking that the buffer has at least 4 bytes in\nuvc_parse_format().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38680",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57929",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm array: fix releasing a faulty array block twice in dm_array_cursor_end\n\nWhen dm_bm_read_lock() fails due to locking or checksum errors, it\nreleases the faulty block implicitly while leaving an invalid output\npointer behind. The caller of dm_bm_read_lock() should not operate on\nthis invalid dm_block pointer, or it will lead to undefined result.\nFor example, the dm_array_cursor incorrectly caches the invalid pointer\non reading a faulty array block, causing a double release in\ndm_array_cursor_end(), then hitting the BUG_ON in dm-bufio cache_put().\n\nReproduce steps:\n\n1. initialize a cache device\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc $262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\n2. wipe the second array block offline\n\ndmsteup remove cache cmeta cdata corig\nmapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\nablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\ndd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock\n\n3. try reopen the cache device\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc $262144\"\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\nKernel logs:\n\n(snip)\ndevice-mapper: array: array_block_check failed: blocknr 0 != wanted 10\ndevice-mapper: block manager: array validator check failed for block 10\ndevice-mapper: array: get_ablock failed\ndevice-mapper: cache metadata: dm_array_cursor_next for mapping failed\n------------[ cut here ]------------\nkernel BUG at drivers/md/dm-bufio.c:638!\n\nFix by setting the cached block pointer to NULL on errors.\n\nIn addition to the reproducer described above, this fix can be\nverified using the \"array_cursor/damaged\" test in dm-unit:\n  dm-unit run /pdata/array_cursor/damaged --kernel-dir <KERNEL_DIR>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57929",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-38635",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoundwire: cadence: fix invalid PDI offset\n\nFor some reason, we add an offset to the PDI, presumably to skip the\nPDI0 and PDI1 which are reserved for BPT.\n\nThis code is however completely wrong and leads to an out-of-bounds\naccess. We were just lucky so far since we used only a couple of PDIs\nand remained within the PDI array bounds.\n\nA Fixes: tag is not provided since there are no known platforms where\nthe out-of-bounds would be accessed, and the initial code had problems\nas well.\n\nA follow-up patch completely removes this useless offset.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38635",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-21",
                    "modification_date": "2025-09-17",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49928",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: avoid reading out of bounds when loading TX power FW elements\n\nBecause the loop-expression will do one more time before getting false from\ncond-expression, the original code copied one more entry size beyond valid\nregion.\n\nFix it by moving the entry copy to loop-body.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49928",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53099",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Check validity of link->type in bpf_link_show_fdinfo()\n\nIf a newly-added link type doesn't invoke BPF_LINK_TYPE(), accessing\nbpf_link_type_strs[link->type] may result in an out-of-bounds access.\n\nTo spot such missed invocations early in the future, checking the\nvalidity of link->type in bpf_link_show_fdinfo() and emitting a warning\nwhen such invocations are missed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53099",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-25",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-52332",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Fix potential invalid memory access in igb_init_module()\n\nThe pci_register_driver() can fail and when this happened, the dca_notifier\nneeds to be unregistered, otherwise the dca_notifier can be called when\nigb fails to install, resulting to invalid memory access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-52332",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57982",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: state: fix out-of-bounds read during lookup\n\nlookup and resize can run in parallel.\n\nThe xfrm_state_hash_generation seqlock ensures a retry, but the hash\nfunctions can observe a hmask value that is too large for the new hlist\narray.\n\nrehash does:\n  rcu_assign_pointer(net->xfrm.state_bydst, ndst) [..]\n  net->xfrm.state_hmask = nhashmask;\n\nWhile state lookup does:\n  h = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family);\n  hlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) {\n\nThis is only safe in case the update to state_bydst is larger than\nnet->xfrm.xfrm_state_hmask (or if the lookup function gets\nserialized via state spinlock again).\n\nFix this by prefetching state_hmask and the associated pointers.\nThe xfrm_state_hash_generation seqlock retry will ensure that the pointer\nand the hmask will be consistent.\n\nThe existing helpers, like xfrm_dst_hash(), are now unsafe for RCU side,\nadd lockdep assertions to document that they are only safe for insert\nside.\n\nxfrm_state_lookup_byaddr() uses the spinlock rather than RCU.\nAFAICS this is an oversight from back when state lookup was converted to\nRCU, this lock should be replaced with RCU in a future patch.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57982",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38502",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix oob access in cgroup local storage\n\nLonial reported that an out-of-bounds access in cgroup local storage\ncan be crafted via tail calls. Given two programs each utilizing a\ncgroup local storage with a different value size, and one program\ndoing a tail call into the other. The verifier will validate each of\nthe indivial programs just fine. However, in the runtime context\nthe bpf_cg_run_ctx holds an bpf_prog_array_item which contains the\nBPF program as well as any cgroup local storage flavor the program\nuses. Helpers such as bpf_get_local_storage() pick this up from the\nruntime context:\n\n  ctx = container_of(current->bpf_ctx, struct bpf_cg_run_ctx, run_ctx);\n  storage = ctx->prog_item->cgroup_storage[stype];\n\n  if (stype == BPF_CGROUP_STORAGE_SHARED)\n    ptr = &READ_ONCE(storage->buf)->data[0];\n  else\n    ptr = this_cpu_ptr(storage->percpu_buf);\n\nFor the second program which was called from the originally attached\none, this means bpf_get_local_storage() will pick up the former\nprogram's map, not its own. With mismatching sizes, this can result\nin an unintended out-of-bounds access.\n\nTo fix this issue, we need to extend bpf_map_owner with an array of\nstorage_cookie[] to match on i) the exact maps from the original\nprogram if the second program was using bpf_get_local_storage(), or\nii) allow the tail call combination if the second program was not\nusing any of the cgroup local storage maps.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38502",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-16",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-47449",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix locking for Tx timestamp tracking flush\n\nCommit 4dd0d5c33c3e (\"ice: add lock around Tx timestamp tracker flush\")\nadded a lock around the Tx timestamp tracker flow which is used to\ncleanup any left over SKBs and prepare for device removal.\n\nThis lock is problematic because it is being held around a call to\nice_clear_phy_tstamp. The clear function takes a mutex to send a PHY\nwrite command to firmware. This could lead to a deadlock if the mutex\nactually sleeps, and causes the following warning on a kernel with\npreemption debugging enabled:\n\n[  715.419426] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:573\n[  715.427900] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 3100, name: rmmod\n[  715.435652] INFO: lockdep is turned off.\n[  715.439591] Preemption disabled at:\n[  715.439594] [<0000000000000000>] 0x0\n[  715.446678] CPU: 52 PID: 3100 Comm: rmmod Tainted: G        W  OE     5.15.0-rc4+ #42 bdd7ec3018e725f159ca0d372ce8c2c0e784891c\n[  715.458058] Hardware name: Intel Corporation S2600STQ/S2600STQ, BIOS SE5C620.86B.02.01.0010.010620200716 01/06/2020\n[  715.468483] Call Trace:\n[  715.470940]  dump_stack_lvl+0x6a/0x9a\n[  715.474613]  ___might_sleep.cold+0x224/0x26a\n[  715.478895]  __mutex_lock+0xb3/0x1440\n[  715.482569]  ? stack_depot_save+0x378/0x500\n[  715.486763]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.494979]  ? kfree+0xc1/0x520\n[  715.498128]  ? mutex_lock_io_nested+0x12a0/0x12a0\n[  715.502837]  ? kasan_set_free_info+0x20/0x30\n[  715.507110]  ? __kasan_slab_free+0x10b/0x140\n[  715.511385]  ? slab_free_freelist_hook+0xc7/0x220\n[  715.516092]  ? kfree+0xc1/0x520\n[  715.519235]  ? ice_deinit_lag+0x16c/0x220 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.527359]  ? ice_remove+0x1cf/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.535133]  ? pci_device_remove+0xab/0x1d0\n[  715.539318]  ? __device_release_driver+0x35b/0x690\n[  715.544110]  ? driver_detach+0x214/0x2f0\n[  715.548035]  ? bus_remove_driver+0x11d/0x2f0\n[  715.552309]  ? pci_unregister_driver+0x26/0x250\n[  715.556840]  ? ice_module_exit+0xc/0x2f [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.564799]  ? __do_sys_delete_module.constprop.0+0x2d8/0x4e0\n[  715.570554]  ? do_syscall_64+0x3b/0x90\n[  715.574303]  ? entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  715.579529]  ? start_flush_work+0x542/0x8f0\n[  715.583719]  ? ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.591923]  ice_sq_send_cmd+0x78/0x14c0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.599960]  ? wait_for_completion_io+0x250/0x250\n[  715.604662]  ? lock_acquire+0x196/0x200\n[  715.608504]  ? do_raw_spin_trylock+0xa5/0x160\n[  715.612864]  ice_sbq_rw_reg+0x1e6/0x2f0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.620813]  ? ice_reset+0x130/0x130 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.628497]  ? __debug_check_no_obj_freed+0x1e8/0x3c0\n[  715.633550]  ? trace_hardirqs_on+0x1c/0x130\n[  715.637748]  ice_write_phy_reg_e810+0x70/0xf0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.646220]  ? do_raw_spin_trylock+0xa5/0x160\n[  715.650581]  ? ice_ptp_release+0x910/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.658797]  ? ice_ptp_release+0x255/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.667013]  ice_clear_phy_tstamp+0x2c/0x110 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.675403]  ice_ptp_release+0x408/0x910 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.683440]  ice_remove+0x560/0x6a0 [ice 9a7e1ec00971c89ecd3fe0d4dc7da2b3786a421d]\n[  715.691037]  ? _raw_spin_unlock_irqrestore+0x46/0x73\n[  715.696005]  pci_device_remove+0xab/0x1d0\n[  715.700018]  __device_release_driver+0x35b/0x690\n[  715.704637]  driver_detach+0x214/0x2f0\n[  715.708389]  bus_remove_driver+0x11d/0x2f0\n[  715.712489]  pci_unregister_driver+0x26/0x250\n[  71\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47449",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47191",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: scsi_debug: Fix out-of-bound read in resp_readcap16()\n\nThe following warning was observed running syzkaller:\n\n[ 3813.830724] sg_write: data in/out 65466/242 bytes for SCSI command 0x9e-- guessing data in;\n[ 3813.830724]    program syz-executor not setting count and/or reply_len properly\n[ 3813.836956] ==================================================================\n[ 3813.839465] BUG: KASAN: stack-out-of-bounds in sg_copy_buffer+0x157/0x1e0\n[ 3813.841773] Read of size 4096 at addr ffff8883cf80f540 by task syz-executor/1549\n[ 3813.846612] Call Trace:\n[ 3813.846995]  dump_stack+0x108/0x15f\n[ 3813.847524]  print_address_description+0xa5/0x372\n[ 3813.848243]  kasan_report.cold+0x236/0x2a8\n[ 3813.849439]  check_memory_region+0x240/0x270\n[ 3813.850094]  memcpy+0x30/0x80\n[ 3813.850553]  sg_copy_buffer+0x157/0x1e0\n[ 3813.853032]  sg_copy_from_buffer+0x13/0x20\n[ 3813.853660]  fill_from_dev_buffer+0x135/0x370\n[ 3813.854329]  resp_readcap16+0x1ac/0x280\n[ 3813.856917]  schedule_resp+0x41f/0x1630\n[ 3813.858203]  scsi_debug_queuecommand+0xb32/0x17e0\n[ 3813.862699]  scsi_dispatch_cmd+0x330/0x950\n[ 3813.863329]  scsi_request_fn+0xd8e/0x1710\n[ 3813.863946]  __blk_run_queue+0x10b/0x230\n[ 3813.864544]  blk_execute_rq_nowait+0x1d8/0x400\n[ 3813.865220]  sg_common_write.isra.0+0xe61/0x2420\n[ 3813.871637]  sg_write+0x6c8/0xef0\n[ 3813.878853]  __vfs_write+0xe4/0x800\n[ 3813.883487]  vfs_write+0x17b/0x530\n[ 3813.884008]  ksys_write+0x103/0x270\n[ 3813.886268]  __x64_sys_write+0x77/0xc0\n[ 3813.886841]  do_syscall_64+0x106/0x360\n[ 3813.887415]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThis issue can be reproduced with the following syzkaller log:\n\nr0 = openat(0xffffffffffffff9c, &(0x7f0000000040)='./file0\\x00', 0x26e1, 0x0)\nr1 = syz_open_procfs(0xffffffffffffffff, &(0x7f0000000000)='fd/3\\x00')\nopen_by_handle_at(r1, &(0x7f00000003c0)=ANY=[@ANYRESHEX], 0x602000)\nr2 = syz_open_dev$sg(&(0x7f0000000000), 0x0, 0x40782)\nwrite$binfmt_aout(r2, &(0x7f0000000340)=ANY=[@ANYBLOB=\"00000000deff000000000000000000000000000000000000000000000000000047f007af9e107a41ec395f1bded7be24277a1501ff6196a83366f4e6362bc0ff2b247f68a972989b094b2da4fb3607fcf611a22dd04310d28c75039d\"], 0x126)\n\nIn resp_readcap16() we get \"int alloc_len\" value -1104926854, and then pass\nthe huge arr_len to fill_from_dev_buffer(), but arr is only 32 bytes. This\nleads to OOB in sg_copy_buffer().\n\nTo solve this issue, define alloc_len as u32.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47191",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-10",
                    "modification_date": "2025-01-14",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-48714",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Use VM_MAP instead of VM_ALLOC for ringbuf\n\nAfter commit 2fd3fb0be1d1 (\"kasan, vmalloc: unpoison VM_ALLOC pages\nafter mapping\"), non-VM_ALLOC mappings will be marked as accessible\nin __get_vm_area_node() when KASAN is enabled. But now the flag for\nringbuf area is VM_ALLOC, so KASAN will complain out-of-bound access\nafter vmap() returns. Because the ringbuf area is created by mapping\nallocated pages, so use VM_MAP instead.\n\nAfter the change, info in /proc/vmallocinfo also changes from\n  [start]-[end]   24576 ringbuf_map_alloc+0x171/0x290 vmalloc user\nto\n  [start]-[end]   24576 ringbuf_map_alloc+0x171/0x290 vmap user",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48714",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2025-09-17",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-50115",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: nSVM: Ignore nCR3[4:0] when loading PDPTEs from memory\n\nIgnore nCR3[4:0] when loading PDPTEs from memory for nested SVM, as bits\n4:0 of CR3 are ignored when PAE paging is used, and thus VMRUN doesn't\nenforce 32-byte alignment of nCR3.\n\nIn the absolute worst case scenario, failure to ignore bits 4:0 can result\nin an out-of-bounds read, e.g. if the target page is at the end of a\nmemslot, and the VMM isn't using guard pages.\n\nPer the APM:\n\n  The CR3 register points to the base address of the page-directory-pointer\n  table. The page-directory-pointer table is aligned on a 32-byte boundary,\n  with the low 5 address bits 4:0 assumed to be 0.\n\nAnd the SDM's much more explicit:\n\n  4:0    Ignored\n\nNote, KVM gets this right when loading PDPTRs, it's only the nSVM flow\nthat is broken.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50115",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-05",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-4460",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: Fix UBSAN shift-out-of-bounds warning\n\nIf get_num_sdma_queues or get_num_xgmi_sdma_queues is 0, we end up\ndoing a shift operation where the number of bits shifted equals\nnumber of bits in the operand. This behaviour is undefined.\n\nSet num_sdma_queues or num_xgmi_sdma_queues to ULLONG_MAX, if the\ncount is >= number of bits in the operand.\n\nBug: https://gitlab.freedesktop.org/drm/amd/-/issues/1472",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4460",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-12-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37785",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix OOB read when checking dotdot dir\n\nMounting a corrupted filesystem with directory which contains '.' dir\nentry with rec_len == block size results in out-of-bounds read (later\non, when the corrupted directory is removed).\n\next4_empty_dir() assumes every ext4 directory contains at least '.'\nand '..' as directory entries in the first data block. It first loads\nthe '.' dir entry, performs sanity checks by calling ext4_check_dir_entry()\nand then uses its rec_len member to compute the location of '..' dir\nentry (in ext4_next_entry). It assumes the '..' dir entry fits into the\nsame data block.\n\nIf the rec_len of '.' is precisely one block (4KB), it slips through the\nsanity checks (it is considered the last directory entry in the data\nblock) and leaves \"struct ext4_dir_entry_2 *de\" point exactly past the\nmemory slot allocated to the data block. The following call to\next4_check_dir_entry() on new value of de then dereferences this pointer\nwhich results in out-of-bounds mem access.\n\nFix this by extending __ext4_check_dir_entry() to check for '.' dir\nentries that reach the end of data block. Make sure to ignore the phony\ndir entries for checksum (by checking name_len for non-zero).\n\nNote: This is reported by KASAN as use-after-free in case another\nstructure was recently freed from the slot past the bound, but it is\nreally an OOB read.\n\nThis issue was found by syzkaller tool.\n\nCall Trace:\n[   38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710\n[   38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375\n[   38.595158]\n[   38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1\n[   38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[   38.595304] Call Trace:\n[   38.595308]  <TASK>\n[   38.595311]  dump_stack_lvl+0xa7/0xd0\n[   38.595325]  print_address_description.constprop.0+0x2c/0x3f0\n[   38.595339]  ? __ext4_check_dir_entry+0x67e/0x710\n[   38.595349]  print_report+0xaa/0x250\n[   38.595359]  ? __ext4_check_dir_entry+0x67e/0x710\n[   38.595368]  ? kasan_addr_to_slab+0x9/0x90\n[   38.595378]  kasan_report+0xab/0xe0\n[   38.595389]  ? __ext4_check_dir_entry+0x67e/0x710\n[   38.595400]  __ext4_check_dir_entry+0x67e/0x710\n[   38.595410]  ext4_empty_dir+0x465/0x990\n[   38.595421]  ? __pfx_ext4_empty_dir+0x10/0x10\n[   38.595432]  ext4_rmdir.part.0+0x29a/0xd10\n[   38.595441]  ? __dquot_initialize+0x2a7/0xbf0\n[   38.595455]  ? __pfx_ext4_rmdir.part.0+0x10/0x10\n[   38.595464]  ? __pfx___dquot_initialize+0x10/0x10\n[   38.595478]  ? down_write+0xdb/0x140\n[   38.595487]  ? __pfx_down_write+0x10/0x10\n[   38.595497]  ext4_rmdir+0xee/0x140\n[   38.595506]  vfs_rmdir+0x209/0x670\n[   38.595517]  ? lookup_one_qstr_excl+0x3b/0x190\n[   38.595529]  do_rmdir+0x363/0x3c0\n[   38.595537]  ? __pfx_do_rmdir+0x10/0x10\n[   38.595544]  ? strncpy_from_user+0x1ff/0x2e0\n[   38.595561]  __x64_sys_unlinkat+0xf0/0x130\n[   38.595570]  do_syscall_64+0x5b/0x180\n[   38.595583]  entry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37785",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47094",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/mmu: Don't advance iterator after restart due to yielding\n\nAfter dropping mmu_lock in the TDP MMU, restart the iterator during\ntdp_iter_next() and do not advance the iterator.  Advancing the iterator\nresults in skipping the top-level SPTE and all its children, which is\nfatal if any of the skipped SPTEs were not visited before yielding.\n\nWhen zapping all SPTEs, i.e. when min_level == root_level, restarting the\niter and then invoking tdp_iter_next() is always fatal if the current gfn\nhas as a valid SPTE, as advancing the iterator results in try_step_side()\nskipping the current gfn, which wasn't visited before yielding.\n\nSprinkle WARNs on iter->yielded being true in various helpers that are\noften used in conjunction with yielding, and tag the helper with\n__must_check to reduce the probabily of improper usage.\n\nFailing to zap a top-level SPTE manifests in one of two ways.  If a valid\nSPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(),\nthe shadow page will be leaked and KVM will WARN accordingly.\n\n  WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm]\n  RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_arch_destroy_vm+0x130/0x1b0 [kvm]\n   kvm_destroy_vm+0x162/0x2a0 [kvm]\n   kvm_vcpu_release+0x34/0x60 [kvm]\n   __fput+0x82/0x240\n   task_work_run+0x5c/0x90\n   do_exit+0x364/0xa10\n   ? futex_unqueue+0x38/0x60\n   do_group_exit+0x33/0xa0\n   get_signal+0x155/0x850\n   arch_do_signal_or_restart+0xed/0x750\n   exit_to_user_mode_prepare+0xc5/0x120\n   syscall_exit_to_user_mode+0x1d/0x40\n   do_syscall_64+0x48/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nIf kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped by\nkvm_tdp_mmu_put_root(), KVM triggers a use-after-free in the form of\nmarking a struct page as dirty/accessed after it has been put back on the\nfree list.  This directly triggers a WARN due to encountering a page with\npage_count() == 0, but it can also lead to data corruption and additional\nerrors in the kernel.\n\n  WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171\n  RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_set_pfn_dirty+0x120/0x1d0 [kvm]\n   __handle_changed_spte+0x92e/0xca0 [kvm]\n   __handle_changed_spte+0x63c/0xca0 [kvm]\n   __handle_changed_spte+0x63c/0xca0 [kvm]\n   __handle_changed_spte+0x63c/0xca0 [kvm]\n   zap_gfn_range+0x549/0x620 [kvm]\n   kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm]\n   mmu_free_root_page+0x219/0x2c0 [kvm]\n   kvm_mmu_free_roots+0x1b4/0x4e0 [kvm]\n   kvm_mmu_unload+0x1c/0xa0 [kvm]\n   kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm]\n   kvm_put_kvm+0x3b1/0x8b0 [kvm]\n   kvm_vcpu_release+0x4e/0x70 [kvm]\n   __fput+0x1f7/0x8c0\n   task_work_run+0xf8/0x1a0\n   do_exit+0x97b/0x2230\n   do_group_exit+0xda/0x2a0\n   get_signal+0x3be/0x1e50\n   arch_do_signal_or_restart+0x244/0x17f0\n   exit_to_user_mode_prepare+0xcb/0x120\n   syscall_exit_to_user_mode+0x1d/0x40\n   do_syscall_64+0x4d/0x90\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nNote, the underlying bug existed even before commit 1af4a96025b3 (\"KVM:\nx86/mmu: Yield in TDU MMU iter even if no SPTES changed\") moved calls to\ntdp_mmu_iter_cond_resched() to the beginning of loops, as KVM could still\nincorrectly advance past a top-level entry when yielding on a lower-level\nentry.  But with respect to leaking shadow pages, the bug was introduced\nby yielding before processing the current gfn.\n\nAlternatively, tdp_mmu_iter_cond_resched() could simply fall through, or\ncallers could jump to their \"retry\" label.  The downside of that approach\nis that tdp_mmu_iter_cond_resched() _must_ be called before anything else\nin the loop, and there's no easy way to enfornce that requirement.\n\nIdeally, KVM would handling the cond_resched() fully within the iterator\nmacro (the code is actually quite clean) and avoid this entire class of\nbugs, but that is extremely difficult do wh\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47094",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-04",
                    "modification_date": "2025-04-08",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21719",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipmr: do not call mr_mfc_uses_dev() for unres entries\n\nsyzbot found that calling mr_mfc_uses_dev() for unres entries\nwould crash [1], because c->mfc_un.res.minvif / c->mfc_un.res.maxvif\nalias to \"struct sk_buff_head unresolved\", which contain two pointers.\n\nThis code never worked, lets remove it.\n\n[1]\nUnable to handle kernel paging request at virtual address ffff5fff2d536613\nKASAN: maybe wild-memory-access in range [0xfffefff96a9b3098-0xfffefff96a9b309f]\nModules linked in:\nCPU: 1 UID: 0 PID: 7321 Comm: syz.0.16 Not tainted 6.13.0-rc7-syzkaller-g1950a0af2d55 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline]\n pc : mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334\n lr : mr_mfc_uses_dev net/ipv4/ipmr_base.c:289 [inline]\n lr : mr_table_dump+0x694/0x8b0 net/ipv4/ipmr_base.c:334\nCall trace:\n  mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline] (P)\n  mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334 (P)\n  mr_rtm_dumproute+0x254/0x454 net/ipv4/ipmr_base.c:382\n  ipmr_rtm_dumproute+0x248/0x4b4 net/ipv4/ipmr.c:2648\n  rtnl_dump_all+0x2e4/0x4e8 net/core/rtnetlink.c:4327\n  rtnl_dumpit+0x98/0x1d0 net/core/rtnetlink.c:6791\n  netlink_dump+0x4f0/0xbc0 net/netlink/af_netlink.c:2317\n  netlink_recvmsg+0x56c/0xe64 net/netlink/af_netlink.c:1973\n  sock_recvmsg_nosec net/socket.c:1033 [inline]\n  sock_recvmsg net/socket.c:1055 [inline]\n  sock_read_iter+0x2d8/0x40c net/socket.c:1125\n  new_sync_read fs/read_write.c:484 [inline]\n  vfs_read+0x740/0x970 fs/read_write.c:565\n  ksys_read+0x15c/0x26c fs/read_write.c:708",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21719",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-58014",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmsmac: add gain range check to wlc_phy_iqcal_gainparams_nphy()\n\nIn 'wlc_phy_iqcal_gainparams_nphy()', add gain range check to WARN()\ninstead of possible out-of-bounds 'tbl_iqcal_gainparams_nphy' access.\nCompile tested only.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-58014",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53117",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: prevent out-of-bounds array speculation when closing a file descriptor\n\nGoogle-Bug-Id: 114199369",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53117",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-02",
                    "modification_date": "2025-11-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48827",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix the behavior of READ near OFFSET_MAX\n\nDan Aloni reports:\n> Due to commit 8cfb9015280d (\"NFS: Always provide aligned buffers to\n> the RPC read layers\") on the client, a read of 0xfff is aligned up\n> to server rsize of 0x1000.\n>\n> As a result, in a test where the server has a file of size\n> 0x7fffffffffffffff, and the client tries to read from the offset\n> 0x7ffffffffffff000, the read causes loff_t overflow in the server\n> and it returns an NFS code of EINVAL to the client. The client as\n> a result indefinitely retries the request.\n\nThe Linux NFS client does not handle NFS?ERR_INVAL, even though all\nNFS specifications permit servers to return that status code for a\nREAD.\n\nInstead of NFS?ERR_INVAL, have out-of-range READ requests succeed\nand return a short result. Set the EOF flag in the result to prevent\nthe client from retrying the READ request. This behavior appears to\nbe consistent with Solaris NFS servers.\n\nNote that NFSv3 and NFSv4 use u64 offset values on the wire. These\nmust be converted to loff_t internally before use -- an implicit\ntype cast is not adequate for this purpose. Otherwise VFS checks\nagainst sb->s_maxbytes do not work properly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48827",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-09-25",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38445",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid1: Fix stack memory use after return in raid1_reshape\n\nIn the raid1_reshape function, newpool is\nallocated on the stack and assigned to conf->r1bio_pool.\nThis results in conf->r1bio_pool.wait.head pointing\nto a stack address.\nAccessing this address later can lead to a kernel panic.\n\nExample access path:\n\nraid1_reshape()\n{\n\t// newpool is on the stack\n\tmempool_t newpool, oldpool;\n\t// initialize newpool.wait.head to stack address\n\tmempool_init(&newpool, ...);\n\tconf->r1bio_pool = newpool;\n}\n\nraid1_read_request() or raid1_write_request()\n{\n\talloc_r1bio()\n\t{\n\t\tmempool_alloc()\n\t\t{\n\t\t\t// if pool->alloc fails\n\t\t\tremove_element()\n\t\t\t{\n\t\t\t\t--pool->curr_nr;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmempool_free()\n{\n\tif (pool->curr_nr < pool->min_nr) {\n\t\t// pool->wait.head is a stack address\n\t\t// wake_up() will try to access this invalid address\n\t\t// which leads to a kernel panic\n\t\treturn;\n\t\twake_up(&pool->wait);\n\t}\n}\n\nFix:\nreinit conf->r1bio_pool.wait after assigning newpool.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38445",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47138",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxgb4: avoid accessing registers when clearing filters\n\nHardware register having the server TID base can contain\ninvalid values when adapter is in bad state (for example,\ndue to AER fatal error). Reading these invalid values in the\nregister can lead to out-of-bound memory access. So, fix\nby using the saved server TID base when clearing filters.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47138",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-25",
                    "modification_date": "2025-03-13",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-37749",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ppp: Add bound checking for skb data on ppp_sync_txmung\n\nEnsure we have enough data in linear buffer from skb before accessing\ninitial bytes. This prevents potential out-of-bounds accesses\nwhen processing short packets.\n\nWhen ppp_sync_txmung receives an incoming package with an empty\npayload:\n(remote) gef\u27a4  p *(struct pppoe_hdr *) (skb->head + skb->network_header)\n$18 = {\n\ttype = 0x1,\n\tver = 0x1,\n\tcode = 0x0,\n\tsid = 0x2,\n        length = 0x0,\n\ttag = 0xffff8880371cdb96\n}\n\nfrom the skb struct (trimmed)\n      tail = 0x16,\n      end = 0x140,\n      head = 0xffff88803346f400 \"4\",\n      data = 0xffff88803346f416 \":\\377\",\n      truesize = 0x380,\n      len = 0x0,\n      data_len = 0x0,\n      mac_len = 0xe,\n      hdr_len = 0x0,\n\nit is not safe to access data[2].\n\n[pabeni@redhat.com: fixed subj typo]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37749",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-04",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53321",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211_hwsim: drop short frames\n\nWhile technically some control frames like ACK are shorter and\nend after Address 1, such frames shouldn't be forwarded through\nwmediumd or similar userspace, so require the full 3-address\nheader to avoid accessing invalid memory if shorter frames are\npassed in.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53321",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-10",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47226",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/fpu: Invalidate FPU state after a failed XRSTOR from a user buffer\n\nBoth Intel and AMD consider it to be architecturally valid for XRSTOR to\nfail with #PF but nonetheless change the register state.  The actual\nconditions under which this might occur are unclear [1], but it seems\nplausible that this might be triggered if one sibling thread unmaps a page\nand invalidates the shared TLB while another sibling thread is executing\nXRSTOR on the page in question.\n\n__fpu__restore_sig() can execute XRSTOR while the hardware registers\nare preserved on behalf of a different victim task (using the\nfpu_fpregs_owner_ctx mechanism), and, in theory, XRSTOR could fail but\nmodify the registers.\n\nIf this happens, then there is a window in which __fpu__restore_sig()\ncould schedule out and the victim task could schedule back in without\nreloading its own FPU registers. This would result in part of the FPU\nstate that __fpu__restore_sig() was attempting to load leaking into the\nvictim task's user-visible state.\n\nInvalidate preserved FPU registers on XRSTOR failure to prevent this\nsituation from corrupting any state.\n\n[1] Frequent readers of the errata lists might imagine \"complex\n    microarchitectural conditions\".",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47226",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-29",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-46723",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: fix ucode out-of-bounds read warning\n\nClear warning that read ucode[] may out-of-bounds.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46723",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-09-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-22104",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: Use kernel helpers for hex dumps\n\nPreviously, when the driver was printing hex dumps, the buffer was cast\nto an 8 byte long and printed using string formatters. If the buffer\nsize was not a multiple of 8 then a read buffer overflow was possible.\n\nTherefore, create a new ibmvnic function that loops over a buffer and\ncalls hex_dump_to_buffer instead.\n\nThis patch address KASAN reports like the one below:\n  ibmvnic 30000003 env3: Login Buffer:\n  ibmvnic 30000003 env3: 01000000af000000\n  <...>\n  ibmvnic 30000003 env3: 2e6d62692e736261\n  ibmvnic 30000003 env3: 65050003006d6f63\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in ibmvnic_login+0xacc/0xffc [ibmvnic]\n  Read of size 8 at addr c0000001331a9aa8 by task ip/17681\n  <...>\n  Allocated by task 17681:\n  <...>\n  ibmvnic_login+0x2f0/0xffc [ibmvnic]\n  ibmvnic_open+0x148/0x308 [ibmvnic]\n  __dev_open+0x1ac/0x304\n  <...>\n  The buggy address is located 168 bytes inside of\n                allocated 175-byte region [c0000001331a9a00, c0000001331a9aaf)\n  <...>\n  =================================================================\n  ibmvnic 30000003 env3: 000000000033766e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-22104",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-16",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50394",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: ismt: Fix an out-of-bounds bug in ismt_access()\n\nWhen the driver does not check the data from the user, the variable\n'data->block[0]' may be very large to cause an out-of-bounds bug.\n\nThe following log can reveal it:\n\n[   33.995542] i2c i2c-1: ioctl, cmd=0x720, arg=0x7ffcb3dc3a20\n[   33.995978] ismt_smbus 0000:00:05.0: I2C_SMBUS_BLOCK_DATA:  WRITE\n[   33.996475] ==================================================================\n[   33.996995] BUG: KASAN: out-of-bounds in ismt_access.cold+0x374/0x214b\n[   33.997473] Read of size 18446744073709551615 at addr ffff88810efcfdb1 by task ismt_poc/485\n[   33.999450] Call Trace:\n[   34.001849]  memcpy+0x20/0x60\n[   34.002077]  ismt_access.cold+0x374/0x214b\n[   34.003382]  __i2c_smbus_xfer+0x44f/0xfb0\n[   34.004007]  i2c_smbus_xfer+0x10a/0x390\n[   34.004291]  i2cdev_ioctl_smbus+0x2c8/0x710\n[   34.005196]  i2cdev_ioctl+0x5ec/0x74c\n\nFix this bug by checking the size of 'data->block[0]' first.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50394",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-18",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49623",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/xive/spapr: correct bitmap allocation size\n\nkasan detects access beyond the end of the xibm->bitmap allocation:\n\nBUG: KASAN: slab-out-of-bounds in _find_first_zero_bit+0x40/0x140\nRead of size 8 at addr c00000001d1d0118 by task swapper/0/1\n\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-rc2-00001-g90df023b36dd #28\nCall Trace:\n[c00000001d98f770] [c0000000012baab8] dump_stack_lvl+0xac/0x108 (unreliable)\n[c00000001d98f7b0] [c00000000068faac] print_report+0x37c/0x710\n[c00000001d98f880] [c0000000006902c0] kasan_report+0x110/0x354\n[c00000001d98f950] [c000000000692324] __asan_load8+0xa4/0xe0\n[c00000001d98f970] [c0000000011c6ed0] _find_first_zero_bit+0x40/0x140\n[c00000001d98f9b0] [c0000000000dbfbc] xive_spapr_get_ipi+0xcc/0x260\n[c00000001d98fa70] [c0000000000d6d28] xive_setup_cpu_ipi+0x1e8/0x450\n[c00000001d98fb30] [c000000004032a20] pSeries_smp_probe+0x5c/0x118\n[c00000001d98fb60] [c000000004018b44] smp_prepare_cpus+0x944/0x9ac\n[c00000001d98fc90] [c000000004009f9c] kernel_init_freeable+0x2d4/0x640\n[c00000001d98fd90] [c0000000000131e8] kernel_init+0x28/0x1d0\n[c00000001d98fe10] [c00000000000cd54] ret_from_kernel_thread+0x5c/0x64\n\nAllocated by task 0:\n kasan_save_stack+0x34/0x70\n __kasan_kmalloc+0xb4/0xf0\n __kmalloc+0x268/0x540\n xive_spapr_init+0x4d0/0x77c\n pseries_init_irq+0x40/0x27c\n init_IRQ+0x44/0x84\n start_kernel+0x2a4/0x538\n start_here_common+0x1c/0x20\n\nThe buggy address belongs to the object at c00000001d1d0118\n which belongs to the cache kmalloc-8 of size 8\nThe buggy address is located 0 bytes inside of\n 8-byte region [c00000001d1d0118, c00000001d1d0120)\n\nThe buggy address belongs to the physical page:\npage:c00c000000074740 refcount:1 mapcount:0 mapping:0000000000000000 index:0xc00000001d1d0558 pfn:0x1d1d\nflags: 0x7ffff000000200(slab|node=0|zone=0|lastcpupid=0x7ffff)\nraw: 007ffff000000200 c00000001d0003c8 c00000001d0003c8 c00000001d010480\nraw: c00000001d1d0558 0000000001e1000a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n c00000001d1d0000: fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n c00000001d1d0080: fc fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc\n>c00000001d1d0100: fc fc fc 02 fc fc fc fc fc fc fc fc fc fc fc fc\n                            ^\n c00000001d1d0180: fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc fc\n c00000001d1d0200: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc\n\nThis happens because the allocation uses the wrong unit (bits) when it\nshould pass (BITS_TO_LONGS(count) * sizeof(long)) or equivalent. With small\nnumbers of bits, the allocated object can be smaller than sizeof(long),\nwhich results in invalid accesses.\n\nUse bitmap_zalloc() to allocate and initialize the irq bitmap, paired with\nbitmap_free() for consistency.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49623",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-21993",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic()\n\nWhen performing an iSCSI boot using IPv6, iscsistart still reads the\n/sys/firmware/ibft/ethernetX/subnet-mask entry. Since the IPv6 prefix\nlength is 64, this causes the shift exponent to become negative,\ntriggering a UBSAN warning. As the concept of a subnet mask does not\napply to IPv6, the value is set to ~0 to suppress the warning message.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21993",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-02",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53272",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ena: fix shift-out-of-bounds in exponential backoff\n\nThe ENA adapters on our instances occasionally reset.  Once recently\nlogged a UBSAN failure to console in the process:\n\n  UBSAN: shift-out-of-bounds in build/linux/drivers/net/ethernet/amazon/ena/ena_com.c:540:13\n  shift exponent 32 is too large for 32-bit type 'unsigned int'\n  CPU: 28 PID: 70012 Comm: kworker/u72:2 Kdump: loaded not tainted 5.15.117\n  Hardware name: Amazon EC2 c5d.9xlarge/, BIOS 1.0 10/16/2017\n  Workqueue: ena ena_fw_reset_device [ena]\n  Call Trace:\n  <TASK>\n  dump_stack_lvl+0x4a/0x63\n  dump_stack+0x10/0x16\n  ubsan_epilogue+0x9/0x36\n  __ubsan_handle_shift_out_of_bounds.cold+0x61/0x10e\n  ? __const_udelay+0x43/0x50\n  ena_delay_exponential_backoff_us.cold+0x16/0x1e [ena]\n  wait_for_reset_state+0x54/0xa0 [ena]\n  ena_com_dev_reset+0xc8/0x110 [ena]\n  ena_down+0x3fe/0x480 [ena]\n  ena_destroy_device+0xeb/0xf0 [ena]\n  ena_fw_reset_device+0x30/0x50 [ena]\n  process_one_work+0x22b/0x3d0\n  worker_thread+0x4d/0x3f0\n  ? process_one_work+0x3d0/0x3d0\n  kthread+0x12a/0x150\n  ? set_kthread_struct+0x50/0x50\n  ret_from_fork+0x22/0x30\n  </TASK>\n\nApparently, the reset delays are getting so large they can trigger a\nUBSAN panic.\n\nLooking at the code, the current timeout is capped at 5000us.  Using a\nbase value of 100us, the current code will overflow after (1<<29).  Even\nat values before 32, this function wraps around, perhaps\nunintentionally.\n\nCap the value of the exponent used for this backoff at (1<<16) which is\nlarger than currently necessary, but large enough to support bigger\nvalues in the future.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53272",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-12-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50103",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched, cpuset: Fix dl_cpu_busy() panic due to empty cs->cpus_allowed\n\nWith cgroup v2, the cpuset's cpus_allowed mask can be empty indicating\nthat the cpuset will just use the effective CPUs of its parent. So\ncpuset_can_attach() can call task_can_attach() with an empty mask.\nThis can lead to cpumask_any_and() returns nr_cpu_ids causing the call\nto dl_bw_of() to crash due to percpu value access of an out of bound\nCPU value. For example:\n\n\t[80468.182258] BUG: unable to handle page fault for address: ffffffff8b6648b0\n\t  :\n\t[80468.191019] RIP: 0010:dl_cpu_busy+0x30/0x2b0\n\t  :\n\t[80468.207946] Call Trace:\n\t[80468.208947]  cpuset_can_attach+0xa0/0x140\n\t[80468.209953]  cgroup_migrate_execute+0x8c/0x490\n\t[80468.210931]  cgroup_update_dfl_csses+0x254/0x270\n\t[80468.211898]  cgroup_subtree_control_write+0x322/0x400\n\t[80468.212854]  kernfs_fop_write_iter+0x11c/0x1b0\n\t[80468.213777]  new_sync_write+0x11f/0x1b0\n\t[80468.214689]  vfs_write+0x1eb/0x280\n\t[80468.215592]  ksys_write+0x5f/0xe0\n\t[80468.216463]  do_syscall_64+0x5c/0x80\n\t[80468.224287]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nFix that by using effective_cpus instead. For cgroup v1, effective_cpus\nis the same as cpus_allowed. For v2, effective_cpus is the real cpumask\nto be used by tasks within the cpuset anyway.\n\nAlso update task_can_attach()'s 2nd argument name to cs_effective_cpus to\nreflect the change. In addition, a check is added to task_can_attach()\nto guard against the possibility that cpumask_any_and() may return a\nvalue >= nr_cpu_ids.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50103",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-19",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52519",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: intel-ish-hid: ipc: Disable and reenable ACPI GPE bit\n\nThe EHL (Elkhart Lake) based platforms provide a OOB (Out of band)\nservice, which allows to wakup device when the system is in S5 (Soft-Off\nstate). This OOB service can be enabled/disabled from BIOS settings. When\nenabled, the ISH device gets PME wake capability. To enable PME wakeup,\ndriver also needs to enable ACPI GPE bit.\n\nOn resume, BIOS will clear the wakeup bit. So driver need to re-enable it\nin resume function to keep the next wakeup capability. But this BIOS\nclearing of wakeup bit doesn't decrement internal OS GPE reference count,\nso this reenabling on every resume will cause reference count to overflow.\n\nSo first disable and reenable ACPI GPE bit using acpi_disable_gpe().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52519",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-02",
                    "modification_date": "2025-01-13",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-50279",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: fix out-of-bounds access to the dirty bitset when resizing\n\ndm-cache checks the dirty bits of the cache blocks to be dropped when\nshrinking the fast device, but an index bug in bitset iteration causes\nout-of-bounds access.\n\nReproduce steps:\n\n1. create a cache device of 1024 cache blocks (128 bytes dirty bitset)\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 131072 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc 262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\n2. shrink the fast device to 512 cache blocks, triggering out-of-bounds\n   access to the dirty bitset (offset 0x80)\n\ndmsetup suspend cache\ndmsetup reload cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup resume cdata\ndmsetup resume cache\n\nKASAN reports:\n\n  BUG: KASAN: vmalloc-out-of-bounds in cache_preresume+0x269/0x7b0\n  Read of size 8 at addr ffffc900000f3080 by task dmsetup/131\n\n  (...snip...)\n  The buggy address belongs to the virtual mapping at\n   [ffffc900000f3000, ffffc900000f5000) created by:\n   cache_ctr+0x176a/0x35f0\n\n  (...snip...)\n  Memory state around the buggy address:\n   ffffc900000f2f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc900000f3000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  >ffffc900000f3080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n                     ^\n   ffffc900000f3100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n   ffffc900000f3180: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n\nFix by making the index post-incremented.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50279",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49518",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: SOF: ipc3-topology: Correct get_control_data for non bytes payload\n\nIt is possible to craft a topology where sof_get_control_data() would do\nout of bounds access because it expects that it is only called when the\npayload is bytes type.\nConfusingly it also handles other types of controls, but the payload\nparsing implementation is only valid for bytes.\n\nFix the code to count the non bytes controls and instead of storing a\npointer to sof_abi_hdr in sof_widget_data (which is only valid for bytes),\nstore the pointer to the data itself and add a new member to save the size\nof the data.\n\nIn case of non bytes controls we store the pointer to the chanv itself,\nwhich is just an array of values at the end.\n\nIn case of bytes control, drop the wrong cdata->data (wdata[i].pdata) check\nagainst NULL since it is incorrect and invalid in this context.\nThe data is pointing to the end of cdata struct, so it should never be\nnull.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49518",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-21",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40064",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmc: Fix use-after-free in __pnet_find_base_ndev().\n\nsyzbot reported use-after-free of net_device in __pnet_find_base_ndev(),\nwhich was called during connect(). [0]\n\nsmc_pnet_find_ism_resource() fetches sk_dst_get(sk)->dev and passes\ndown to pnet_find_base_ndev(), where RTNL is held.  Then, UAF happened\nat __pnet_find_base_ndev() when the dev is first used.\n\nThis means dev had already been freed before acquiring RTNL in\npnet_find_base_ndev().\n\nWhile dev is going away, dst->dev could be swapped with blackhole_netdev,\nand the dev's refcnt by dst will be released.\n\nWe must hold dev's refcnt before calling smc_pnet_find_ism_resource().\n\nAlso, smc_pnet_find_roce_resource() has the same problem.\n\nLet's use __sk_dst_get() and dst_dev_rcu() in the two functions.\n\n[0]:\nBUG: KASAN: use-after-free in __pnet_find_base_ndev+0x1b1/0x1c0 net/smc/smc_pnet.c:926\nRead of size 1 at addr ffff888036bac33a by task syz.0.3632/18609\n\nCPU: 1 UID: 0 PID: 18609 Comm: syz.0.3632 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x240 mm/kasan/report.c:482\n kasan_report+0x118/0x150 mm/kasan/report.c:595\n __pnet_find_base_ndev+0x1b1/0x1c0 net/smc/smc_pnet.c:926\n pnet_find_base_ndev net/smc/smc_pnet.c:946 [inline]\n smc_pnet_find_ism_by_pnetid net/smc/smc_pnet.c:1103 [inline]\n smc_pnet_find_ism_resource+0xef/0x390 net/smc/smc_pnet.c:1154\n smc_find_ism_device net/smc/af_smc.c:1030 [inline]\n smc_find_proposal_devices net/smc/af_smc.c:1115 [inline]\n __smc_connect+0x372/0x1890 net/smc/af_smc.c:1545\n smc_connect+0x877/0xd90 net/smc/af_smc.c:1715\n __sys_connect_file net/socket.c:2086 [inline]\n __sys_connect+0x313/0x440 net/socket.c:2105\n __do_sys_connect net/socket.c:2111 [inline]\n __se_sys_connect net/socket.c:2108 [inline]\n __x64_sys_connect+0x7a/0x90 net/socket.c:2108\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f47cbf8eba9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f47ccdb1038 EFLAGS: 00000246 ORIG_RAX: 000000000000002a\nRAX: ffffffffffffffda RBX: 00007f47cc1d5fa0 RCX: 00007f47cbf8eba9\nRDX: 0000000000000010 RSI: 0000200000000280 RDI: 000000000000000b\nRBP: 00007f47cc011e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007f47cc1d6038 R14: 00007f47cc1d5fa0 R15: 00007ffc512f8aa8\n </TASK>\n\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0xffff888036bacd00 pfn:0x36bac\nflags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000000000 ffffea0001243d08 ffff8880b863fdc0 0000000000000000\nraw: ffff888036bacd00 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as freed\npage last allocated via order 2, migratetype Unmovable, gfp_mask 0x446dc0(GFP_KERNEL_ACCOUNT|__GFP_ZERO|__GFP_NOWARN|__GFP_RETRY_MAYFAIL|__GFP_COMP), pid 16741, tgid 16741 (syz-executor), ts 343313197788, free_ts 380670750466\n set_page_owner include/linux/page_owner.h:32 [inline]\n post_alloc_hook+0x240/0x2a0 mm/page_alloc.c:1851\n prep_new_page mm/page_alloc.c:1859 [inline]\n get_page_from_freelist+0x21e4/0x22c0 mm/page_alloc.c:3858\n __alloc_frozen_pages_noprof+0x181/0x370 mm/page_alloc.c:5148\n alloc_pages_mpol+0x232/0x4a0 mm/mempolicy.c:2416\n ___kmalloc_large_node+0x5f/0x1b0 mm/slub.c:4317\n __kmalloc_large_node_noprof+0x18/0x90 mm/slub.c:4348\n __do_kmalloc_node mm/slub.c:4364 [inline]\n __kvmalloc_node\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47262",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Ensure liveliness of nested VM-Enter fail tracepoint message\n\nUse the __string() machinery provided by the tracing subystem to make a\ncopy of the string literals consumed by the \"nested VM-Enter failed\"\ntracepoint.  A complete copy is necessary to ensure that the tracepoint\ncan't outlive the data/memory it consumes and deference stale memory.\n\nBecause the tracepoint itself is defined by kvm, if kvm-intel and/or\nkvm-amd are built as modules, the memory holding the string literals\ndefined by the vendor modules will be freed when the module is unloaded,\nwhereas the tracepoint and its data in the ring buffer will live until\nkvm is unloaded (or \"indefinitely\" if kvm is built-in).\n\nThis bug has existed since the tracepoint was added, but was recently\nexposed by a new check in tracing to detect exactly this type of bug.\n\n  fmt: '%s%s\n  ' current_buffer: ' vmx_dirty_log_t-140127  [003] ....  kvm_nested_vmenter_failed: '\n  WARNING: CPU: 3 PID: 140134 at kernel/trace/trace.c:3759 trace_check_vprintf+0x3be/0x3e0\n  CPU: 3 PID: 140134 Comm: less Not tainted 5.13.0-rc1-ce2e73ce600a-req #184\n  Hardware name: ASUS Q87M-E/Q87M-E, BIOS 1102 03/03/2014\n  RIP: 0010:trace_check_vprintf+0x3be/0x3e0\n  Code: <0f> 0b 44 8b 4c 24 1c e9 a9 fe ff ff c6 44 02 ff 00 49 8b 97 b0 20\n  RSP: 0018:ffffa895cc37bcb0 EFLAGS: 00010282\n  RAX: 0000000000000000 RBX: ffffa895cc37bd08 RCX: 0000000000000027\n  RDX: 0000000000000027 RSI: 00000000ffffdfff RDI: ffff9766cfad74f8\n  RBP: ffffffffc0a041d4 R08: ffff9766cfad74f0 R09: ffffa895cc37bad8\n  R10: 0000000000000001 R11: 0000000000000001 R12: ffffffffc0a041d4\n  R13: ffffffffc0f4dba8 R14: 0000000000000000 R15: ffff976409f2c000\n  FS:  00007f92fa200740(0000) GS:ffff9766cfac0000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000559bd11b0000 CR3: 000000019fbaa002 CR4: 00000000001726e0\n  Call Trace:\n   trace_event_printf+0x5e/0x80\n   trace_raw_output_kvm_nested_vmenter_failed+0x3a/0x60 [kvm]\n   print_trace_line+0x1dd/0x4e0\n   s_show+0x45/0x150\n   seq_read_iter+0x2d5/0x4c0\n   seq_read+0x106/0x150\n   vfs_read+0x98/0x180\n   ksys_read+0x5f/0xe0\n   do_syscall_64+0x40/0xb0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47262",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-30",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-56663",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: nl80211: fix NL80211_ATTR_MLO_LINK_ID off-by-one\n\nSince the netlink attribute range validation provides inclusive\nchecking, the *max* of attribute NL80211_ATTR_MLO_LINK_ID should be\nIEEE80211_MLD_MAX_NUM_LINKS - 1 otherwise causing an off-by-one.\n\nOne crash stack for demonstration:\n==================================================================\nBUG: KASAN: wild-memory-access in ieee80211_tx_control_port+0x3b6/0xca0 net/mac80211/tx.c:5939\nRead of size 6 at addr 001102080000000c by task fuzzer.386/9508\n\nCPU: 1 PID: 9508 Comm: syz.1.386 Not tainted 6.1.70 #2\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x177/0x231 lib/dump_stack.c:106\n print_report+0xe0/0x750 mm/kasan/report.c:398\n kasan_report+0x139/0x170 mm/kasan/report.c:495\n kasan_check_range+0x287/0x290 mm/kasan/generic.c:189\n memcpy+0x25/0x60 mm/kasan/shadow.c:65\n ieee80211_tx_control_port+0x3b6/0xca0 net/mac80211/tx.c:5939\n rdev_tx_control_port net/wireless/rdev-ops.h:761 [inline]\n nl80211_tx_control_port+0x7b3/0xc40 net/wireless/nl80211.c:15453\n genl_family_rcv_msg_doit+0x22e/0x320 net/netlink/genetlink.c:756\n genl_family_rcv_msg net/netlink/genetlink.c:833 [inline]\n genl_rcv_msg+0x539/0x740 net/netlink/genetlink.c:850\n netlink_rcv_skb+0x1de/0x420 net/netlink/af_netlink.c:2508\n genl_rcv+0x24/0x40 net/netlink/genetlink.c:861\n netlink_unicast_kernel net/netlink/af_netlink.c:1326 [inline]\n netlink_unicast+0x74b/0x8c0 net/netlink/af_netlink.c:1352\n netlink_sendmsg+0x882/0xb90 net/netlink/af_netlink.c:1874\n sock_sendmsg_nosec net/socket.c:716 [inline]\n __sock_sendmsg net/socket.c:728 [inline]\n ____sys_sendmsg+0x5cc/0x8f0 net/socket.c:2499\n ___sys_sendmsg+0x21c/0x290 net/socket.c:2553\n __sys_sendmsg net/socket.c:2582 [inline]\n __do_sys_sendmsg net/socket.c:2591 [inline]\n __se_sys_sendmsg+0x19e/0x270 net/socket.c:2589\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x45/0x90 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nUpdate the policy to ensure correct validation.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56663",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39933",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: let recv_done verify data_offset, data_length and remaining_data_length\n\nThis is inspired by the related server fixes.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49503",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nath9k_htc: fix potential out of bounds access with invalid rxstatus->rs_keyix\n\nThe \"rxstatus->rs_keyix\" eventually gets passed to test_bit() so we need to\nensure that it is within the bitmap.\n\ndrivers/net/wireless/ath/ath9k/common.c:46 ath9k_cmn_rx_accept()\nerror: passing untrusted data 'rx_stats->rs_keyix' to 'test_bit()'",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49503",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-21",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49740",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: Check the count value of channel spec to prevent out-of-bounds reads\n\nThis patch fixes slab-out-of-bounds reads in brcmfmac that occur in\nbrcmf_construct_chaninfo() and brcmf_enable_bw40_2g() when the count\nvalue of channel specifications provided by the device is greater than\nthe length of 'list->element[]', decided by the size of the 'list'\nallocated with kzalloc(). The patch adds checks that make the functions\nfree the buffer and return -EINVAL if that is the case. Note that the\nnegative return is handled by the caller, brcmf_setup_wiphybands() or\nbrcmf_cfg80211_attach().\n\nFound by a modified version of syzkaller.\n\nCrash Report from brcmf_construct_chaninfo():\n==================================================================\nBUG: KASAN: slab-out-of-bounds in brcmf_setup_wiphybands+0x1238/0x1430\nRead of size 4 at addr ffff888115f24600 by task kworker/0:2/1896\n\nCPU: 0 PID: 1896 Comm: kworker/0:2 Tainted: G        W  O      5.14.0+ #132\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n dump_stack_lvl+0x57/0x7d\n print_address_description.constprop.0.cold+0x93/0x334\n kasan_report.cold+0x83/0xdf\n brcmf_setup_wiphybands+0x1238/0x1430\n brcmf_cfg80211_attach+0x2118/0x3fd0\n brcmf_attach+0x389/0xd40\n brcmf_usb_probe+0x12de/0x1690\n usb_probe_interface+0x25f/0x710\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_set_configuration+0x984/0x1770\n usb_generic_driver_probe+0x69/0x90\n usb_probe_device+0x9c/0x220\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_new_device.cold+0x463/0xf66\n hub_event+0x10d5/0x3330\n process_one_work+0x873/0x13e0\n worker_thread+0x8b/0xd10\n kthread+0x379/0x450\n ret_from_fork+0x1f/0x30\n\nAllocated by task 1896:\n kasan_save_stack+0x1b/0x40\n __kasan_kmalloc+0x7c/0x90\n kmem_cache_alloc_trace+0x19e/0x330\n brcmf_setup_wiphybands+0x290/0x1430\n brcmf_cfg80211_attach+0x2118/0x3fd0\n brcmf_attach+0x389/0xd40\n brcmf_usb_probe+0x12de/0x1690\n usb_probe_interface+0x25f/0x710\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_set_configuration+0x984/0x1770\n usb_generic_driver_probe+0x69/0x90\n usb_probe_device+0x9c/0x220\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n bus_for_each_drv+0x123/0x1a0\n __device_attach+0x207/0x330\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n usb_new_device.cold+0x463/0xf66\n hub_event+0x10d5/0x3330\n process_one_work+0x873/0x13e0\n worker_thread+0x8b/0xd10\n kthread+0x379/0x450\n ret_from_fork+0x1f/0x30\n\nThe buggy address belongs to the object at ffff888115f24000\n which belongs to the cache kmalloc-2k of size 2048\nThe buggy address is located 1536 bytes inside of\n 2048-byte region [ffff888115f24000, ffff888115f24800)\n\nMemory state around the buggy address:\n ffff888115f24500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff888115f24580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff888115f24600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                   ^\n ffff888115f24680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888115f24700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n==================================================================\n\nCrash Report from brcmf_enable_bw40_2g():\n==========\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49740",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49860",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: sysfs: validate return type of _STR method\n\nOnly buffer objects are valid return values of _STR.\n\nIf something else is returned description_show() will access invalid\nmemory.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49860",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38320",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64/ptrace: Fix stack-out-of-bounds read in regs_get_kernel_stack_nth()\n\nKASAN reports a stack-out-of-bounds read in regs_get_kernel_stack_nth().\n\nCall Trace:\n[   97.283505] BUG: KASAN: stack-out-of-bounds in regs_get_kernel_stack_nth+0xa8/0xc8\n[   97.284677] Read of size 8 at addr ffff800089277c10 by task 1.sh/2550\n[   97.285732]\n[   97.286067] CPU: 7 PID: 2550 Comm: 1.sh Not tainted 6.6.0+ #11\n[   97.287032] Hardware name: linux,dummy-virt (DT)\n[   97.287815] Call trace:\n[   97.288279]  dump_backtrace+0xa0/0x128\n[   97.288946]  show_stack+0x20/0x38\n[   97.289551]  dump_stack_lvl+0x78/0xc8\n[   97.290203]  print_address_description.constprop.0+0x84/0x3c8\n[   97.291159]  print_report+0xb0/0x280\n[   97.291792]  kasan_report+0x84/0xd0\n[   97.292421]  __asan_load8+0x9c/0xc0\n[   97.293042]  regs_get_kernel_stack_nth+0xa8/0xc8\n[   97.293835]  process_fetch_insn+0x770/0xa30\n[   97.294562]  kprobe_trace_func+0x254/0x3b0\n[   97.295271]  kprobe_dispatcher+0x98/0xe0\n[   97.295955]  kprobe_breakpoint_handler+0x1b0/0x210\n[   97.296774]  call_break_hook+0xc4/0x100\n[   97.297451]  brk_handler+0x24/0x78\n[   97.298073]  do_debug_exception+0xac/0x178\n[   97.298785]  el1_dbg+0x70/0x90\n[   97.299344]  el1h_64_sync_handler+0xcc/0xe8\n[   97.300066]  el1h_64_sync+0x78/0x80\n[   97.300699]  kernel_clone+0x0/0x500\n[   97.301331]  __arm64_sys_clone+0x70/0x90\n[   97.302084]  invoke_syscall+0x68/0x198\n[   97.302746]  el0_svc_common.constprop.0+0x11c/0x150\n[   97.303569]  do_el0_svc+0x38/0x50\n[   97.304164]  el0_svc+0x44/0x1d8\n[   97.304749]  el0t_64_sync_handler+0x100/0x130\n[   97.305500]  el0t_64_sync+0x188/0x190\n[   97.306151]\n[   97.306475] The buggy address belongs to stack of task 1.sh/2550\n[   97.307461]  and is located at offset 0 in frame:\n[   97.308257]  __se_sys_clone+0x0/0x138\n[   97.308910]\n[   97.309241] This frame has 1 object:\n[   97.309873]  [48, 184) 'args'\n[   97.309876]\n[   97.310749] The buggy address belongs to the virtual mapping at\n[   97.310749]  [ffff800089270000, ffff800089279000) created by:\n[   97.310749]  dup_task_struct+0xc0/0x2e8\n[   97.313347]\n[   97.313674] The buggy address belongs to the physical page:\n[   97.314604] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x14f69a\n[   97.315885] flags: 0x15ffffe00000000(node=1|zone=2|lastcpupid=0xfffff)\n[   97.316957] raw: 015ffffe00000000 0000000000000000 dead000000000122 0000000000000000\n[   97.318207] raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\n[   97.319445] page dumped because: kasan: bad access detected\n[   97.320371]\n[   97.320694] Memory state around the buggy address:\n[   97.321511]  ffff800089277b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   97.322681]  ffff800089277b80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   97.323846] >ffff800089277c00: 00 00 f1 f1 f1 f1 f1 f1 00 00 00 00 00 00 00 00\n[   97.325023]                          ^\n[   97.325683]  ffff800089277c80: 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3 f3 f3\n[   97.326856]  ffff800089277d00: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nThis issue seems to be related to the behavior of some gcc compilers and\nwas also fixed on the s390 architecture before:\n\n commit d93a855c31b7 (\"s390/ptrace: Avoid KASAN false positives in regs_get_kernel_stack_nth()\")\n\nAs described in that commit, regs_get_kernel_stack_nth() has confirmed that\n`addr` is on the stack, so reading the value at `*addr` should be allowed.\nUse READ_ONCE_NOCHECK() helper to silence the KASAN check for this case.\n\n[will: Use '*addr' as the argument to READ_ONCE_NOCHECK()]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38320",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-19",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47277",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkvm: avoid speculation-based attacks from out-of-range memslot accesses\n\nKVM's mechanism for accessing guest memory translates a guest physical\naddress (gpa) to a host virtual address using the right-shifted gpa\n(also known as gfn) and a struct kvm_memory_slot.  The translation is\nperformed in __gfn_to_hva_memslot using the following formula:\n\n      hva = slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE\n\nIt is expected that gfn falls within the boundaries of the guest's\nphysical memory.  However, a guest can access invalid physical addresses\nin such a way that the gfn is invalid.\n\n__gfn_to_hva_memslot is called from kvm_vcpu_gfn_to_hva_prot, which first\nretrieves a memslot through __gfn_to_memslot.  While __gfn_to_memslot\ndoes check that the gfn falls within the boundaries of the guest's\nphysical memory or not, a CPU can speculate the result of the check and\ncontinue execution speculatively using an illegal gfn. The speculation\ncan result in calculating an out-of-bounds hva.  If the resulting host\nvirtual address is used to load another guest physical address, this\nis effectively a Spectre gadget consisting of two consecutive reads,\nthe second of which is data dependent on the first.\n\nRight now it's not clear if there are any cases in which this is\nexploitable.  One interesting case was reported by the original author\nof this patch, and involves visiting guest page tables on x86.  Right\nnow these are not vulnerable because the hva read goes through get_user(),\nwhich contains an LFENCE speculation barrier.  However, there are\npatches in progress for x86 uaccess.h to mask kernel addresses instead of\nusing LFENCE; once these land, a guest could use speculation to read\nfrom the VMM's ring 3 address space.  Other architectures such as ARM\nalready use the address masking method, and would be susceptible to\nthis same kind of data-dependent access gadgets.  Therefore, this patch\nproactively protects from these attacks by masking out-of-bounds gfns\nin __gfn_to_hva_memslot, which blocks speculation of invalid hvas.\n\nSean Christopherson noted that this patch does not cover\nkvm_read_guest_offset_cached.  This however is limited to a few bytes\npast the end of the cache, and therefore it is unlikely to be useful in\nthe context of building a chain of data dependent accesses.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47277",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-30",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53034",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_trans\n\nThere is a kernel API ntb_mw_clear_trans() would pass 0 to both addr and\nsize. This would make xlate_pos negative.\n\n[   23.734156] switchtec switchtec0: MW 0: part 0 addr 0x0000000000000000 size 0x0000000000000000\n[   23.734158] ================================================================================\n[   23.734172] UBSAN: shift-out-of-bounds in drivers/ntb/hw/mscc/ntb_hw_switchtec.c:293:7\n[   23.734418] shift exponent -1 is negative\n\nEnsuring xlate_pos is a positive or zero before BIT.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-53034",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-16",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-22121",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix out-of-bound read in ext4_xattr_inode_dec_ref_all()\n\nThere's issue as follows:\nBUG: KASAN: use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790\nRead of size 4 at addr ffff88807b003000 by task syz-executor.0/15172\n\nCPU: 3 PID: 15172 Comm: syz-executor.0\nCall Trace:\n __dump_stack lib/dump_stack.c:82 [inline]\n dump_stack+0xbe/0xfd lib/dump_stack.c:123\n print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c:400\n __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560\n kasan_report+0x3a/0x50 mm/kasan/report.c:585\n ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c:1137\n ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c:2896\n ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c:323\n evict+0x39f/0x880 fs/inode.c:622\n iput_final fs/inode.c:1746 [inline]\n iput fs/inode.c:1772 [inline]\n iput+0x525/0x6c0 fs/inode.c:1758\n ext4_orphan_cleanup fs/ext4/super.c:3298 [inline]\n ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c:5300\n mount_bdev+0x355/0x410 fs/super.c:1446\n legacy_get_tree+0xfe/0x220 fs/fs_context.c:611\n vfs_get_tree+0x8d/0x2f0 fs/super.c:1576\n do_new_mount fs/namespace.c:2983 [inline]\n path_mount+0x119a/0x1ad0 fs/namespace.c:3316\n do_mount+0xfc/0x110 fs/namespace.c:3329\n __do_sys_mount fs/namespace.c:3540 [inline]\n __se_sys_mount+0x219/0x2e0 fs/namespace.c:3514\n do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x67/0xd1\n\nMemory state around the buggy address:\n ffff88807b002f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88807b002f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88807b003000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n                   ^\n ffff88807b003080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88807b003100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nAbove issue happens as ext4_xattr_delete_inode() isn't check xattr\nis valid if xattr is in inode.\nTo solve above issue call xattr_check_inode() check if xattr if valid\nin inode. In fact, we can directly verify in ext4_iget_extra_inode(),\nso that there is no divergent verification.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-22121",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-16",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50035",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nppp: fix ppp_async_encode() illegal access\n\nsyzbot reported an issue in ppp_async_encode() [1]\n\nIn this case, pppoe_sendmsg() is called with a zero size.\nThen ppp_async_encode() is called with an empty skb.\n\nBUG: KMSAN: uninit-value in ppp_async_encode drivers/net/ppp/ppp_async.c:545 [inline]\n BUG: KMSAN: uninit-value in ppp_async_push+0xb4f/0x2660 drivers/net/ppp/ppp_async.c:675\n  ppp_async_encode drivers/net/ppp/ppp_async.c:545 [inline]\n  ppp_async_push+0xb4f/0x2660 drivers/net/ppp/ppp_async.c:675\n  ppp_async_send+0x130/0x1b0 drivers/net/ppp/ppp_async.c:634\n  ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2280 [inline]\n  ppp_input+0x1f1/0xe60 drivers/net/ppp/ppp_generic.c:2304\n  pppoe_rcv_core+0x1d3/0x720 drivers/net/ppp/pppoe.c:379\n  sk_backlog_rcv+0x13b/0x420 include/net/sock.h:1113\n  __release_sock+0x1da/0x330 net/core/sock.c:3072\n  release_sock+0x6b/0x250 net/core/sock.c:3626\n  pppoe_sendmsg+0x2b8/0xb90 drivers/net/ppp/pppoe.c:903\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:4092 [inline]\n  slab_alloc_node mm/slub.c:4135 [inline]\n  kmem_cache_alloc_node_noprof+0x6bf/0xb80 mm/slub.c:4187\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:587\n  __alloc_skb+0x363/0x7b0 net/core/skbuff.c:678\n  alloc_skb include/linux/skbuff.h:1322 [inline]\n  sock_wmalloc+0xfe/0x1a0 net/core/sock.c:2732\n  pppoe_sendmsg+0x3a7/0xb90 drivers/net/ppp/pppoe.c:867\n  sock_sendmsg_nosec net/socket.c:729 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:744\n  ____sys_sendmsg+0x903/0xb60 net/socket.c:2602\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2656\n  __sys_sendmmsg+0x3c1/0x960 net/socket.c:2742\n  __do_sys_sendmmsg net/socket.c:2771 [inline]\n  __se_sys_sendmmsg net/socket.c:2768 [inline]\n  __x64_sys_sendmmsg+0xbc/0x120 net/socket.c:2768\n  x64_sys_call+0xb6e/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:308\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nCPU: 1 UID: 0 PID: 5411 Comm: syz.1.14 Not tainted 6.12.0-rc1-syzkaller-00165-g360c1f1f24c6 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50035",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49407",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndlm: fix plock invalid read\n\nThis patch fixes an invalid read showed by KASAN. A unlock will allocate a\n\"struct plock_op\" and a followed send_op() will append it to a global\nsend_list data structure. In some cases a followed dev_read() moves it\nto recv_list and dev_write() will cast it to \"struct plock_xop\" and access\nfields which are only available in those structures. At this point an\ninvalid read happens by accessing those fields.\n\nTo fix this issue the \"callback\" field is moved to \"struct plock_op\" to\nindicate that a cast to \"plock_xop\" is allowed and does the additional\n\"plock_xop\" handling if set.\n\nExample of the KASAN output which showed the invalid read:\n\n[ 2064.296453] ==================================================================\n[ 2064.304852] BUG: KASAN: slab-out-of-bounds in dev_write+0x52b/0x5a0 [dlm]\n[ 2064.306491] Read of size 8 at addr ffff88800ef227d8 by task dlm_controld/7484\n[ 2064.308168]\n[ 2064.308575] CPU: 0 PID: 7484 Comm: dlm_controld Kdump: loaded Not tainted 5.14.0+ #9\n[ 2064.310292] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n[ 2064.311618] Call Trace:\n[ 2064.312218]  dump_stack_lvl+0x56/0x7b\n[ 2064.313150]  print_address_description.constprop.8+0x21/0x150\n[ 2064.314578]  ? dev_write+0x52b/0x5a0 [dlm]\n[ 2064.315610]  ? dev_write+0x52b/0x5a0 [dlm]\n[ 2064.316595]  kasan_report.cold.14+0x7f/0x11b\n[ 2064.317674]  ? dev_write+0x52b/0x5a0 [dlm]\n[ 2064.318687]  dev_write+0x52b/0x5a0 [dlm]\n[ 2064.319629]  ? dev_read+0x4a0/0x4a0 [dlm]\n[ 2064.320713]  ? bpf_lsm_kernfs_init_security+0x10/0x10\n[ 2064.321926]  vfs_write+0x17e/0x930\n[ 2064.322769]  ? __fget_light+0x1aa/0x220\n[ 2064.323753]  ksys_write+0xf1/0x1c0\n[ 2064.324548]  ? __ia32_sys_read+0xb0/0xb0\n[ 2064.325464]  do_syscall_64+0x3a/0x80\n[ 2064.326387]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[ 2064.327606] RIP: 0033:0x7f807e4ba96f\n[ 2064.328470] Code: 89 54 24 18 48 89 74 24 10 89 7c 24 08 e8 39 87 f8 ff 48 8b 54 24 18 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 31 44 89 c7 48 89 44 24 08 e8 7c 87 f8 ff 48\n[ 2064.332902] RSP: 002b:00007ffd50cfe6e0 EFLAGS: 00000293 ORIG_RAX: 0000000000000001\n[ 2064.334658] RAX: ffffffffffffffda RBX: 000055cc3886eb30 RCX: 00007f807e4ba96f\n[ 2064.336275] RDX: 0000000000000040 RSI: 00007ffd50cfe7e0 RDI: 0000000000000010\n[ 2064.337980] RBP: 00007ffd50cfe7e0 R08: 0000000000000000 R09: 0000000000000001\n[ 2064.339560] R10: 000055cc3886eb30 R11: 0000000000000293 R12: 000055cc3886eb80\n[ 2064.341237] R13: 000055cc3886eb00 R14: 000055cc3886f590 R15: 0000000000000001\n[ 2064.342857]\n[ 2064.343226] Allocated by task 12438:\n[ 2064.344057]  kasan_save_stack+0x1c/0x40\n[ 2064.345079]  __kasan_kmalloc+0x84/0xa0\n[ 2064.345933]  kmem_cache_alloc_trace+0x13b/0x220\n[ 2064.346953]  dlm_posix_unlock+0xec/0x720 [dlm]\n[ 2064.348811]  do_lock_file_wait.part.32+0xca/0x1d0\n[ 2064.351070]  fcntl_setlk+0x281/0xbc0\n[ 2064.352879]  do_fcntl+0x5e4/0xfe0\n[ 2064.354657]  __x64_sys_fcntl+0x11f/0x170\n[ 2064.356550]  do_syscall_64+0x3a/0x80\n[ 2064.358259]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[ 2064.360745]\n[ 2064.361511] Last potentially related work creation:\n[ 2064.363957]  kasan_save_stack+0x1c/0x40\n[ 2064.365811]  __kasan_record_aux_stack+0xaf/0xc0\n[ 2064.368100]  call_rcu+0x11b/0xf70\n[ 2064.369785]  dlm_process_incoming_buffer+0x47d/0xfd0 [dlm]\n[ 2064.372404]  receive_from_sock+0x290/0x770 [dlm]\n[ 2064.374607]  process_recv_sockets+0x32/0x40 [dlm]\n[ 2064.377290]  process_one_work+0x9a8/0x16e0\n[ 2064.379357]  worker_thread+0x87/0xbf0\n[ 2064.381188]  kthread+0x3ac/0x490\n[ 2064.383460]  ret_from_fork+0x22/0x30\n[ 2064.385588]\n[ 2064.386518] Second to last potentially related work creation:\n[ 2064.389219]  kasan_save_stack+0x1c/0x40\n[ 2064.391043]  __kasan_record_aux_stack+0xaf/0xc0\n[ 2064.393303]  call_rcu+0x11b/0xf70\n[ 2064.394885]  dlm_process_incoming_buffer+0x47d/0xfd0 [dlm]\n[ 2064.397694]  receive_from_sock+0x290/0x770 \n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49407",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-22",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38111",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mdiobus: Fix potential out-of-bounds read/write access\n\nWhen using publicly available tools like 'mdio-tools' to read/write data\nfrom/to network interface and its PHY via mdiobus, there is no verification of\nparameters passed to the ioctl and it accepts any mdio address.\nCurrently there is support for 32 addresses in kernel via PHY_MAX_ADDR define,\nbut it is possible to pass higher value than that via ioctl.\nWhile read/write operation should generally fail in this case,\nmdiobus provides stats array, where wrong address may allow out-of-bounds\nread/write.\n\nFix that by adding address verification before read/write operation.\nWhile this excludes this access from any statistics, it improves security of\nread/write operation.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38111",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53675",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Fix possible desc_ptr out-of-bounds accesses\n\nSanitize possible desc_ptr out-of-bounds accesses in\nses_enclosure_data_process().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48988",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemcg: fix possible use-after-free in memcg_write_event_control()\n\nmemcg_write_event_control() accesses the dentry->d_name of the specified\ncontrol fd to route the write call.  As a cgroup interface file can't be\nrenamed, it's safe to access d_name as long as the specified file is a\nregular cgroup file.  Also, as these cgroup interface files can't be\nremoved before the directory, it's safe to access the parent too.\n\nPrior to 347c4a874710 (\"memcg: remove cgroup_event->cft\"), there was a\ncall to __file_cft() which verified that the specified file is a regular\ncgroupfs file before further accesses.  The cftype pointer returned from\n__file_cft() was no longer necessary and the commit inadvertently dropped\nthe file type check with it allowing any file to slip through.  With the\ninvarients broken, the d_name and parent accesses can now race against\nrenames and removals of arbitrary files and cause use-after-free's.\n\nFix the bug by resurrecting the file type check in __file_cft().  Now that\ncgroupfs is implemented through kernfs, checking the file operations needs\nto go through a layer of indirection.  Instead, let's check the superblock\nand dentry type.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48988",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-11-01",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68209",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlx5: Fix default values in create CQ\n\nCurrently, CQs without a completion function are assigned the\nmlx5_add_cq_to_tasklet function by default. This is problematic since\nonly user CQs created through the mlx5_ib driver are intended to use\nthis function.\n\nAdditionally, all CQs that will use doorbells instead of polling for\ncompletions must call mlx5_cq_arm. However, the default CQ creation flow\nleaves a valid value in the CQ's arm_db field, allowing FW to send\ninterrupts to polling-only CQs in certain corner cases.\n\nThese two factors would allow a polling-only kernel CQ to be triggered\nby an EQ interrupt and call a completion function intended only for user\nCQs, causing a null pointer exception.\n\nSome areas in the driver have prevented this issue with one-off fixes\nbut did not address the root cause.\n\nThis patch fixes the described issue by adding defaults to the create CQ\nflow. It adds a default dummy completion function to protect against\nnull pointer exceptions, and it sets an invalid command sequence number\nby default in kernel CQs to prevent the FW from sending an interrupt to\nthe CQ until it is armed. User CQs are responsible for their own\ninitialization values.\n\nCallers of mlx5_core_create_cq are responsible for changing the\ncompletion function and arming the CQ per their needs.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2024-56672",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-cgroup: Fix UAF in blkcg_unpin_online()\n\nblkcg_unpin_online() walks up the blkcg hierarchy putting the online pin. To\nwalk up, it uses blkcg_parent(blkcg) but it was calling that after\nblkcg_destroy_blkgs(blkcg) which could free the blkcg, leading to the\nfollowing UAF:\n\n  ==================================================================\n  BUG: KASAN: slab-use-after-free in blkcg_unpin_online+0x15a/0x270\n  Read of size 8 at addr ffff8881057678c0 by task kworker/9:1/117\n\n  CPU: 9 UID: 0 PID: 117 Comm: kworker/9:1 Not tainted 6.13.0-rc1-work-00182-gb8f52214c61a-dirty #48\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS unknown 02/02/2022\n  Workqueue: cgwb_release cgwb_release_workfn\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x27/0x80\n   print_report+0x151/0x710\n   kasan_report+0xc0/0x100\n   blkcg_unpin_online+0x15a/0x270\n   cgwb_release_workfn+0x194/0x480\n   process_scheduled_works+0x71b/0xe20\n   worker_thread+0x82a/0xbd0\n   kthread+0x242/0x2c0\n   ret_from_fork+0x33/0x70\n   ret_from_fork_asm+0x1a/0x30\n   </TASK>\n  ...\n  Freed by task 1944:\n   kasan_save_track+0x2b/0x70\n   kasan_save_free_info+0x3c/0x50\n   __kasan_slab_free+0x33/0x50\n   kfree+0x10c/0x330\n   css_free_rwork_fn+0xe6/0xb30\n   process_scheduled_works+0x71b/0xe20\n   worker_thread+0x82a/0xbd0\n   kthread+0x242/0x2c0\n   ret_from_fork+0x33/0x70\n   ret_from_fork_asm+0x1a/0x30\n\nNote that the UAF is not easy to trigger as the free path is indirected\nbehind a couple RCU grace periods and a work item execution. I could only\ntrigger it with artifical msleep() injected in blkcg_unpin_online().\n\nFix it by reading the parent pointer before destroying the blkcg's blkg's.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56672",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40280",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Fix use-after-free in tipc_mon_reinit_self().\n\nsyzbot reported use-after-free of tipc_net(net)->monitors[]\nin tipc_mon_reinit_self(). [0]\n\nThe array is protected by RTNL, but tipc_mon_reinit_self()\niterates over it without RTNL.\n\ntipc_mon_reinit_self() is called from tipc_net_finalize(),\nwhich is always under RTNL except for tipc_net_finalize_work().\n\nLet's hold RTNL in tipc_net_finalize_work().\n\n[0]:\nBUG: KASAN: slab-use-after-free in __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]\nBUG: KASAN: slab-use-after-free in _raw_spin_lock_irqsave+0xa7/0xf0 kernel/locking/spinlock.c:162\nRead of size 1 at addr ffff88805eae1030 by task kworker/0:7/5989\n\nCPU: 0 UID: 0 PID: 5989 Comm: kworker/0:7 Not tainted syzkaller #0 PREEMPT_{RT,(full)}\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025\nWorkqueue: events tipc_net_finalize_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0xca/0x240 mm/kasan/report.c:482\n kasan_report+0x118/0x150 mm/kasan/report.c:595\n __kasan_check_byte+0x2a/0x40 mm/kasan/common.c:568\n kasan_check_byte include/linux/kasan.h:399 [inline]\n lock_acquire+0x8d/0x360 kernel/locking/lockdep.c:5842\n __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]\n _raw_spin_lock_irqsave+0xa7/0xf0 kernel/locking/spinlock.c:162\n rtlock_slowlock kernel/locking/rtmutex.c:1894 [inline]\n rwbase_rtmutex_lock_state kernel/locking/spinlock_rt.c:160 [inline]\n rwbase_write_lock+0xd3/0x7e0 kernel/locking/rwbase_rt.c:244\n rt_write_lock+0x76/0x110 kernel/locking/spinlock_rt.c:243\n write_lock_bh include/linux/rwlock_rt.h:99 [inline]\n tipc_mon_reinit_self+0x79/0x430 net/tipc/monitor.c:718\n tipc_net_finalize+0x115/0x190 net/tipc/net.c:140\n process_one_work kernel/workqueue.c:3236 [inline]\n process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3319\n worker_thread+0x8a0/0xda0 kernel/workqueue.c:3400\n kthread+0x70e/0x8a0 kernel/kthread.c:463\n ret_from_fork+0x439/0x7d0 arch/x86/kernel/process.c:148\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n </TASK>\n\nAllocated by task 6089:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:388 [inline]\n __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:405\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x1a8/0x320 mm/slub.c:4407\n kmalloc_noprof include/linux/slab.h:905 [inline]\n kzalloc_noprof include/linux/slab.h:1039 [inline]\n tipc_mon_create+0xc3/0x4d0 net/tipc/monitor.c:657\n tipc_enable_bearer net/tipc/bearer.c:357 [inline]\n __tipc_nl_bearer_enable+0xe16/0x13f0 net/tipc/bearer.c:1047\n __tipc_nl_compat_doit net/tipc/netlink_compat.c:371 [inline]\n tipc_nl_compat_doit+0x3bc/0x5f0 net/tipc/netlink_compat.c:393\n tipc_nl_compat_handle net/tipc/netlink_compat.c:-1 [inline]\n tipc_nl_compat_recv+0x83c/0xbe0 net/tipc/netlink_compat.c:1321\n genl_family_rcv_msg_doit+0x215/0x300 net/netlink/genetlink.c:1115\n genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]\n genl_rcv_msg+0x60e/0x790 net/netlink/genetlink.c:1210\n netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2552\n genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219\n netlink_unicast_kernel net/netlink/af_netlink.c:1320 [inline]\n netlink_unicast+0x846/0xa10 net/netlink/af_netlink.c:1346\n netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1896\n sock_sendmsg_nosec net/socket.c:714 [inline]\n __sock_sendmsg+0x21c/0x270 net/socket.c:729\n ____sys_sendmsg+0x508/0x820 net/socket.c:2614\n ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2668\n __sys_sendmsg net/socket.c:2700 [inline]\n __do_sys_sendmsg net/socket.c:2705 [inline]\n __se_sys_sendmsg net/socket.c:2703 [inline]\n __x64_sys_sendmsg+0x1a1/0x260 net/socket.c:2703\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-06",
                    "modification_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50673",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix use-after-free in ext4_orphan_cleanup\n\nI caught a issue as follows:\n==================================================================\n BUG: KASAN: use-after-free in __list_add_valid+0x28/0x1a0\n Read of size 8 at addr ffff88814b13f378 by task mount/710\n\n CPU: 1 PID: 710 Comm: mount Not tainted 6.1.0-rc3-next #370\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x73/0x9f\n  print_report+0x25d/0x759\n  kasan_report+0xc0/0x120\n  __asan_load8+0x99/0x140\n  __list_add_valid+0x28/0x1a0\n  ext4_orphan_cleanup+0x564/0x9d0 [ext4]\n  __ext4_fill_super+0x48e2/0x5300 [ext4]\n  ext4_fill_super+0x19f/0x3a0 [ext4]\n  get_tree_bdev+0x27b/0x450\n  ext4_get_tree+0x19/0x30 [ext4]\n  vfs_get_tree+0x49/0x150\n  path_mount+0xaae/0x1350\n  do_mount+0xe2/0x110\n  __x64_sys_mount+0xf0/0x190\n  do_syscall_64+0x35/0x80\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  </TASK>\n [...]\n==================================================================\n\nAbove issue may happen as follows:\n-------------------------------------\next4_fill_super\n  ext4_orphan_cleanup\n   --- loop1: assume last_orphan is 12 ---\n    list_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan)\n    ext4_truncate --> return 0\n      ext4_inode_attach_jinode --> return -ENOMEM\n    iput(inode) --> free inode<12>\n   --- loop2: last_orphan is still 12 ---\n    list_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n    // use inode<12> and trigger UAF\n\nTo solve this issue, we need to propagate the return value of\next4_inode_attach_jinode() appropriately.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53232",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: mt7921: fix kernel panic by accessing unallocated eeprom.data\n\nThe MT7921 driver no longer uses eeprom.data, but the relevant code has not\nbeen removed completely since\ncommit 16d98b548365 (\"mt76: mt7921: rely on mcu_get_nic_capability\").\nThis could result in potential invalid memory access.\n\nTo fix the kernel panic issue in mt7921, it is necessary to avoid accessing\nunallocated eeprom.data which can lead to invalid memory access.\n\nFurthermore, it is possible to entirely eliminate the\nmt7921_mcu_parse_eeprom function and solely depend on\nmt7921_mcu_parse_response to divide the RxD header.\n\n[2.702735] BUG: kernel NULL pointer dereference, address: 0000000000000550\n[2.702740] #PF: supervisor write access in kernel mode\n[2.702741] #PF: error_code(0x0002) - not-present page\n[2.702743] PGD 0 P4D 0\n[2.702747] Oops: 0002 [#1] PREEMPT SMP NOPTI\n[2.702755] RIP: 0010:mt7921_mcu_parse_response+0x147/0x170 [mt7921_common]\n[2.702758] RSP: 0018:ffffae7c00fef828 EFLAGS: 00010286\n[2.702760] RAX: ffffa367f57be024 RBX: ffffa367cc7bf500 RCX: 0000000000000000\n[2.702762] RDX: 0000000000000550 RSI: 0000000000000000 RDI: ffffa367cc7bf500\n[2.702763] RBP: ffffae7c00fef840 R08: ffffa367cb167000 R09: 0000000000000005\n[2.702764] R10: 0000000000000000 R11: ffffffffc04702e4 R12: ffffa367e8329f40\n[2.702766] R13: 0000000000000000 R14: 0000000000000001 R15: ffffa367e8329f40\n[2.702768] FS:  000079ee6cf20c40(0000) GS:ffffa36b2f940000(0000) knlGS:0000000000000000\n[2.702769] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[2.702775] CR2: 0000000000000550 CR3: 00000001233c6004 CR4: 0000000000770ee0\n[2.702776] PKRU: 55555554\n[2.702777] Call Trace:\n[2.702782]  mt76_mcu_skb_send_and_get_msg+0xc3/0x11e [mt76 <HASH:1bc4 5>]\n[2.702785]  mt7921_run_firmware+0x241/0x853 [mt7921_common <HASH:6a2f 6>]\n[2.702789]  mt7921e_mcu_init+0x2b/0x56 [mt7921e <HASH:d290 7>]\n[2.702792]  mt7921_register_device+0x2eb/0x5a5 [mt7921_common <HASH:6a2f 6>]\n[2.702795]  ? mt7921_irq_tasklet+0x1d4/0x1d4 [mt7921e <HASH:d290 7>]\n[2.702797]  mt7921_pci_probe+0x2d6/0x319 [mt7921e <HASH:d290 7>]\n[2.702799]  pci_device_probe+0x9f/0x12a",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-15",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47280",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: Fix use-after-free read in drm_getunique()\n\nThere is a time-of-check-to-time-of-use error in drm_getunique() due\nto retrieving file_priv->master prior to locking the device's master\nmutex.\n\nAn example can be seen in the crash report of the use-after-free error\nfound by Syzbot:\nhttps://syzkaller.appspot.com/bug?id=148d2f1dfac64af52ffd27b661981a540724f803\n\nIn the report, the master pointer was used after being freed. This is\nbecause another process had acquired the device's master mutex in\ndrm_setmaster_ioctl(), then overwrote fpriv->master in\ndrm_new_set_master(). The old value of fpriv->master was subsequently\nfreed before the mutex was unlocked.\n\nTo fix this, we lock the device's master mutex before retrieving the\npointer from from fpriv->master. This patch passes the Syzbot\nreproducer test.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47280",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-24",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68231",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/mempool: fix poisoning order>0 pages with HIGHMEM\n\nThe kernel test has reported:\n\n  BUG: unable to handle page fault for address: fffba000\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0002) - not-present page\n  *pde = 03171067 *pte = 00000000\n  Oops: Oops: 0002 [#1]\n  CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G                T   6.18.0-rc2-00031-gec7f31b2a2d3 #1 NONE  a1d066dfe789f54bc7645c7989957d2bdee593ca\n  Tainted: [T]=RANDSTRUCT\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n  EIP: memset (arch/x86/include/asm/string_32.h:168 arch/x86/lib/memcpy_32.c:17)\n  Code: a5 8b 4d f4 83 e1 03 74 02 f3 a4 83 c4 04 5e 5f 5d 2e e9 73 41 01 00 90 90 90 3e 8d 74 26 00 55 89 e5 57 56 89 c6 89 d0 89 f7 <f3> aa 89 f0 5e 5f 5d 2e e9 53 41 01 00 cc cc cc 55 89 e5 53 57 56\n  EAX: 0000006b EBX: 00000015 ECX: 001fefff EDX: 0000006b\n  ESI: fffb9000 EDI: fffba000 EBP: c611fbf0 ESP: c611fbe8\n  DS: 007b ES: 007b FS: 0000 GS: 0000 SS: 0068 EFLAGS: 00010287\n  CR0: 80050033 CR2: fffba000 CR3: 0316e000 CR4: 00040690\n  Call Trace:\n   poison_element (mm/mempool.c:83 mm/mempool.c:102)\n   mempool_init_node (mm/mempool.c:142 mm/mempool.c:226)\n   mempool_init_noprof (mm/mempool.c:250 (discriminator 1))\n   ? mempool_alloc_pages (mm/mempool.c:640)\n   bio_integrity_initfn (block/bio-integrity.c:483 (discriminator 8))\n   ? mempool_alloc_pages (mm/mempool.c:640)\n   do_one_initcall (init/main.c:1283)\n\nChristoph found out this is due to the poisoning code not dealing\nproperly with CONFIG_HIGHMEM because only the first page is mapped but\nthen the whole potentially high-order page is accessed.\n\nWe could give up on HIGHMEM here, but it's straightforward to fix this\nwith a loop that's mapping, poisoning or checking and unmapping\nindividual pages.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40259",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: sg: Do not sleep in atomic context\n\nsg_finish_rem_req() calls blk_rq_unmap_user(). The latter function may\nsleep. Hence, call sg_finish_rem_req() with interrupts enabled instead\nof disabled.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40168",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmc: Use __sk_dst_get() and dst_dev_rcu() in smc_clc_prfx_match().\n\nsmc_clc_prfx_match() is called from smc_listen_work() and\nnot under RCU nor RTNL.\n\nUsing sk_dst_get(sk)->dev could trigger UAF.\n\nLet's use __sk_dst_get() and dst_dev_rcu().\n\nNote that the returned value of smc_clc_prfx_match() is not\nused in the caller.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53821",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nip6_vti: fix slab-use-after-free in decode_session6\n\nWhen ipv6_vti device is set to the qdisc of the sfb type, the cb field\nof the sent skb may be modified during enqueuing. Then,\nslab-use-after-free may occur when ipv6_vti device sends IPv6 packets.\n\nThe stack information is as follows:\nBUG: KASAN: slab-use-after-free in decode_session6+0x103f/0x1890\nRead of size 1 at addr ffff88802e08edc2 by task swapper/0/0\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted 6.4.0-next-20230707-00001-g84e2cad7f979 #410\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 04/01/2014\nCall Trace:\n<IRQ>\ndump_stack_lvl+0xd9/0x150\nprint_address_description.constprop.0+0x2c/0x3c0\nkasan_report+0x11d/0x130\ndecode_session6+0x103f/0x1890\n__xfrm_decode_session+0x54/0xb0\nvti6_tnl_xmit+0x3e6/0x1ee0\ndev_hard_start_xmit+0x187/0x700\nsch_direct_xmit+0x1a3/0xc30\n__qdisc_run+0x510/0x17a0\n__dev_queue_xmit+0x2215/0x3b10\nneigh_connected_output+0x3c2/0x550\nip6_finish_output2+0x55a/0x1550\nip6_finish_output+0x6b9/0x1270\nip6_output+0x1f1/0x540\nndisc_send_skb+0xa63/0x1890\nndisc_send_rs+0x132/0x6f0\naddrconf_rs_timer+0x3f1/0x870\ncall_timer_fn+0x1a0/0x580\nexpire_timers+0x29b/0x4b0\nrun_timer_softirq+0x326/0x910\n__do_softirq+0x1d4/0x905\nirq_exit_rcu+0xb7/0x120\nsysvec_apic_timer_interrupt+0x97/0xc0\n</IRQ>\nAllocated by task 9176:\nkasan_save_stack+0x22/0x40\nkasan_set_track+0x25/0x30\n__kasan_slab_alloc+0x7f/0x90\nkmem_cache_alloc_node+0x1cd/0x410\nkmalloc_reserve+0x165/0x270\n__alloc_skb+0x129/0x330\nnetlink_sendmsg+0x9b1/0xe30\nsock_sendmsg+0xde/0x190\n____sys_sendmsg+0x739/0x920\n___sys_sendmsg+0x110/0x1b0\n__sys_sendmsg+0xf7/0x1c0\ndo_syscall_64+0x39/0xb0\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\nFreed by task 9176:\nkasan_save_stack+0x22/0x40\nkasan_set_track+0x25/0x30\nkasan_save_free_info+0x2b/0x40\n____kasan_slab_free+0x160/0x1c0\nslab_free_freelist_hook+0x11b/0x220\nkmem_cache_free+0xf0/0x490\nskb_free_head+0x17f/0x1b0\nskb_release_data+0x59c/0x850\nconsume_skb+0xd2/0x170\nnetlink_unicast+0x54f/0x7f0\nnetlink_sendmsg+0x926/0xe30\nsock_sendmsg+0xde/0x190\n____sys_sendmsg+0x739/0x920\n___sys_sendmsg+0x110/0x1b0\n__sys_sendmsg+0xf7/0x1c0\ndo_syscall_64+0x39/0xb0\nentry_SYSCALL_64_after_hwframe+0x63/0xcd\nThe buggy address belongs to the object at ffff88802e08ed00\nwhich belongs to the cache skbuff_small_head of size 640\nThe buggy address is located 194 bytes inside of\nfreed 640-byte region [ffff88802e08ed00, ffff88802e08ef80)\n\nAs commit f855691975bb (\"xfrm6: Fix the nexthdr offset in\n_decode_session6.\") showed, xfrm_decode_session was originally intended\nonly for the receive path. IP6CB(skb)->nhoff is not set during\ntransmission. Therefore, set the cb field in the skb to 0 before\nsending packets.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39998",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: target_core_configfs: Add length check to avoid buffer overflow\n\nA buffer overflow arises from the usage of snprintf to write into the\nbuffer \"buf\" in target_lu_gp_members_show function located in\n/drivers/target/target_core_configfs.c. This buffer is allocated with\nsize LU_GROUP_NAME_BUF (256 bytes).\n\nsnprintf(...) formats multiple strings into buf with the HBA name\n(hba->hba_group.cg_item), a slash character, a devicename (dev->\ndev_group.cg_item) and a newline character, the total formatted string\nlength may exceed the buffer size of 256 bytes.\n\nSince snprintf() returns the total number of bytes that would have been\nwritten (the length of %s/%sn ), this value may exceed the buffer length\n(256 bytes) passed to memcpy(), this will ultimately cause function\nmemcpy reporting a buffer overflow error.\n\nAn additional check of the return value of snprintf() can avoid this\nbuffer overflow.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53761",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: usbtmc: Fix direction for 0-length ioctl control messages\n\nThe syzbot fuzzer found a problem in the usbtmc driver: When a user\nsubmits an ioctl for a 0-length control transfer, the driver does not\ncheck that the direction is set to OUT:\n\n------------[ cut here ]------------\nusb 3-1: BOGUS control dir, pipe 80000b80 doesn't match bRequestType fd\nWARNING: CPU: 0 PID: 5100 at drivers/usb/core/urb.c:411 usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411\nModules linked in:\nCPU: 0 PID: 5100 Comm: syz-executor428 Not tainted 6.3.0-syzkaller-12049-g58390c8ce1bd #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/14/2023\nRIP: 0010:usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411\nCode: 7c 24 40 e8 1b 13 5c fb 48 8b 7c 24 40 e8 21 1d f0 fe 45 89 e8 44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 e0 b5 fc 8a e8 19 c8 23 fb <0f> 0b e9 9f ee ff ff e8 ed 12 5c fb 0f b6 1d 12 8a 3c 08 31 ff 41\nRSP: 0018:ffffc90003d2fb00 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff8880789e9058 RCX: 0000000000000000\nRDX: ffff888029593b80 RSI: ffffffff814c1447 RDI: 0000000000000001\nRBP: ffff88801ea742f8 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff88802915e528\nR13: 00000000000000fd R14: 0000000080000b80 R15: ffff8880222b3100\nFS:  0000555556ca63c0(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f9ef4d18150 CR3: 0000000073e5b000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x101/0x4b0 drivers/usb/core/message.c:58\n usb_internal_control_msg drivers/usb/core/message.c:102 [inline]\n usb_control_msg+0x320/0x4a0 drivers/usb/core/message.c:153\n usbtmc_ioctl_request drivers/usb/class/usbtmc.c:1954 [inline]\n usbtmc_ioctl+0x1b3d/0x2840 drivers/usb/class/usbtmc.c:2097\n\nTo fix this, we must override the direction in the bRequestType field\nof the control request structure when the length is 0.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40158",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: use RCU in ip6_output()\n\nUse RCU in ip6_output() in order to use dst_dev_rcu() to prevent\npossible UAF.\n\nWe can remove rcu_read_lock()/rcu_read_unlock() pairs\nfrom ip6_finish_output2().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50700",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath10k: Delay the unmapping of the buffer\n\nOn WCN3990, we are seeing a rare scenario where copy engine hardware is\nsending a copy complete interrupt to the host driver while still\nprocessing the buffer that the driver has sent, this is leading into an\nSMMU fault triggering kernel panic. This is happening on copy engine\nchannel 3 (CE3) where the driver normally enqueues WMI commands to the\nfirmware. Upon receiving a copy complete interrupt, host driver will\nimmediately unmap and frees the buffer presuming that hardware has\nprocessed the buffer. In the issue case, upon receiving copy complete\ninterrupt, host driver will unmap and free the buffer but since hardware\nis still accessing the buffer (which in this case got unmapped in\nparallel), SMMU hardware will trigger an SMMU fault resulting in a\nkernel panic.\n\nIn order to avoid this, as a work around, add a delay before unmapping\nthe copy engine source DMA buffer. This is conditionally done for\nWCN3990 and only for the CE3 channel where issue is seen.\n\nBelow is the crash signature:\n\nwifi smmu error: kernel: [ 10.120965] arm-smmu 15000000.iommu: Unhandled\ncontext fault: fsr=0x402, iova=0x7fdfd8ac0,\nfsynr=0x500003,cbfrsynra=0xc1, cb=6 arm-smmu 15000000.iommu: Unhandled\ncontext fault:fsr=0x402, iova=0x7fe06fdc0, fsynr=0x710003,\ncbfrsynra=0xc1, cb=6 qcom-q6v5-mss 4080000.remoteproc: fatal error\nreceived: err_qdi.c:1040:EF:wlan_process:0x1:WLAN RT:0x2091:\ncmnos_thread.c:3998:Asserted in copy_engine.c:AXI_ERROR_DETECTED:2149\nremoteproc remoteproc0: crash detected in\n4080000.remoteproc: type fatal error <3> remoteproc remoteproc0:\nhandling crash #1 in 4080000.remoteproc\n\npc : __arm_lpae_unmap+0x500/0x514\nlr : __arm_lpae_unmap+0x4bc/0x514\nsp : ffffffc011ffb530\nx29: ffffffc011ffb590 x28: 0000000000000000\nx27: 0000000000000000 x26: 0000000000000004\nx25: 0000000000000003 x24: ffffffc011ffb890\nx23: ffffffa762ef9be0 x22: ffffffa77244ef00\nx21: 0000000000000009 x20: 00000007fff7c000\nx19: 0000000000000003 x18: 0000000000000000\nx17: 0000000000000004 x16: ffffffd7a357d9f0\nx15: 0000000000000000 x14: 00fd5d4fa7ffffff\nx13: 000000000000000e x12: 0000000000000000\nx11: 00000000ffffffff x10: 00000000fffffe00\nx9 : 000000000000017c x8 : 000000000000000c\nx7 : 0000000000000000 x6 : ffffffa762ef9000\nx5 : 0000000000000003 x4 : 0000000000000004\nx3 : 0000000000001000 x2 : 00000007fff7c000\nx1 : ffffffc011ffb890 x0 : 0000000000000000 Call trace:\n__arm_lpae_unmap+0x500/0x514\n__arm_lpae_unmap+0x4bc/0x514\n__arm_lpae_unmap+0x4bc/0x514\narm_lpae_unmap_pages+0x78/0xa4\narm_smmu_unmap_pages+0x78/0x104\n__iommu_unmap+0xc8/0x1e4\niommu_unmap_fast+0x38/0x48\n__iommu_dma_unmap+0x84/0x104\niommu_dma_free+0x34/0x50\ndma_free_attrs+0xa4/0xd0\nath10k_htt_rx_free+0xc4/0xf4 [ath10k_core] ath10k_core_stop+0x64/0x7c\n[ath10k_core]\nath10k_halt+0x11c/0x180 [ath10k_core]\nath10k_stop+0x54/0x94 [ath10k_core]\ndrv_stop+0x48/0x1c8 [mac80211]\nieee80211_do_open+0x638/0x77c [mac80211] ieee80211_open+0x48/0x5c\n[mac80211]\n__dev_open+0xb4/0x174\n__dev_change_flags+0xc4/0x1dc\ndev_change_flags+0x3c/0x7c\ndevinet_ioctl+0x2b4/0x580\ninet_ioctl+0xb0/0x1b4\nsock_do_ioctl+0x4c/0x16c\ncompat_ifreq_ioctl+0x1cc/0x35c\ncompat_sock_ioctl+0x110/0x2ac\n__arm64_compat_sys_ioctl+0xf4/0x3e0\nel0_svc_common+0xb4/0x17c\nel0_svc_compat_handler+0x2c/0x58\nel0_svc_compat+0x8/0x2c\n\nTested-on: WCN3990 hw1.0 SNOC WLAN.HL.2.0-01387-QCAHLSWMTPLZ-1",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68192",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: qmi_wwan: initialize MAC header offset in qmimux_rx_fixup\n\nRaw IP packets have no MAC header, leaving skb->mac_header uninitialized.\nThis can trigger kernel panics on ARM64 when xfrm or other subsystems\naccess the offset due to strict alignment checks.\n\nInitialize the MAC header to prevent such crashes.\n\nThis can trigger kernel panics on ARM when running IPsec over the\nqmimux0 interface.\n\nExample trace:\n\n    Internal error: Oops: 000000009600004f [#1] SMP\n    CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.34-gbe78e49cb433 #1\n    Hardware name: LS1028A RDB Board (DT)\n    pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n    pc : xfrm_input+0xde8/0x1318\n    lr : xfrm_input+0x61c/0x1318\n    sp : ffff800080003b20\n    Call trace:\n     xfrm_input+0xde8/0x1318\n     xfrm6_rcv+0x38/0x44\n     xfrm6_esp_rcv+0x48/0xa8\n     ip6_protocol_deliver_rcu+0x94/0x4b0\n     ip6_input_finish+0x44/0x70\n     ip6_input+0x44/0xc0\n     ipv6_rcv+0x6c/0x114\n     __netif_receive_skb_one_core+0x5c/0x8c\n     __netif_receive_skb+0x18/0x60\n     process_backlog+0x78/0x17c\n     __napi_poll+0x38/0x180\n     net_rx_action+0x168/0x2f0",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2023-53803",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ses: Fix slab-out-of-bounds in ses_enclosure_data_process()\n\nA fix for:\n\nBUG: KASAN: slab-out-of-bounds in ses_enclosure_data_process+0x949/0xe30 [ses]\nRead of size 1 at addr ffff88a1b043a451 by task systemd-udevd/3271\n\nChecking after (and before in next loop) addl_desc_ptr[1] is sufficient, we\nexpect the size to be sanitized before first access to addl_desc_ptr[1].\nMake sure we don't walk beyond end of page.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53762",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_sync: Fix UAF in hci_disconnect_all_sync\n\nUse-after-free can occur in hci_disconnect_all_sync if a connection is\ndeleted by concurrent processing of a controller event.\n\nTo prevent this the code now tries to iterate over the list backwards\nto ensure the links are cleanup before its parents, also it no longer\nrelies on a cursor, instead it always uses the last element since\nhci_abort_conn_sync is guaranteed to call hci_conn_del.\n\nUAF crash log:\n==================================================================\nBUG: KASAN: slab-use-after-free in hci_set_powered_sync\n(net/bluetooth/hci_sync.c:5424) [bluetooth]\nRead of size 8 at addr ffff888009d9c000 by task kworker/u9:0/124\n\nCPU: 0 PID: 124 Comm: kworker/u9:0 Tainted: G        W\n6.5.0-rc1+ #10\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\n1.16.2-1.fc38 04/01/2014\nWorkqueue: hci0 hci_cmd_sync_work [bluetooth]\nCall Trace:\n <TASK>\n dump_stack_lvl+0x5b/0x90\n print_report+0xcf/0x670\n ? __virt_addr_valid+0xdd/0x160\n ? hci_set_powered_sync+0x2c9/0x4a0 [bluetooth]\n kasan_report+0xa6/0xe0\n ? hci_set_powered_sync+0x2c9/0x4a0 [bluetooth]\n ? __pfx_set_powered_sync+0x10/0x10 [bluetooth]\n hci_set_powered_sync+0x2c9/0x4a0 [bluetooth]\n ? __pfx_hci_set_powered_sync+0x10/0x10 [bluetooth]\n ? __pfx_lock_release+0x10/0x10\n ? __pfx_set_powered_sync+0x10/0x10 [bluetooth]\n hci_cmd_sync_work+0x137/0x220 [bluetooth]\n process_one_work+0x526/0x9d0\n ? __pfx_process_one_work+0x10/0x10\n ? __pfx_do_raw_spin_lock+0x10/0x10\n ? mark_held_locks+0x1a/0x90\n worker_thread+0x92/0x630\n ? __pfx_worker_thread+0x10/0x10\n kthread+0x196/0x1e0\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x2c/0x50\n </TASK>\n\nAllocated by task 1782:\n kasan_save_stack+0x33/0x60\n kasan_set_track+0x25/0x30\n __kasan_kmalloc+0x8f/0xa0\n hci_conn_add+0xa5/0xa80 [bluetooth]\n hci_bind_cis+0x881/0x9b0 [bluetooth]\n iso_connect_cis+0x121/0x520 [bluetooth]\n iso_sock_connect+0x3f6/0x790 [bluetooth]\n __sys_connect+0x109/0x130\n __x64_sys_connect+0x40/0x50\n do_syscall_64+0x60/0x90\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\nFreed by task 695:\n kasan_save_stack+0x33/0x60\n kasan_set_track+0x25/0x30\n kasan_save_free_info+0x2b/0x50\n __kasan_slab_free+0x10a/0x180\n __kmem_cache_free+0x14d/0x2e0\n device_release+0x5d/0xf0\n kobject_put+0xdf/0x270\n hci_disconn_complete_evt+0x274/0x3a0 [bluetooth]\n hci_event_packet+0x579/0x7e0 [bluetooth]\n hci_rx_work+0x287/0xaa0 [bluetooth]\n process_one_work+0x526/0x9d0\n worker_thread+0x92/0x630\n kthread+0x196/0x1e0\n ret_from_fork+0x2c/0x50\n==================================================================",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68185",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfs4_setup_readdir(): insufficient locking for ->d_parent->d_inode dereferencing\n\nTheoretically it's an oopsable race, but I don't believe one can manage\nto hit it on real hardware; might become doable on a KVM, but it still\nwon't be easy to attack.\n\nAnyway, it's easy to deal with - since xdr_encode_hyper() is just a call of\nput_unaligned_be64(), we can put that under ->d_lock and be done with that.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53581",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Check for NOT_READY flag state after locking\n\nCurrently the check for NOT_READY flag is performed before obtaining the\nnecessary lock. This opens a possibility for race condition when the flow\nis concurrently removed from unready_flows list by the workqueue task,\nwhich causes a double-removal from the list and a crash[0]. Fix the issue\nby moving the flag check inside the section protected by\nuplink_priv->unready_flows_lock mutex.\n\n[0]:\n[44376.389654] general protection fault, probably for non-canonical address 0xdead000000000108: 0000 [#1] SMP\n[44376.391665] CPU: 7 PID: 59123 Comm: tc Not tainted 6.4.0-rc4+ #1\n[44376.392984] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[44376.395342] RIP: 0010:mlx5e_tc_del_fdb_flow+0xb3/0x340 [mlx5_core]\n[44376.396857] Code: 00 48 8b b8 68 ce 02 00 e8 8a 4d 02 00 4c 8d a8 a8 01 00 00 4c 89 ef e8 8b 79 88 e1 48 8b 83 98 06 00 00 48 8b 93 90 06 00 00 <48> 89 42 08 48 89 10 48 b8 00 01 00 00 00 00 ad de 48 89 83 90 06\n[44376.399167] RSP: 0018:ffff88812cc97570 EFLAGS: 00010246\n[44376.399680] RAX: dead000000000122 RBX: ffff8881088e3800 RCX: ffff8881881bac00\n[44376.400337] RDX: dead000000000100 RSI: ffff88812cc97500 RDI: ffff8881242f71b0\n[44376.401001] RBP: ffff88811cbb0940 R08: 0000000000000400 R09: 0000000000000001\n[44376.401663] R10: 0000000000000001 R11: 0000000000000000 R12: ffff88812c944000\n[44376.402342] R13: ffff8881242f71a8 R14: ffff8881222b4000 R15: 0000000000000000\n[44376.402999] FS:  00007f0451104800(0000) GS:ffff88852cb80000(0000) knlGS:0000000000000000\n[44376.403787] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[44376.404343] CR2: 0000000000489108 CR3: 0000000123a79003 CR4: 0000000000370ea0\n[44376.405004] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[44376.405665] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[44376.406339] Call Trace:\n[44376.406651]  <TASK>\n[44376.406939]  ? die_addr+0x33/0x90\n[44376.407311]  ? exc_general_protection+0x192/0x390\n[44376.407795]  ? asm_exc_general_protection+0x22/0x30\n[44376.408292]  ? mlx5e_tc_del_fdb_flow+0xb3/0x340 [mlx5_core]\n[44376.408876]  __mlx5e_tc_del_fdb_peer_flow+0xbc/0xe0 [mlx5_core]\n[44376.409482]  mlx5e_tc_del_flow+0x42/0x210 [mlx5_core]\n[44376.410055]  mlx5e_flow_put+0x25/0x50 [mlx5_core]\n[44376.410529]  mlx5e_delete_flower+0x24b/0x350 [mlx5_core]\n[44376.411043]  tc_setup_cb_reoffload+0x22/0x80\n[44376.411462]  fl_reoffload+0x261/0x2f0 [cls_flower]\n[44376.411907]  ? mlx5e_rep_indr_setup_ft_cb+0x160/0x160 [mlx5_core]\n[44376.412481]  ? mlx5e_rep_indr_setup_ft_cb+0x160/0x160 [mlx5_core]\n[44376.413044]  tcf_block_playback_offloads+0x76/0x170\n[44376.413497]  tcf_block_unbind+0x7b/0xd0\n[44376.413881]  tcf_block_setup+0x17d/0x1c0\n[44376.414269]  tcf_block_offload_cmd.isra.0+0xf1/0x130\n[44376.414725]  tcf_block_offload_unbind+0x43/0x70\n[44376.415153]  __tcf_block_put+0x82/0x150\n[44376.415532]  ingress_destroy+0x22/0x30 [sch_ingress]\n[44376.415986]  qdisc_destroy+0x3b/0xd0\n[44376.416343]  qdisc_graft+0x4d0/0x620\n[44376.416706]  tc_get_qdisc+0x1c9/0x3b0\n[44376.417074]  rtnetlink_rcv_msg+0x29c/0x390\n[44376.419978]  ? rep_movs_alternative+0x3a/0xa0\n[44376.420399]  ? rtnl_calcit.isra.0+0x120/0x120\n[44376.420813]  netlink_rcv_skb+0x54/0x100\n[44376.421192]  netlink_unicast+0x1f6/0x2c0\n[44376.421573]  netlink_sendmsg+0x232/0x4a0\n[44376.421980]  sock_sendmsg+0x38/0x60\n[44376.422328]  ____sys_sendmsg+0x1d0/0x1e0\n[44376.422709]  ? copy_msghdr_from_user+0x6d/0xa0\n[44376.423127]  ___sys_sendmsg+0x80/0xc0\n[44376.423495]  ? ___sys_recvmsg+0x8b/0xc0\n[44376.423869]  __sys_sendmsg+0x51/0x90\n[44376.424226]  do_syscall_64+0x3d/0x90\n[44376.424587]  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n[44376.425046] RIP: 0033:0x7f045134f887\n[44376.425403] Code: 0a 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b9 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2e 00\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53764",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath12k: Handle lock during peer_id find\n\nath12k_peer_find_by_id() requires that the caller hold the\nab->base_lock. Currently the WBM error path does not hold\nthe lock and calling that function, leads to the\nfollowing lockdep_assert()in QCN9274:\n\n[105162.160893] ------------[ cut here ]------------\n[105162.160916] WARNING: CPU: 3 PID: 0 at drivers/net/wireless/ath/ath12k/peer.c:71 ath12k_peer_find_by_id+0x52/0x60 [ath12k]\n[105162.160933] Modules linked in: ath12k(O) qrtr_mhi qrtr mac80211 cfg80211 mhi qmi_helpers libarc4 nvme nvme_core [last unloaded: ath12k(O)]\n[105162.160967] CPU: 3 PID: 0 Comm: swapper/3 Tainted: G        W  O       6.1.0-rc2+ #3\n[105162.160972] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0056.2019.0506.1527 05/06/2019\n[105162.160977] RIP: 0010:ath12k_peer_find_by_id+0x52/0x60 [ath12k]\n[105162.160990] Code: 07 eb 0f 39 68 24 74 0a 48 8b 00 48 39 f8 75 f3 31 c0 5b 5d c3 48 8d bf b0 f2 00 00 be ff ff ff ff e8 22 20 c4 e2 85 c0 75 bf <0f> 0b eb bb 66 2e 0f 1f 84 00 00 00 00 00 41 54 4c 8d a7 98 f2 00\n[105162.160996] RSP: 0018:ffffa223001acc60 EFLAGS: 00010246\n[105162.161003] RAX: 0000000000000000 RBX: ffff9f0573940000 RCX: 0000000000000000\n[105162.161008] RDX: 0000000000000001 RSI: ffffffffa3951c8e RDI: ffffffffa39a96d7\n[105162.161013] RBP: 000000000000000a R08: 0000000000000000 R09: 0000000000000000\n[105162.161017] R10: ffffa223001acb40 R11: ffffffffa3d57c60 R12: ffff9f057394f2e0\n[105162.161022] R13: ffff9f0573940000 R14: ffff9f04ecd659c0 R15: ffff9f04d5a9b040\n[105162.161026] FS:  0000000000000000(0000) GS:ffff9f0575600000(0000) knlGS:0000000000000000\n[105162.161031] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[105162.161036] CR2: 00001d5c8277a008 CR3: 00000001e6224006 CR4: 00000000003706e0\n[105162.161041] Call Trace:\n[105162.161046]  <IRQ>\n[105162.161051]  ath12k_dp_rx_process_wbm_err+0x6da/0xaf0 [ath12k]\n[105162.161072]  ? ath12k_dp_rx_process_err+0x80e/0x15a0 [ath12k]\n[105162.161084]  ? __lock_acquire+0x4ca/0x1a60\n[105162.161104]  ath12k_dp_service_srng+0x263/0x310 [ath12k]\n[105162.161120]  ath12k_pci_ext_grp_napi_poll+0x1c/0x70 [ath12k]\n[105162.161133]  __napi_poll+0x22/0x260\n[105162.161141]  net_rx_action+0x2f8/0x380\n[105162.161153]  __do_softirq+0xd0/0x4c9\n[105162.161162]  irq_exit_rcu+0x88/0xe0\n[105162.161169]  common_interrupt+0xa5/0xc0\n[105162.161174]  </IRQ>\n[105162.161179]  <TASK>\n[105162.161184]  asm_common_interrupt+0x22/0x40\n\nHandle spin lock/unlock in WBM error path to hold the necessary lock\nexpected by ath12k_peer_find_by_id().\n\nTested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0-03171-QCAHKSWPL_SILICONZ-1",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40271",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/proc: fix uaf in proc_readdir_de()\n\nPde is erased from subdir rbtree through rb_erase(), but not set the node\nto EMPTY, which may result in uaf access.  We should use RB_CLEAR_NODE()\nset the erased node to EMPTY, then pde_subdir_next() will return NULL to\navoid uaf access.\n\nWe found an uaf issue while using stress-ng testing, need to run testcase\ngetdent and tun in the same time.  The steps of the issue is as follows:\n\n1) use getdent to traverse dir /proc/pid/net/dev_snmp6/, and current\n   pde is tun3;\n\n2) in the [time windows] unregister netdevice tun3 and tun2, and erase\n   them from rbtree.  erase tun3 first, and then erase tun2.  the\n   pde(tun2) will be released to slab;\n\n3) continue to getdent process, then pde_subdir_next() will return\n   pde(tun2) which is released, it will case uaf access.\n\nCPU 0                                      |    CPU 1\n-------------------------------------------------------------------------\ntraverse dir /proc/pid/net/dev_snmp6/      |   unregister_netdevice(tun->dev)   //tun3 tun2\nsys_getdents64()                           |\n  iterate_dir()                            |\n    proc_readdir()                         |\n      proc_readdir_de()                    |     snmp6_unregister_dev()\n        pde_get(de);                       |       proc_remove()\n        read_unlock(&proc_subdir_lock);    |         remove_proc_subtree()\n                                           |           write_lock(&proc_subdir_lock);\n        [time window]                      |           rb_erase(&root->subdir_node, &parent->subdir);\n                                           |           write_unlock(&proc_subdir_lock);\n        read_lock(&proc_subdir_lock);      |\n        next = pde_subdir_next(de);        |\n        pde_put(de);                       |\n        de = next;    //UAF                |\n\nrbtree of dev_snmp6\n                        |\n                    pde(tun3)\n                     /    \\\n                  NULL  pde(tun2)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-06",
                    "modification_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50638",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix bug_on in __es_tree_search caused by bad boot loader inode\n\nWe got a issue as fllows:\n==================================================================\n kernel BUG at fs/ext4/extents_status.c:203!\n invalid opcode: 0000 [#1] PREEMPT SMP\n CPU: 1 PID: 945 Comm: cat Not tainted 6.0.0-next-20221007-dirty #349\n RIP: 0010:ext4_es_end.isra.0+0x34/0x42\n RSP: 0018:ffffc9000143b768 EFLAGS: 00010203\n RAX: 0000000000000000 RBX: ffff8881769cd0b8 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffffffff8fc27cf7 RDI: 00000000ffffffff\n RBP: ffff8881769cd0bc R08: 0000000000000000 R09: ffffc9000143b5f8\n R10: 0000000000000001 R11: 0000000000000001 R12: ffff8881769cd0a0\n R13: ffff8881768e5668 R14: 00000000768e52f0 R15: 0000000000000000\n FS: 00007f359f7f05c0(0000)GS:ffff88842fd00000(0000)knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f359f5a2000 CR3: 000000017130c000 CR4: 00000000000006e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <TASK>\n  __es_tree_search.isra.0+0x6d/0xf5\n  ext4_es_cache_extent+0xfa/0x230\n  ext4_cache_extents+0xd2/0x110\n  ext4_find_extent+0x5d5/0x8c0\n  ext4_ext_map_blocks+0x9c/0x1d30\n  ext4_map_blocks+0x431/0xa50\n  ext4_mpage_readpages+0x48e/0xe40\n  ext4_readahead+0x47/0x50\n  read_pages+0x82/0x530\n  page_cache_ra_unbounded+0x199/0x2a0\n  do_page_cache_ra+0x47/0x70\n  page_cache_ra_order+0x242/0x400\n  ondemand_readahead+0x1e8/0x4b0\n  page_cache_sync_ra+0xf4/0x110\n  filemap_get_pages+0x131/0xb20\n  filemap_read+0xda/0x4b0\n  generic_file_read_iter+0x13a/0x250\n  ext4_file_read_iter+0x59/0x1d0\n  vfs_read+0x28f/0x460\n  ksys_read+0x73/0x160\n  __x64_sys_read+0x1e/0x30\n  do_syscall_64+0x35/0x80\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  </TASK>\n==================================================================\n\nIn the above issue, ioctl invokes the swap_inode_boot_loader function to\nswap inode<5> and inode<12>. However, inode<5> contain incorrect imode and\ndisordered extents, and i_nlink is set to 1. The extents check for inode in\nthe ext4_iget function can be bypassed bacause 5 is EXT4_BOOT_LOADER_INO.\nWhile links_count is set to 1, the extents are not initialized in\nswap_inode_boot_loader. After the ioctl command is executed successfully,\nthe extents are swapped to inode<12>, in this case, run the `cat` command\nto view inode<12>. And Bug_ON is triggered due to the incorrect extents.\n\nWhen the boot loader inode is not initialized, its imode can be one of the\nfollowing:\n1) the imode is a bad type, which is marked as bad_inode in ext4_iget and\n   set to S_IFREG.\n2) the imode is good type but not S_IFREG.\n3) the imode is S_IFREG.\n\nThe BUG_ON may be triggered by bypassing the check in cases 1 and 2.\nTherefore, when the boot loader inode is bad_inode or its imode is not\nS_IFREG, initialize the inode to avoid triggering the BUG.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53833",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915: Fix NULL ptr deref by checking new_crtc_state\n\nintel_atomic_get_new_crtc_state can return NULL, unless crtc state wasn't\nobtained previously with intel_atomic_get_crtc_state, so we must check it\nfor NULLness here, just as in many other places, where we can't guarantee\nthat intel_atomic_get_crtc_state was called.\nWe are currently getting NULL ptr deref because of that, so this fix was\nconfirmed to help.\n\n(cherry picked from commit 1d5b09f8daf859247a1ea65b0d732a24d88980d8)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68211",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nksm: use range-walk function to jump over holes in scan_get_next_rmap_item\n\nCurrently, scan_get_next_rmap_item() walks every page address in a VMA to\nlocate mergeable pages.  This becomes highly inefficient when scanning\nlarge virtual memory areas that contain mostly unmapped regions, causing\nksmd to use large amount of cpu without deduplicating much pages.\n\nThis patch replaces the per-address lookup with a range walk using\nwalk_page_range().  The range walker allows KSM to skip over entire\nunmapped holes in a VMA, avoiding unnecessary lookups.  This problem was\npreviously discussed in [1].\n\nConsider the following test program which creates a 32 TiB mapping in the\nvirtual address space but only populates a single page:\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/mman.h>\n\n/* 32 TiB */\nconst size_t size = 32ul * 1024 * 1024 * 1024 * 1024;\n\nint main() {\n        char *area = mmap(NULL, size, PROT_READ | PROT_WRITE,\n                          MAP_NORESERVE | MAP_PRIVATE | MAP_ANON, -1, 0);\n\n        if (area == MAP_FAILED) {\n                perror(\"mmap() failed\\n\");\n                return -1;\n        }\n\n        /* Populate a single page such that we get an anon_vma. */\n        *area = 0;\n\n        /* Enable KSM. */\n        madvise(area, size, MADV_MERGEABLE);\n        pause();\n        return 0;\n}\n\n$ ./ksm-sparse  &\n$ echo 1 > /sys/kernel/mm/ksm/run \n\nWithout this patch ksmd uses 100% of the cpu for a long time (more then 1\nhour in my test machine) scanning all the 32 TiB virtual address space\nthat contain only one mapped page.  This makes ksmd essentially deadlocked\nnot able to deduplicate anything of value.  With this patch ksmd walks\nonly the one mapped page and skips the rest of the 32 TiB virtual address\nspace, making the scan fast using little cpu.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-71094",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: asix: validate PHY address before use\n\nThe ASIX driver reads the PHY address from the USB device via\nasix_read_phy_addr(). A malicious or faulty device can return an\ninvalid address (>= PHY_MAX_ADDR), which causes a warning in\nmdiobus_get_phy():\n\n  addr 207 out of range\n  WARNING: drivers/net/phy/mdio_bus.c:76\n\nValidate the PHY address in asix_read_phy_addr() and remove the\nnow-redundant check in ax88172a.c.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2026-01-13",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40363",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv6: fix field-spanning memcpy warning in AH output\n\nFix field-spanning memcpy warnings in ah6_output() and\nah6_output_done() where extension headers are copied to/from IPv6\naddress fields, triggering fortify-string warnings about writes beyond\nthe 16-byte address fields.\n\n  memcpy: detected field-spanning write (size 40) of single field \"&top_iph->saddr\" at net/ipv6/ah6.c:439 (size 16)\n  WARNING: CPU: 0 PID: 8838 at net/ipv6/ah6.c:439 ah6_output+0xe7e/0x14e0 net/ipv6/ah6.c:439\n\nThe warnings are false positives as the extension headers are\nintentionally placed after the IPv6 header in memory. Fix by properly\ncopying addresses and extension headers separately, and introduce\nhelper functions to avoid code duplication.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40220",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfuse: fix livelock in synchronous file put from fuseblk workers\n\nI observed a hang when running generic/323 against a fuseblk server.\nThis test opens a file, initiates a lot of AIO writes to that file\ndescriptor, and closes the file descriptor before the writes complete.\nUnsurprisingly, the AIO exerciser threads are mostly stuck waiting for\nresponses from the fuseblk server:\n\n# cat /proc/372265/task/372313/stack\n[<0>] request_wait_answer+0x1fe/0x2a0 [fuse]\n[<0>] __fuse_simple_request+0xd3/0x2b0 [fuse]\n[<0>] fuse_do_getattr+0xfc/0x1f0 [fuse]\n[<0>] fuse_file_read_iter+0xbe/0x1c0 [fuse]\n[<0>] aio_read+0x130/0x1e0\n[<0>] io_submit_one+0x542/0x860\n[<0>] __x64_sys_io_submit+0x98/0x1a0\n[<0>] do_syscall_64+0x37/0xf0\n[<0>] entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\nBut the /weird/ part is that the fuseblk server threads are waiting for\nresponses from itself:\n\n# cat /proc/372210/task/372232/stack\n[<0>] request_wait_answer+0x1fe/0x2a0 [fuse]\n[<0>] __fuse_simple_request+0xd3/0x2b0 [fuse]\n[<0>] fuse_file_put+0x9a/0xd0 [fuse]\n[<0>] fuse_release+0x36/0x50 [fuse]\n[<0>] __fput+0xec/0x2b0\n[<0>] task_work_run+0x55/0x90\n[<0>] syscall_exit_to_user_mode+0xe9/0x100\n[<0>] do_syscall_64+0x43/0xf0\n[<0>] entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\nThe fuseblk server is fuse2fs so there's nothing all that exciting in\nthe server itself.  So why is the fuse server calling fuse_file_put?\nThe commit message for the fstest sheds some light on that:\n\n\"By closing the file descriptor before calling io_destroy, you pretty\nmuch guarantee that the last put on the ioctx will be done in interrupt\ncontext (during I/O completion).\n\nAha.  AIO fgets a new struct file from the fd when it queues the ioctx.\nThe completion of the FUSE_WRITE command from userspace causes the fuse\nserver to call the AIO completion function.  The completion puts the\nstruct file, queuing a delayed fput to the fuse server task.  When the\nfuse server task returns to userspace, it has to run the delayed fput,\nwhich in the case of a fuseblk server, it does synchronously.\n\nSending the FUSE_RELEASE command sychronously from fuse server threads\nis a bad idea because a client program can initiate enough simultaneous\nAIOs such that all the fuse server threads end up in delayed_fput, and\nnow there aren't any threads left to handle the queued fuse commands.\n\nFix this by only using asynchronous fputs when closing files, and leave\na comment explaining why.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53780",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: fix FCLK pstate change underflow\n\n[Why]\nCurrently we set FCLK p-state change\nwatermark calculated based on dummy\np-state latency when UCLK p-state is\nnot supported\n\n[How]\nCalculate FCLK p-state change watermark\nbased on on FCLK pstate change latency\nin case UCLK p-state is not supported",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-40490",
                    "description": "A race condition was discovered in ext4_write_inline_data_end in fs/ext4/inline.c in the ext4 subsystem in the Linux kernel through 5.13.13.",
                    "nvd_score": 4.4,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:M/Au:N/C:P/I:P/A:P",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-40490",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-09-03",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48790",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme: fix a possible use-after-free in controller reset during load\n\nUnlike .queue_rq, in .submit_async_event drivers may not check the ctrl\nreadiness for AER submission. This may lead to a use-after-free\ncondition that was observed with nvme-tcp.\n\nThe race condition may happen in the following scenario:\n1. driver executes its reset_ctrl_work\n2. -> nvme_stop_ctrl - flushes ctrl async_event_work\n3. ctrl sends AEN which is received by the host, which in turn\n   schedules AEN handling\n4. teardown admin queue (which releases the queue socket)\n5. AEN processed, submits another AER, calling the driver to submit\n6. driver attempts to send the cmd\n==> use-after-free\n\nIn order to fix that, add ctrl state check to validate the ctrl\nis actually able to accept the AER submission.\n\nThis addresses the above race in controller resets because the driver\nduring teardown should:\n1. change ctrl state to RESETTING\n2. flush async_event_work (as well as other async work elements)\n\nSo after 1,2, any other AER command will find the\nctrl state to be RESETTING and bail out without submitting the AER.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48790",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38051",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: Fix use-after-free in cifs_fill_dirent\n\nThere is a race condition in the readdir concurrency process, which may\naccess the rsp buffer after it has been released, triggering the\nfollowing KASAN warning.\n\n ==================================================================\n BUG: KASAN: slab-use-after-free in cifs_fill_dirent+0xb03/0xb60 [cifs]\n Read of size 4 at addr ffff8880099b819c by task a.out/342975\n\n CPU: 2 UID: 0 PID: 342975 Comm: a.out Not tainted 6.15.0-rc6+ #240 PREEMPT(full)\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x53/0x70\n  print_report+0xce/0x640\n  kasan_report+0xb8/0xf0\n  cifs_fill_dirent+0xb03/0xb60 [cifs]\n  cifs_readdir+0x12cb/0x3190 [cifs]\n  iterate_dir+0x1a1/0x520\n  __x64_sys_getdents+0x134/0x220\n  do_syscall_64+0x4b/0x110\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n RIP: 0033:0x7f996f64b9f9\n Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89\n f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01\n f0 ff ff  0d f7 c3 0c 00 f7 d8 64 89 8\n RSP: 002b:00007f996f53de78 EFLAGS: 00000207 ORIG_RAX: 000000000000004e\n RAX: ffffffffffffffda RBX: 00007f996f53ecdc RCX: 00007f996f64b9f9\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\n RBP: 00007f996f53dea0 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000207 R12: ffffffffffffff88\n R13: 0000000000000000 R14: 00007ffc8cd9a500 R15: 00007f996f51e000\n  </TASK>\n\n Allocated by task 408:\n  kasan_save_stack+0x20/0x40\n  kasan_save_track+0x14/0x30\n  __kasan_slab_alloc+0x6e/0x70\n  kmem_cache_alloc_noprof+0x117/0x3d0\n  mempool_alloc_noprof+0xf2/0x2c0\n  cifs_buf_get+0x36/0x80 [cifs]\n  allocate_buffers+0x1d2/0x330 [cifs]\n  cifs_demultiplex_thread+0x22b/0x2690 [cifs]\n  kthread+0x394/0x720\n  ret_from_fork+0x34/0x70\n  ret_from_fork_asm+0x1a/0x30\n\n Freed by task 342979:\n  kasan_save_stack+0x20/0x40\n  kasan_save_track+0x14/0x30\n  kasan_save_free_info+0x3b/0x60\n  __kasan_slab_free+0x37/0x50\n  kmem_cache_free+0x2b8/0x500\n  cifs_buf_release+0x3c/0x70 [cifs]\n  cifs_readdir+0x1c97/0x3190 [cifs]\n  iterate_dir+0x1a1/0x520\n  __x64_sys_getdents64+0x134/0x220\n  do_syscall_64+0x4b/0x110\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\n The buggy address belongs to the object at ffff8880099b8000\n  which belongs to the cache cifs_request of size 16588\n The buggy address is located 412 bytes inside of\n  freed 16588-byte region [ffff8880099b8000, ffff8880099bc0cc)\n\n The buggy address belongs to the physical page:\n page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x99b8\n head: order:3 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n anon flags: 0x80000000000040(head|node=0|zone=1)\n page_type: f5(slab)\n raw: 0080000000000040 ffff888001e03400 0000000000000000 dead000000000001\n raw: 0000000000000000 0000000000010001 00000000f5000000 0000000000000000\n head: 0080000000000040 ffff888001e03400 0000000000000000 dead000000000001\n head: 0000000000000000 0000000000010001 00000000f5000000 0000000000000000\n head: 0080000000000003 ffffea0000266e01 00000000ffffffff 00000000ffffffff\n head: ffffffffffffffff 0000000000000000 00000000ffffffff 0000000000000008\n page dumped because: kasan: bad access detected\n\n Memory state around the buggy address:\n  ffff8880099b8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff8880099b8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n >ffff8880099b8180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                             ^\n  ffff8880099b8200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  ffff8880099b8280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ==================================================================\n\nPOC is available in the link [1].\n\nThe problem triggering process is as follows:\n\nProcess 1                       Process 2\n-----------------------------------\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38051",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2026-01-12",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54110",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: rndis_host: Secure rndis_query check against int overflow\n\nVariables off and len typed as uint32 in rndis_query function\nare controlled by incoming RNDIS response message thus their\nvalue may be manipulated. Setting off to a unexpectetly large\nvalue will cause the sum with len and 8 to overflow and pass\nthe implemented validation step. Consequently the response\npointer will be referring to a location past the expected\nbuffer boundaries allowing information leakage e.g. via\nRNDIS_OID_802_3_PERMANENT_ADDRESS OID.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-40281",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: prevent possible shift-out-of-bounds in sctp_transport_update_rto\n\nsyzbot reported a possible shift-out-of-bounds [1]\n\nBlamed commit added rto_alpha_max and rto_beta_max set to 1000.\n\nIt is unclear if some sctp users are setting very large rto_alpha\nand/or rto_beta.\n\nIn order to prevent user regression, perform the test at run time.\n\nAlso add READ_ONCE() annotations as sysctl values can change under us.\n\n[1]\n\nUBSAN: shift-out-of-bounds in net/sctp/transport.c:509:41\nshift exponent 64 is too large for 32-bit type 'unsigned int'\nCPU: 0 UID: 0 PID: 16704 Comm: syz.2.2320 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/02/2025\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:94 [inline]\n  dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120\n  ubsan_epilogue lib/ubsan.c:233 [inline]\n  __ubsan_handle_shift_out_of_bounds+0x27f/0x420 lib/ubsan.c:494\n  sctp_transport_update_rto.cold+0x1c/0x34b net/sctp/transport.c:509\n  sctp_check_transmitted+0x11c4/0x1c30 net/sctp/outqueue.c:1502\n  sctp_outq_sack+0x4ef/0x1b20 net/sctp/outqueue.c:1338\n  sctp_cmd_process_sack net/sctp/sm_sideeffect.c:840 [inline]\n  sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1372 [inline]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-06",
                    "modification_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40324",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix crash in nfsd4_read_release()\n\nWhen tracing is enabled, the trace_nfsd_read_done trace point\ncrashes during the pynfs read.testNoFh test.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-43882",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nexec: Fix ToCToU between perm check and set-uid/gid usage\n\nWhen opening a file for exec via do_filp_open(), permission checking is\ndone against the file's metadata at that moment, and on success, a file\npointer is passed back. Much later in the execve() code path, the file\nmetadata (specifically mode, uid, and gid) is used to determine if/how\nto set the uid and gid. However, those values may have changed since the\npermissions check, meaning the execution may gain unintended privileges.\n\nFor example, if a file could change permissions from executable and not\nset-id:\n\n---------x 1 root root 16048 Aug  7 13:16 target\n\nto set-id and non-executable:\n\n---S------ 1 root root 16048 Aug  7 13:16 target\n\nit is possible to gain root privileges when execution should have been\ndisallowed.\n\nWhile this race condition is rare in real-world scenarios, it has been\nobserved (and proven exploitable) when package managers are updating\nthe setuid bits of installed programs. Such files start with being\nworld-executable but then are adjusted to be group-exec with a set-uid\nbit. For example, \"chmod o-x,u+s target\" makes \"target\" executable only\nby uid \"root\" and gid \"cdrom\", while also becoming setuid-root:\n\n-rwxr-xr-x 1 root cdrom 16048 Aug  7 13:16 target\n\nbecomes:\n\n-rwsr-xr-- 1 root cdrom 16048 Aug  7 13:16 target\n\nBut racing the chmod means users without group \"cdrom\" membership can\nget the permission to execute \"target\" just before the chmod, and when\nthe chmod finishes, the exec reaches brpm_fill_uid(), and performs the\nsetuid to root, violating the expressed authorization of \"only cdrom\ngroup members can setuid to root\".\n\nRe-check that we still have execute permissions in case the metadata\nhas changed. It would be better to keep a copy from the perm-check time,\nbut until we can do that refactoring, the least-bad option is to do a\nfull inode_permission() call (under inode lock). It is understood that\nthis is safe against dead-locks, but hardly optimal.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-43882",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40215",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: delete x->tunnel as we delete x\n\nThe ipcomp fallback tunnels currently get deleted (from the various\nlists and hashtables) as the last user state that needed that fallback\nis destroyed (not deleted). If a reference to that user state still\nexists, the fallback state will remain on the hashtables/lists,\ntriggering the WARN in xfrm_state_fini. Because of those remaining\nreferences, the fix in commit f75a2804da39 (\"xfrm: destroy xfrm_state\nsynchronously on net exit path\") is not complete.\n\nWe recently fixed one such situation in TCP due to defered freeing of\nskbs (commit 9b6412e6979f (\"tcp: drop secpath at the same time as we\ncurrently drop dst\")). This can also happen due to IP reassembly: skbs\nwith a secpath remain on the reassembly queue until netns\ndestruction. If we can't guarantee that the queues are flushed by the\ntime xfrm_state_fini runs, there may still be references to a (user)\nxfrm_state, preventing the timely deletion of the corresponding\nfallback state.\n\nInstead of chasing each instance of skbs holding a secpath one by one,\nthis patch fixes the issue directly within xfrm, by deleting the\nfallback state as soon as the last user state depending on it has been\ndeleted. Destruction will still happen when the final reference is\ndropped.\n\nA separate lockdep class for the fallback state is required since\nwe're going to lock x->tunnel while x is locked.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53765",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: free background tracker's queued work in btracker_destroy\n\nOtherwise the kernel can BUG with:\n\n[ 2245.426978] =============================================================================\n[ 2245.435155] BUG bt_work (Tainted: G    B   W         ): Objects remaining in bt_work on __kmem_cache_shutdown()\n[ 2245.445233] -----------------------------------------------------------------------------\n[ 2245.445233]\n[ 2245.454879] Slab 0x00000000b0ce2b30 objects=64 used=2 fp=0x000000000a3c6a4e flags=0x17ffffc0000200(slab|node=0|zone=2|lastcpupid=0x1fffff)\n[ 2245.467300] CPU: 7 PID: 10805 Comm: lvm Kdump: loaded Tainted: G    B   W          6.0.0-rc2 #19\n[ 2245.476078] Hardware name: Dell Inc. PowerEdge R7525/0590KW, BIOS 2.5.6 10/06/2021\n[ 2245.483646] Call Trace:\n[ 2245.486100]  <TASK>\n[ 2245.488206]  dump_stack_lvl+0x34/0x48\n[ 2245.491878]  slab_err+0x95/0xcd\n[ 2245.495028]  __kmem_cache_shutdown.cold+0x31/0x136\n[ 2245.499821]  kmem_cache_destroy+0x49/0x130\n[ 2245.503928]  btracker_destroy+0x12/0x20 [dm_cache]\n[ 2245.508728]  smq_destroy+0x15/0x60 [dm_cache_smq]\n[ 2245.513435]  dm_cache_policy_destroy+0x12/0x20 [dm_cache]\n[ 2245.518834]  destroy+0xc0/0x110 [dm_cache]\n[ 2245.522933]  dm_table_destroy+0x5c/0x120 [dm_mod]\n[ 2245.527649]  __dm_destroy+0x10e/0x1c0 [dm_mod]\n[ 2245.532102]  dev_remove+0x117/0x190 [dm_mod]\n[ 2245.536384]  ctl_ioctl+0x1a2/0x290 [dm_mod]\n[ 2245.540579]  dm_ctl_ioctl+0xa/0x20 [dm_mod]\n[ 2245.544773]  __x64_sys_ioctl+0x8a/0xc0\n[ 2245.548524]  do_syscall_64+0x5c/0x90\n[ 2245.552104]  ? syscall_exit_to_user_mode+0x12/0x30\n[ 2245.556897]  ? do_syscall_64+0x69/0x90\n[ 2245.560648]  ? do_syscall_64+0x69/0x90\n[ 2245.564394]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[ 2245.569447] RIP: 0033:0x7fe52583ec6b\n...\n[ 2245.646771] ------------[ cut here ]------------\n[ 2245.651395] kmem_cache_destroy bt_work: Slab cache still has objects when called from btracker_destroy+0x12/0x20 [dm_cache]\n[ 2245.651408] WARNING: CPU: 7 PID: 10805 at mm/slab_common.c:478 kmem_cache_destroy+0x128/0x130\n\nFound using: lvm2-testsuite --only \"cache-single-split.sh\"\n\nBen bisected and found that commit 0495e337b703 (\"mm/slab_common:\nDeleting kobject in kmem_cache_destroy() without holding\nslab_mutex/cpu_hotplug_lock\") first exposed dm-cache's incomplete\ncleanup of its background tracker work objects.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38107",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: ets: fix a race in ets_qdisc_change()\n\nGerrard Tai reported a race condition in ETS, whenever SFQ perturb timer\nfires at the wrong time.\n\nThe race is as follows:\n\nCPU 0                                 CPU 1\n[1]: lock root\n[2]: qdisc_tree_flush_backlog()\n[3]: unlock root\n |\n |                                    [5]: lock root\n |                                    [6]: rehash\n |                                    [7]: qdisc_tree_reduce_backlog()\n |\n[4]: qdisc_put()\n\nThis can be abused to underflow a parent's qlen.\n\nCalling qdisc_purge_queue() instead of qdisc_tree_flush_backlog()\nshould fix the race, because all packets will be purged from the qdisc\nbefore releasing the lock.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38107",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40096",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/sched: Fix potential double free in drm_sched_job_add_resv_dependencies\n\nWhen adding dependencies with drm_sched_job_add_dependency(), that\nfunction consumes the fence reference both on success and failure, so in\nthe latter case the dma_fence_put() on the error path (xarray failed to\nexpand) is a double free.\n\nInterestingly this bug appears to have been present ever since\ncommit ebd5f74255b9 (\"drm/sched: Add dependency tracking\"), since the code\nback then looked like this:\n\ndrm_sched_job_add_implicit_dependencies():\n...\n       for (i = 0; i < fence_count; i++) {\n               ret = drm_sched_job_add_dependency(job, fences[i]);\n               if (ret)\n                       break;\n       }\n\n       for (; i < fence_count; i++)\n               dma_fence_put(fences[i]);\n\nWhich means for the failing 'i' the dma_fence_put was already a double\nfree. Possibly there were no users at that time, or the test cases were\ninsufficient to hit it.\n\nThe bug was then only noticed and fixed after\ncommit 9c2ba265352a (\"drm/scheduler: use new iterator in drm_sched_job_add_implicit_dependencies v2\")\nlanded, with its fixup of\ncommit 4eaf02d6076c (\"drm/scheduler: fix drm_sched_job_add_implicit_dependencies\").\n\nAt that point it was a slightly different flavour of a double free, which\ncommit 963d0b356935 (\"drm/scheduler: fix drm_sched_job_add_implicit_dependencies harder\")\nnoticed and attempted to fix.\n\nBut it only moved the double free from happening inside the\ndrm_sched_job_add_dependency(), when releasing the reference not yet\nobtained, to the caller, when releasing the reference already released by\nthe former in the failure case.\n\nAs such it is not easy to identify the right target for the fixes tag so\nlets keep it simple and just continue the chain.\n\nWhile fixing we also improve the comment and explain the reason for taking\nthe reference and not dropping it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-38561",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkunit: Fix kthread reference\n\nThere is a race condition when a kthread finishes after the deadline and\nbefore the call to kthread_stop(), which may lead to use after free.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38561",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40154",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: Intel: bytcr_rt5640: Fix invalid quirk input mapping\n\nWhen an invalid value is passed via quirk option, currently\nbytcr_rt5640 driver only shows an error message but leaves as is.\nThis may lead to unepxected results like OOB access.\n\nThis patch corrects the input mapping to the certain default value if\nan invalid value is passed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50717",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet-tcp: add bounds check on Transfer Tag\n\nttag is used as an index to get cmd in nvmet_tcp_handle_h2c_data_pdu(),\nadd a bounds check to avoid out-of-bounds access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-37915",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: drr: Fix double list add in class with netem as child qdisc\n\nAs described in Gerrard's report [1], there are use cases where a netem\nchild qdisc will make the parent qdisc's enqueue callback reentrant.\nIn the case of drr, there won't be a UAF, but the code will add the same\nclassifier to the list twice, which will cause memory corruption.\n\nIn addition to checking for qlen being zero, this patch checks whether the\nclass was already added to the active_list (cl_is_active) before adding\nto the list to cover for the reentrant case.\n\n[1] https://lore.kernel.org/netdev/CAHcdcOm+03OD2j6R0=YHKqmy=VgJ8xEOKuP6c7mSgnp-TEJJbw@mail.gmail.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-37915",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-20",
                    "modification_date": "2025-11-17",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54028",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix the error \"trying to register non-static key in rxe_cleanup_task\"\n\nIn the function rxe_create_qp(), rxe_qp_from_init() is called to\ninitialize qp, internally things like rxe_init_task are not setup until\nrxe_qp_init_req().\n\nIf an error occurred before this point then the unwind will call\nrxe_cleanup() and eventually to rxe_qp_do_cleanup()/rxe_cleanup_task()\nwhich will oops when trying to access the uninitialized spinlock.\n\nIf rxe_init_task is not executed, rxe_cleanup_task will not be called.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68301",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atlantic: fix fragment overflow handling in RX path\n\nThe atlantic driver can receive packets with more than MAX_SKB_FRAGS (17)\nfragments when handling large multi-descriptor packets. This causes an\nout-of-bounds write in skb_add_rx_frag_netmem() leading to kernel panic.\n\nThe issue occurs because the driver doesn't check the total number of\nfragments before calling skb_add_rx_frag(). When a packet requires more\nthan MAX_SKB_FRAGS fragments, the fragment index exceeds the array bounds.\n\nFix by assuming there will be an extra frag if buff->len > AQ_CFG_RX_HDR_SIZE,\nthen all fragments are accounted for. And reusing the existing check to\nprevent the overflow earlier in the code path.\n\nThis crash occurred in production with an Aquantia AQC113 10G NIC.\n\nStack trace from production environment:\n```\nRIP: 0010:skb_add_rx_frag_netmem+0x29/0xd0\nCode: 90 f3 0f 1e fa 0f 1f 44 00 00 48 89 f8 41 89\nca 48 89 d7 48 63 ce 8b 90 c0 00 00 00 48 c1 e1 04 48 01 ca 48 03 90\nc8 00 00 00 <48> 89 7a 30 44 89 52 3c 44 89 42 38 40 f6 c7 01 75 74 48\n89 fa 83\nRSP: 0018:ffffa9bec02a8d50 EFLAGS: 00010287\nRAX: ffff925b22e80a00 RBX: ffff925ad38d2700 RCX:\nfffffffe0a0c8000\nRDX: ffff9258ea95bac0 RSI: ffff925ae0a0c800 RDI:\n0000000000037a40\nRBP: 0000000000000024 R08: 0000000000000000 R09:\n0000000000000021\nR10: 0000000000000848 R11: 0000000000000000 R12:\nffffa9bec02a8e24\nR13: ffff925ad8615570 R14: 0000000000000000 R15:\nffff925b22e80a00\nFS: 0000000000000000(0000)\nGS:ffff925e47880000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffff9258ea95baf0 CR3: 0000000166022004 CR4:\n0000000000f72ef0\nPKRU: 55555554\nCall Trace:\n<IRQ>\naq_ring_rx_clean+0x175/0xe60 [atlantic]\n? aq_ring_rx_clean+0x14d/0xe60 [atlantic]\n? aq_ring_tx_clean+0xdf/0x190 [atlantic]\n? kmem_cache_free+0x348/0x450\n? aq_vec_poll+0x81/0x1d0 [atlantic]\n? __napi_poll+0x28/0x1c0\n? net_rx_action+0x337/0x420\n```\n\nChanges in v4:\n- Add Fixes: tag to satisfy patch validation requirements.\n\nChanges in v3:\n- Fix by assuming there will be an extra frag if buff->len > AQ_CFG_RX_HDR_SIZE,\n  then all fragments are accounted for.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-39905",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phylink: add lock for serializing concurrent pl->phydev writes with resolver\n\nCurrently phylink_resolve() protects itself against concurrent\nphylink_bringup_phy() or phylink_disconnect_phy() calls which modify\npl->phydev by relying on pl->state_mutex.\n\nThe problem is that in phylink_resolve(), pl->state_mutex is in a lock\ninversion state with pl->phydev->lock. So pl->phydev->lock needs to be\nacquired prior to pl->state_mutex. But that requires dereferencing\npl->phydev in the first place, and without pl->state_mutex, that is\nracy.\n\nHence the reason for the extra lock. Currently it is redundant, but it\nwill serve a functional purpose once mutex_lock(&phy->lock) will be\nmoved outside of the mutex_lock(&pl->state_mutex) section.\n\nAnother alternative considered would have been to let phylink_resolve()\nacquire the rtnl_mutex, which is also held when phylink_bringup_phy()\nand phylink_disconnect_phy() are called. But since phylink_disconnect_phy()\nruns under rtnl_lock(), it would deadlock with phylink_resolve() when\ncalling flush_work(&pl->resolve). Additionally, it would have been\nundesirable because it would have unnecessarily blocked many other call\npaths as well in the entire kernel, so the smaller-scoped lock was\npreferred.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39905",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39968",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: add max boundary check for VF filters\n\nThere is no check for max filters that VF can request. Add it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-16",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50106",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: fix race between laundromat and free_stateid\n\nThere is a race between laundromat handling of revoked delegations\nand a client sending free_stateid operation. Laundromat thread\nfinds that delegation has expired and needs to be revoked so it\nmarks the delegation stid revoked and it puts it on a reaper list\nbut then it unlock the state lock and the actual delegation revocation\nhappens without the lock. Once the stid is marked revoked a racing\nfree_stateid processing thread does the following (1) it calls\nlist_del_init() which removes it from the reaper list and (2) frees\nthe delegation stid structure. The laundromat thread ends up not\ncalling the revoke_delegation() function for this particular delegation\nbut that means it will no release the lock lease that exists on\nthe file.\n\nNow, a new open for this file comes in and ends up finding that\nlease list isn't empty and calls nfsd_breaker_owns_lease() which ends\nup trying to derefence a freed delegation stateid. Leading to the\nfollowint use-after-free KASAN warning:\n\nkernel: ==================================================================\nkernel: BUG: KASAN: slab-use-after-free in nfsd_breaker_owns_lease+0x140/0x160 [nfsd]\nkernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205\nkernel:\nkernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9\nkernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024\nkernel: Call trace:\nkernel: dump_backtrace+0x98/0x120\nkernel: show_stack+0x1c/0x30\nkernel: dump_stack_lvl+0x80/0xe8\nkernel: print_address_description.constprop.0+0x84/0x390\nkernel: print_report+0xa4/0x268\nkernel: kasan_report+0xb4/0xf8\nkernel: __asan_report_load8_noabort+0x1c/0x28\nkernel: nfsd_breaker_owns_lease+0x140/0x160 [nfsd]\nkernel: nfsd_file_do_acquire+0xb3c/0x11d0 [nfsd]\nkernel: nfsd_file_acquire_opened+0x84/0x110 [nfsd]\nkernel: nfs4_get_vfs_file+0x634/0x958 [nfsd]\nkernel: nfsd4_process_open2+0xa40/0x1a40 [nfsd]\nkernel: nfsd4_open+0xa08/0xe80 [nfsd]\nkernel: nfsd4_proc_compound+0xb8c/0x2130 [nfsd]\nkernel: nfsd_dispatch+0x22c/0x718 [nfsd]\nkernel: svc_process_common+0x8e8/0x1960 [sunrpc]\nkernel: svc_process+0x3d4/0x7e0 [sunrpc]\nkernel: svc_handle_xprt+0x828/0xe10 [sunrpc]\nkernel: svc_recv+0x2cc/0x6a8 [sunrpc]\nkernel: nfsd+0x270/0x400 [nfsd]\nkernel: kthread+0x288/0x310\nkernel: ret_from_fork+0x10/0x20\n\nThis patch proposes a fixed that's based on adding 2 new additional\nstid's sc_status values that help coordinate between the laundromat\nand other operations (nfsd4_free_stateid() and nfsd4_delegreturn()).\n\nFirst to make sure, that once the stid is marked revoked, it is not\nremoved by the nfsd4_free_stateid(), the laundromat take a reference\non the stateid. Then, coordinating whether the stid has been put\non the cl_revoked list or we are processing FREE_STATEID and need to\nmake sure to remove it from the list, each check that state and act\naccordingly. If laundromat has added to the cl_revoke list before\nthe arrival of FREE_STATEID, then nfsd4_free_stateid() knows to remove\nit from the list. If nfsd4_free_stateid() finds that operations arrived\nbefore laundromat has placed it on cl_revoke list, it marks the state\nfreed and then laundromat will no longer add it to the list.\n\nAlso, for nfsd4_delegreturn() when looking for the specified stid,\nwe need to access stid that are marked removed or freeable, it means\nthe laundromat has started processing it but hasn't finished and this\ndelegreturn needs to return nfserr_deleg_revoked and not\nnfserr_bad_stateid. The latter will not trigger a FREE_STATEID and the\nlack of it will leave this stid on the cl_revoked list indefinitely.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50106",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-05",
                    "modification_date": "2024-12-11",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-21702",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npfifo_tail_enqueue: Drop new packet when sch->limit == 0\n\nExpected behaviour:\nIn case we reach scheduler's limit, pfifo_tail_enqueue() will drop a\npacket in scheduler's queue and decrease scheduler's qlen by one.\nThen, pfifo_tail_enqueue() enqueue new packet and increase\nscheduler's qlen by one. Finally, pfifo_tail_enqueue() return\n`NET_XMIT_CN` status code.\n\nWeird behaviour:\nIn case we set `sch->limit == 0` and trigger pfifo_tail_enqueue() on a\nscheduler that has no packet, the 'drop a packet' step will do nothing.\nThis means the scheduler's qlen still has value equal 0.\nThen, we continue to enqueue new packet and increase scheduler's qlen by\none. In summary, we can leverage pfifo_tail_enqueue() to increase qlen by\none and return `NET_XMIT_CN` status code.\n\nThe problem is:\nLet's say we have two qdiscs: Qdisc_A and Qdisc_B.\n - Qdisc_A's type must have '->graft()' function to create parent/child relationship.\n   Let's say Qdisc_A's type is `hfsc`. Enqueue packet to this qdisc will trigger `hfsc_enqueue`.\n - Qdisc_B's type is pfifo_head_drop. Enqueue packet to this qdisc will trigger `pfifo_tail_enqueue`.\n - Qdisc_B is configured to have `sch->limit == 0`.\n - Qdisc_A is configured to route the enqueued's packet to Qdisc_B.\n\nEnqueue packet through Qdisc_A will lead to:\n - hfsc_enqueue(Qdisc_A) -> pfifo_tail_enqueue(Qdisc_B)\n - Qdisc_B->q.qlen += 1\n - pfifo_tail_enqueue() return `NET_XMIT_CN`\n - hfsc_enqueue() check for `NET_XMIT_SUCCESS` and see `NET_XMIT_CN` => hfsc_enqueue() don't increase qlen of Qdisc_A.\n\nThe whole process lead to a situation where Qdisc_A->q.qlen == 0 and Qdisc_B->q.qlen == 1.\nReplace 'hfsc' with other type (for example: 'drr') still lead to the same problem.\nThis violate the design where parent's qlen should equal to the sum of its childrens'qlen.\n\nBug impact: This issue can be used for user->kernel privilege escalation when it is reachable.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-21702",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-18",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48858",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Fix a race on command flush flow\n\nFix a refcount use after free warning due to a race on command entry.\nSuch race occurs when one of the commands releases its last refcount and\nfrees its index and entry while another process running command flush\nflow takes refcount to this command entry. The process which handles\ncommands flush may see this command as needed to be flushed if the other\nprocess released its refcount but didn't release the index yet. Fix it\nby adding the needed spin lock.\n\nIt fixes the following warning trace:\n\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 11 PID: 540311 at lib/refcount.c:25 refcount_warn_saturate+0x80/0xe0\n...\nRIP: 0010:refcount_warn_saturate+0x80/0xe0\n...\nCall Trace:\n <TASK>\n mlx5_cmd_trigger_completions+0x293/0x340 [mlx5_core]\n mlx5_cmd_flush+0x3a/0xf0 [mlx5_core]\n enter_error_state+0x44/0x80 [mlx5_core]\n mlx5_fw_fatal_reporter_err_work+0x37/0xe0 [mlx5_core]\n process_one_work+0x1be/0x390\n worker_thread+0x4d/0x3d0\n ? rescuer_thread+0x350/0x350\n kthread+0x141/0x160\n ? set_kthread_struct+0x40/0x40\n ret_from_fork+0x1f/0x30\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48858",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-45885",
                    "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-45885",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-11-25",
                    "modification_date": "2025-04-29",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54015",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Devcom, fix error flow in mlx5_devcom_register_device\n\nIn case devcom allocation is failed, mlx5 is always freeing the priv.\nHowever, this priv might have been allocated by a different thread,\nand freeing it might lead to use-after-free bugs.\nFix it by freeing the priv only in case it was allocated by the\nrunning thread.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39994",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: tuner: xc5000: Fix use-after-free in xc5000_release\n\nThe original code uses cancel_delayed_work() in xc5000_release(), which\ndoes not guarantee that the delayed work item timer_sleep has fully\ncompleted if it was already running. This leads to use-after-free scenarios\nwhere xc5000_release() may free the xc5000_priv while timer_sleep is still\nactive and attempts to dereference the xc5000_priv.\n\nA typical race condition is illustrated below:\n\nCPU 0 (release thread)                 | CPU 1 (delayed work callback)\nxc5000_release()                       | xc5000_do_timer_sleep()\n  cancel_delayed_work()                |\n  hybrid_tuner_release_state(priv)     |\n    kfree(priv)                        |\n                                       |   priv = container_of() // UAF\n\nReplace cancel_delayed_work() with cancel_delayed_work_sync() to ensure\nthat the timer_sleep is properly canceled before the xc5000_priv memory\nis deallocated.\n\nA deadlock concern was considered: xc5000_release() is called in a process\ncontext and is not holding any locks that the timer_sleep work item might\nalso need. Therefore, the use of the _sync() variant is safe here.\n\nThis bug was initially identified through static analysis.\n\n[hverkuil: fix typo in Subject: tunner -> tuner]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53552",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915: mark requests for GuC virtual engines to avoid use-after-free\n\nReferences to i915_requests may be trapped by userspace inside a\nsync_file or dmabuf (dma-resv) and held indefinitely across different\nproceses. To counter-act the memory leaks, we try to not to keep\nreferences from the request past their completion.\nOn the other side on fence release we need to know if rq->engine\nis valid and points to hw engine (true for non-virtual requests).\nTo make it possible extra bit has been added to rq->execution_mask,\nfor marking virtual engines.\n\n(cherry picked from commit 280410677af763f3871b93e794a199cfcf6fb580)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50036",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: do not delay dst_entries_add() in dst_release()\n\ndst_entries_add() uses per-cpu data that might be freed at netns\ndismantle from ip6_route_net_exit() calling dst_entries_destroy()\n\nBefore ip6_route_net_exit() can be called, we release all\nthe dsts associated with this netns, via calls to dst_release(),\nwhich waits an rcu grace period before calling dst_destroy()\n\ndst_entries_add() use in dst_destroy() is racy, because\ndst_entries_destroy() could have been called already.\n\nDecrementing the number of dsts must happen sooner.\n\nNotes:\n\n1) in CONFIG_XFRM case, dst_destroy() can call\n   dst_release_immediate(child), this might also cause UAF\n   if the child does not have DST_NOCOUNT set.\n   IPSEC maintainers might take a look and see how to address this.\n\n2) There is also discussion about removing this count of dst,\n   which might happen in future kernels.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50036",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54102",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Prevent lpfc_debugfs_lockstat_write() buffer overflow\n\nA static code analysis tool flagged the possibility of buffer overflow when\nusing copy_from_user() for a debugfs entry.\n\nCurrently, it is possible that copy_from_user() copies more bytes than what\nwould fit in the mybuf char array.  Add a min() restriction check between\nsizeof(mybuf) - 1 and nbytes passed from the userspace buffer to protect\nagainst buffer overflow.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2023-54155",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: core: remove unnecessary frame_sz check in bpf_xdp_adjust_tail()\n\nSyzkaller reported the following issue:\n=======================================\nToo BIG xdp->frame_sz = 131072\nWARNING: CPU: 0 PID: 5020 at net/core/filter.c:4121\n  ____bpf_xdp_adjust_tail net/core/filter.c:4121 [inline]\nWARNING: CPU: 0 PID: 5020 at net/core/filter.c:4121\n  bpf_xdp_adjust_tail+0x466/0xa10 net/core/filter.c:4103\n...\nCall Trace:\n <TASK>\n bpf_prog_4add87e5301a4105+0x1a/0x1c\n __bpf_prog_run include/linux/filter.h:600 [inline]\n bpf_prog_run_xdp include/linux/filter.h:775 [inline]\n bpf_prog_run_generic_xdp+0x57e/0x11e0 net/core/dev.c:4721\n netif_receive_generic_xdp net/core/dev.c:4807 [inline]\n do_xdp_generic+0x35c/0x770 net/core/dev.c:4866\n tun_get_user+0x2340/0x3ca0 drivers/net/tun.c:1919\n tun_chr_write_iter+0xe8/0x210 drivers/net/tun.c:2043\n call_write_iter include/linux/fs.h:1871 [inline]\n new_sync_write fs/read_write.c:491 [inline]\n vfs_write+0x650/0xe40 fs/read_write.c:584\n ksys_write+0x12f/0x250 fs/read_write.c:637\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x38/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nxdp->frame_sz > PAGE_SIZE check was introduced in commit c8741e2bfe87\n(\"xdp: Allow bpf_xdp_adjust_tail() to grow packet size\"). But Jesper\nDangaard Brouer <jbrouer@redhat.com> noted that after introducing the\nxdp_init_buff() which all XDP driver use - it's safe to remove this\ncheck. The original intend was to catch cases where XDP drivers have\nnot been updated to use xdp.frame_sz, but that is not longer a concern\n(since xdp_init_buff).\n\nRunning the initial syzkaller repro it was discovered that the\ncontiguous physical memory allocation is used for both xdp paths in\ntun_get_user(), e.g. tun_build_skb() and tun_alloc_skb(). It was also\nstated by Jesper Dangaard Brouer <jbrouer@redhat.com> that XDP can\nwork on higher order pages, as long as this is contiguous physical\nmemory (e.g. a page).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40309",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: SCO: Fix UAF on sco_conn_free\n\nBUG: KASAN: slab-use-after-free in sco_conn_free net/bluetooth/sco.c:87 [inline]\nBUG: KASAN: slab-use-after-free in kref_put include/linux/kref.h:65 [inline]\nBUG: KASAN: slab-use-after-free in sco_conn_put+0xdd/0x410\nnet/bluetooth/sco.c:107\nWrite of size 8 at addr ffff88811cb96b50 by task kworker/u17:4/352\n\nCPU: 1 UID: 0 PID: 352 Comm: kworker/u17:4 Not tainted\n6.17.0-rc5-g717368f83676 #4 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nWorkqueue: hci13 hci_cmd_sync_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x10b/0x170 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x191/0x550 mm/kasan/report.c:482\n kasan_report+0xc4/0x100 mm/kasan/report.c:595\n sco_conn_free net/bluetooth/sco.c:87 [inline]\n kref_put include/linux/kref.h:65 [inline]\n sco_conn_put+0xdd/0x410 net/bluetooth/sco.c:107\n sco_connect_cfm+0xb4/0xae0 net/bluetooth/sco.c:1441\n hci_connect_cfm include/net/bluetooth/hci_core.h:2082 [inline]\n hci_conn_failed+0x20a/0x2e0 net/bluetooth/hci_conn.c:1313\n hci_conn_unlink+0x55f/0x810 net/bluetooth/hci_conn.c:1121\n hci_conn_del+0xb6/0x1110 net/bluetooth/hci_conn.c:1147\n hci_abort_conn_sync+0x8c5/0xbb0 net/bluetooth/hci_sync.c:5689\n hci_cmd_sync_work+0x281/0x380 net/bluetooth/hci_sync.c:332\n process_one_work kernel/workqueue.c:3236 [inline]\n process_scheduled_works+0x77e/0x1040 kernel/workqueue.c:3319\n worker_thread+0xbee/0x1200 kernel/workqueue.c:3400\n kthread+0x3c7/0x870 kernel/kthread.c:463\n ret_from_fork+0x13a/0x1e0 arch/x86/kernel/process.c:148\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n </TASK>\n\nAllocated by task 31370:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x30/0x70 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:388 [inline]\n __kasan_kmalloc+0x82/0x90 mm/kasan/common.c:405\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4382 [inline]\n __kmalloc_noprof+0x22f/0x390 mm/slub.c:4394\n kmalloc_noprof include/linux/slab.h:909 [inline]\n sk_prot_alloc+0xae/0x220 net/core/sock.c:2239\n sk_alloc+0x34/0x5a0 net/core/sock.c:2295\n bt_sock_alloc+0x3c/0x330 net/bluetooth/af_bluetooth.c:151\n sco_sock_alloc net/bluetooth/sco.c:562 [inline]\n sco_sock_create+0xc0/0x350 net/bluetooth/sco.c:593\n bt_sock_create+0x161/0x3b0 net/bluetooth/af_bluetooth.c:135\n __sock_create+0x3ad/0x780 net/socket.c:1589\n sock_create net/socket.c:1647 [inline]\n __sys_socket_create net/socket.c:1684 [inline]\n __sys_socket+0xd5/0x330 net/socket.c:1731\n __do_sys_socket net/socket.c:1745 [inline]\n __se_sys_socket net/socket.c:1743 [inline]\n __x64_sys_socket+0x7a/0x90 net/socket.c:1743\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xc7/0x240 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 31374:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x30/0x70 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:576\n poison_slab_object mm/kasan/common.c:243 [inline]\n __kasan_slab_free+0x3d/0x50 mm/kasan/common.c:275\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2428 [inline]\n slab_free mm/slub.c:4701 [inline]\n kfree+0x199/0x3b0 mm/slub.c:4900\n sk_prot_free net/core/sock.c:2278 [inline]\n __sk_destruct+0x4aa/0x630 net/core/sock.c:2373\n sco_sock_release+0x2ad/0x300 net/bluetooth/sco.c:1333\n __sock_release net/socket.c:649 [inline]\n sock_close+0xb8/0x230 net/socket.c:1439\n __fput+0x3d1/0x9e0 fs/file_table.c:468\n task_work_run+0x206/0x2a0 kernel/task_work.c:227\n get_signal+0x1201/0x1410 kernel/signal.c:2807\n arch_do_signal_or_restart+0x34/0x740 arch/x86/kernel/signal.c:337\n exit_to_user_mode_loop+0x68/0xc0 kernel/entry/common.c:40\n exit_to_user_mode_prepare include/linux/irq-entry-common.h:225 [inline]\n s\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "modification_date": "2026-01-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53989",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: mm: fix VA-range sanity check\n\nBoth create_mapping_noalloc() and update_mapping_prot() sanity-check\ntheir 'virt' parameter, but the check itself doesn't make much sense.\nThe condition used today appears to be a historical accident.\n\nThe sanity-check condition:\n\n\tif ((virt >= PAGE_END) && (virt < VMALLOC_START)) {\n\t\t[ ... warning here ... ]\n\t\treturn;\n\t}\n\n... can only be true for the KASAN shadow region or the module region,\nand there's no reason to exclude these specifically for creating and\nupdateing mappings.\n\nWhen arm64 support was first upstreamed in commit:\n\n  c1cc1552616d0f35 (\"arm64: MMU initialisation\")\n\n... the condition was:\n\n\tif (virt < VMALLOC_START) {\n\t\t[ ... warning here ... ]\n\t\treturn;\n\t}\n\nAt the time, VMALLOC_START was the lowest kernel address, and this was\nchecking whether 'virt' would be translated via TTBR1.\n\nSubsequently in commit:\n\n  14c127c957c1c607 (\"arm64: mm: Flip kernel VA space\")\n\n... the condition was changed to:\n\n\tif ((virt >= VA_START) && (virt < VMALLOC_START)) {\n\t\t[ ... warning here ... ]\n\t\treturn;\n\t}\n\nThis appear to have been a thinko. The commit moved the linear map to\nthe bottom of the kernel address space, with VMALLOC_START being at the\nhalfway point. The old condition would warn for changes to the linear\nmap below this, and at the time VA_START was the end of the linear map.\n\nSubsequently we cleaned up the naming of VA_START in commit:\n\n  77ad4ce69321abbe (\"arm64: memory: rename VA_START to PAGE_END\")\n\n... keeping the erroneous condition as:\n\n\tif ((virt >= PAGE_END) && (virt < VMALLOC_START)) {\n\t\t[ ... warning here ... ]\n\t\treturn;\n\t}\n\nCorrect the condition to check against the start of the TTBR1 address\nspace, which is currently PAGE_OFFSET. This simplifies the logic, and\nmore clearly matches the \"outside kernel range\" message in the warning.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53800",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nubi: Fix use-after-free when volume resizing failed\n\nThere is an use-after-free problem reported by KASAN:\n  ==================================================================\n  BUG: KASAN: use-after-free in ubi_eba_copy_table+0x11f/0x1c0 [ubi]\n  Read of size 8 at addr ffff888101eec008 by task ubirsvol/4735\n\n  CPU: 2 PID: 4735 Comm: ubirsvol\n  Not tainted 6.1.0-rc1-00003-g84fa3304a7fc-dirty #14\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),\n  BIOS 1.14.0-1.fc33 04/01/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x34/0x44\n   print_report+0x171/0x472\n   kasan_report+0xad/0x130\n   ubi_eba_copy_table+0x11f/0x1c0 [ubi]\n   ubi_resize_volume+0x4f9/0xbc0 [ubi]\n   ubi_cdev_ioctl+0x701/0x1850 [ubi]\n   __x64_sys_ioctl+0x11d/0x170\n   do_syscall_64+0x35/0x80\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n   </TASK>\n\nWhen ubi_change_vtbl_record() returns an error in ubi_resize_volume(),\n\"new_eba_tbl\" will be freed on error handing path, but it is holded\nby \"vol->eba_tbl\" in ubi_eba_replace_table(). It means that the liftcycle\nof \"vol->eba_tbl\" and \"vol\" are different, so when resizing volume in\nnext time, it causing an use-after-free fault.\n\nFix it by not freeing \"new_eba_tbl\" after it replaced in\nubi_eba_replace_table(), while will be freed in next volume resizing.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40248",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: Ignore signal/timeout on connect() if already established\n\nDuring connect(), acting on a signal/timeout by disconnecting an already\nestablished socket leads to several issues:\n\n1. connect() invoking vsock_transport_cancel_pkt() ->\n   virtio_transport_purge_skbs() may race with sendmsg() invoking\n   virtio_transport_get_credit(). This results in a permanently elevated\n   `vvs->bytes_unsent`. Which, in turn, confuses the SOCK_LINGER handling.\n\n2. connect() resetting a connected socket's state may race with socket\n   being placed in a sockmap. A disconnected socket remaining in a sockmap\n   breaks sockmap's assumptions. And gives rise to WARNs.\n\n3. connect() transitioning SS_CONNECTED -> SS_UNCONNECTED allows for a\n   transport change/drop after TCP_ESTABLISHED. Which poses a problem for\n   any simultaneous sendmsg() or connect() and may result in a\n   use-after-free/null-ptr-deref.\n\nDo not disconnect socket on signal/timeout. Keep the logic for unconnected\nsockets: they don't linger, can't be placed in a sockmap, are rejected by\nsendmsg().\n\n[1]: https://lore.kernel.org/netdev/e07fd95c-9a38-4eea-9638-133e38c2ec9b@rbox.co/\n[2]: https://lore.kernel.org/netdev/20250317-vsock-trans-signal-race-v4-0-fc8837f3f1d4@rbox.co/\n[3]: https://lore.kernel.org/netdev/60f1b7db-3099-4f6a-875e-af9f6ef194f6@rbox.co/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2022-50701",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7921s: fix slab-out-of-bounds access in sdio host\n\nSDIO may need addtional 511 bytes to align bus operation. If the tailroom\nof this skb is not big enough, we would access invalid memory region.\nFor low level operation, increase skb size to keep valid memory access in\nSDIO host.\n\nError message:\n[69.951] BUG: KASAN: slab-out-of-bounds in sg_copy_buffer+0xe9/0x1a0\n[69.951] Read of size 64 at addr ffff88811c9cf000 by task kworker/u16:7/451\n[69.951] CPU: 4 PID: 451 Comm: kworker/u16:7 Tainted: G W  OE  6.1.0-rc5 #1\n[69.951] Workqueue: kvub300c vub300_cmndwork_thread [vub300]\n[69.951] Call Trace:\n[69.951]  <TASK>\n[69.952]  dump_stack_lvl+0x49/0x63\n[69.952]  print_report+0x171/0x4a8\n[69.952]  kasan_report+0xb4/0x130\n[69.952]  kasan_check_range+0x149/0x1e0\n[69.952]  memcpy+0x24/0x70\n[69.952]  sg_copy_buffer+0xe9/0x1a0\n[69.952]  sg_copy_to_buffer+0x12/0x20\n[69.952]  __command_write_data.isra.0+0x23c/0xbf0 [vub300]\n[69.952]  vub300_cmndwork_thread+0x17f3/0x58b0 [vub300]\n[69.952]  process_one_work+0x7ee/0x1320\n[69.952]  worker_thread+0x53c/0x1240\n[69.952]  kthread+0x2b8/0x370\n[69.952]  ret_from_fork+0x1f/0x30\n[69.952]  </TASK>\n\n[69.952] Allocated by task 854:\n[69.952]  kasan_save_stack+0x26/0x50\n[69.952]  kasan_set_track+0x25/0x30\n[69.952]  kasan_save_alloc_info+0x1b/0x30\n[69.952]  __kasan_kmalloc+0x87/0xa0\n[69.952]  __kmalloc_node_track_caller+0x63/0x150\n[69.952]  kmalloc_reserve+0x31/0xd0\n[69.952]  __alloc_skb+0xfc/0x2b0\n[69.952]  __mt76_mcu_msg_alloc+0xbf/0x230 [mt76]\n[69.952]  mt76_mcu_send_and_get_msg+0xab/0x110 [mt76]\n[69.952]  __mt76_mcu_send_firmware.cold+0x94/0x15d [mt76]\n[69.952]  mt76_connac_mcu_send_ram_firmware+0x415/0x54d [mt76_connac_lib]\n[69.952]  mt76_connac2_load_ram.cold+0x118/0x4bc [mt76_connac_lib]\n[69.952]  mt7921_run_firmware.cold+0x2e9/0x405 [mt7921_common]\n[69.952]  mt7921s_mcu_init+0x45/0x80 [mt7921s]\n[69.953]  mt7921_init_work+0xe1/0x2a0 [mt7921_common]\n[69.953]  process_one_work+0x7ee/0x1320\n[69.953]  worker_thread+0x53c/0x1240\n[69.953]  kthread+0x2b8/0x370\n[69.953]  ret_from_fork+0x1f/0x30\n[69.953] The buggy address belongs to the object at ffff88811c9ce800\n             which belongs to the cache kmalloc-2k of size 2048\n[69.953] The buggy address is located 0 bytes to the right of\n             2048-byte region [ffff88811c9ce800, ffff88811c9cf000)\n\n[69.953] Memory state around the buggy address:\n[69.953]  ffff88811c9cef00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[69.953]  ffff88811c9cef80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[69.953] >ffff88811c9cf000: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[69.953]                    ^\n[69.953]  ffff88811c9cf080: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[69.953]  ffff88811c9cf100: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53811",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/irdma: Cap MSIX used to online CPUs + 1\n\nThe irdma driver can use a maximum number of msix vectors equal\nto num_online_cpus() + 1 and the kernel warning stack below is shown\nif that number is exceeded.\n\nThe kernel throws a warning as the driver tries to update the affinity\nhint with a CPU mask greater than the max CPU IDs. Fix this by capping\nthe MSIX vectors to num_online_cpus() + 1.\n\n WARNING: CPU: 7 PID: 23655 at include/linux/cpumask.h:106 irdma_cfg_ceq_vector+0x34c/0x3f0 [irdma]\n RIP: 0010:irdma_cfg_ceq_vector+0x34c/0x3f0 [irdma]\n Call Trace:\n irdma_rt_init_hw+0xa62/0x1290 [irdma]\n ? irdma_alloc_local_mac_entry+0x1a0/0x1a0 [irdma]\n ? __is_kernel_percpu_address+0x63/0x310\n ? rcu_read_lock_held_common+0xe/0xb0\n ? irdma_lan_unregister_qset+0x280/0x280 [irdma]\n ? irdma_request_reset+0x80/0x80 [irdma]\n ? ice_get_qos_params+0x84/0x390 [ice]\n irdma_probe+0xa40/0xfc0 [irdma]\n ? rcu_read_lock_bh_held+0xd0/0xd0\n ? irdma_remove+0x140/0x140 [irdma]\n ? rcu_read_lock_sched_held+0x62/0xe0\n ? down_write+0x187/0x3d0\n ? auxiliary_match_id+0xf0/0x1a0\n ? irdma_remove+0x140/0x140 [irdma]\n auxiliary_bus_probe+0xa6/0x100\n __driver_probe_device+0x4a4/0xd50\n ? __device_attach_driver+0x2c0/0x2c0\n driver_probe_device+0x4a/0x110\n __driver_attach+0x1aa/0x350\n bus_for_each_dev+0x11d/0x1b0\n ? subsys_dev_iter_init+0xe0/0xe0\n bus_add_driver+0x3b1/0x610\n driver_register+0x18e/0x410\n ? 0xffffffffc0b88000\n irdma_init_module+0x50/0xaa [irdma]\n do_one_initcall+0x103/0x5f0\n ? perf_trace_initcall_level+0x420/0x420\n ? do_init_module+0x4e/0x700\n ? __kasan_kmalloc+0x7d/0xa0\n ? kmem_cache_alloc_trace+0x188/0x2b0\n ? kasan_unpoison+0x21/0x50\n do_init_module+0x1d1/0x700\n load_module+0x3867/0x5260\n ? layout_and_allocate+0x3990/0x3990\n ? rcu_read_lock_held_common+0xe/0xb0\n ? rcu_read_lock_sched_held+0x62/0xe0\n ? rcu_read_lock_bh_held+0xd0/0xd0\n ? __vmalloc_node_range+0x46b/0x890\n ? lock_release+0x5c8/0xba0\n ? alloc_vm_area+0x120/0x120\n ? selinux_kernel_module_from_file+0x2a5/0x300\n ? __inode_security_revalidate+0xf0/0xf0\n ? __do_sys_init_module+0x1db/0x260\n __do_sys_init_module+0x1db/0x260\n ? load_module+0x5260/0x5260\n ? do_syscall_64+0x22/0x450\n do_syscall_64+0xa5/0x450\n entry_SYSCALL_64_after_hwframe+0x66/0xdb",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49919",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: release flow rule object from commit path\n\nNo need to postpone this to the commit release path, since no packets\nare walking over this object, this is accessed from control plane only.\nThis helped uncovered UAF triggered by races with the netlink notifier.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49919",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-56664",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Fix race between element replace and close()\n\nElement replace (with a socket different from the one stored) may race\nwith socket's close() link popping & unlinking. __sock_map_delete()\nunconditionally unrefs the (wrong) element:\n\n// set map[0] = s0\nmap_update_elem(map, 0, s0)\n\n// drop fd of s0\nclose(s0)\n  sock_map_close()\n    lock_sock(sk)               (s0!)\n    sock_map_remove_links(sk)\n      link = sk_psock_link_pop()\n      sock_map_unlink(sk, link)\n        sock_map_delete_from_link\n                                        // replace map[0] with s1\n                                        map_update_elem(map, 0, s1)\n                                          sock_map_update_elem\n                                (s1!)       lock_sock(sk)\n                                            sock_map_update_common\n                                              psock = sk_psock(sk)\n                                              spin_lock(&stab->lock)\n                                              osk = stab->sks[idx]\n                                              sock_map_add_link(..., &stab->sks[idx])\n                                              sock_map_unref(osk, &stab->sks[idx])\n                                                psock = sk_psock(osk)\n                                                sk_psock_put(sk, psock)\n                                                  if (refcount_dec_and_test(&psock))\n                                                    sk_psock_drop(sk, psock)\n                                              spin_unlock(&stab->lock)\n                                            unlock_sock(sk)\n          __sock_map_delete\n            spin_lock(&stab->lock)\n            sk = *psk                        // s1 replaced s0; sk == s1\n            if (!sk_test || sk_test == sk)   // sk_test (s0) != sk (s1); no branch\n              sk = xchg(psk, NULL)\n            if (sk)\n              sock_map_unref(sk, psk)        // unref s1; sks[idx] will dangle\n                psock = sk_psock(sk)\n                sk_psock_put(sk, psock)\n                  if (refcount_dec_and_test())\n                    sk_psock_drop(sk, psock)\n            spin_unlock(&stab->lock)\n    release_sock(sk)\n\nThen close(map) enqueues bpf_map_free_deferred, which finally calls\nsock_map_free(). This results in some refcount_t warnings along with\na KASAN splat [1].\n\nFix __sock_map_delete(), do not allow sock_map_unref() on elements that\nmay have been replaced.\n\n[1]:\nBUG: KASAN: slab-use-after-free in sock_map_free+0x10e/0x330\nWrite of size 4 at addr ffff88811f5b9100 by task kworker/u64:12/1063\n\nCPU: 14 UID: 0 PID: 1063 Comm: kworker/u64:12 Not tainted 6.12.0+ #125\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014\nWorkqueue: events_unbound bpf_map_free_deferred\nCall Trace:\n <TASK>\n dump_stack_lvl+0x68/0x90\n print_report+0x174/0x4f6\n kasan_report+0xb9/0x190\n kasan_check_range+0x10f/0x1e0\n sock_map_free+0x10e/0x330\n bpf_map_free_deferred+0x173/0x320\n process_one_work+0x846/0x1420\n worker_thread+0x5b3/0xf80\n kthread+0x29e/0x360\n ret_from_fork+0x2d/0x70\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 1202:\n kasan_save_stack+0x1e/0x40\n kasan_save_track+0x10/0x30\n __kasan_slab_alloc+0x85/0x90\n kmem_cache_alloc_noprof+0x131/0x450\n sk_prot_alloc+0x5b/0x220\n sk_alloc+0x2c/0x870\n unix_create1+0x88/0x8a0\n unix_create+0xc5/0x180\n __sock_create+0x241/0x650\n __sys_socketpair+0x1ce/0x420\n __x64_sys_socketpair+0x92/0x100\n do_syscall_64+0x93/0x180\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 46:\n kasan_save_stack+0x1e/0x40\n kasan_save_track+0x10/0x30\n kasan_save_free_info+0x37/0x60\n __kasan_slab_free+0x4b/0x70\n kmem_cache_free+0x1a1/0x590\n __sk_destruct+0x388/0x5a0\n sk_psock_destroy+0x73e/0xa50\n process_one_work+0x846/0x1420\n worker_thread+0x5b3/0xf80\n kthread+0x29e/0x360\n ret_from_fork+0x2d/0x70\n ret_from_fork_asm+0x1a/0x30\n\nThe bu\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56664",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-27",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53996",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/sev: Make enc_dec_hypercall() accept a size instead of npages\n\nenc_dec_hypercall() accepted a page count instead of a size, which\nforced its callers to round up. As a result, non-page aligned\nvaddrs caused pages to be spuriously marked as decrypted via the\nencryption status hypercall, which in turn caused consistent\ncorruption of pages during live migration. Live migration requires\naccurate encryption status information to avoid migrating pages\nfrom the wrong perspective.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68367",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmacintosh/mac_hid: fix race condition in mac_hid_toggle_emumouse\n\nThe following warning appears when running syzkaller, and this issue also\nexists in the mainline code.\n\n ------------[ cut here ]------------\n list_add double add: new=ffffffffa57eee28, prev=ffffffffa57eee28, next=ffffffffa5e63100.\n WARNING: CPU: 0 PID: 1491 at lib/list_debug.c:35 __list_add_valid_or_report+0xf7/0x130\n Modules linked in:\n CPU: 0 PID: 1491 Comm: syz.1.28 Not tainted 6.6.0+ #3\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\n RIP: 0010:__list_add_valid_or_report+0xf7/0x130\n RSP: 0018:ff1100010dfb7b78 EFLAGS: 00010282\n RAX: 0000000000000000 RBX: ffffffffa57eee18 RCX: ffffffff97fc9817\n RDX: 0000000000040000 RSI: ffa0000002383000 RDI: 0000000000000001\n RBP: ffffffffa57eee28 R08: 0000000000000001 R09: ffe21c0021bf6f2c\n R10: 0000000000000001 R11: 6464615f7473696c R12: ffffffffa5e63100\n R13: ffffffffa57eee28 R14: ffffffffa57eee28 R15: ff1100010dfb7d48\n FS:  00007fb14398b640(0000) GS:ff11000119600000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 000000010d096005 CR4: 0000000000773ef0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 80000000\n Call Trace:\n  <TASK>\n  input_register_handler+0xb3/0x210\n  mac_hid_start_emulation+0x1c5/0x290\n  mac_hid_toggle_emumouse+0x20a/0x240\n  proc_sys_call_handler+0x4c2/0x6e0\n  new_sync_write+0x1b1/0x2d0\n  vfs_write+0x709/0x950\n  ksys_write+0x12a/0x250\n  do_syscall_64+0x5a/0x110\n  entry_SYSCALL_64_after_hwframe+0x78/0xe2\n\nThe WARNING occurs when two processes concurrently write to the mac-hid\nemulation sysctl, causing a race condition in mac_hid_toggle_emumouse().\nBoth processes read old_val=0, then both try to register the input handler,\nleading to a double list_add of the same handler.\n\n  CPU0                             CPU1\n  -------------------------        -------------------------\n  vfs_write() //write 1            vfs_write()  //write 1\n    proc_sys_write()                 proc_sys_write()\n      mac_hid_toggle_emumouse()          mac_hid_toggle_emumouse()\n        old_val = *valp // old_val=0\n                                           old_val = *valp // old_val=0\n                                           mutex_lock_killable()\n                                           proc_dointvec() // *valp=1\n                                           mac_hid_start_emulation()\n                                             input_register_handler()\n                                           mutex_unlock()\n        mutex_lock_killable()\n        proc_dointvec()\n        mac_hid_start_emulation()\n          input_register_handler() //Trigger Warning\n        mutex_unlock()\n\nFix this by moving the old_val read inside the mutex lock region.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-38102",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nVMCI: fix race between vmci_host_setup_notify and vmci_ctx_unset_notify\n\nDuring our test, it is found that a warning can be trigger in try_grab_folio\nas follow:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 1678 at mm/gup.c:147 try_grab_folio+0x106/0x130\n  Modules linked in:\n  CPU: 0 UID: 0 PID: 1678 Comm: syz.3.31 Not tainted 6.15.0-rc5 #163 PREEMPT(undef)\n  RIP: 0010:try_grab_folio+0x106/0x130\n  Call Trace:\n   <TASK>\n   follow_huge_pmd+0x240/0x8e0\n   follow_pmd_mask.constprop.0.isra.0+0x40b/0x5c0\n   follow_pud_mask.constprop.0.isra.0+0x14a/0x170\n   follow_page_mask+0x1c2/0x1f0\n   __get_user_pages+0x176/0x950\n   __gup_longterm_locked+0x15b/0x1060\n   ? gup_fast+0x120/0x1f0\n   gup_fast_fallback+0x17e/0x230\n   get_user_pages_fast+0x5f/0x80\n   vmci_host_unlocked_ioctl+0x21c/0xf80\n  RIP: 0033:0x54d2cd\n  ---[ end trace 0000000000000000 ]---\n\nDigging into the source, context->notify_page may init by get_user_pages_fast\nand can be seen in vmci_ctx_unset_notify which will try to put_page. However\nget_user_pages_fast is not finished here and lead to following\ntry_grab_folio warning. The race condition is shown as follow:\n\ncpu0\t\t\tcpu1\nvmci_host_do_set_notify\nvmci_host_setup_notify\nget_user_pages_fast(uva, 1, FOLL_WRITE, &context->notify_page);\nlockless_pages_from_mm\ngup_pgd_range\ngup_huge_pmd  // update &context->notify_page\n\t\t\tvmci_host_do_set_notify\n\t\t\tvmci_ctx_unset_notify\n\t\t\tnotify_page = context->notify_page;\n\t\t\tif (notify_page)\n\t\t\tput_page(notify_page);\t// page is freed\n__gup_longterm_locked\n__get_user_pages\nfollow_trans_huge_pmd\ntry_grab_folio // warn here\n\nTo slove this, use local variable page to make notify_page can be seen\nafter finish get_user_pages_fast.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38102",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54040",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix wrong fallback logic for FDIR\n\nWhen adding a FDIR filter, if ice_vc_fdir_set_irq_ctx returns failure,\nthe inserted fdir entry will not be removed and if ice_vc_fdir_write_fltr\nreturns failure, the fdir context info for irq handler will not be cleared\nwhich may lead to inconsistent or memory leak issue. This patch refines\nfailure cases to resolve this issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2022-50082",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix warning in ext4_iomap_begin as race between bmap and write\n\nWe got issue as follows:\n------------[ cut here ]------------\nWARNING: CPU: 3 PID: 9310 at fs/ext4/inode.c:3441 ext4_iomap_begin+0x182/0x5d0\nRIP: 0010:ext4_iomap_begin+0x182/0x5d0\nRSP: 0018:ffff88812460fa08 EFLAGS: 00010293\nRAX: ffff88811f168000 RBX: 0000000000000000 RCX: ffffffff97793c12\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\nRBP: ffff88812c669160 R08: ffff88811f168000 R09: ffffed10258cd20f\nR10: ffff88812c669077 R11: ffffed10258cd20e R12: 0000000000000001\nR13: 00000000000000a4 R14: 000000000000000c R15: ffff88812c6691ee\nFS:  00007fd0d6ff3740(0000) GS:ffff8883af180000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fd0d6dda290 CR3: 0000000104a62000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n iomap_apply+0x119/0x570\n iomap_bmap+0x124/0x150\n ext4_bmap+0x14f/0x250\n bmap+0x55/0x80\n do_vfs_ioctl+0x952/0xbd0\n __x64_sys_ioctl+0xc6/0x170\n do_syscall_64+0x33/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nAbove issue may happen as follows:\n          bmap                    write\nbmap\n  ext4_bmap\n    iomap_bmap\n      ext4_iomap_begin\n                            ext4_file_write_iter\n\t\t\t      ext4_buffered_write_iter\n\t\t\t        generic_perform_write\n\t\t\t\t  ext4_da_write_begin\n\t\t\t\t    ext4_da_write_inline_data_begin\n\t\t\t\t      ext4_prepare_inline_data\n\t\t\t\t        ext4_create_inline_data\n\t\t\t\t\t  ext4_set_inode_flag(inode,\n\t\t\t\t\t\tEXT4_INODE_INLINE_DATA);\n      if (WARN_ON_ONCE(ext4_has_inline_data(inode))) ->trigger bug_on\n\nTo solved above issue hold inode lock in ext4_bamp.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-50082",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-18",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40297",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix use-after-free due to MST port state bypass\n\nsyzbot reported[1] a use-after-free when deleting an expired fdb. It is\ndue to a race condition between learning still happening and a port being\ndeleted, after all its fdbs have been flushed. The port's state has been\ntoggled to disabled so no learning should happen at that time, but if we\nhave MST enabled, it will bypass the port's state, that together with VLAN\nfiltering disabled can lead to fdb learning at a time when it shouldn't\nhappen while the port is being deleted. VLAN filtering must be disabled\nbecause we flush the port VLANs when it's being deleted which will stop\nlearning. This fix adds a check for the port's vlan group which is\ninitialized to NULL when the port is getting deleted, that avoids the port\nstate bypass. When MST is enabled there would be a minimal new overhead\nin the fast-path because the port's vlan group pointer is cache-hot.\n\n[1] https://syzkaller.appspot.com/bug?extid=dd280197f0f7ab3917be",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54072",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: pcm: Fix potential data race at PCM memory allocation helpers\n\nThe PCM memory allocation helpers have a sanity check against too many\nbuffer allocations.  However, the check is performed without a proper\nlock and the allocation isn't serialized; this allows user to allocate\nmore memories than predefined max size.\n\nPractically seen, this isn't really a big problem, as it's more or\nless some \"soft limit\" as a sanity check, and it's not possible to\nallocate unlimitedly.  But it's still better to address this for more\nconsistent behavior.\n\nThe patch covers the size check in do_alloc_pages() with the\ncard->memory_mutex, and increases the allocated size there for\npreventing the further overflow.  When the actual allocation fails,\nthe size is decreased accordingly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2023-53756",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: VMX: Fix crash due to uninitialized current_vmcs\n\nKVM enables 'Enlightened VMCS' and 'Enlightened MSR Bitmap' when running as\na nested hypervisor on top of Hyper-V. When MSR bitmap is updated,\nevmcs_touch_msr_bitmap function uses current_vmcs per-cpu variable to mark\nthat the msr bitmap was changed.\n\nvmx_vcpu_create() modifies the msr bitmap via vmx_disable_intercept_for_msr\n-> vmx_msr_bitmap_l01_changed which in the end calls this function. The\nfunction checks for current_vmcs if it is null but the check is\ninsufficient because current_vmcs is not initialized. Because of this, the\ncode might incorrectly write to the structure pointed by current_vmcs value\nleft by another task. Preemption is not disabled, the current task can be\npreempted and moved to another CPU while current_vmcs is accessed multiple\ntimes from evmcs_touch_msr_bitmap() which leads to crash.\n\nThe manipulation of MSR bitmaps by callers happens only for vmcs01 so the\nsolution is to use vmx->vmcs01.vmcs instead of current_vmcs.\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000338\n  PGD 4e1775067 P4D 0\n  Oops: 0002 [#1] PREEMPT SMP NOPTI\n  ...\n  RIP: 0010:vmx_msr_bitmap_l01_changed+0x39/0x50 [kvm_intel]\n  ...\n  Call Trace:\n   vmx_disable_intercept_for_msr+0x36/0x260 [kvm_intel]\n   vmx_vcpu_create+0xe6/0x540 [kvm_intel]\n   kvm_arch_vcpu_create+0x1d1/0x2e0 [kvm]\n   kvm_vm_ioctl_create_vcpu+0x178/0x430 [kvm]\n   kvm_vm_ioctl+0x53f/0x790 [kvm]\n   __x64_sys_ioctl+0x8a/0xc0\n   do_syscall_64+0x5c/0x90\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "low",
                    "aqua_score": 9.1,
                    "aqua_severity": "low",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-40135",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: use RCU in ip6_xmit()\n\nUse RCU in ip6_xmit() in order to use dst_dev_rcu() to prevent\npossible UAF.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2022-50583",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/raid0, raid10: Don't set discard sectors for request queue\n\nIt should use disk_stack_limits to get a proper max_discard_sectors\nrather than setting a value by stack drivers.\n\nAnd there is a bug. If all member disks are rotational devices,\nraid0/raid10 set max_discard_sectors. So the member devices are\nnot ssd/nvme, but raid0/raid10 export the wrong value. It reports\nwarning messages in function __blkdev_issue_discard when mkfs.xfs\nlike this:\n\n[ 4616.022599] ------------[ cut here ]------------\n[ 4616.027779] WARNING: CPU: 4 PID: 99634 at block/blk-lib.c:50 __blkdev_issue_discard+0x16a/0x1a0\n[ 4616.140663] RIP: 0010:__blkdev_issue_discard+0x16a/0x1a0\n[ 4616.146601] Code: 24 4c 89 20 31 c0 e9 fe fe ff ff c1 e8 09 8d 48 ff 4c 89 f0 4c 09 e8 48 85 c1 0f 84 55 ff ff ff b8 ea ff ff ff e9 df fe ff ff <0f> 0b 48 8d 74 24 08 e8 ea d6 00 00 48 c7 c6 20 1e 89 ab 48 c7 c7\n[ 4616.167567] RSP: 0018:ffffaab88cbffca8 EFLAGS: 00010246\n[ 4616.173406] RAX: ffff9ba1f9e44678 RBX: 0000000000000000 RCX: ffff9ba1c9792080\n[ 4616.181376] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9ba1c9792080\n[ 4616.189345] RBP: 0000000000000cc0 R08: ffffaab88cbffd10 R09: 0000000000000000\n[ 4616.197317] R10: 0000000000000012 R11: 0000000000000000 R12: 0000000000000000\n[ 4616.205288] R13: 0000000000400000 R14: 0000000000000cc0 R15: ffff9ba1c9792080\n[ 4616.213259] FS:  00007f9a5534e980(0000) GS:ffff9ba1b7c80000(0000) knlGS:0000000000000000\n[ 4616.222298] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 4616.228719] CR2: 000055a390a4c518 CR3: 0000000123e40006 CR4: 00000000001706e0\n[ 4616.236689] Call Trace:\n[ 4616.239428]  blkdev_issue_discard+0x52/0xb0\n[ 4616.244108]  blkdev_common_ioctl+0x43c/0xa00\n[ 4616.248883]  blkdev_ioctl+0x116/0x280\n[ 4616.252977]  __x64_sys_ioctl+0x8a/0xc0\n[ 4616.257163]  do_syscall_64+0x5c/0x90\n[ 4616.261164]  ? handle_mm_fault+0xc5/0x2a0\n[ 4616.265652]  ? do_user_addr_fault+0x1d8/0x690\n[ 4616.270527]  ? do_syscall_64+0x69/0x90\n[ 4616.274717]  ? exc_page_fault+0x62/0x150\n[ 4616.279097]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[ 4616.284748] RIP: 0033:0x7f9a55398c6b",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-1077",
                    "description": "In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-1077",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-03-27",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38108",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: red: fix a race in __red_change()\n\nGerrard Tai reported a race condition in RED, whenever SFQ perturb timer\nfires at the wrong time.\n\nThe race is as follows:\n\nCPU 0                                 CPU 1\n[1]: lock root\n[2]: qdisc_tree_flush_backlog()\n[3]: unlock root\n |\n |                                    [5]: lock root\n |                                    [6]: rehash\n |                                    [7]: qdisc_tree_reduce_backlog()\n |\n[4]: qdisc_put()\n\nThis can be abused to underflow a parent's qlen.\n\nCalling qdisc_purge_queue() instead of qdisc_tree_flush_backlog()\nshould fix the race, because all packets will be purged from the qdisc\nbefore releasing the lock.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38108",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-03",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 7,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50440",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/vmwgfx: Validate the box size for the snooped cursor\n\nInvalid userspace dma surface copies could potentially overflow\nthe memcpy from the surface to the snooped image leading to crashes.\nTo fix it the dimensions of the copybox have to be validated\nagainst the expected size of the snooped cursor.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-10-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-35843",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/vt-d: Use device rbtree in iopf reporting path\n\nThe existing I/O page fault handler currently locates the PCI device by\ncalling pci_get_domain_bus_and_slot(). This function searches the list\nof all PCI devices until the desired device is found. To improve lookup\nefficiency, replace it with device_rbtree_find() to search the device\nwithin the probed device rbtree.\n\nThe I/O page fault is initiated by the device, which does not have any\nsynchronization mechanism with the software to ensure that the device\nstays in the probed device tree. Theoretically, a device could be released\nby the IOMMU subsystem after device_rbtree_find() and before\niopf_get_dev_fault_param(), which would cause a use-after-free problem.\n\nAdd a mutex to synchronize the I/O page fault reporting path and the IOMMU\nrelease device path. This lock doesn't introduce any performance overhead,\nas the conflict between I/O page fault reporting and device releasing is\nvery rare.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35843",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-17",
                    "modification_date": "2025-04-07",
                    "nvd_score_v3": 6.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.8,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-68346",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: dice: fix buffer overflow in detect_stream_formats()\n\nThe function detect_stream_formats() reads the stream_count value directly\nfrom a FireWire device without validating it. This can lead to\nout-of-bounds writes when a malicious device provides a stream_count value\ngreater than MAX_STREAMS.\n\nFix by applying the same validation to both TX and RX stream counts in\ndetect_stream_formats().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36013",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect()\n\nExtend a critical section to prevent chan from early freeing.\nAlso make the l2cap_connect() return type void. Nothing is using the\nreturned value but it is ugly to return a potentially freed pointer.\nMaking it void will help with backports because earlier kernels did use\nthe return value. Now the compile will break for kernels where this\npatch is not a complete fix.\n\nCall stack summary:\n\n[use]\nl2cap_bredr_sig_cmd\n  l2cap_connect\n  \u250c mutex_lock(&conn->chan_lock);\n  \u2502 chan = pchan->ops->new_connection(pchan); <- alloc chan\n  \u2502 __l2cap_chan_add(conn, chan);\n  \u2502   l2cap_chan_hold(chan);\n  \u2502   list_add(&chan->list, &conn->chan_l);   ... (1)\n  \u2514 mutex_unlock(&conn->chan_lock);\n    chan->conf_state              ... (4) <- use after free\n\n[free]\nl2cap_conn_del\n\u250c mutex_lock(&conn->chan_lock);\n\u2502 foreach chan in conn->chan_l:            ... (2)\n\u2502   l2cap_chan_put(chan);\n\u2502     l2cap_chan_destroy\n\u2502       kfree(chan)               ... (3) <- chan freed\n\u2514 mutex_unlock(&conn->chan_lock);\n\n==================================================================\nBUG: KASAN: slab-use-after-free in instrument_atomic_read\ninclude/linux/instrumented.h:68 [inline]\nBUG: KASAN: slab-use-after-free in _test_bit\ninclude/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]\nBUG: KASAN: slab-use-after-free in l2cap_connect+0xa67/0x11a0\nnet/bluetooth/l2cap_core.c:4260\nRead of size 8 at addr ffff88810bf040a0 by task kworker/u3:1/311",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36013",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-23",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 6.8,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.8,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40345",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: storage: sddr55: Reject out-of-bound new_pba\n\nDiscovered by Atuin - Automated Vulnerability Discovery Engine.\n\nnew_pba comes from the status packet returned after each write.\nA bogus device could report values beyond the block count derived\nfrom info->capacity, letting the driver walk off the end of\npba_to_lba[] and corrupt heap memory.\n\nReject PBAs that exceed the computed block count and fail the\ntransfer so we avoid touching out-of-range mapping entries.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-12",
                    "modification_date": "2025-12-15",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40257",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix a race in mptcp_pm_del_add_timer()\n\nmptcp_pm_del_add_timer() can call sk_stop_timer_sync(sk, &entry->add_timer)\nwhile another might have free entry already, as reported by syzbot.\n\nAdd RCU protection to fix this issue.\n\nAlso change confusing add_timer variable with stop_timer boolean.\n\nsyzbot report:\n\nBUG: KASAN: slab-use-after-free in __timer_delete_sync+0x372/0x3f0 kernel/time/timer.c:1616\nRead of size 4 at addr ffff8880311e4150 by task kworker/1:1/44\n\nCPU: 1 UID: 0 PID: 44 Comm: kworker/1:1 Not tainted syzkaller #0 PREEMPT_{RT,(full)}\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/02/2025\nWorkqueue: events mptcp_worker\nCall Trace:\n <TASK>\n  dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n  print_address_description mm/kasan/report.c:378 [inline]\n  print_report+0xca/0x240 mm/kasan/report.c:482\n  kasan_report+0x118/0x150 mm/kasan/report.c:595\n  __timer_delete_sync+0x372/0x3f0 kernel/time/timer.c:1616\n  sk_stop_timer_sync+0x1b/0x90 net/core/sock.c:3631\n  mptcp_pm_del_add_timer+0x283/0x310 net/mptcp/pm.c:362\n  mptcp_incoming_options+0x1357/0x1f60 net/mptcp/options.c:1174\n  tcp_data_queue+0xca/0x6450 net/ipv4/tcp_input.c:5361\n  tcp_rcv_established+0x1335/0x2670 net/ipv4/tcp_input.c:6441\n  tcp_v4_do_rcv+0x98b/0xbf0 net/ipv4/tcp_ipv4.c:1931\n  tcp_v4_rcv+0x252a/0x2dc0 net/ipv4/tcp_ipv4.c:2374\n  ip_protocol_deliver_rcu+0x221/0x440 net/ipv4/ip_input.c:205\n  ip_local_deliver_finish+0x3bb/0x6f0 net/ipv4/ip_input.c:239\n  NF_HOOK+0x30c/0x3a0 include/linux/netfilter.h:318\n  NF_HOOK+0x30c/0x3a0 include/linux/netfilter.h:318\n  __netif_receive_skb_one_core net/core/dev.c:6079 [inline]\n  __netif_receive_skb+0x143/0x380 net/core/dev.c:6192\n  process_backlog+0x31e/0x900 net/core/dev.c:6544\n  __napi_poll+0xb6/0x540 net/core/dev.c:7594\n  napi_poll net/core/dev.c:7657 [inline]\n  net_rx_action+0x5f7/0xda0 net/core/dev.c:7784\n  handle_softirqs+0x22f/0x710 kernel/softirq.c:622\n  __do_softirq kernel/softirq.c:656 [inline]\n  __local_bh_enable_ip+0x1a0/0x2e0 kernel/softirq.c:302\n  mptcp_pm_send_ack net/mptcp/pm.c:210 [inline]\n mptcp_pm_addr_send_ack+0x41f/0x500 net/mptcp/pm.c:-1\n  mptcp_pm_worker+0x174/0x320 net/mptcp/pm.c:1002\n  mptcp_worker+0xd5/0x1170 net/mptcp/protocol.c:2762\n  process_one_work kernel/workqueue.c:3263 [inline]\n  process_scheduled_works+0xae1/0x17b0 kernel/workqueue.c:3346\n  worker_thread+0x8a0/0xda0 kernel/workqueue.c:3427\n  kthread+0x711/0x8a0 kernel/kthread.c:463\n  ret_from_fork+0x4bc/0x870 arch/x86/kernel/process.c:158\n  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n </TASK>\n\nAllocated by task 44:\n  kasan_save_stack mm/kasan/common.c:56 [inline]\n  kasan_save_track+0x3e/0x80 mm/kasan/common.c:77\n  poison_kmalloc_redzone mm/kasan/common.c:400 [inline]\n  __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:417\n  kasan_kmalloc include/linux/kasan.h:262 [inline]\n  __kmalloc_cache_noprof+0x1ef/0x6c0 mm/slub.c:5748\n  kmalloc_noprof include/linux/slab.h:957 [inline]\n  mptcp_pm_alloc_anno_list+0x104/0x460 net/mptcp/pm.c:385\n  mptcp_pm_create_subflow_or_signal_addr+0xf9d/0x1360 net/mptcp/pm_kernel.c:355\n  mptcp_pm_nl_fully_established net/mptcp/pm_kernel.c:409 [inline]\n  __mptcp_pm_kernel_worker+0x417/0x1ef0 net/mptcp/pm_kernel.c:1529\n  mptcp_pm_worker+0x1ee/0x320 net/mptcp/pm.c:1008\n  mptcp_worker+0xd5/0x1170 net/mptcp/protocol.c:2762\n  process_one_work kernel/workqueue.c:3263 [inline]\n  process_scheduled_works+0xae1/0x17b0 kernel/workqueue.c:3346\n  worker_thread+0x8a0/0xda0 kernel/workqueue.c:3427\n  kthread+0x711/0x8a0 kernel/kthread.c:463\n  ret_from_fork+0x4bc/0x870 arch/x86/kernel/process.c:158\n  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n\nFreed by task 6630:\n  kasan_save_stack mm/kasan/common.c:56 [inline]\n  kasan_save_track+0x3e/0x80 mm/kasan/common.c:77\n  __kasan_save_free_info+0x46/0x50 mm/kasan/generic.c:587\n  kasan_save_free_info mm/kasan/kasan.h:406 [inline]\n  poison_slab_object m\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-28972",
                    "description": "In drivers/pci/hotplug/rpadlpar_sysfs.c in the Linux kernel through 5.11.8, the RPA PCI Hotplug driver has a user-tolerable buffer overflow when writing a new device name to the driver from userspace, allowing userspace to write data to the kernel stack frame directly. This occurs because add_slot_store and remove_slot_store mishandle drc_name '\\0' termination, aka CID-cc7a0bb058b8.",
                    "nvd_score": 7.2,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
                    "nvd_severity": "high",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28972",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-03-22",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50496",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: Fix UAF in destroy()\n\nDm_cache also has the same UAF problem when dm_resume()\nand dm_destroy() are concurrent.\n\nTherefore, cancelling timer again in destroy().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52447",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Defer the free of inner map when necessary\n\nWhen updating or deleting an inner map in map array or map htab, the map\nmay still be accessed by non-sleepable program or sleepable program.\nHowever bpf_map_fd_put_ptr() decreases the ref-counter of the inner map\ndirectly through bpf_map_put(), if the ref-counter is the last one\n(which is true for most cases), the inner map will be freed by\nops->map_free() in a kworker. But for now, most .map_free() callbacks\ndon't use synchronize_rcu() or its variants to wait for the elapse of a\nRCU grace period, so after the invocation of ops->map_free completes,\nthe bpf program which is accessing the inner map may incur\nuse-after-free problem.\n\nFix the free of inner map by invoking bpf_map_free_deferred() after both\none RCU grace period and one tasks trace RCU grace period if the inner\nmap has been removed from the outer map before. The deferment is\naccomplished by using call_rcu() or call_rcu_tasks_trace() when\nreleasing the last ref-counter of bpf map. The newly-added rcu_head\nfield in bpf_map shares the same storage space with work field to\nreduce the size of bpf_map.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52447",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-22",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-3159",
                    "description": "A use after free issue was discovered in driver/firewire in outbound_phy_packet_callback in the Linux Kernel. In this flaw a local attacker with special privilege may cause a use after free problem when queue_event() fails.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-3159",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-06-12",
                    "modification_date": "2025-04-23",
                    "nvd_score_v3": 6.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-26828",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: fix underflow in parse_server_interfaces()\n\nIn this loop, we step through the buffer and after each item we check\nif the size_left is greater than the minimum size we need.  However,\nthe problem is that \"bytes_left\" is type ssize_t while sizeof() is type\nsize_t.  That means that because of type promotion, the comparison is\ndone as an unsigned and if we have negative bytes left the loop\ncontinues instead of ending.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26828",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-17",
                    "modification_date": "2025-04-08",
                    "nvd_score_v3": 6.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2024-35976",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxsk: validate user input for XDP_{UMEM|COMPLETION}_FILL_RING\n\nsyzbot reported an illegal copy in xsk_setsockopt() [1]\n\nMake sure to validate setsockopt() @optlen parameter.\n\n[1]\n\n BUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\n BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline]\n BUG: KASAN: slab-out-of-bounds in xsk_setsockopt+0x909/0xa40 net/xdp/xsk.c:1420\nRead of size 4 at addr ffff888028c6cde3 by task syz-executor.0/7549\n\nCPU: 0 PID: 7549 Comm: syz-executor.0 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:88 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]\n  copy_from_sockptr include/linux/sockptr.h:55 [inline]\n  xsk_setsockopt+0x909/0xa40 net/xdp/xsk.c:1420\n  do_sock_setsockopt+0x3af/0x720 net/socket.c:2311\n  __sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n  __do_sys_setsockopt net/socket.c:2343 [inline]\n  __se_sys_setsockopt net/socket.c:2340 [inline]\n  __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\n do_syscall_64+0xfb/0x240\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\nRIP: 0033:0x7fb40587de69\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 e1 20 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fb40665a0c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 00007fb4059abf80 RCX: 00007fb40587de69\nRDX: 0000000000000005 RSI: 000000000000011b RDI: 0000000000000006\nRBP: 00007fb4058ca47a R08: 0000000000000002 R09: 0000000000000000\nR10: 0000000020001980 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007fb4059abf80 R15: 00007fff57ee4d08\n </TASK>\n\nAllocated by task 7549:\n  kasan_save_stack mm/kasan/common.c:47 [inline]\n  kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n  poison_kmalloc_redzone mm/kasan/common.c:370 [inline]\n  __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:387\n  kasan_kmalloc include/linux/kasan.h:211 [inline]\n  __do_kmalloc_node mm/slub.c:3966 [inline]\n  __kmalloc+0x233/0x4a0 mm/slub.c:3979\n  kmalloc include/linux/slab.h:632 [inline]\n  __cgroup_bpf_run_filter_setsockopt+0xd2f/0x1040 kernel/bpf/cgroup.c:1869\n  do_sock_setsockopt+0x6b4/0x720 net/socket.c:2293\n  __sys_setsockopt+0x1ae/0x250 net/socket.c:2334\n  __do_sys_setsockopt net/socket.c:2343 [inline]\n  __se_sys_setsockopt net/socket.c:2340 [inline]\n  __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340\n do_syscall_64+0xfb/0x240\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nThe buggy address belongs to the object at ffff888028c6cde0\n which belongs to the cache kmalloc-8 of size 8\nThe buggy address is located 1 bytes to the right of\n allocated 2-byte region [ffff888028c6cde0, ffff888028c6cde2)\n\nThe buggy address belongs to the physical page:\npage:ffffea0000a31b00 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888028c6c9c0 pfn:0x28c6c\nanon flags: 0xfff00000000800(slab|node=0|zone=1|lastcpupid=0x7ff)\npage_type: 0xffffffff()\nraw: 00fff00000000800 ffff888014c41280 0000000000000000 dead000000000001\nraw: ffff888028c6c9c0 0000000080800057 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 0, migratetype Unmovable, gfp_mask 0x112cc0(GFP_USER|__GFP_NOWARN|__GFP_NORETRY), pid 6648, tgid 6644 (syz-executor.0), ts 133906047828, free_ts 133859922223\n  set_page_owner include/linux/page_owner.h:31 [inline]\n  post_alloc_hook+0x1ea/0x210 mm/page_alloc.c:1533\n  prep_new_page mm/page_alloc.c:\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-35976",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-20",
                    "modification_date": "2025-11-04",
                    "nvd_score_v3": 6.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53619",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: conntrack: Avoid nf_ct_helper_hash uses after free\n\nIf nf_conntrack_init_start() fails (for example due to a\nregister_nf_conntrack_bpf() failure), the nf_conntrack_helper_fini()\nclean-up path frees the nf_ct_helper_hash map.\n\nWhen built with NF_CONNTRACK=y, further netfilter modules (e.g:\nnetfilter_conntrack_ftp) can still be loaded and call\nnf_conntrack_helpers_register(), independently of whether nf_conntrack\ninitialized correctly. This accesses the nf_ct_helper_hash dangling\npointer and causes a uaf, possibly leading to random memory corruption.\n\nThis patch guards nf_conntrack_helper_register() from accessing a freed\nor uninitialized nf_ct_helper_hash pointer and fixes possible\nuses-after-free when loading a conntrack module.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39790",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: mhi: host: Detect events pointing to unexpected TREs\n\nWhen a remote device sends a completion event to the host, it contains a\npointer to the consumed TRE. The host uses this pointer to process all of\nthe TREs between it and the host's local copy of the ring's read pointer.\nThis works when processing completion for chained transactions, but can\nlead to nasty results if the device sends an event for a single-element\ntransaction with a read pointer that is multiple elements ahead of the\nhost's read pointer.\n\nFor instance, if the host accesses an event ring while the device is\nupdating it, the pointer inside of the event might still point to an old\nTRE. If the host uses the channel's xfer_cb() to directly free the buffer\npointed to by the TRE, the buffer will be double-freed.\n\nThis behavior was observed on an ep that used upstream EP stack without\n'commit 6f18d174b73d (\"bus: mhi: ep: Update read pointer only after buffer\nis written\")'. Where the device updated the events ring pointer before\nupdating the event contents, so it left a window where the host was able to\naccess the stale data the event pointed to, before the device had the\nchance to update them. The usual pattern was that the host received an\nevent pointing to a TRE that is not immediately after the last processed\none, so it got treated as if it was a chained transaction, processing all\nof the TREs in between the two read pointers.\n\nThis commit aims to harden the host by ensuring transactions where the\nevent points to a TRE that isn't local_rp + 1 are chained.\n\n[mani: added stable tag and reworded commit message]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-34981",
                    "description": "Linux Kernel Bluetooth CMTP Module Double Free Privilege Escalation Vulnerability. This vulnerability allows local attackers to escalate privileges on affected installations of Linux Kernel. An attacker must first obtain the ability to execute high-privileged code on the target system in order to exploit this vulnerability.\n\nThe specific flaw exists within the CMTP module. The issue results from the lack of validating the existence of an object prior to performing further free operations on the object. An attacker can leverage this vulnerability to escalate privileges and execute code in the context of the kernel. Was ZDI-CAN-11977.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-34981",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-07",
                    "modification_date": "2025-08-14",
                    "nvd_score_v3": 6.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53676",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: iscsi: Fix buffer overflow in lio_target_nacl_info_show()\n\nThe function lio_target_nacl_info_show() uses sprintf() in a loop to print\ndetails for every iSCSI connection in a session without checking for the\nbuffer length. With enough iSCSI connections it's possible to overflow the\nbuffer provided by configfs and corrupt the memory.\n\nThis patch replaces sprintf() with sysfs_emit_at() that checks for buffer\nboundries.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54168",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx4: Prevent shift wrapping in set_user_sq_size()\n\nThe ucmd->log_sq_bb_count variable is controlled by the user so this\nshift can wrap.  Fix it by using check_shl_overflow() in the same way\nthat it was done in commit 515f60004ed9 (\"RDMA/hns: Prevent undefined\nbehavior in hns_roce_set_user_sq_size()\").",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39824",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: asus: fix UAF via HID_CLAIMED_INPUT validation\n\nAfter hid_hw_start() is called hidinput_connect() will eventually be\ncalled to set up the device with the input layer since the\nHID_CONNECT_DEFAULT connect mask is used. During hidinput_connect()\nall input and output reports are processed and corresponding hid_inputs\nare allocated and configured via hidinput_configure_usages(). This\nprocess involves slot tagging report fields and configuring usages\nby setting relevant bits in the capability bitmaps. However it is possible\nthat the capability bitmaps are not set at all leading to the subsequent\nhidinput_has_been_populated() check to fail leading to the freeing of the\nhid_input and the underlying input device.\n\nThis becomes problematic because a malicious HID device like a\nASUS ROG N-Key keyboard can trigger the above scenario via a\nspecially crafted descriptor which then leads to a user-after-free\nwhen the name of the freed input device is written to later on after\nhid_hw_start(). Below, report 93 intentionally utilises the\nHID_UP_UNDEFINED Usage Page which is skipped during usage\nconfiguration, leading to the frees.\n\n0x05, 0x0D,        // Usage Page (Digitizer)\n0x09, 0x05,        // Usage (Touch Pad)\n0xA1, 0x01,        // Collection (Application)\n0x85, 0x0D,        //   Report ID (13)\n0x06, 0x00, 0xFF,  //   Usage Page (Vendor Defined 0xFF00)\n0x09, 0xC5,        //   Usage (0xC5)\n0x15, 0x00,        //   Logical Minimum (0)\n0x26, 0xFF, 0x00,  //   Logical Maximum (255)\n0x75, 0x08,        //   Report Size (8)\n0x95, 0x04,        //   Report Count (4)\n0xB1, 0x02,        //   Feature (Data,Var,Abs)\n0x85, 0x5D,        //   Report ID (93)\n0x06, 0x00, 0x00,  //   Usage Page (Undefined)\n0x09, 0x01,        //   Usage (0x01)\n0x15, 0x00,        //   Logical Minimum (0)\n0x26, 0xFF, 0x00,  //   Logical Maximum (255)\n0x75, 0x08,        //   Report Size (8)\n0x95, 0x1B,        //   Report Count (27)\n0x81, 0x02,        //   Input (Data,Var,Abs)\n0xC0,              // End Collection\n\nBelow is the KASAN splat after triggering the UAF:\n\n[   21.672709] ==================================================================\n[   21.673700] BUG: KASAN: slab-use-after-free in asus_probe+0xeeb/0xf80\n[   21.673700] Write of size 8 at addr ffff88810a0ac000 by task kworker/1:2/54\n[   21.673700]\n[   21.673700] CPU: 1 UID: 0 PID: 54 Comm: kworker/1:2 Not tainted 6.16.0-rc4-g9773391cf4dd-dirty #36 PREEMPT(voluntary)\n[   21.673700] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n[   21.673700] Call Trace:\n[   21.673700]  <TASK>\n[   21.673700]  dump_stack_lvl+0x5f/0x80\n[   21.673700]  print_report+0xd1/0x660\n[   21.673700]  kasan_report+0xe5/0x120\n[   21.673700]  __asan_report_store8_noabort+0x1b/0x30\n[   21.673700]  asus_probe+0xeeb/0xf80\n[   21.673700]  hid_device_probe+0x2ee/0x700\n[   21.673700]  really_probe+0x1c6/0x6b0\n[   21.673700]  __driver_probe_device+0x24f/0x310\n[   21.673700]  driver_probe_device+0x4e/0x220\n[...]\n[   21.673700]\n[   21.673700] Allocated by task 54:\n[   21.673700]  kasan_save_stack+0x3d/0x60\n[   21.673700]  kasan_save_track+0x18/0x40\n[   21.673700]  kasan_save_alloc_info+0x3b/0x50\n[   21.673700]  __kasan_kmalloc+0x9c/0xa0\n[   21.673700]  __kmalloc_cache_noprof+0x139/0x340\n[   21.673700]  input_allocate_device+0x44/0x370\n[   21.673700]  hidinput_connect+0xcb6/0x2630\n[   21.673700]  hid_connect+0xf74/0x1d60\n[   21.673700]  hid_hw_start+0x8c/0x110\n[   21.673700]  asus_probe+0x5a3/0xf80\n[   21.673700]  hid_device_probe+0x2ee/0x700\n[   21.673700]  really_probe+0x1c6/0x6b0\n[   21.673700]  __driver_probe_device+0x24f/0x310\n[   21.673700]  driver_probe_device+0x4e/0x220\n[...]\n[   21.673700]\n[   21.673700] Freed by task 54:\n[   21.673700]  kasan_save_stack+0x3d/0x60\n[   21.673700]  kasan_save_track+0x18/0x40\n[   21.673700]  kasan_save_free_info+0x3f/0x60\n[   21.673700]  __kasan_slab_free+0x3c/0x50\n[   21.673700]  kfre\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40018",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipvs: Defer ip_vs_ftp unregister during netns cleanup\n\nOn the netns cleanup path, __ip_vs_ftp_exit() may unregister ip_vs_ftp\nbefore connections with valid cp->app pointers are flushed, leading to a\nuse-after-free.\n\nFix this by introducing a global `exiting_module` flag, set to true in\nip_vs_ftp_exit() before unregistering the pernet subsystem. In\n__ip_vs_ftp_exit(), skip ip_vs_ftp unregister if called during netns\ncleanup (when exiting_module is false) and defer it to\n__ip_vs_cleanup_batch(), which unregisters all apps after all connections\nare flushed. If called during module exit, unregister ip_vs_ftp\nimmediately.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-24",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40261",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme: nvme-fc: Ensure ->ioerr_work is cancelled in nvme_fc_delete_ctrl()\n\nnvme_fc_delete_assocation() waits for pending I/O to complete before\nreturning, and an error can cause ->ioerr_work to be queued after\ncancel_work_sync() had been called.  Move the call to cancel_work_sync() to\nbe after nvme_fc_delete_association() to ensure ->ioerr_work is not running\nwhen the nvme_fc_ctrl object is freed.  Otherwise the following can occur:\n\n[ 1135.911754] list_del corruption, ff2d24c8093f31f8->next is NULL\n[ 1135.917705] ------------[ cut here ]------------\n[ 1135.922336] kernel BUG at lib/list_debug.c:52!\n[ 1135.926784] Oops: invalid opcode: 0000 [#1] SMP NOPTI\n[ 1135.931851] CPU: 48 UID: 0 PID: 726 Comm: kworker/u449:23 Kdump: loaded Not tainted 6.12.0 #1 PREEMPT(voluntary)\n[ 1135.943490] Hardware name: Dell Inc. PowerEdge R660/0HGTK9, BIOS 2.5.4 01/16/2025\n[ 1135.950969] Workqueue:  0x0 (nvme-wq)\n[ 1135.954673] RIP: 0010:__list_del_entry_valid_or_report.cold+0xf/0x6f\n[ 1135.961041] Code: c7 c7 98 68 72 94 e8 26 45 fe ff 0f 0b 48 c7 c7 70 68 72 94 e8 18 45 fe ff 0f 0b 48 89 fe 48 c7 c7 80 69 72 94 e8 07 45 fe ff <0f> 0b 48 89 d1 48 c7 c7 a0 6a 72 94 48 89 c2 e8 f3 44 fe ff 0f 0b\n[ 1135.979788] RSP: 0018:ff579b19482d3e50 EFLAGS: 00010046\n[ 1135.985015] RAX: 0000000000000033 RBX: ff2d24c8093f31f0 RCX: 0000000000000000\n[ 1135.992148] RDX: 0000000000000000 RSI: ff2d24d6bfa1d0c0 RDI: ff2d24d6bfa1d0c0\n[ 1135.999278] RBP: ff2d24c8093f31f8 R08: 0000000000000000 R09: ffffffff951e2b08\n[ 1136.006413] R10: ffffffff95122ac8 R11: 0000000000000003 R12: ff2d24c78697c100\n[ 1136.013546] R13: fffffffffffffff8 R14: 0000000000000000 R15: ff2d24c78697c0c0\n[ 1136.020677] FS:  0000000000000000(0000) GS:ff2d24d6bfa00000(0000) knlGS:0000000000000000\n[ 1136.028765] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 1136.034510] CR2: 00007fd207f90b80 CR3: 000000163ea22003 CR4: 0000000000f73ef0\n[ 1136.041641] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 1136.048776] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400\n[ 1136.055910] PKRU: 55555554\n[ 1136.058623] Call Trace:\n[ 1136.061074]  <TASK>\n[ 1136.063179]  ? show_trace_log_lvl+0x1b0/0x2f0\n[ 1136.067540]  ? show_trace_log_lvl+0x1b0/0x2f0\n[ 1136.071898]  ? move_linked_works+0x4a/0xa0\n[ 1136.075998]  ? __list_del_entry_valid_or_report.cold+0xf/0x6f\n[ 1136.081744]  ? __die_body.cold+0x8/0x12\n[ 1136.085584]  ? die+0x2e/0x50\n[ 1136.088469]  ? do_trap+0xca/0x110\n[ 1136.091789]  ? do_error_trap+0x65/0x80\n[ 1136.095543]  ? __list_del_entry_valid_or_report.cold+0xf/0x6f\n[ 1136.101289]  ? exc_invalid_op+0x50/0x70\n[ 1136.105127]  ? __list_del_entry_valid_or_report.cold+0xf/0x6f\n[ 1136.110874]  ? asm_exc_invalid_op+0x1a/0x20\n[ 1136.115059]  ? __list_del_entry_valid_or_report.cold+0xf/0x6f\n[ 1136.120806]  move_linked_works+0x4a/0xa0\n[ 1136.124733]  worker_thread+0x216/0x3a0\n[ 1136.128485]  ? __pfx_worker_thread+0x10/0x10\n[ 1136.132758]  kthread+0xfa/0x240\n[ 1136.135904]  ? __pfx_kthread+0x10/0x10\n[ 1136.139657]  ret_from_fork+0x31/0x50\n[ 1136.143236]  ? __pfx_kthread+0x10/0x10\n[ 1136.146988]  ret_from_fork_asm+0x1a/0x30\n[ 1136.150915]  </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47230",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Immediately reset the MMU context when the SMM flag is cleared\n\nImmediately reset the MMU context when the vCPU's SMM flag is cleared so\nthat the SMM flag in the MMU role is always synchronized with the vCPU's\nflag.  If RSM fails (which isn't correctly emulated), KVM will bail\nwithout calling post_leave_smm() and leave the MMU in a bad state.\n\nThe bad MMU role can lead to a NULL pointer dereference when grabbing a\nshadow page's rmap for a page fault as the initial lookups for the gfn\nwill happen with the vCPU's SMM flag (=0), whereas the rmap lookup will\nuse the shadow page's SMM flag, which comes from the MMU (=1).  SMM has\nan entirely different set of memslots, and so the initial lookup can find\na memslot (SMM=0) and then explode on the rmap memslot lookup (SMM=1).\n\n  general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  CPU: 1 PID: 8410 Comm: syz-executor382 Not tainted 5.13.0-rc5-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:__gfn_to_rmap arch/x86/kvm/mmu/mmu.c:935 [inline]\n  RIP: 0010:gfn_to_rmap+0x2b0/0x4d0 arch/x86/kvm/mmu/mmu.c:947\n  Code: <42> 80 3c 20 00 74 08 4c 89 ff e8 f1 79 a9 00 4c 89 fb 4d 8b 37 44\n  RSP: 0018:ffffc90000ffef98 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffff888015b9f414 RCX: ffff888019669c40\n  RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000001\n  RBP: 0000000000000001 R08: ffffffff811d9cdb R09: ffffed10065a6002\n  R10: ffffed10065a6002 R11: 0000000000000000 R12: dffffc0000000000\n  R13: 0000000000000003 R14: 0000000000000001 R15: 0000000000000000\n  FS:  000000000124b300(0000) GS:ffff8880b9b00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 0000000028e31000 CR4: 00000000001526e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   rmap_add arch/x86/kvm/mmu/mmu.c:965 [inline]\n   mmu_set_spte+0x862/0xe60 arch/x86/kvm/mmu/mmu.c:2604\n   __direct_map arch/x86/kvm/mmu/mmu.c:2862 [inline]\n   direct_page_fault+0x1f74/0x2b70 arch/x86/kvm/mmu/mmu.c:3769\n   kvm_mmu_do_page_fault arch/x86/kvm/mmu.h:124 [inline]\n   kvm_mmu_page_fault+0x199/0x1440 arch/x86/kvm/mmu/mmu.c:5065\n   vmx_handle_exit+0x26/0x160 arch/x86/kvm/vmx/vmx.c:6122\n   vcpu_enter_guest+0x3bdd/0x9630 arch/x86/kvm/x86.c:9428\n   vcpu_run+0x416/0xc20 arch/x86/kvm/x86.c:9494\n   kvm_arch_vcpu_ioctl_run+0x4e8/0xa40 arch/x86/kvm/x86.c:9722\n   kvm_vcpu_ioctl+0x70f/0xbb0 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3460\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:1069 [inline]\n   __se_sys_ioctl+0xfb/0x170 fs/ioctl.c:1055\n   do_syscall_64+0x3f/0xb0 arch/x86/entry/common.c:47\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  RIP: 0033:0x440ce9",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47230",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-04",
                    "nvd_score_v3": 6.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53729",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: qmi_encdec: Restrict string length in decode\n\nThe QMI TLV value for strings in a lot of qmi element info structures\naccount for null terminated strings with MAX_LEN + 1. If a string is\nactually MAX_LEN + 1 length, this will cause an out of bounds access\nwhen the NULL character is appended in decoding.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-22",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-0607",
                    "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The issue is in the nft_byteorder_eval() function, where the code iterates through a loop and writes to the `dst` array. On each iteration, 8 bytes are written, but `dst` is an array of u32, so each element only has space for 4 bytes. That means every iteration overwrites part of the previous element corrupting this array of u32. This flaw allows a local user to cause a denial of service or potentially break NetFilter functionality.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-0607",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-01-18",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52819",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd: Fix UBSAN array-index-out-of-bounds for Polaris and Tonga\n\nFor pptable structs that use flexible array sizes, use flexible arrays.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52819",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 6.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50783",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: use proper req destructor for IPv6\n\nBefore, only the destructor from TCP request sock in IPv4 was called\neven if the subflow was IPv6.\n\nIt is important to use the right destructor to avoid memory leaks with\nsome advanced IPv6 features, e.g. when the request socks contain\nspecific IPv6 options.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-28712",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put()\n\nsyzbot reported that nf_reject_ip6_tcphdr_put() was possibly sending\ngarbage on the four reserved tcp bits (th->res1)\n\nUse skb_put_zero() to clear the whole TCP header,\nas done in nf_reject_ip_tcphdr_put()\n\nBUG: KMSAN: uninit-value in nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1da/0xa00 net/core/dev.c:5775\n  process_backlog+0x4ad/0xa50 net/core/dev.c:6108\n  __napi_poll+0xe7/0x980 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0xa5a/0x19b0 net/core/dev.c:6963\n  handle_softirqs+0x1ce/0x800 kernel/softirq.c:554\n  __do_softirq+0x14/0x1a kernel/softirq.c:588\n  do_softirq+0x9a/0x100 kernel/softirq.c:455\n  __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:382\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:908 [inline]\n  __dev_queue_xmit+0x2692/0x5610 net/core/dev.c:4450\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  neigh_resolve_output+0x9ca/0xae0 net/core/neighbour.c:1565\n  neigh_output include/net/neighbour.h:542 [inline]\n  ip6_finish_output2+0x2347/0x2ba0 net/ipv6/ip6_output.c:141\n  __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]\n  ip6_finish_output+0xbb8/0x14b0 net/ipv6/ip6_output.c:226\n  NF_HOOK_COND include/linux/netfilter.h:303 [inline]\n  ip6_output+0x356/0x620 net/ipv6/ip6_output.c:247\n  dst_output include/net/dst.h:450 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_xmit+0x1ba6/0x25d0 net/ipv6/ip6_output.c:366\n  inet6_csk_xmit+0x442/0x530 net/ipv6/inet6_connection_sock.c:135\n  __tcp_transmit_skb+0x3b07/0x4880 net/ipv4/tcp_output.c:1466\n  tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n  tcp_connect+0x35b6/0x7130 net/ipv4/tcp_output.c:4143\n  tcp_v6_connect+0x1bcc/0x1e40 net/ipv6/tcp_ipv6.c:333\n  __inet_stream_connect+0x2ef/0x1730 net/ipv4/af_inet.c:679\n  inet_stream_connect+0x6a/0xd0 net/ipv4/af_inet.c:750\n  __sys_connect_file net/socket.c:2061 [inline]\n  __sys_connect+0x606/0x690 net/socket.c:2078\n  __do_sys_connect net/socket.c:2088 [inline]\n  __se_sys_connect net/socket.c:2085 [inline]\n  __x64_sys_connect+0x91/0xe0 net/socket.c:2085\n  x64_sys_call+0x27a5/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:43\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was stored to memory at:\n  nf_reject_ip6_tcphdr_put+0x60c/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:249\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core\n---truncated---",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28712",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-01-05",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47692",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: return -EINVAL when namelen is 0\n\nWhen we have a corrupted main.sqlite in /var/lib/nfs/nfsdcld/, it may\nresult in namelen being 0, which will cause memdup_user() to return\nZERO_SIZE_PTR.\nWhen we access the name.data that has been assigned the value of\nZERO_SIZE_PTR in nfs4_client_to_reclaim(), null pointer dereference is\ntriggered.\n\n[ T1205] ==================================================================\n[ T1205] BUG: KASAN: null-ptr-deref in nfs4_client_to_reclaim+0xe9/0x260\n[ T1205] Read of size 1 at addr 0000000000000010 by task nfsdcld/1205\n[ T1205]\n[ T1205] CPU: 11 PID: 1205 Comm: nfsdcld Not tainted 5.10.0-00003-g2c1423731b8d #406\n[ T1205] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-buildvm-ppc64le-16.ppc.fedoraproject.org-3.fc31 04/01/2014\n[ T1205] Call Trace:\n[ T1205]  dump_stack+0x9a/0xd0\n[ T1205]  ? nfs4_client_to_reclaim+0xe9/0x260\n[ T1205]  __kasan_report.cold+0x34/0x84\n[ T1205]  ? nfs4_client_to_reclaim+0xe9/0x260\n[ T1205]  kasan_report+0x3a/0x50\n[ T1205]  nfs4_client_to_reclaim+0xe9/0x260\n[ T1205]  ? nfsd4_release_lockowner+0x410/0x410\n[ T1205]  cld_pipe_downcall+0x5ca/0x760\n[ T1205]  ? nfsd4_cld_tracking_exit+0x1d0/0x1d0\n[ T1205]  ? down_write_killable_nested+0x170/0x170\n[ T1205]  ? avc_policy_seqno+0x28/0x40\n[ T1205]  ? selinux_file_permission+0x1b4/0x1e0\n[ T1205]  rpc_pipe_write+0x84/0xb0\n[ T1205]  vfs_write+0x143/0x520\n[ T1205]  ksys_write+0xc9/0x170\n[ T1205]  ? __ia32_sys_read+0x50/0x50\n[ T1205]  ? ktime_get_coarse_real_ts64+0xfe/0x110\n[ T1205]  ? ktime_get_coarse_real_ts64+0xa2/0x110\n[ T1205]  do_syscall_64+0x33/0x40\n[ T1205]  entry_SYSCALL_64_after_hwframe+0x67/0xd1\n[ T1205] RIP: 0033:0x7fdbdb761bc7\n[ T1205] Code: 0f 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b7 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 514\n[ T1205] RSP: 002b:00007fff8c4b7248 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[ T1205] RAX: ffffffffffffffda RBX: 000000000000042b RCX: 00007fdbdb761bc7\n[ T1205] RDX: 000000000000042b RSI: 00007fff8c4b75f0 RDI: 0000000000000008\n[ T1205] RBP: 00007fdbdb761bb0 R08: 0000000000000000 R09: 0000000000000001\n[ T1205] R10: 0000000000000000 R11: 0000000000000246 R12: 000000000000042b\n[ T1205] R13: 0000000000000008 R14: 00007fff8c4b75f0 R15: 0000000000000000\n[ T1205] ==================================================================\n\nFix it by checking namelen.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47692",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-3178",
                    "description": "fs/nfsd/nfs3xdr.c in the Linux kernel through 5.10.8, when there is an NFS export of a subdirectory of a filesystem, allows remote attackers to traverse to other parts of the filesystem via READDIRPLUS. NOTE: some parties argue that such a subdirectory export is not intended to prevent this attack; see also the exports(5) no_subtree_check default behavior",
                    "nvd_score": 5.5,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:N/AC:L/Au:S/C:P/I:P/A:N",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3178",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-01-19",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39969",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix validation of VF state in get resources\n\nVF state I40E_VF_STATE_ACTIVE is not the only state in which\nVF is actually active so it should not be used to determine\nif a VF is allowed to obtain resources.\n\nUse I40E_VF_STATE_RESOURCES_LOADED that is set only in\ni40e_vc_get_vf_resources_msg() and cleared during reset.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-16",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-26886",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: af_bluetooth: Fix deadlock\n\nAttemting to do sock_lock on .recvmsg may cause a deadlock as shown\nbellow, so instead of using sock_sock this uses sk_receive_queue.lock\non bt_sock_ioctl to avoid the UAF:\n\nINFO: task kworker/u9:1:121 blocked for more than 30 seconds.\n      Not tainted 6.7.6-lemon #183\nWorkqueue: hci0 hci_rx_work\nCall Trace:\n <TASK>\n __schedule+0x37d/0xa00\n schedule+0x32/0xe0\n __lock_sock+0x68/0xa0\n ? __pfx_autoremove_wake_function+0x10/0x10\n lock_sock_nested+0x43/0x50\n l2cap_sock_recv_cb+0x21/0xa0\n l2cap_recv_frame+0x55b/0x30a0\n ? psi_task_switch+0xeb/0x270\n ? finish_task_switch.isra.0+0x93/0x2a0\n hci_rx_work+0x33a/0x3f0\n process_one_work+0x13a/0x2f0\n worker_thread+0x2f0/0x410\n ? __pfx_worker_thread+0x10/0x10\n kthread+0xe0/0x110\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x2c/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1b/0x30\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-26886",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-17",
                    "modification_date": "2025-03-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-3702",
                    "description": "u'Specifically timed and handcrafted traffic can cause internal errors in a WLAN device that lead to improper layer 2 Wi-Fi encryption with a consequent possibility of information disclosure over the air for a discrete set of traffic' in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables, Snapdragon Wired Infrastructure and Networking in APQ8053, IPQ4019, IPQ8064, MSM8909W, MSM8996AU, QCA9531, QCN5502, QCS405, SDX20, SM6150, SM7150",
                    "nvd_score": 3.3,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:A/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-3702",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2020-09-08",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54292",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/irdma: Fix data race on CQP request done\n\nKCSAN detects a data race on cqp_request->request_done memory location\nwhich is accessed locklessly in irdma_handle_cqp_op while being\nupdated in irdma_cqp_ce_handler.\n\nAnnotate lockless intent with READ_ONCE/WRITE_ONCE to avoid any\ncompiler optimizations like load fusing and/or KCSAN warning.\n\n[222808.417128] BUG: KCSAN: data-race in irdma_cqp_ce_handler [irdma] / irdma_wait_event [irdma]\n\n[222808.417532] write to 0xffff8e44107019dc of 1 bytes by task 29658 on cpu 5:\n[222808.417610]  irdma_cqp_ce_handler+0x21e/0x270 [irdma]\n[222808.417725]  cqp_compl_worker+0x1b/0x20 [irdma]\n[222808.417827]  process_one_work+0x4d1/0xa40\n[222808.417835]  worker_thread+0x319/0x700\n[222808.417842]  kthread+0x180/0x1b0\n[222808.417852]  ret_from_fork+0x22/0x30\n\n[222808.417918] read to 0xffff8e44107019dc of 1 bytes by task 29688 on cpu 1:\n[222808.417995]  irdma_wait_event+0x1e2/0x2c0 [irdma]\n[222808.418099]  irdma_handle_cqp_op+0xae/0x170 [irdma]\n[222808.418202]  irdma_cqp_cq_destroy_cmd+0x70/0x90 [irdma]\n[222808.418308]  irdma_puda_dele_rsrc+0x46d/0x4d0 [irdma]\n[222808.418411]  irdma_rt_deinit_hw+0x179/0x1d0 [irdma]\n[222808.418514]  irdma_ib_dealloc_device+0x11/0x40 [irdma]\n[222808.418618]  ib_dealloc_device+0x2a/0x120 [ib_core]\n[222808.418823]  __ib_unregister_device+0xde/0x100 [ib_core]\n[222808.418981]  ib_unregister_device+0x22/0x40 [ib_core]\n[222808.419142]  irdma_ib_unregister_device+0x70/0x90 [irdma]\n[222808.419248]  i40iw_close+0x6f/0xc0 [irdma]\n[222808.419352]  i40e_client_device_unregister+0x14a/0x180 [i40e]\n[222808.419450]  i40iw_remove+0x21/0x30 [irdma]\n[222808.419554]  auxiliary_bus_remove+0x31/0x50\n[222808.419563]  device_remove+0x69/0xb0\n[222808.419572]  device_release_driver_internal+0x293/0x360\n[222808.419582]  driver_detach+0x7c/0xf0\n[222808.419592]  bus_remove_driver+0x8c/0x150\n[222808.419600]  driver_unregister+0x45/0x70\n[222808.419610]  auxiliary_driver_unregister+0x16/0x30\n[222808.419618]  irdma_exit_module+0x18/0x1e [irdma]\n[222808.419733]  __do_sys_delete_module.constprop.0+0x1e2/0x310\n[222808.419745]  __x64_sys_delete_module+0x1b/0x30\n[222808.419755]  do_syscall_64+0x39/0x90\n[222808.419763]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\n[222808.419829] value changed: 0x01 -> 0x03",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53785",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: mt7921: don't assume adequate headroom for SDIO headers\n\nmt7921_usb_sdio_tx_prepare_skb() calls mt7921_usb_sdio_write_txwi() and\nmt7921_skb_add_usb_sdio_hdr(), both of which blindly assume that\nadequate headroom will be available in the passed skb. This assumption\ntypically is satisfied when the skb was allocated in the net core for\ntransmission via the mt7921 netdev (although even that is only an\noptimization and is not strictly guaranteed), but the assumption is\nsometimes not satisfied when the skb originated in the receive path of\nanother netdev and was passed through to the mt7921, such as by the\nbridge layer. Blindly prepending bytes to an skb is always wrong.\n\nThis commit introduces a call to skb_cow_head() before the call to\nmt7921_usb_sdio_write_txwi() in mt7921_usb_sdio_tx_prepare_skb() to\nensure that at least MT_SDIO_TXD_SIZE + MT_SDIO_HDR_SIZE bytes can be\npushed onto the skb.\n\nWithout this fix, I can trivially cause kernel panics by bridging an\nMT7921AU-based USB 802.11ax interface with an Ethernet interface on an\nIntel Atom-based x86 system using its onboard RTL8169 PCI Ethernet\nadapter and also on an ARM-based Raspberry Pi 1 using its onboard\nSMSC9512 USB Ethernet adapter. Note that the panics do not occur in\nevery system configuration, as they occur only if the receiving netdev\nleaves less headroom in its received skbs than the mt7921 needs for its\nSDIO headers.\n\nHere is an example stack trace of this panic on Raspberry Pi OS Lite\n2023-02-21 running kernel 6.1.24+ [1]:\n\n skb_panic from skb_push+0x44/0x48\n skb_push from mt7921_usb_sdio_tx_prepare_skb+0xd4/0x190 [mt7921_common]\n mt7921_usb_sdio_tx_prepare_skb [mt7921_common] from mt76u_tx_queue_skb+0x94/0x1d0 [mt76_usb]\n mt76u_tx_queue_skb [mt76_usb] from __mt76_tx_queue_skb+0x4c/0xc8 [mt76]\n __mt76_tx_queue_skb [mt76] from mt76_txq_schedule.part.0+0x13c/0x398 [mt76]\n mt76_txq_schedule.part.0 [mt76] from mt76_txq_schedule_all+0x24/0x30 [mt76]\n mt76_txq_schedule_all [mt76] from mt7921_tx_worker+0x58/0xf4 [mt7921_common]\n mt7921_tx_worker [mt7921_common] from __mt76_worker_fn+0x9c/0xec [mt76]\n __mt76_worker_fn [mt76] from kthread+0xbc/0xe0\n kthread from ret_from_fork+0x14/0x34\n\nAfter this fix, bridging the mt7921 interface works fine on both of my\npreviously problematic systems.\n\n[1] https://github.com/raspberrypi/firmware/tree/5c276f55a4b21345cd4d6200a504ee991851ff7a",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47308",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libfc: Fix array index out of bound exception\n\nFix array index out of bound exception in fc_rport_prli_resp().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47308",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-02",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53135",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: VMX: Bury Intel PT virtualization (guest/host mode) behind CONFIG_BROKEN\n\nHide KVM's pt_mode module param behind CONFIG_BROKEN, i.e. disable support\nfor virtualizing Intel PT via guest/host mode unless BROKEN=y.  There are\nmyriad bugs in the implementation, some of which are fatal to the guest,\nand others which put the stability and health of the host at risk.\n\nFor guest fatalities, the most glaring issue is that KVM fails to ensure\ntracing is disabled, and *stays* disabled prior to VM-Enter, which is\nnecessary as hardware disallows loading (the guest's) RTIT_CTL if tracing\nis enabled (enforced via a VMX consistency check).  Per the SDM:\n\n  If the logical processor is operating with Intel PT enabled (if\n  IA32_RTIT_CTL.TraceEn = 1) at the time of VM entry, the \"load\n  IA32_RTIT_CTL\" VM-entry control must be 0.\n\nOn the host side, KVM doesn't validate the guest CPUID configuration\nprovided by userspace, and even worse, uses the guest configuration to\ndecide what MSRs to save/load at VM-Enter and VM-Exit.  E.g. configuring\nguest CPUID to enumerate more address ranges than are supported in hardware\nwill result in KVM trying to passthrough, save, and load non-existent MSRs,\nwhich generates a variety of WARNs, ToPA ERRORs in the host, a potential\ndeadlock, etc.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53135",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68284",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibceph: prevent potential out-of-bounds writes in handle_auth_session_key()\n\nThe len field originates from untrusted network packets. Boundary\nchecks have been added to prevent potential out-of-bounds writes when\ndecrypting the connection secret or processing service tickets.\n\n[ idryomov: changelog ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2021-28713",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put()\n\nsyzbot reported that nf_reject_ip6_tcphdr_put() was possibly sending\ngarbage on the four reserved tcp bits (th->res1)\n\nUse skb_put_zero() to clear the whole TCP header,\nas done in nf_reject_ip_tcphdr_put()\n\nBUG: KMSAN: uninit-value in nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1da/0xa00 net/core/dev.c:5775\n  process_backlog+0x4ad/0xa50 net/core/dev.c:6108\n  __napi_poll+0xe7/0x980 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0xa5a/0x19b0 net/core/dev.c:6963\n  handle_softirqs+0x1ce/0x800 kernel/softirq.c:554\n  __do_softirq+0x14/0x1a kernel/softirq.c:588\n  do_softirq+0x9a/0x100 kernel/softirq.c:455\n  __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:382\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:908 [inline]\n  __dev_queue_xmit+0x2692/0x5610 net/core/dev.c:4450\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  neigh_resolve_output+0x9ca/0xae0 net/core/neighbour.c:1565\n  neigh_output include/net/neighbour.h:542 [inline]\n  ip6_finish_output2+0x2347/0x2ba0 net/ipv6/ip6_output.c:141\n  __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]\n  ip6_finish_output+0xbb8/0x14b0 net/ipv6/ip6_output.c:226\n  NF_HOOK_COND include/linux/netfilter.h:303 [inline]\n  ip6_output+0x356/0x620 net/ipv6/ip6_output.c:247\n  dst_output include/net/dst.h:450 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_xmit+0x1ba6/0x25d0 net/ipv6/ip6_output.c:366\n  inet6_csk_xmit+0x442/0x530 net/ipv6/inet6_connection_sock.c:135\n  __tcp_transmit_skb+0x3b07/0x4880 net/ipv4/tcp_output.c:1466\n  tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n  tcp_connect+0x35b6/0x7130 net/ipv4/tcp_output.c:4143\n  tcp_v6_connect+0x1bcc/0x1e40 net/ipv6/tcp_ipv6.c:333\n  __inet_stream_connect+0x2ef/0x1730 net/ipv4/af_inet.c:679\n  inet_stream_connect+0x6a/0xd0 net/ipv4/af_inet.c:750\n  __sys_connect_file net/socket.c:2061 [inline]\n  __sys_connect+0x606/0x690 net/socket.c:2078\n  __do_sys_connect net/socket.c:2088 [inline]\n  __se_sys_connect net/socket.c:2085 [inline]\n  __x64_sys_connect+0x91/0xe0 net/socket.c:2085\n  x64_sys_call+0x27a5/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:43\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was stored to memory at:\n  nf_reject_ip6_tcphdr_put+0x60c/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:249\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core\n---truncated---",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28713",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-01-05",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-38199",
                    "description": "fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection.",
                    "nvd_score": 3.3,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:A/AC:L/Au:N/C:N/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38199",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-08-08",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2021-28711",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_reject_ipv6: fix nf_reject_ip6_tcphdr_put()\n\nsyzbot reported that nf_reject_ip6_tcphdr_put() was possibly sending\ngarbage on the four reserved tcp bits (th->res1)\n\nUse skb_put_zero() to clear the whole TCP header,\nas done in nf_reject_ip_tcphdr_put()\n\nBUG: KMSAN: uninit-value in nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_reject_ip6_tcphdr_put+0x688/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:255\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1da/0xa00 net/core/dev.c:5775\n  process_backlog+0x4ad/0xa50 net/core/dev.c:6108\n  __napi_poll+0xe7/0x980 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0xa5a/0x19b0 net/core/dev.c:6963\n  handle_softirqs+0x1ce/0x800 kernel/softirq.c:554\n  __do_softirq+0x14/0x1a kernel/softirq.c:588\n  do_softirq+0x9a/0x100 kernel/softirq.c:455\n  __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:382\n  local_bh_enable include/linux/bottom_half.h:33 [inline]\n  rcu_read_unlock_bh include/linux/rcupdate.h:908 [inline]\n  __dev_queue_xmit+0x2692/0x5610 net/core/dev.c:4450\n  dev_queue_xmit include/linux/netdevice.h:3105 [inline]\n  neigh_resolve_output+0x9ca/0xae0 net/core/neighbour.c:1565\n  neigh_output include/net/neighbour.h:542 [inline]\n  ip6_finish_output2+0x2347/0x2ba0 net/ipv6/ip6_output.c:141\n  __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]\n  ip6_finish_output+0xbb8/0x14b0 net/ipv6/ip6_output.c:226\n  NF_HOOK_COND include/linux/netfilter.h:303 [inline]\n  ip6_output+0x356/0x620 net/ipv6/ip6_output.c:247\n  dst_output include/net/dst.h:450 [inline]\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_xmit+0x1ba6/0x25d0 net/ipv6/ip6_output.c:366\n  inet6_csk_xmit+0x442/0x530 net/ipv6/inet6_connection_sock.c:135\n  __tcp_transmit_skb+0x3b07/0x4880 net/ipv4/tcp_output.c:1466\n  tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n  tcp_connect+0x35b6/0x7130 net/ipv4/tcp_output.c:4143\n  tcp_v6_connect+0x1bcc/0x1e40 net/ipv6/tcp_ipv6.c:333\n  __inet_stream_connect+0x2ef/0x1730 net/ipv4/af_inet.c:679\n  inet_stream_connect+0x6a/0xd0 net/ipv4/af_inet.c:750\n  __sys_connect_file net/socket.c:2061 [inline]\n  __sys_connect+0x606/0x690 net/socket.c:2078\n  __do_sys_connect net/socket.c:2088 [inline]\n  __se_sys_connect net/socket.c:2085 [inline]\n  __x64_sys_connect+0x91/0xe0 net/socket.c:2085\n  x64_sys_call+0x27a5/0x3ba0 arch/x86/include/generated/asm/syscalls_64.h:43\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nUninit was stored to memory at:\n  nf_reject_ip6_tcphdr_put+0x60c/0x6c0 net/ipv6/netfilter/nf_reject_ipv6.c:249\n  nf_send_reset6+0xd84/0x15b0 net/ipv6/netfilter/nf_reject_ipv6.c:344\n  nft_reject_inet_eval+0x3c1/0x880 net/netfilter/nft_reject_inet.c:48\n  expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]\n  nft_do_chain+0x438/0x22a0 net/netfilter/nf_tables_core.c:288\n  nft_do_chain_inet+0x41a/0x4f0 net/netfilter/nft_chain_filter.c:161\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK include/linux/netfilter.h:312 [inline]\n  ipv6_rcv+0x29b/0x390 net/ipv6/ip6_input.c:310\n  __netif_receive_skb_one_core\n---truncated---",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-28711",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-01-05",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36968",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix div-by-zero in l2cap_le_flowctl_init()\n\nl2cap_le_flowctl_init() can cause both div-by-zero and an integer\noverflow since hdev->le_mtu may not fall in the valid range.\n\nMove MTU from hci_dev to hci_conn to validate MTU and stop the connection\nprocess earlier if MTU is invalid.\nAlso, add a missing validation in read_buffer_size() and make it return\nan error value if the validation fails.\nNow hci_conn_add() returns ERR_PTR() as it can fail due to the both a\nkzalloc failure and invalid MTU value.\n\ndivide error: 0000 [#1] PREEMPT SMP KASAN NOPTI\nCPU: 0 PID: 67 Comm: kworker/u5:0 Tainted: G        W          6.9.0-rc5+ #20\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nWorkqueue: hci0 hci_rx_work\nRIP: 0010:l2cap_le_flowctl_init+0x19e/0x3f0 net/bluetooth/l2cap_core.c:547\nCode: e8 17 17 0c 00 66 41 89 9f 84 00 00 00 bf 01 00 00 00 41 b8 02 00 00 00 4c\n89 fe 4c 89 e2 89 d9 e8 27 17 0c 00 44 89 f0 31 d2 <66> f7 f3 89 c3 ff c3 4d 8d\nb7 88 00 00 00 4c 89 f0 48 c1 e8 03 42\nRSP: 0018:ffff88810bc0f858 EFLAGS: 00010246\nRAX: 00000000000002a0 RBX: 0000000000000000 RCX: dffffc0000000000\nRDX: 0000000000000000 RSI: ffff88810bc0f7c0 RDI: ffffc90002dcb66f\nRBP: ffff88810bc0f880 R08: aa69db2dda70ff01 R09: 0000ffaaaaaaaaaa\nR10: 0084000000ffaaaa R11: 0000000000000000 R12: ffff88810d65a084\nR13: dffffc0000000000 R14: 00000000000002a0 R15: ffff88810d65a000\nFS:  0000000000000000(0000) GS:ffff88811ac00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000100 CR3: 0000000103268003 CR4: 0000000000770ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n l2cap_le_connect_req net/bluetooth/l2cap_core.c:4902 [inline]\n l2cap_le_sig_cmd net/bluetooth/l2cap_core.c:5420 [inline]\n l2cap_le_sig_channel net/bluetooth/l2cap_core.c:5486 [inline]\n l2cap_recv_frame+0xe59d/0x11710 net/bluetooth/l2cap_core.c:6809\n l2cap_recv_acldata+0x544/0x10a0 net/bluetooth/l2cap_core.c:7506\n hci_acldata_packet net/bluetooth/hci_core.c:3939 [inline]\n hci_rx_work+0x5e5/0xb20 net/bluetooth/hci_core.c:4176\n process_one_work kernel/workqueue.c:3254 [inline]\n process_scheduled_works+0x90f/0x1530 kernel/workqueue.c:3335\n worker_thread+0x926/0xe70 kernel/workqueue.c:3416\n kthread+0x2e3/0x380 kernel/kthread.c:388\n ret_from_fork+0x5c/0x90 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\nModules linked in:\n---[ end trace 0000000000000000 ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36968",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-08",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-0564",
                    "description": "A flaw was found in the Linux kernel's memory deduplication mechanism. The max page sharing of Kernel Samepage Merging (KSM), added in Linux kernel version 4.4.0-96.119, can create a side channel. When the attacker and the victim share the same host and the default setting of KSM is \"max page sharing=256\", it is possible for the attacker to time the unmap to merge with the victim's page. The unmapping time depends on whether it merges with the victim's page and additional physical pages are created beyond the KSM's \"max page share\". Through these operations, the attacker can leak the victim's page.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-0564",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-01-30",
                    "modification_date": "2024-11-25",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-68380",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix peer HE MCS assignment\n\nIn ath11k_wmi_send_peer_assoc_cmd(), peer's transmit MCS is sent to\nfirmware as receive MCS while peer's receive MCS sent as transmit MCS,\nwhich goes against firmwire's definition.\n\nWhile connecting to a misbehaved AP that advertises 0xffff (meaning not\nsupported) for 160 MHz transmit MCS map, firmware crashes due to 0xffff\nis assigned to he_mcs->rx_mcs_set field.\n\n\tExt Tag: HE Capabilities\n\t    [...]\n\t    Supported HE-MCS and NSS Set\n\t\t[...]\n\t        Rx and Tx MCS Maps 160 MHz\n\t\t    [...]\n\t            Tx HE-MCS Map 160 MHz: 0xffff\n\nSwap the assignment to fix this issue.\n\nAs the HE rate control mask is meant to limit our own transmit MCS, it\nneeds to go via he_mcs->rx_mcs_set field. With the aforementioned swapping\ndone, change is needed as well to apply it to the peer's receive MCS.\n\nTested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.41\nTested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.4.1-00199-QCAHKSWPL_SILICONZ-1",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50821",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: Don't leak netobj memory when gss_read_proxy_verf() fails",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-47693",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/core: Fix ib_cache_setup_one error flow cleanup\n\nWhen ib_cache_update return an error, we exit ib_cache_setup_one\ninstantly with no proper cleanup, even though before this we had\nalready successfully done gid_table_setup_one, that results in\nthe kernel WARN below.\n\nDo proper cleanup using gid_table_cleanup_one before returning\nthe err in order to fix the issue.\n\nWARNING: CPU: 4 PID: 922 at drivers/infiniband/core/cache.c:806 gid_table_release_one+0x181/0x1a0\nModules linked in:\nCPU: 4 UID: 0 PID: 922 Comm: c_repro Not tainted 6.11.0-rc1+ #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\nRIP: 0010:gid_table_release_one+0x181/0x1a0\nCode: 44 8b 38 75 0c e8 2f cb 34 ff 4d 8b b5 28 05 00 00 e8 23 cb 34 ff 44 89 f9 89 da 4c 89 f6 48 c7 c7 d0 58 14 83 e8 4f de 21 ff <0f> 0b 4c 8b 75 30 e9 54 ff ff ff 48 8    3 c4 10 5b 5d 41 5c 41 5d 41\nRSP: 0018:ffffc90002b835b0 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff811c8527\nRDX: 0000000000000000 RSI: ffffffff811c8534 RDI: 0000000000000001\nRBP: ffff8881011b3d00 R08: ffff88810b3abe00 R09: 205d303839303631\nR10: 666572207972746e R11: 72746e6520444947 R12: 0000000000000001\nR13: ffff888106390000 R14: ffff8881011f2110 R15: 0000000000000001\nFS:  00007fecc3b70800(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000340 CR3: 000000010435a001 CR4: 00000000003706b0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ? show_regs+0x94/0xa0\n ? __warn+0x9e/0x1c0\n ? gid_table_release_one+0x181/0x1a0\n ? report_bug+0x1f9/0x340\n ? gid_table_release_one+0x181/0x1a0\n ? handle_bug+0xa2/0x110\n ? exc_invalid_op+0x31/0xa0\n ? asm_exc_invalid_op+0x16/0x20\n ? __warn_printk+0xc7/0x180\n ? __warn_printk+0xd4/0x180\n ? gid_table_release_one+0x181/0x1a0\n ib_device_release+0x71/0xe0\n ? __pfx_ib_device_release+0x10/0x10\n device_release+0x44/0xd0\n kobject_put+0x135/0x3d0\n put_device+0x20/0x30\n rxe_net_add+0x7d/0xa0\n rxe_newlink+0xd7/0x190\n nldev_newlink+0x1b0/0x2a0\n ? __pfx_nldev_newlink+0x10/0x10\n rdma_nl_rcv_msg+0x1ad/0x2e0\n rdma_nl_rcv_skb.constprop.0+0x176/0x210\n netlink_unicast+0x2de/0x400\n netlink_sendmsg+0x306/0x660\n __sock_sendmsg+0x110/0x120\n ____sys_sendmsg+0x30e/0x390\n ___sys_sendmsg+0x9b/0xf0\n ? kstrtouint+0x6e/0xa0\n ? kstrtouint_from_user+0x7c/0xb0\n ? get_pid_task+0xb0/0xd0\n ? proc_fail_nth_write+0x5b/0x140\n ? __fget_light+0x9a/0x200\n ? preempt_count_add+0x47/0xa0\n __sys_sendmsg+0x61/0xd0\n do_syscall_64+0x50/0x110\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47693",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40321",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: fix crash while sending Action Frames in standalone AP Mode\n\nCurrently, whenever there is a need to transmit an Action frame,\nthe brcmfmac driver always uses the P2P vif to send the \"actframe\" IOVAR to\nfirmware. The P2P interfaces were available when wpa_supplicant is managing\nthe wlan interface.\n\nHowever, the P2P interfaces are not created/initialized when only hostapd\nis managing the wlan interface. And if hostapd receives an ANQP Query REQ\nAction frame even from an un-associated STA, the brcmfmac driver tries\nto use an uninitialized P2P vif pointer for sending the IOVAR to firmware.\nThis NULL pointer dereferencing triggers a driver crash.\n\n [ 1417.074538] Unable to handle kernel NULL pointer dereference at virtual\n address 0000000000000000\n [...]\n [ 1417.075188] Hardware name: Raspberry Pi 4 Model B Rev 1.5 (DT)\n [...]\n [ 1417.075653] Call trace:\n [ 1417.075662]  brcmf_p2p_send_action_frame+0x23c/0xc58 [brcmfmac]\n [ 1417.075738]  brcmf_cfg80211_mgmt_tx+0x304/0x5c0 [brcmfmac]\n [ 1417.075810]  cfg80211_mlme_mgmt_tx+0x1b0/0x428 [cfg80211]\n [ 1417.076067]  nl80211_tx_mgmt+0x238/0x388 [cfg80211]\n [ 1417.076281]  genl_family_rcv_msg_doit+0xe0/0x158\n [ 1417.076302]  genl_rcv_msg+0x220/0x2a0\n [ 1417.076317]  netlink_rcv_skb+0x68/0x140\n [ 1417.076330]  genl_rcv+0x40/0x60\n [ 1417.076343]  netlink_unicast+0x330/0x3b8\n [ 1417.076357]  netlink_sendmsg+0x19c/0x3f8\n [ 1417.076370]  __sock_sendmsg+0x64/0xc0\n [ 1417.076391]  ____sys_sendmsg+0x268/0x2a0\n [ 1417.076408]  ___sys_sendmsg+0xb8/0x118\n [ 1417.076427]  __sys_sendmsg+0x90/0xf8\n [ 1417.076445]  __arm64_sys_sendmsg+0x2c/0x40\n [ 1417.076465]  invoke_syscall+0x50/0x120\n [ 1417.076486]  el0_svc_common.constprop.0+0x48/0xf0\n [ 1417.076506]  do_el0_svc+0x24/0x38\n [ 1417.076525]  el0_svc+0x30/0x100\n [ 1417.076548]  el0t_64_sync_handler+0x100/0x130\n [ 1417.076569]  el0t_64_sync+0x190/0x198\n [ 1417.076589] Code: f9401e80 aa1603e2 f9403be1 5280e483 (f9400000)\n\nFix this, by always using the vif corresponding to the wdev on which the\nAction frame Transmission request was initiated by the userspace. This way,\neven if P2P vif is not available, the IOVAR is sent to firmware on AP vif\nand the ANQP Query RESP Action frame is transmitted without crashing the\ndriver.\n\nMove init_completion() for \"send_af_done\" from brcmf_p2p_create_p2pdev()\nto brcmf_p2p_attach(). Because the former function would not get executed\nwhen only hostapd is managing wlan interface, and it is not safe to do\nreinit_completion() later in brcmf_p2p_tx_action_frame(), without any prior\ninit_completion().\n\nAnd in the brcmf_p2p_tx_action_frame() function, the condition check for\nP2P Presence response frame is not needed, since the wpa_supplicant is\nproperly sending the P2P Presense Response frame on the P2P-GO vif instead\nof the P2P-Device vif.\n\n[Cc stable]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-20154",
                    "description": "In lock_sock_nested of sock.c, there is a possible use after free due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-174846563References: Upstream kernel",
                    "nvd_score": 4.4,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:M/Au:N/C:P/I:P/A:P",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-20154",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-06-15",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.4,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53627",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: hisi_sas: Grab sas_dev lock when traversing the members of sas_dev.list\n\nWhen freeing slots in function slot_complete_v3_hw(), it is possible that\nsas_dev.list is being traversed elsewhere, and it may trigger a NULL\npointer exception, such as follows:\n\n==>cq thread                    ==>scsi_eh_6\n\n                                ==>scsi_error_handler()\n\t\t\t\t  ==>sas_eh_handle_sas_errors()\n\t\t\t\t    ==>sas_scsi_find_task()\n\t\t\t\t      ==>lldd_abort_task()\n==>slot_complete_v3_hw()              ==>hisi_sas_abort_task()\n  ==>hisi_sas_slot_task_free()\t        ==>dereg_device_v3_hw()\n    ==>list_del_init()        \t\t  ==>list_for_each_entry_safe()\n\n[ 7165.434918] sas: Enter sas_scsi_recover_host busy: 32 failed: 32\n[ 7165.434926] sas: trying to find task 0x00000000769b5ba5\n[ 7165.434927] sas: sas_scsi_find_task: aborting task 0x00000000769b5ba5\n[ 7165.434940] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000769b5ba5) aborted\n[ 7165.434964] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000c9f7aa07) ignored\n[ 7165.434965] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000e2a1cf01) ignored\n[ 7165.434968] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000\n[ 7165.434972] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(0000000022d52d93) ignored\n[ 7165.434975] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(0000000066a7516c) ignored\n[ 7165.434976] Mem abort info:\n[ 7165.434982]   ESR = 0x96000004\n[ 7165.434991]   Exception class = DABT (current EL), IL = 32 bits\n[ 7165.434992]   SET = 0, FnV = 0\n[ 7165.434993]   EA = 0, S1PTW = 0\n[ 7165.434994] Data abort info:\n[ 7165.434994]   ISV = 0, ISS = 0x00000004\n[ 7165.434995]   CM = 0, WnR = 0\n[ 7165.434997] user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000f29543f2\n[ 7165.434998] [0000000000000000] pgd=0000000000000000\n[ 7165.435003] Internal error: Oops: 96000004 [#1] SMP\n[ 7165.439863] Process scsi_eh_6 (pid: 4109, stack limit = 0x00000000c43818d5)\n[ 7165.468862] pstate: 00c00009 (nzcv daif +PAN +UAO)\n[ 7165.473637] pc : dereg_device_v3_hw+0x68/0xa8 [hisi_sas_v3_hw]\n[ 7165.479443] lr : dereg_device_v3_hw+0x2c/0xa8 [hisi_sas_v3_hw]\n[ 7165.485247] sp : ffff00001d623bc0\n[ 7165.488546] x29: ffff00001d623bc0 x28: ffffa027d03b9508\n[ 7165.493835] x27: ffff80278ed50af0 x26: ffffa027dd31e0a8\n[ 7165.499123] x25: ffffa027d9b27f88 x24: ffffa027d9b209f8\n[ 7165.504411] x23: ffffa027c45b0d60 x22: ffff80278ec07c00\n[ 7165.509700] x21: 0000000000000008 x20: ffffa027d9b209f8\n[ 7165.514988] x19: ffffa027d9b27f88 x18: ffffffffffffffff\n[ 7165.520276] x17: 0000000000000000 x16: 0000000000000000\n[ 7165.525564] x15: ffff0000091d9708 x14: ffff0000093b7dc8\n[ 7165.530852] x13: ffff0000093b7a23 x12: 6e7265746e692067\n[ 7165.536140] x11: 0000000000000000 x10: 0000000000000bb0\n[ 7165.541429] x9 : ffff00001d6238f0 x8 : ffffa027d877af00\n[ 7165.546718] x7 : ffffa027d6329600 x6 : ffff7e809f58ca00\n[ 7165.552006] x5 : 0000000000001f8a x4 : 000000000000088e\n[ 7165.557295] x3 : ffffa027d9b27fa8 x2 : 0000000000000000\n[ 7165.562583] x1 : 0000000000000000 x0 : 000000003000188e\n[ 7165.567872] Call trace:\n[ 7165.570309]  dereg_device_v3_hw+0x68/0xa8 [hisi_sas_v3_hw]\n[ 7165.575775]  hisi_sas_abort_task+0x248/0x358 [hisi_sas_main]\n[ 7165.581415]  sas_eh_handle_sas_errors+0x258/0x8e0 [libsas]\n[ 7165.586876]  sas_scsi_recover_host+0x134/0x458 [libsas]\n[ 7165.592082]  scsi_error_handler+0xb4/0x488\n[ 7165.596163]  kthread+0x134/0x138\n[ 7165.599380]  ret_from_fork+0x10/0x18\n[ 7165.602940] Code: d5033e9f b9000040 aa0103e2 eb03003f (f9400021)\n[ 7165.609004] kernel fault(0x1) notification starting on CPU 75\n[ 7165.700728] ---[ end trace fc042cbbea224efc ]---\n[ 7165.705326] Kernel panic - not syncing: Fatal exception\n\nTo fix the issue, grab sas_dev lock when traversing the members of\nsas_dev.list in dereg_device_v3_hw() and hisi_sas_release_tasks() to avoid\nconcurrency of adding and deleting member. When \n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39866",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: writeback: fix use-after-free in __mark_inode_dirty()\n\nAn use-after-free issue occurred when __mark_inode_dirty() get the\nbdi_writeback that was in the progress of switching.\n\nCPU: 1 PID: 562 Comm: systemd-random- Not tainted 6.6.56-gb4403bd46a8e #1\n......\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __mark_inode_dirty+0x124/0x418\nlr : __mark_inode_dirty+0x118/0x418\nsp : ffffffc08c9dbbc0\n........\nCall trace:\n __mark_inode_dirty+0x124/0x418\n generic_update_time+0x4c/0x60\n file_modified+0xcc/0xd0\n ext4_buffered_write_iter+0x58/0x124\n ext4_file_write_iter+0x54/0x704\n vfs_write+0x1c0/0x308\n ksys_write+0x74/0x10c\n __arm64_sys_write+0x1c/0x28\n invoke_syscall+0x48/0x114\n el0_svc_common.constprop.0+0xc0/0xe0\n do_el0_svc+0x1c/0x28\n el0_svc+0x40/0xe4\n el0t_64_sync_handler+0x120/0x12c\n el0t_64_sync+0x194/0x198\n\nRoot cause is:\n\nsystemd-random-seed                         kworker\n----------------------------------------------------------------------\n___mark_inode_dirty                     inode_switch_wbs_work_fn\n\n  spin_lock(&inode->i_lock);\n  inode_attach_wb\n  locked_inode_to_wb_and_lock_list\n     get inode->i_wb\n     spin_unlock(&inode->i_lock);\n     spin_lock(&wb->list_lock)\n  spin_lock(&inode->i_lock)\n  inode_io_list_move_locked\n  spin_unlock(&wb->list_lock)\n  spin_unlock(&inode->i_lock)\n                                    spin_lock(&old_wb->list_lock)\n                                      inode_do_switch_wbs\n                                        spin_lock(&inode->i_lock)\n                                        inode->i_wb = new_wb\n                                        spin_unlock(&inode->i_lock)\n                                    spin_unlock(&old_wb->list_lock)\n                                    wb_put_many(old_wb, nr_switched)\n                                      cgwb_release\n                                      old wb released\n  wb_wakeup_delayed() accesses wb,\n  then trigger the use-after-free\n  issue\n\nFix this race condition by holding inode spinlock until\nwb_wakeup_delayed() finished.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-19",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54156",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsfc: fix crash when reading stats while NIC is resetting\n\nefx_net_stats() (.ndo_get_stats64) can be called during an ethtool\n selftest, during which time nic_data->mc_stats is NULL as the NIC has\n been fini'd.  In this case do not attempt to fetch the latest stats\n from the hardware, else we will crash on a NULL dereference:\n    BUG: kernel NULL pointer dereference, address: 0000000000000038\n    RIP efx_nic_update_stats\n    abridged calltrace:\n    efx_ef10_update_stats_pf\n    efx_net_stats\n    dev_get_stats\n    dev_seq_printf_stats\nSkipping the read is safe, we will simply give out stale stats.\nTo ensure that the free in efx_ef10_fini_nic() does not race against\n efx_ef10_update_stats_pf(), which could cause a TOCTTOU bug, take the\n efx->stats_lock in fini_nic (it is already held across update_stats).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40074",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv4: start using dst_dev_rcu()\n\nChange icmpv4_xrlim_allow(), ip_defrag() to prevent possible UAF.\n\nChange ipmr_prepare_xmit(), ipmr_queue_fwd_xmit(), ip_mr_output(),\nipv4_neigh_lookup() to use lockdep enabled dst_dev_rcu().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50880",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath10k: add peer map clean up for peer delete in ath10k_sta_state()\n\nWhen peer delete failed in a disconnect operation, use-after-free\ndetected by KFENCE in below log. It is because for each vdev_id and\naddress, it has only one struct ath10k_peer, it is allocated in\nath10k_peer_map_event(). When connected to an AP, it has more than\none HTT_T2H_MSG_TYPE_PEER_MAP reported from firmware, then the\narray peer_map of struct ath10k will be set muti-elements to the\nsame ath10k_peer in ath10k_peer_map_event(). When peer delete failed\nin ath10k_sta_state(), the ath10k_peer will be free for the 1st peer\nid in array peer_map of struct ath10k, and then use-after-free happened\nfor the 2nd peer id because they map to the same ath10k_peer.\n\nAnd clean up all peers in array peer_map for the ath10k_peer, then\nuser-after-free disappeared\n\npeer map event log:\n[  306.911021] wlan0: authenticate with b0:2a:43:e6:75:0e\n[  306.957187] ath10k_pci 0000:01:00.0: mac vdev 0 peer create b0:2a:43:e6:75:0e (new sta) sta 1 / 32 peer 1 / 33\n[  306.957395] ath10k_pci 0000:01:00.0: htt peer map vdev 0 peer b0:2a:43:e6:75:0e id 246\n[  306.957404] ath10k_pci 0000:01:00.0: htt peer map vdev 0 peer b0:2a:43:e6:75:0e id 198\n[  306.986924] ath10k_pci 0000:01:00.0: htt peer map vdev 0 peer b0:2a:43:e6:75:0e id 166\n\npeer unmap event log:\n[  435.715691] wlan0: deauthenticating from b0:2a:43:e6:75:0e by local choice (Reason: 3=DEAUTH_LEAVING)\n[  435.716802] ath10k_pci 0000:01:00.0: mac vdev 0 peer delete b0:2a:43:e6:75:0e sta ffff990e0e9c2b50 (sta gone)\n[  435.717177] ath10k_pci 0000:01:00.0: htt peer unmap vdev 0 peer b0:2a:43:e6:75:0e id 246\n[  435.717186] ath10k_pci 0000:01:00.0: htt peer unmap vdev 0 peer b0:2a:43:e6:75:0e id 198\n[  435.717193] ath10k_pci 0000:01:00.0: htt peer unmap vdev 0 peer b0:2a:43:e6:75:0e id 166\n\nuse-after-free log:\n[21705.888627] wlan0: deauthenticating from d0:76:8f:82:be:75 by local choice (Reason: 3=DEAUTH_LEAVING)\n[21713.799910] ath10k_pci 0000:01:00.0: failed to delete peer d0:76:8f:82:be:75 for vdev 0: -110\n[21713.799925] ath10k_pci 0000:01:00.0: found sta peer d0:76:8f:82:be:75 (ptr 0000000000000000 id 102) entry on vdev 0 after it was supposedly removed\n[21713.799968] ==================================================================\n[21713.799991] BUG: KFENCE: use-after-free read in ath10k_sta_state+0x265/0xb8a [ath10k_core]\n[21713.799991]\n[21713.799997] Use-after-free read at 0x00000000abe1c75e (in kfence-#69):\n[21713.800010]  ath10k_sta_state+0x265/0xb8a [ath10k_core]\n[21713.800041]  drv_sta_state+0x115/0x677 [mac80211]\n[21713.800059]  __sta_info_destroy_part2+0xb1/0x133 [mac80211]\n[21713.800076]  __sta_info_flush+0x11d/0x162 [mac80211]\n[21713.800093]  ieee80211_set_disassoc+0x12d/0x2f4 [mac80211]\n[21713.800110]  ieee80211_mgd_deauth+0x26c/0x29b [mac80211]\n[21713.800137]  cfg80211_mlme_deauth+0x13f/0x1bb [cfg80211]\n[21713.800153]  nl80211_deauthenticate+0xf8/0x121 [cfg80211]\n[21713.800161]  genl_rcv_msg+0x38e/0x3be\n[21713.800166]  netlink_rcv_skb+0x89/0xf7\n[21713.800171]  genl_rcv+0x28/0x36\n[21713.800176]  netlink_unicast+0x179/0x24b\n[21713.800181]  netlink_sendmsg+0x3a0/0x40e\n[21713.800187]  sock_sendmsg+0x72/0x76\n[21713.800192]  ____sys_sendmsg+0x16d/0x1e3\n[21713.800196]  ___sys_sendmsg+0x95/0xd1\n[21713.800200]  __sys_sendmsg+0x85/0xbf\n[21713.800205]  do_syscall_64+0x43/0x55\n[21713.800210]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[21713.800213]\n[21713.800219] kfence-#69: 0x000000009149b0d5-0x000000004c0697fb, size=1064, cache=kmalloc-2k\n[21713.800219]\n[21713.800224] allocated by task 13 on cpu 0 at 21705.501373s:\n[21713.800241]  ath10k_peer_map_event+0x7e/0x154 [ath10k_core]\n[21713.800254]  ath10k_htt_t2h_msg_handler+0x586/0x1039 [ath10k_core]\n[21713.800265]  ath10k_htt_htc_t2h_msg_handler+0x12/0x28 [ath10k_core]\n[21713.800277]  ath10k_htc_rx_completion_handler+0x14c/0x1b5 [ath10k_core]\n[21713.800283]  ath10k_pci_process_rx_cb+0x195/0x1d\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-52886",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: core: Fix race by not overwriting udev->descriptor in hub_port_init()\n\nSyzbot reported an out-of-bounds read in sysfs.c:read_descriptors():\n\nBUG: KASAN: slab-out-of-bounds in read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883\nRead of size 8 at addr ffff88801e78b8c8 by task udevd/5011\n\nCPU: 0 PID: 5011 Comm: udevd Not tainted 6.4.0-rc6-syzkaller-00195-g40f71e7cd3c6 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xd9/0x150 lib/dump_stack.c:106\n print_address_description.constprop.0+0x2c/0x3c0 mm/kasan/report.c:351\n print_report mm/kasan/report.c:462 [inline]\n kasan_report+0x11c/0x130 mm/kasan/report.c:572\n read_descriptors+0x263/0x280 drivers/usb/core/sysfs.c:883\n...\nAllocated by task 758:\n...\n __do_kmalloc_node mm/slab_common.c:966 [inline]\n __kmalloc+0x5e/0x190 mm/slab_common.c:979\n kmalloc include/linux/slab.h:563 [inline]\n kzalloc include/linux/slab.h:680 [inline]\n usb_get_configuration+0x1f7/0x5170 drivers/usb/core/config.c:887\n usb_enumerate_device drivers/usb/core/hub.c:2407 [inline]\n usb_new_device+0x12b0/0x19d0 drivers/usb/core/hub.c:2545\n\nAs analyzed by Khazhy Kumykov, the cause of this bug is a race between\nread_descriptors() and hub_port_init(): The first routine uses a field\nin udev->descriptor, not expecting it to change, while the second\noverwrites it.\n\nPrior to commit 45bf39f8df7f (\"USB: core: Don't hold device lock while\nreading the \"descriptors\" sysfs file\") this race couldn't occur,\nbecause the routines were mutually exclusive thanks to the device\nlocking.  Removing that locking from read_descriptors() exposed it to\nthe race.\n\nThe best way to fix the bug is to keep hub_port_init() from changing\nudev->descriptor once udev has been initialized and registered.\nDrivers expect the descriptors stored in the kernel to be immutable;\nwe should not undermine this expectation.  In fact, this change should\nhave been made long ago.\n\nSo now hub_port_init() will take an additional argument, specifying a\nbuffer in which to store the device descriptor it reads.  (If udev has\nnot yet been initialized, the buffer pointer will be NULL and then\nhub_port_init() will store the device descriptor in udev as before.)\nThis eliminates the data race responsible for the out-of-bounds read.\n\nThe changes to hub_port_init() appear more extensive than they really\nare, because of indentation changes resulting from an attempt to avoid\nwriting to other parts of the usb_device structure after it has been\ninitialized.  Similar changes should be made to the code that reads\nthe BOS descriptor, but that can be handled in a separate patch later\non.  This patch is sufficient to fix the bug found by syzbot.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2023-52886",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6.4,
                    "nvd_vectors_v3": "CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.4,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-39911",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix IRQ freeing in i40e_vsi_request_irq_msix error path\n\nIf request_irq() in i40e_vsi_request_irq_msix() fails in an iteration\nlater than the first, the error path wants to free the IRQs requested\nso far. However, it uses the wrong dev_id argument for free_irq(), so\nit does not free the IRQs correctly and instead triggers the warning:\n\n Trying to free already-free IRQ 173\n WARNING: CPU: 25 PID: 1091 at kernel/irq/manage.c:1829 __free_irq+0x192/0x2c0\n Modules linked in: i40e(+) [...]\n CPU: 25 UID: 0 PID: 1091 Comm: NetworkManager Not tainted 6.17.0-rc1+ #1 PREEMPT(lazy)\n Hardware name: [...]\n RIP: 0010:__free_irq+0x192/0x2c0\n [...]\n Call Trace:\n  <TASK>\n  free_irq+0x32/0x70\n  i40e_vsi_request_irq_msix.cold+0x63/0x8b [i40e]\n  i40e_vsi_request_irq+0x79/0x80 [i40e]\n  i40e_vsi_open+0x21f/0x2f0 [i40e]\n  i40e_open+0x63/0x130 [i40e]\n  __dev_open+0xfc/0x210\n  __dev_change_flags+0x1fc/0x240\n  netif_change_flags+0x27/0x70\n  do_setlink.isra.0+0x341/0xc70\n  rtnl_newlink+0x468/0x860\n  rtnetlink_rcv_msg+0x375/0x450\n  netlink_rcv_skb+0x5c/0x110\n  netlink_unicast+0x288/0x3c0\n  netlink_sendmsg+0x20d/0x430\n  ____sys_sendmsg+0x3a2/0x3d0\n  ___sys_sendmsg+0x99/0xe0\n  __sys_sendmsg+0x8a/0xf0\n  do_syscall_64+0x82/0x2c0\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  [...]\n  </TASK>\n ---[ end trace 0000000000000000 ]---\n\nUse the same dev_id for free_irq() as for request_irq().\n\nI tested this with inserting code to fail intentionally.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-42161",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Avoid uninitialized value in BPF_CORE_READ_BITFIELD\n\n[Changes from V1:\n - Use a default branch in the switch statement to initialize `val'.]\n\nGCC warns that `val' may be used uninitialized in the\nBPF_CRE_READ_BITFIELD macro, defined in bpf_core_read.h as:\n\n\t[...]\n\tunsigned long long val;\t\t\t\t\t\t      \\\n\t[...]\t\t\t\t\t\t\t\t      \\\n\tswitch (__CORE_RELO(s, field, BYTE_SIZE)) {\t\t\t      \\\n\tcase 1: val = *(const unsigned char *)p; break;\t\t\t      \\\n\tcase 2: val = *(const unsigned short *)p; break;\t\t      \\\n\tcase 4: val = *(const unsigned int *)p; break;\t\t\t      \\\n\tcase 8: val = *(const unsigned long long *)p; break;\t\t      \\\n        }       \t\t\t\t\t\t\t      \\\n\t[...]\n\tval;\t\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n\nThis patch adds a default entry in the switch statement that sets\n`val' to zero in order to avoid the warning, and random values to be\nused in case __builtin_preserve_field_info returns unexpected values\nfor BPF_FIELD_BYTE_SIZE.\n\nTested in bpf-next master.\nNo regressions.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-42161",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-30",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.3,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.3,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50490",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Propagate error from htab_lock_bucket() to userspace\n\nIn __htab_map_lookup_and_delete_batch() if htab_lock_bucket() returns\n-EBUSY, it will go to next bucket. Going to next bucket may not only\nskip the elements in current bucket silently, but also incur\nout-of-bound memory access or expose kernel memory to userspace if\ncurrent bucket_cnt is greater than bucket_size or zero.\n\nFixing it by stopping batch operation and returning -EBUSY when\nhtab_lock_bucket() fails, and the application can retry or skip the busy\nbatch as needed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-57893",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: seq: oss: Fix races at processing SysEx messages\n\nOSS sequencer handles the SysEx messages split in 6 bytes packets, and\nALSA sequencer OSS layer tries to combine those.  It stores the data\nin the internal buffer and this access is racy as of now, which may\nlead to the out-of-bounds access.\n\nAs a temporary band-aid fix, introduce a mutex for serializing the\nprocess of the SysEx message packets.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-57893",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-15",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.3,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.3,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53600",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntunnels: fix kasan splat when generating ipv4 pmtu error\n\nIf we try to emit an icmp error in response to a nonliner skb, we get\n\nBUG: KASAN: slab-out-of-bounds in ip_compute_csum+0x134/0x220\nRead of size 4 at addr ffff88811c50db00 by task iperf3/1691\nCPU: 2 PID: 1691 Comm: iperf3 Not tainted 6.5.0-rc3+ #309\n[..]\n kasan_report+0x105/0x140\n ip_compute_csum+0x134/0x220\n iptunnel_pmtud_build_icmp+0x554/0x1020\n skb_tunnel_check_pmtu+0x513/0xb80\n vxlan_xmit_one+0x139e/0x2ef0\n vxlan_xmit+0x1867/0x2760\n dev_hard_start_xmit+0x1ee/0x4f0\n br_dev_queue_push_xmit+0x4d1/0x660\n [..]\n\nip_compute_csum() cannot deal with nonlinear skbs, so avoid it.\nAfter this change, splat is gone and iperf3 is no longer stuck.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40000",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: fix use-after-free in rtw89_core_tx_kick_off_and_wait()\n\nThere is a bug observed when rtw89_core_tx_kick_off_and_wait() tries to\naccess already freed skb_data:\n\n BUG: KFENCE: use-after-free write in rtw89_core_tx_kick_off_and_wait drivers/net/wireless/realtek/rtw89/core.c:1110\n\n CPU: 6 UID: 0 PID: 41377 Comm: kworker/u64:24 Not tainted  6.17.0-rc1+ #1 PREEMPT(lazy)\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS edk2-20250523-14.fc42 05/23/2025\n Workqueue: events_unbound cfg80211_wiphy_work [cfg80211]\n\n Use-after-free write at 0x0000000020309d9d (in kfence-#251):\n rtw89_core_tx_kick_off_and_wait drivers/net/wireless/realtek/rtw89/core.c:1110\n rtw89_core_scan_complete drivers/net/wireless/realtek/rtw89/core.c:5338\n rtw89_hw_scan_complete_cb drivers/net/wireless/realtek/rtw89/fw.c:7979\n rtw89_chanctx_proceed_cb drivers/net/wireless/realtek/rtw89/chan.c:3165\n rtw89_chanctx_proceed drivers/net/wireless/realtek/rtw89/chan.h:141\n rtw89_hw_scan_complete drivers/net/wireless/realtek/rtw89/fw.c:8012\n rtw89_mac_c2h_scanofld_rsp drivers/net/wireless/realtek/rtw89/mac.c:5059\n rtw89_fw_c2h_work drivers/net/wireless/realtek/rtw89/fw.c:6758\n process_one_work kernel/workqueue.c:3241\n worker_thread kernel/workqueue.c:3400\n kthread kernel/kthread.c:463\n ret_from_fork arch/x86/kernel/process.c:154\n ret_from_fork_asm arch/x86/entry/entry_64.S:258\n\n kfence-#251: 0x0000000056e2393d-0x000000009943cb62, size=232, cache=skbuff_head_cache\n\n allocated by task 41377 on cpu 6 at 77869.159548s (0.009551s ago):\n __alloc_skb net/core/skbuff.c:659\n __netdev_alloc_skb net/core/skbuff.c:734\n ieee80211_nullfunc_get net/mac80211/tx.c:5844\n rtw89_core_send_nullfunc drivers/net/wireless/realtek/rtw89/core.c:3431\n rtw89_core_scan_complete drivers/net/wireless/realtek/rtw89/core.c:5338\n rtw89_hw_scan_complete_cb drivers/net/wireless/realtek/rtw89/fw.c:7979\n rtw89_chanctx_proceed_cb drivers/net/wireless/realtek/rtw89/chan.c:3165\n rtw89_chanctx_proceed drivers/net/wireless/realtek/rtw89/chan.c:3194\n rtw89_hw_scan_complete drivers/net/wireless/realtek/rtw89/fw.c:8012\n rtw89_mac_c2h_scanofld_rsp drivers/net/wireless/realtek/rtw89/mac.c:5059\n rtw89_fw_c2h_work drivers/net/wireless/realtek/rtw89/fw.c:6758\n process_one_work kernel/workqueue.c:3241\n worker_thread kernel/workqueue.c:3400\n kthread kernel/kthread.c:463\n ret_from_fork arch/x86/kernel/process.c:154\n ret_from_fork_asm arch/x86/entry/entry_64.S:258\n\n freed by task 1045 on cpu 9 at 77869.168393s (0.001557s ago):\n ieee80211_tx_status_skb net/mac80211/status.c:1117\n rtw89_pci_release_txwd_skb drivers/net/wireless/realtek/rtw89/pci.c:564\n rtw89_pci_release_tx_skbs.isra.0 drivers/net/wireless/realtek/rtw89/pci.c:651\n rtw89_pci_release_tx drivers/net/wireless/realtek/rtw89/pci.c:676\n rtw89_pci_napi_poll drivers/net/wireless/realtek/rtw89/pci.c:4238\n __napi_poll net/core/dev.c:7495\n net_rx_action net/core/dev.c:7557 net/core/dev.c:7684\n handle_softirqs kernel/softirq.c:580\n do_softirq.part.0 kernel/softirq.c:480\n __local_bh_enable_ip kernel/softirq.c:407\n rtw89_pci_interrupt_threadfn drivers/net/wireless/realtek/rtw89/pci.c:927\n irq_thread_fn kernel/irq/manage.c:1133\n irq_thread kernel/irq/manage.c:1257\n kthread kernel/kthread.c:463\n ret_from_fork arch/x86/kernel/process.c:154\n ret_from_fork_asm arch/x86/entry/entry_64.S:258\n\nIt is a consequence of a race between the waiting and the signaling side\nof the completion:\n\n            Waiting thread                            Completing thread\n\nrtw89_core_tx_kick_off_and_wait()\n  rcu_assign_pointer(skb_data->wait, wait)\n  /* start waiting */\n  wait_for_completion_timeout()\n                                                rtw89_pci_tx_status()\n                                                  rtw89_core_tx_wait_complete()\n                                                    rcu_read_lock()\n                                                    /* signals completion and\n   \n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-16",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-38544",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix seg fault in rxe_comp_queue_pkt\n\nIn rxe_comp_queue_pkt() an incoming response packet skb is enqueued to the\nresp_pkts queue and then a decision is made whether to run the completer\ntask inline or schedule it. Finally the skb is dereferenced to bump a 'hw'\nperformance counter. This is wrong because if the completer task is\nalready running in a separate thread it may have already processed the skb\nand freed it which can cause a seg fault.  This has been observed\ninfrequently in testing at high scale.\n\nThis patch fixes this by changing the order of enqueuing the packet until\nafter the counter is accessed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-38544",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.3,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.3,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68283",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nlibceph: replace BUG_ON with bounds check for map->max_osd\n\nOSD indexes come from untrusted network packets. Boundary checks are\nadded to validate these against map->max_osd.\n\n[ idryomov: drop BUG_ON in ceph_get_primary_affinity(), minor cosmetic\n  edits ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-38494",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: core: do not bypass hid_hw_raw_request\n\nhid_hw_raw_request() is actually useful to ensure the provided buffer\nand length are valid. Directly calling in the low level transport driver\nfunction bypassed those checks and allowed invalid paramto be used.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-28",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50861",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Finish converting the NFSv2 GETACL result encoder\n\nThe xdr_stream conversion inadvertently left some code that set the\npage_len of the send buffer. The XDR stream encoders should handle\nthis automatically now.\n\nThis oversight adds garbage past the end of the Reply message.\nClients typically ignore the garbage, but NFSD does not need to send\nit, as it leaks stale memory contents onto the wire.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40146",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: fix potential deadlock while nr_requests grown\n\nAllocate and free sched_tags while queue is freezed can deadlock[1],\nthis is a long term problem, hence allocate memory before freezing\nqueue and free memory after queue is unfreezed.\n\n[1] https://lore.kernel.org/all/0659ea8d-a463-47c8-9180-43c719e106eb@linux.ibm.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50838",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: stream: purge sk_error_queue in sk_stream_kill_queues()\n\nChangheon Lee reported TCP socket leaks, with a nice repro.\n\nIt seems we leak TCP sockets with the following sequence:\n\n1) SOF_TIMESTAMPING_TX_ACK is enabled on the socket.\n\n   Each ACK will cook an skb put in error queue, from __skb_tstamp_tx().\n   __skb_tstamp_tx() is using skb_clone(), unless\n   SOF_TIMESTAMPING_OPT_TSONLY was also requested.\n\n2) If the application is also using MSG_ZEROCOPY, then we put in the\n   error queue cloned skbs that had a struct ubuf_info attached to them.\n\n   Whenever an struct ubuf_info is allocated, sock_zerocopy_alloc()\n   does a sock_hold().\n\n   As long as the cloned skbs are still in sk_error_queue,\n   socket refcount is kept elevated.\n\n3) Application closes the socket, while error queue is not empty.\n\nSince tcp_close() no longer purges the socket error queue,\nwe might end up with a TCP socket with at least one skb in\nerror queue keeping the socket alive forever.\n\nThis bug can be (ab)used to consume all kernel memory\nand freeze the host.\n\nWe need to purge the error queue, with proper synchronization\nagainst concurrent writers.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-50251",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_payload: sanitize offset and length before calling skb_checksum()\n\nIf access to offset + length is larger than the skbuff length, then\nskb_checksum() triggers BUG_ON().\n\nskb_checksum() internally subtracts the length parameter while iterating\nover skbuff, BUG_ON(len) at the end of it checks that the expected\nlength to be included in the checksum calculation is fully consumed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50251",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-11-09",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 6.2,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.2,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48646",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsfc/siena: fix null pointer dereference in efx_hard_start_xmit\n\nLike in previous patch for sfc, prevent potential (but unlikely) NULL\npointer dereference.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48646",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-03-20",
                    "nvd_score_v3": 6.2,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.2,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48635",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfsdax: Fix infinite loop in dax_iomap_rw()\n\nI got an infinite loop and a WARNING report when executing a tail command\nin virtiofs.\n\n  WARNING: CPU: 10 PID: 964 at fs/iomap/iter.c:34 iomap_iter+0x3a2/0x3d0\n  Modules linked in:\n  CPU: 10 PID: 964 Comm: tail Not tainted 5.19.0-rc7\n  Call Trace:\n  <TASK>\n  dax_iomap_rw+0xea/0x620\n  ? __this_cpu_preempt_check+0x13/0x20\n  fuse_dax_read_iter+0x47/0x80\n  fuse_file_read_iter+0xae/0xd0\n  new_sync_read+0xfe/0x180\n  ? 0xffffffff81000000\n  vfs_read+0x14d/0x1a0\n  ksys_read+0x6d/0xf0\n  __x64_sys_read+0x1a/0x20\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe tail command will call read() with a count of 0. In this case,\niomap_iter() will report this WARNING, and always return 1 which casuing\nthe infinite loop in dax_iomap_rw().\n\nFixing by checking count whether is 0 in dax_iomap_rw().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48635",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 6.2,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.2,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-40048",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuio_hv_generic: Let userspace take care of interrupt mask\n\nRemove the logic to set interrupt mask by default in uio_hv_generic\ndriver as the interrupt mask value is supposed to be controlled\ncompletely by the user space. If the mask bit gets changed\nby the driver, concurrently with user mode operating on the ring,\nthe mask bit may be set when it is supposed to be clear, and the\nuser-mode driver will miss an interrupt which will cause a hang.\n\nFor eg- when the driver sets inbound ring buffer interrupt mask to 1,\nthe host does not interrupt the guest on the UIO VMBus channel.\nHowever, setting the mask does not prevent the host from putting a\nmessage in the inbound ring buffer.\u00a0So let\u2019s assume that happens,\nthe host puts a message into the ring buffer but does not interrupt.\n\nSubsequently, the user space code in the guest sets the inbound ring\nbuffer interrupt mask to 0, saying \u201cHey, I\u2019m ready for interrupts\u201d.\nUser space code then calls pread() to wait for an interrupt.\nThen one of two things happens:\n\n* The host never sends another message. So the pread() waits forever.\n* The host does send another message. But because there\u2019s already a\n  message in the ring buffer, it doesn\u2019t generate an interrupt.\n  This is the correct behavior, because the host should only send an\n  interrupt when the inbound ring buffer transitions from empty to\n  not-empty. Adding an additional message to a ring buffer that is not\n  empty is not supposed to generate an interrupt on the guest.\n  Since the guest is waiting in pread() and not removing messages from\n  the ring buffer, the pread() waits forever.\n\nThis could be easily reproduced in hv_fcopy_uio_daemon if we delay\nsetting interrupt mask to 0.\n\nSimilarly if hv_uio_channel_cb() sets the interrupt_mask to 1,\nthere\u2019s a race condition. Once user space empties the inbound ring\nbuffer, but before user space sets interrupt_mask to 0, the host could\nput another message in the ring buffer but it wouldn\u2019t interrupt.\nThen the next pread() would hang.\n\nFix these by removing all instances where interrupt_mask is changed,\nwhile keeping the one in set_event() unchanged to enable userspace\ncontrol the interrupt mask by writing 0/1 to /dev/uioX.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36910",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nuio_hv_generic: Don't free decrypted memory\n\nIn CoCo VMs it is possible for the untrusted host to cause\nset_memory_encrypted() or set_memory_decrypted() to fail such that an\nerror is returned and the resulting memory is shared. Callers need to\ntake care to handle these errors to avoid returning decrypted (shared)\nmemory to the page allocator, which could lead to functional or security\nissues.\n\nThe VMBus device UIO driver could free decrypted/shared pages if\nset_memory_decrypted() fails. Check the decrypted field in the gpadl\nto decide whether to free the memory.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36910",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-30",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 6.2,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6.2,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50551",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: Fix potential shift-out-of-bounds in brcmf_fw_alloc_request()\n\nThis patch fixes a shift-out-of-bounds in brcmfmac that occurs in\nBIT(chiprev) when a 'chiprev' provided by the device is too large.\nIt should also not be equal to or greater than BITS_PER_TYPE(u32)\nas we do bitwise AND with a u32 variable and BIT(chiprev). The patch\nadds a check that makes the function return NULL if that is the case.\nNote that the NULL case is later handled by the bus-specific caller,\nbrcmf_usb_probe_cb() or brcmf_usb_reset_resume(), for example.\n\nFound by a modified version of syzkaller.\n\nUBSAN: shift-out-of-bounds in drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c\nshift exponent 151055786 is too large for 64-bit type 'long unsigned int'\nCPU: 0 PID: 1885 Comm: kworker/0:2 Tainted: G           O      5.14.0+ #132\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n dump_stack_lvl+0x57/0x7d\n ubsan_epilogue+0x5/0x40\n __ubsan_handle_shift_out_of_bounds.cold+0x53/0xdb\n ? lock_chain_count+0x20/0x20\n brcmf_fw_alloc_request.cold+0x19/0x3ea\n ? brcmf_fw_get_firmwares+0x250/0x250\n ? brcmf_usb_ioctl_resp_wait+0x1a7/0x1f0\n brcmf_usb_get_fwname+0x114/0x1a0\n ? brcmf_usb_reset_resume+0x120/0x120\n ? number+0x6c4/0x9a0\n brcmf_c_process_clm_blob+0x168/0x590\n ? put_dec+0x90/0x90\n ? enable_ptr_key_workfn+0x20/0x20\n ? brcmf_common_pd_remove+0x50/0x50\n ? rcu_read_lock_sched_held+0xa1/0xd0\n brcmf_c_preinit_dcmds+0x673/0xc40\n ? brcmf_c_set_joinpref_default+0x100/0x100\n ? rcu_read_lock_sched_held+0xa1/0xd0\n ? rcu_read_lock_bh_held+0xb0/0xb0\n ? lock_acquire+0x19d/0x4e0\n ? find_held_lock+0x2d/0x110\n ? brcmf_usb_deq+0x1cc/0x260\n ? mark_held_locks+0x9f/0xe0\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n ? _raw_spin_unlock_irqrestore+0x47/0x50\n ? trace_hardirqs_on+0x1c/0x120\n ? brcmf_usb_deq+0x1a7/0x260\n ? brcmf_usb_rx_fill_all+0x5a/0xf0\n brcmf_attach+0x246/0xd40\n ? wiphy_new_nm+0x1476/0x1d50\n ? kmemdup+0x30/0x40\n brcmf_usb_probe+0x12de/0x1690\n ? brcmf_usbdev_qinit.constprop.0+0x470/0x470\n usb_probe_interface+0x25f/0x710\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n ? usb_match_id.part.0+0x88/0xc0\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n ? driver_allows_async_probing+0x120/0x120\n bus_for_each_drv+0x123/0x1a0\n ? bus_rescan_devices+0x20/0x20\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n ? trace_hardirqs_on+0x1c/0x120\n __device_attach+0x207/0x330\n ? device_bind_driver+0xb0/0xb0\n ? kobject_uevent_env+0x230/0x12c0\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n ? __mutex_unlock_slowpath+0xe7/0x660\n ? __fw_devlink_link_to_suppliers+0x550/0x550\n usb_set_configuration+0x984/0x1770\n ? kernfs_create_link+0x175/0x230\n usb_generic_driver_probe+0x69/0x90\n usb_probe_device+0x9c/0x220\n really_probe+0x1be/0xa90\n __driver_probe_device+0x2ab/0x460\n driver_probe_device+0x49/0x120\n __device_attach_driver+0x18a/0x250\n ? driver_allows_async_probing+0x120/0x120\n bus_for_each_drv+0x123/0x1a0\n ? bus_rescan_devices+0x20/0x20\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n ? trace_hardirqs_on+0x1c/0x120\n __device_attach+0x207/0x330\n ? device_bind_driver+0xb0/0xb0\n ? kobject_uevent_env+0x230/0x12c0\n bus_probe_device+0x1a2/0x260\n device_add+0xa61/0x1ce0\n ? __fw_devlink_link_to_suppliers+0x550/0x550\n usb_new_device.cold+0x463/0xf66\n ? hub_disconnect+0x400/0x400\n ? _raw_spin_unlock_irq+0x24/0x30\n hub_event+0x10d5/0x3330\n ? hub_port_debounce+0x280/0x280\n ? __lock_acquire+0x1671/0x5790\n ? wq_calc_node_cpumask+0x170/0x2a0\n ? lock_release+0x640/0x640\n ? rcu_read_lock_sched_held+0xa1/0xd0\n ? rcu_read_lock_bh_held+0xb0/0xb0\n ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n process_one_work+0x873/0x13e0\n ? lock_release+0x640/0x640\n ? pwq_dec_nr_in_flight+0x320/0x320\n ? rwlock_bug.part.0+0x90/0x90\n worker_thread+0x8b/0xd10\n ? __kthread_parkme+0xd9/0x1d0\n ? pr\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50764",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6/sit: use DEV_STATS_INC() to avoid data-races\n\nsyzbot/KCSAN reported that multiple cpus are updating dev->stats.tx_error\nconcurrently.\n\nThis is because sit tunnels are NETIF_F_LLTX, meaning their ndo_start_xmit()\nis not protected by a spinlock.\n\nWhile original KCSAN report was about tx path, rx path has the same issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39891",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Initialize the chan_stats array to zero\n\nThe adapter->chan_stats[] array is initialized in\nmwifiex_init_channel_scan_gap() with vmalloc(), which doesn't zero out\nmemory.  The array is filled in mwifiex_update_chan_statistics()\nand then the user can query the data in mwifiex_cfg80211_dump_survey().\n\nThere are two potential issues here.  What if the user calls\nmwifiex_cfg80211_dump_survey() before the data has been filled in.\nAlso the mwifiex_update_chan_statistics() function doesn't necessarily\ninitialize the whole array.  Since the array was not initialized at\nthe start that could result in an information leak.\n\nAlso this array is pretty small.  It's a maximum of 900 bytes so it's\nmore appropriate to use kcalloc() instead vmalloc().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53667",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: cdc_ncm: Deal with too low values of dwNtbOutMaxSize\n\nCurrently in cdc_ncm_check_tx_max(), if dwNtbOutMaxSize is lower than\nthe calculated \"min\" value, but greater than zero, the logic sets\ntx_max to dwNtbOutMaxSize. This is then used to allocate a new SKB in\ncdc_ncm_fill_tx_frame() where all the data is handled.\n\nFor small values of dwNtbOutMaxSize the memory allocated during\nalloc_skb(dwNtbOutMaxSize, GFP_ATOMIC) will have the same size, due to\nhow size is aligned at alloc time:\n\tsize = SKB_DATA_ALIGN(size);\n        size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\nThus we hit the same bug that we tried to squash with\ncommit 2be6d4d16a084 (\"net: cdc_ncm: Allow for dwNtbOutMaxSize to be unset or zero\")\n\nLow values of dwNtbOutMaxSize do not cause an issue presently because at\nalloc_skb() time more memory (512b) is allocated than required for the\nSKB headers alone (320b), leaving some space (512b - 320b = 192b)\nfor CDC data (172b).\n\nHowever, if more elements (for example 3 x u64 = [24b]) were added to\none of the SKB header structs, say 'struct skb_shared_info',\nincreasing its original size (320b [320b aligned]) to something larger\n(344b [384b aligned]), then suddenly the CDC data (172b) no longer\nfits in the spare SKB data area (512b - 384b = 128b).\n\nConsequently the SKB bounds checking semantics fails and panics:\n\nskbuff: skb_over_panic: text:ffffffff831f755b len:184 put:172 head:ffff88811f1c6c00 data:ffff88811f1c6c00 tail:0xb8 end:0x80 dev:<NULL>\n------------[ cut here ]------------\nkernel BUG at net/core/skbuff.c:113!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\nCPU: 0 PID: 57 Comm: kworker/0:2 Not tainted 5.15.106-syzkaller-00249-g19c0ed55a470 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/14/2023\nWorkqueue: mld mld_ifc_work\nRIP: 0010:skb_panic net/core/skbuff.c:113 [inline]\nRIP: 0010:skb_over_panic+0x14c/0x150 net/core/skbuff.c:118\n[snip]\nCall Trace:\n <TASK>\n skb_put+0x151/0x210 net/core/skbuff.c:2047\n skb_put_zero include/linux/skbuff.h:2422 [inline]\n cdc_ncm_ndp16 drivers/net/usb/cdc_ncm.c:1131 [inline]\n cdc_ncm_fill_tx_frame+0x11ab/0x3da0 drivers/net/usb/cdc_ncm.c:1308\n cdc_ncm_tx_fixup+0xa3/0x100\n\nDeal with too low values of dwNtbOutMaxSize, clamp it in the range\n[USB_CDC_NCM_NTB_MIN_OUT_SIZE, CDC_NCM_NTB_MAX_SIZE_TX]. We ensure\nenough data space is allocated to handle CDC data by making sure\ndwNtbOutMaxSize is not smaller than USB_CDC_NCM_NTB_MIN_OUT_SIZE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:P/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:P/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53850",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niavf: use internal state to free traffic IRQs\n\nIf the system tries to close the netdev while iavf_reset_task() is\nrunning, __LINK_STATE_START will be cleared and netif_running() will\nreturn false in iavf_reinit_interrupt_scheme(). This will result in\niavf_free_traffic_irqs() not being called and a leak as follows:\n\n    [7632.489326] remove_proc_entry: removing non-empty directory 'irq/999', leaking at least 'iavf-enp24s0f0v0-TxRx-0'\n    [7632.490214] WARNING: CPU: 0 PID: 10 at fs/proc/generic.c:718 remove_proc_entry+0x19b/0x1b0\n\nis shown when pci_disable_msix() is later called. Fix by using the\ninternal adapter state. The traffic IRQs will always exist if\nstate == __IAVF_RUNNING.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:L",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:L",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39931",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: af_alg - Set merge to zero early in af_alg_sendmsg\n\nIf an error causes af_alg_sendmsg to abort, ctx->merge may contain\na garbage value from the previous loop.  This may then trigger a\ncrash on the next entry into af_alg_sendmsg when it attempts to do\na merge that can't be done.\n\nFix this by setting ctx->merge to zero near the start of the loop.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53808",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: fix memory leak in mwifiex_histogram_read()\n\nAlways free the zeroed page on return from 'mwifiex_histogram_read()'.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40080",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: restrict sockets to TCP and UDP\n\nRecently, syzbot started to abuse NBD with all kinds of sockets.\n\nCommit cf1b2326b734 (\"nbd: verify socket is supported during setup\")\nmade sure the socket supported a shutdown() method.\n\nExplicitely accept TCP and UNIX stream sockets.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53788",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: hda/ca0132: fixup buffer overrun at tuning_ctl_set()\n\ntuning_ctl_set() might have buffer overrun at (X) if it didn't break\nfrom loop by matching (A).\n\n\tstatic int tuning_ctl_set(...)\n\t{\n\t\tfor (i = 0; i < TUNING_CTLS_COUNT; i++)\n(A)\t\t\tif (nid == ca0132_tuning_ctls[i].nid)\n\t\t\t\tbreak;\n\n\t\tsnd_hda_power_up(...);\n(X)\t\tdspio_set_param(..., ca0132_tuning_ctls[i].mid, ...);\n\t\tsnd_hda_power_down(...);                ^\n\n\t\treturn 1;\n\t}\n\nWe will get below error by cppcheck\n\n\tsound/pci/hda/patch_ca0132.c:4229:2: note: After for loop, i has value 12\n\t for (i = 0; i < TUNING_CTLS_COUNT; i++)\n\t ^\n\tsound/pci/hda/patch_ca0132.c:4234:43: note: Array index out of bounds\n\t dspio_set_param(codec, ca0132_tuning_ctls[i].mid, 0x20,\n\t                                           ^\nThis patch cares non match case.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53802",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: htc_hst: free skb in ath9k_htc_rx_msg() if there is no callback function\n\nIt is stated that ath9k_htc_rx_msg() either frees the provided skb or\npasses its management to another callback function. However, the skb is\nnot freed in case there is no another callback function, and Syzkaller was\nable to cause a memory leak. Also minor comment fix.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68245",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: netpoll: fix incorrect refcount handling causing incorrect cleanup\n\ncommit efa95b01da18 (\"netpoll: fix use after free\") incorrectly\nignored the refcount and prematurely set dev->npinfo to NULL during\nnetpoll cleanup, leading to improper behavior and memory leaks.\n\nScenario causing lack of proper cleanup:\n\n1) A netpoll is associated with a NIC (e.g., eth0) and netdev->npinfo is\n   allocated, and refcnt = 1\n   - Keep in mind that npinfo is shared among all netpoll instances. In\n     this case, there is just one.\n\n2) Another netpoll is also associated with the same NIC and\n   npinfo->refcnt += 1.\n   - Now dev->npinfo->refcnt = 2;\n   - There is just one npinfo associated to the netdev.\n\n3) When the first netpolls goes to clean up:\n   - The first cleanup succeeds and clears np->dev->npinfo, ignoring\n     refcnt.\n     - It basically calls `RCU_INIT_POINTER(np->dev->npinfo, NULL);`\n   - Set dev->npinfo = NULL, without proper cleanup\n   - No ->ndo_netpoll_cleanup() is either called\n\n4) Now the second target tries to clean up\n   - The second cleanup fails because np->dev->npinfo is already NULL.\n     * In this case, ops->ndo_netpoll_cleanup() was never called, and\n       the skb pool is not cleaned as well (for the second netpoll\n       instance)\n  - This leaks npinfo and skbpool skbs, which is clearly reported by\n    kmemleak.\n\nRevert commit efa95b01da18 (\"netpoll: fix use after free\") and adds\nclarifying comments emphasizing that npinfo cleanup should only happen\nonce the refcount reaches zero, ensuring stable and correct netpoll\nbehavior.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53840",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: early: xhci-dbc: Fix a potential out-of-bound memory access\n\nIf xdbc_bulk_write() fails, the values in 'buf' can be anything. So the\nstring is not guaranteed to be NULL terminated when xdbc_trace() is called.\n\nReserve an extra byte, which will be zeroed automatically because 'buf' is\na static variable, in order to avoid troubles, should it happen.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40071",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: n_gsm: Don't block input queue by waiting MSC\n\nCurrently gsm_queue() processes incoming frames and when opening\na DLC channel it calls gsm_dlci_open() which calls gsm_modem_update().\nIf basic mode is used it calls gsm_modem_upd_via_msc() and it\ncannot block the input queue by waiting the response to come\ninto the same input queue.\n\nInstead allow sending Modem Status Command without waiting for remote\nend to respond. Define a new function gsm_modem_send_initial_msc()\nfor this purpose. As MSC is only valid for basic encoding, it does\nnot do anything for advanced or when convergence layer type 2 is used.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40190",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: guard against EA inode refcount underflow in xattr update\n\nsyzkaller found a path where ext4_xattr_inode_update_ref() reads an EA\ninode refcount that is already <= 0 and then applies ref_change (often\n-1). That lets the refcount underflow and we proceed with a bogus value,\ntriggering errors like:\n\n  EXT4-fs error: EA inode <n> ref underflow: ref_count=-1 ref_change=-1\n  EXT4-fs warning: ea_inode dec ref err=-117\n\nMake the invariant explicit: if the current refcount is non-positive,\ntreat this as on-disk corruption, emit ext4_error_inode(), and fail the\noperation with -EFSCORRUPTED instead of updating the refcount. Delete the\nWARN_ONCE() as negative refcounts are now impossible; keep error reporting\nin ext4_error_inode().\n\nThis prevents the underflow and the follow-on orphan/cleanup churn.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68764",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Automounted filesystems should inherit ro,noexec,nodev,sync flags\n\nWhen a filesystem is being automounted, it needs to preserve the\nuser-set superblock mount options, such as the \"ro\" flag.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2026-01-05",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40019",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: essiv - Check ssize for decryption and in-place encryption\n\nMove the ssize check to the start in essiv_aead_crypt so that\nit's also checked for decryption and in-place encryption.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-24",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53543",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvdpa: Add max vqp attr to vdpa_nl_policy for nlattr length check\n\nThe vdpa_nl_policy structure is used to validate the nlattr when parsing\nthe incoming nlmsg. It will ensure the attribute being described produces\na valid nlattr pointer in info->attrs before entering into each handler\nin vdpa_nl_ops.\n\nThat is to say, the missing part in vdpa_nl_policy may lead to illegal\nnlattr after parsing, which could lead to OOB read just like CVE-2023-3773.\n\nThis patch adds the missing nla_policy for vdpa max vqp attr to avoid\nsuch bugs.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53477",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Add lwtunnel encap size of all siblings in nexthop calculation\n\nIn function rt6_nlmsg_size(), the length of nexthop is calculated\nby multipling the nexthop length of fib6_info and the number of\nsiblings. However if the fib6_info has no lwtunnel but the siblings\nhave lwtunnels, the nexthop length is less than it should be, and\nit will trigger a warning in inet6_rt_notify() as follows:\n\nWARNING: CPU: 0 PID: 6082 at net/ipv6/route.c:6180 inet6_rt_notify+0x120/0x130\n......\nCall Trace:\n <TASK>\n fib6_add_rt2node+0x685/0xa30\n fib6_add+0x96/0x1b0\n ip6_route_add+0x50/0xd0\n inet6_rtm_newroute+0x97/0xa0\n rtnetlink_rcv_msg+0x156/0x3d0\n netlink_rcv_skb+0x5a/0x110\n netlink_unicast+0x246/0x350\n netlink_sendmsg+0x250/0x4c0\n sock_sendmsg+0x66/0x70\n ___sys_sendmsg+0x7c/0xd0\n __sys_sendmsg+0x5d/0xb0\n do_syscall_64+0x3f/0x90\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThis bug can be reproduced by script:\n\nip -6 addr add 2002::2/64 dev ens2\nip -6 route add 100::/64 via 2002::1 dev ens2 metric 100\n\nfor i in 10 20 30 40 50 60 70;\ndo\n\tip link add link ens2 name ipv_$i type ipvlan\n\tip -6 addr add 2002::$i/64 dev ipv_$i\n\tifconfig ipv_$i up\ndone\n\nfor i in 10 20 30 40 50 60;\ndo\n\tip -6 route append 100::/64 encap ip6 dst 2002::$i via 2002::1\ndev ipv_$i metric 100\ndone\n\nip -6 route append 100::/64 via 2002::1 dev ipv_70 metric 100\n\nThis patch fixes it by adding nexthop_len of every siblings using\nrt6_nh_nlmsg_size().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-10-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53615",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Fix deletion race condition\n\nSystem crash when using debug kernel due to link list corruption. The cause\nof the link list corruption is due to session deletion was allowed to queue\nup twice.  Here's the internal trace that show the same port was allowed to\ndouble queue for deletion on different cpu.\n\n20808683956 015 qla2xxx [0000:13:00.1]-e801:4: Scheduling sess ffff93ebf9306800 for deletion 50:06:0e:80:12:48:ff:50 fc4_type 1\n20808683957 027 qla2xxx [0000:13:00.1]-e801:4: Scheduling sess ffff93ebf9306800 for deletion 50:06:0e:80:12:48:ff:50 fc4_type 1\n\nMove the clearing/setting of deleted flag lock.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-27171",
                    "description": "An issue was discovered in the Linux kernel before 5.11.8. kernel/bpf/verifier.c has an off-by-one error (with a resultant integer underflow) affecting out-of-bounds speculation on pointer arithmetic, leading to side-channel attacks that defeat Spectre mitigations and obtain sensitive information from kernel memory, aka CID-10d2bb2e6b1d.",
                    "nvd_score": 3.6,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-27171",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-03-20",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53582",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: ensure CLM version is null-terminated to prevent stack-out-of-bounds\n\nFix a stack-out-of-bounds read in brcmfmac that occurs\nwhen 'buf' that is not null-terminated is passed as an argument of\nstrreplace() in brcmf_c_preinit_dcmds(). This buffer is filled with\na CLM version string by memcpy() in brcmf_fil_iovar_data_get().\nEnsure buf is null-terminated.\n\nFound by a modified version of syzkaller.\n\n[   33.004414][ T1896] brcmfmac: brcmf_c_process_clm_blob: no clm_blob available (err=-2), device may have limited channels available\n[   33.013486][ T1896] brcmfmac: brcmf_c_preinit_dcmds: Firmware: BCM43236/3 wl0: Nov 30 2011 17:33:42 version 5.90.188.22\n[   33.021554][ T1896] ==================================================================\n[   33.022379][ T1896] BUG: KASAN: stack-out-of-bounds in strreplace+0xf2/0x110\n[   33.023122][ T1896] Read of size 1 at addr ffffc90001d6efc8 by task kworker/0:2/1896\n[   33.023852][ T1896]\n[   33.024096][ T1896] CPU: 0 PID: 1896 Comm: kworker/0:2 Tainted: G           O      5.14.0+ #132\n[   33.024927][ T1896] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014\n[   33.026065][ T1896] Workqueue: usb_hub_wq hub_event\n[   33.026581][ T1896] Call Trace:\n[   33.026896][ T1896]  dump_stack_lvl+0x57/0x7d\n[   33.027372][ T1896]  print_address_description.constprop.0.cold+0xf/0x334\n[   33.028037][ T1896]  ? strreplace+0xf2/0x110\n[   33.028403][ T1896]  ? strreplace+0xf2/0x110\n[   33.028807][ T1896]  kasan_report.cold+0x83/0xdf\n[   33.029283][ T1896]  ? strreplace+0xf2/0x110\n[   33.029666][ T1896]  strreplace+0xf2/0x110\n[   33.029966][ T1896]  brcmf_c_preinit_dcmds+0xab1/0xc40\n[   33.030351][ T1896]  ? brcmf_c_set_joinpref_default+0x100/0x100\n[   33.030787][ T1896]  ? rcu_read_lock_sched_held+0xa1/0xd0\n[   33.031223][ T1896]  ? rcu_read_lock_bh_held+0xb0/0xb0\n[   33.031661][ T1896]  ? lock_acquire+0x19d/0x4e0\n[   33.032091][ T1896]  ? find_held_lock+0x2d/0x110\n[   33.032605][ T1896]  ? brcmf_usb_deq+0x1a7/0x260\n[   33.033087][ T1896]  ? brcmf_usb_rx_fill_all+0x5a/0xf0\n[   33.033582][ T1896]  brcmf_attach+0x246/0xd40\n[   33.034022][ T1896]  ? wiphy_new_nm+0x1476/0x1d50\n[   33.034383][ T1896]  ? kmemdup+0x30/0x40\n[   33.034722][ T1896]  brcmf_usb_probe+0x12de/0x1690\n[   33.035223][ T1896]  ? brcmf_usbdev_qinit.constprop.0+0x470/0x470\n[   33.035833][ T1896]  usb_probe_interface+0x25f/0x710\n[   33.036315][ T1896]  really_probe+0x1be/0xa90\n[   33.036656][ T1896]  __driver_probe_device+0x2ab/0x460\n[   33.037026][ T1896]  ? usb_match_id.part.0+0x88/0xc0\n[   33.037383][ T1896]  driver_probe_device+0x49/0x120\n[   33.037790][ T1896]  __device_attach_driver+0x18a/0x250\n[   33.038300][ T1896]  ? driver_allows_async_probing+0x120/0x120\n[   33.038986][ T1896]  bus_for_each_drv+0x123/0x1a0\n[   33.039906][ T1896]  ? bus_rescan_devices+0x20/0x20\n[   33.041412][ T1896]  ? lockdep_hardirqs_on_prepare+0x273/0x3e0\n[   33.041861][ T1896]  ? trace_hardirqs_on+0x1c/0x120\n[   33.042330][ T1896]  __device_attach+0x207/0x330\n[   33.042664][ T1896]  ? device_bind_driver+0xb0/0xb0\n[   33.043026][ T1896]  ? kobject_uevent_env+0x230/0x12c0\n[   33.043515][ T1896]  bus_probe_device+0x1a2/0x260\n[   33.043914][ T1896]  device_add+0xa61/0x1ce0\n[   33.044227][ T1896]  ? __mutex_unlock_slowpath+0xe7/0x660\n[   33.044891][ T1896]  ? __fw_devlink_link_to_suppliers+0x550/0x550\n[   33.045531][ T1896]  usb_set_configuration+0x984/0x1770\n[   33.046051][ T1896]  ? kernfs_create_link+0x175/0x230\n[   33.046548][ T1896]  usb_generic_driver_probe+0x69/0x90\n[   33.046931][ T1896]  usb_probe_device+0x9c/0x220\n[   33.047434][ T1896]  really_probe+0x1be/0xa90\n[   33.047760][ T1896]  __driver_probe_device+0x2ab/0x460\n[   33.048134][ T1896]  driver_probe_device+0x49/0x120\n[   33.048516][ T1896]  __device_attach_driver+0x18a/0x250\n[   33.048910][ T1896]  ? driver_allows_async_probing+0x120/0x120\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2023-53575",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: fix potential array out of bounds access\n\nAccount for IWL_SEC_WEP_KEY_OFFSET when needed while verifying\nkey_len size in iwl_mvm_sec_key_add().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39967",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbcon: fix integer overflow in fbcon_do_set_font\n\nFix integer overflow vulnerabilities in fbcon_do_set_font() where font\nsize calculations could overflow when handling user-controlled font\nparameters.\n\nThe vulnerabilities occur when:\n1. CALC_FONTSZ(h, pitch, charcount) performs h * pith * charcount\n   multiplication with user-controlled values that can overflow.\n2. FONT_EXTRA_WORDS * sizeof(int) + size addition can also overflow\n3. This results in smaller allocations than expected, leading to buffer\n   overflows during font data copying.\n\nAdd explicit overflow checking using check_mul_overflow() and\ncheck_add_overflow() kernel helpers to safety validate all size\ncalculations before allocation.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-16",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53661",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt: avoid overflow in bnxt_get_nvram_directory()\n\nThe value of an arithmetic expression is subject\nof possible overflow due to a failure to cast operands to a larger data\ntype before performing arithmetic. Used macro for multiplication instead\noperator for avoiding overflow.\n\nFound by Security Code and Linux Verification\nCenter (linuxtesting.org) with SVACE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2019-19081",
                    "description": "A memory leak in the nfp_flower_spawn_vnic_reprs() function in drivers/net/ethernet/netronome/nfp/flower/main.c in the Linux kernel before 5.3.4 allows attackers to cause a denial of service (memory consumption), aka CID-8ce39eb5a67a.",
                    "nvd_score": 7.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
                    "nvd_severity": "high",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19081",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2019-11-18",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.9,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.9,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50849",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npstore: Avoid kcore oops by vmap()ing with VM_IOREMAP\n\nAn oops can be induced by running 'cat /proc/kcore > /dev/null' on\ndevices using pstore with the ram backend because kmap_atomic() assumes\nlowmem pages are accessible with __va().\n\n Unable to handle kernel paging request at virtual address ffffff807ff2b000\n Mem abort info:\n ESR = 0x96000006\n EC = 0x25: DABT (current EL), IL = 32 bits\n SET = 0, FnV = 0\n EA = 0, S1PTW = 0\n FSC = 0x06: level 2 translation fault\n Data abort info:\n ISV = 0, ISS = 0x00000006\n CM = 0, WnR = 0\n swapper pgtable: 4k pages, 39-bit VAs, pgdp=0000000081d87000\n [ffffff807ff2b000] pgd=180000017fe18003, p4d=180000017fe18003, pud=180000017fe18003, pmd=0000000000000000\n Internal error: Oops: 96000006 [#1] PREEMPT SMP\n Modules linked in: dm_integrity\n CPU: 7 PID: 21179 Comm: perf Not tainted 5.15.67-10882-ge4eb2eb988cd #1 baa443fb8e8477896a370b31a821eb2009f9bfba\n Hardware name: Google Lazor (rev3 - 8) (DT)\n pstate: a0400009 (NzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : __memcpy+0x110/0x260\n lr : vread+0x194/0x294\n sp : ffffffc013ee39d0\n x29: ffffffc013ee39f0 x28: 0000000000001000 x27: ffffff807ff2b000\n x26: 0000000000001000 x25: ffffffc0085a2000 x24: ffffff802d4b3000\n x23: ffffff80f8a60000 x22: ffffff802d4b3000 x21: ffffffc0085a2000\n x20: ffffff8080b7bc68 x19: 0000000000001000 x18: 0000000000000000\n x17: 0000000000000000 x16: 0000000000000000 x15: ffffffd3073f2e60\n x14: ffffffffad588000 x13: 0000000000000000 x12: 0000000000000001\n x11: 00000000000001a2 x10: 00680000fff2bf0b x9 : 03fffffff807ff2b\n x8 : 0000000000000001 x7 : 0000000000000000 x6 : 0000000000000000\n x5 : ffffff802d4b4000 x4 : ffffff807ff2c000 x3 : ffffffc013ee3a78\n x2 : 0000000000001000 x1 : ffffff807ff2b000 x0 : ffffff802d4b3000\n Call trace:\n __memcpy+0x110/0x260\n read_kcore+0x584/0x778\n proc_reg_read+0xb4/0xe4\n\nDuring early boot, memblock reserves the pages for the ramoops reserved\nmemory node in DT that would otherwise be part of the direct lowmem\nmapping. Pstore's ram backend reuses those reserved pages to change the\nmemory type (writeback or non-cached) by passing the pages to vmap()\n(see pfn_to_page() usage in persistent_ram_vmap() for more details) with\nspecific flags. When read_kcore() starts iterating over the vmalloc\nregion, it runs over the virtual address that vmap() returned for\nramoops. In aligned_vread() the virtual address is passed to\nvmalloc_to_page() which returns the page struct for the reserved lowmem\narea. That lowmem page is passed to kmap_atomic(), which effectively\ncalls page_to_virt() that assumes a lowmem page struct must be directly\naccessible with __va() and friends. These pages are mapped via vmap()\nthough, and the lowmem mapping was never made, so accessing them via the\nlowmem virtual address oopses like above.\n\nLet's side-step this problem by passing VM_IOREMAP to vmap(). This will\ntell vread() to not include the ramoops region in the kcore. Instead the\narea will look like a bunch of zeros. The alternative is to teach kmap()\nabout vmalloc areas that intersect with lowmem. Presumably such a change\nisn't a one-liner, and there isn't much interest in inspecting the\nramoops region in kcore files anyway, so the most expedient route is\ntaken for now.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40242",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Fix unlikely race in gdlm_put_lock\n\nIn gdlm_put_lock(), there is a small window of time in which the\nDFL_UNMOUNT flag has been set but the lockspace hasn't been released,\nyet.  In that window, dlm may still call gdlm_ast() and gdlm_bast().\nTo prevent it from dereferencing freed glock objects, only free the\nglock if the lockspace has actually been released.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2019-19076",
                    "description": "A memory leak in the nfp_abm_u32_knode_replace() function in drivers/net/ethernet/netronome/nfp/abm/cls.c in the Linux kernel before 5.3.6 allows attackers to cause a denial of service (memory consumption), aka CID-78beef629fd9. NOTE: This has been argued as not a valid vulnerability. The upstream commit 78beef629fd9 was reverted",
                    "nvd_score": 7.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
                    "nvd_severity": "high",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19076",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2019-11-18",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.9,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.9,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2022-50666",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/siw: Fix QP destroy to wait for all references dropped.\n\nDelay QP destroy completion until all siw references to QP are\ndropped. The calling RDMA core will free QP structure after\nsuccessful return from siw_qp_destroy() call, so siw must not\nhold any remaining reference to the QP upon return.\nA use-after-free was encountered in xfstest generic/460, while\ntesting NFSoRDMA. Here, after a TCP connection drop by peer,\nthe triggered siw_cm_work_handler got delayed until after\nQP destroy call, referencing a QP which has already freed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50756",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-pci: fix mempool alloc size\n\nConvert the max size to bytes to match the units of the divisor that\ncalculates the worst-case number of PRP entries.\n\nThe result is used to determine how many PRP Lists are required. The\ncode was previously rounding this to 1 list, but we can require 2 in the\nworst case. In that scenario, the driver would corrupt memory beyond the\nsize provided by the mempool.\n\nWhile unlikely to occur (you'd need a 4MB in exactly 127 phys segments\non a queue that doesn't support SGLs), this memory corruption has been\nobserved by kfence.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2019-19080",
                    "description": "Four memory leaks in the nfp_flower_spawn_phy_reprs() function in drivers/net/ethernet/netronome/nfp/flower/main.c in the Linux kernel before 5.3.4 allow attackers to cause a denial of service (memory consumption), aka CID-8572cea1461a.",
                    "nvd_score": 7.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
                    "nvd_severity": "high",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2019-19080",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2019-11-18",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.9,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.9,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-54048",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/bnxt_re: Prevent handling any completions after qp destroy\n\nHW may generate completions that indicates QP is destroyed.\nDriver should not be scheduling any more completion handlers\nfor this QP, after the QP is destroyed. Since CQs are active\nduring the QP destroy, driver may still schedule completion\nhandlers. This can cause a race where the destroy_cq and poll_cq\nrunning simultaneously.\n\nSnippet of kernel panic while doing bnxt_re driver load unload in loop.\nThis indicates a poll after the CQ is freed.\u00a0\n\n[77786.481636] Call Trace:\n[77786.481640] \u00a0<TASK>\n[77786.481644] \u00a0bnxt_re_poll_cq+0x14a/0x620 [bnxt_re]\n[77786.481658] \u00a0? kvm_clock_read+0x14/0x30\n[77786.481693] \u00a0__ib_process_cq+0x57/0x190 [ib_core]\n[77786.481728] \u00a0ib_cq_poll_work+0x26/0x80 [ib_core]\n[77786.481761] \u00a0process_one_work+0x1e5/0x3f0\n[77786.481768] \u00a0worker_thread+0x50/0x3a0\n[77786.481785] \u00a0? __pfx_worker_thread+0x10/0x10\n[77786.481790] \u00a0kthread+0xe2/0x110\n[77786.481794] \u00a0? __pfx_kthread+0x10/0x10\n[77786.481797] \u00a0ret_from_fork+0x2c/0x50\n\nTo avoid this, complete all completion handlers before returning the\ndestroy QP. If free_cq is called soon after destroy_qp,  IB stack\nwill cancel the CQ work before invoking the destroy_cq verb and\nthis will prevent any race mentioned.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-3714",
                    "description": "A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-3714",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-08-23",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.9,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.9,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-2312",
                    "description": "A flaw was found in cifs-utils. When trying to obtain Kerberos credentials, the cifs.upcall program from the cifs-utils package makes an upcall to the wrong namespace in containerized environments. This issue may lead to disclosing sensitive data from the host's Kerberos credentials cache.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-2312",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-25",
                    "modification_date": "2025-03-27",
                    "nvd_score_v3": 5.9,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.9,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54302",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/irdma: Fix data race on CQP completion stats\n\nCQP completion statistics is read lockesly in irdma_wait_event and\nirdma_check_cqp_progress while it can be updated in the completion\nthread irdma_sc_ccq_get_cqe_info on another CPU as KCSAN reports.\n\nMake completion statistics an atomic variable to reflect coherent updates\nto it. This will also avoid load/store tearing logic bug potentially\npossible by compiler optimizations.\n\n[77346.170861] BUG: KCSAN: data-race in irdma_handle_cqp_op [irdma] / irdma_sc_ccq_get_cqe_info [irdma]\n\n[77346.171383] write to 0xffff8a3250b108e0 of 8 bytes by task 9544 on cpu 4:\n[77346.171483]  irdma_sc_ccq_get_cqe_info+0x27a/0x370 [irdma]\n[77346.171658]  irdma_cqp_ce_handler+0x164/0x270 [irdma]\n[77346.171835]  cqp_compl_worker+0x1b/0x20 [irdma]\n[77346.172009]  process_one_work+0x4d1/0xa40\n[77346.172024]  worker_thread+0x319/0x700\n[77346.172037]  kthread+0x180/0x1b0\n[77346.172054]  ret_from_fork+0x22/0x30\n\n[77346.172136] read to 0xffff8a3250b108e0 of 8 bytes by task 9838 on cpu 2:\n[77346.172234]  irdma_handle_cqp_op+0xf4/0x4b0 [irdma]\n[77346.172413]  irdma_cqp_aeq_cmd+0x75/0xa0 [irdma]\n[77346.172592]  irdma_create_aeq+0x390/0x45a [irdma]\n[77346.172769]  irdma_rt_init_hw.cold+0x212/0x85d [irdma]\n[77346.172944]  irdma_probe+0x54f/0x620 [irdma]\n[77346.173122]  auxiliary_bus_probe+0x66/0xa0\n[77346.173137]  really_probe+0x140/0x540\n[77346.173154]  __driver_probe_device+0xc7/0x220\n[77346.173173]  driver_probe_device+0x5f/0x140\n[77346.173190]  __driver_attach+0xf0/0x2c0\n[77346.173208]  bus_for_each_dev+0xa8/0xf0\n[77346.173225]  driver_attach+0x29/0x30\n[77346.173240]  bus_add_driver+0x29c/0x2f0\n[77346.173255]  driver_register+0x10f/0x1a0\n[77346.173272]  __auxiliary_driver_register+0xbc/0x140\n[77346.173287]  irdma_init_module+0x55/0x1000 [irdma]\n[77346.173460]  do_one_initcall+0x7d/0x410\n[77346.173475]  do_init_module+0x81/0x2c0\n[77346.173491]  load_module+0x1232/0x12c0\n[77346.173506]  __do_sys_finit_module+0x101/0x180\n[77346.173522]  __x64_sys_finit_module+0x3c/0x50\n[77346.173538]  do_syscall_64+0x39/0x90\n[77346.173553]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\n[77346.173634] value changed: 0x0000000000000094 -> 0x0000000000000095",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40083",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_qfq: Fix null-deref in agg_dequeue\n\nTo prevent a potential crash in agg_dequeue (net/sched/sch_qfq.c)\nwhen cl->qdisc->ops->peek(cl->qdisc) returns NULL, we check the return\nvalue before using it, similar to the existing approach in sch_hfsc.c.\n\nTo avoid code duplication, the following changes are made:\n\n1. Changed qdisc_warn_nonwc(include/net/pkt_sched.h) into a static\ninline function.\n\n2. Moved qdisc_peek_len from net/sched/sch_hfsc.c to\ninclude/net/pkt_sched.h so that sch_qfq can reuse it.\n\n3. Applied qdisc_peek_len in agg_dequeue to avoid crashing.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-29",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-28097",
                    "description": "The vgacon subsystem in the Linux kernel before 5.8.10 mishandles software scrollback. There is a vgacon_scrolldelta out-of-bounds read, aka CID-973c096f6a85.",
                    "nvd_score": 3.6,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-28097",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-06-24",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.9,
                    "nvd_vectors_v3": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.9,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54214",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: Fix potential user-after-free\n\nThis fixes all instances of which requires to allocate a buffer calling\nalloc_skb which may release the chan lock and reacquire later which\nmakes it possible that the chan is disconnected in the meantime.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40167",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: detect invalid INLINE_DATA + EXTENTS flag combination\n\nsyzbot reported a BUG_ON in ext4_es_cache_extent() when opening a verity\nfile on a corrupted ext4 filesystem mounted without a journal.\n\nThe issue is that the filesystem has an inode with both the INLINE_DATA\nand EXTENTS flags set:\n\n    EXT4-fs error (device loop0): ext4_cache_extents:545: inode #15:\n    comm syz.0.17: corrupted extent tree: lblk 0 < prev 66\n\nInvestigation revealed that the inode has both flags set:\n    DEBUG: inode 15 - flag=1, i_inline_off=164, has_inline=1, extents_flag=1\n\nThis is an invalid combination since an inode should have either:\n- INLINE_DATA: data stored directly in the inode\n- EXTENTS: data stored in extent-mapped blocks\n\nHaving both flags causes ext4_has_inline_data() to return true, skipping\nextent tree validation in __ext4_iget(). The unvalidated out-of-order\nextents then trigger a BUG_ON in ext4_es_cache_extent() due to integer\nunderflow when calculating hole sizes.\n\nFix this by detecting this invalid flag combination early in ext4_iget()\nand rejecting the corrupted inode.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50625",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: amba-pl011: avoid SBSA UART accessing DMACR register\n\nChapter \"B Generic UART\" in \"ARM Server Base System Architecture\" [1]\ndocumentation describes a generic UART interface. Such generic UART\ndoes not support DMA. In current code, sbsa_uart_pops and\namba_pl011_pops share the same stop_rx operation, which will invoke\npl011_dma_rx_stop, leading to an access of the DMACR register. This\ncommit adds a using_rx_dma check in pl011_dma_rx_stop to avoid the\naccess to DMACR register for SBSA UARTs which does not support DMA.\n\nWhen the kernel enables DMA engine with \"CONFIG_DMA_ENGINE=y\", Linux\nSBSA PL011 driver will access PL011 DMACR register in some functions.\nFor most real SBSA Pl011 hardware implementations, the DMACR write\nbehaviour will be ignored. So these DMACR operations will not cause\nobvious problems. But for some virtual SBSA PL011 hardware, like Xen\nvirtual SBSA PL011 (vpl011) device, the behaviour might be different.\nXen vpl011 emulation will inject a data abort to guest, when guest is\naccessing an unimplemented UART register. As Xen VPL011 is SBSA\ncompatible, it will not implement DMACR register. So when Linux SBSA\nPL011 driver access DMACR register, it will get an unhandled data abort\nfault and the application will get a segmentation fault:\nUnhandled fault at 0xffffffc00944d048\nMem abort info:\n  ESR = 0x96000000\n  EC = 0x25: DABT (current EL), IL = 32 bits\n  SET = 0, FnV = 0\n  EA = 0, S1PTW = 0\n  FSC = 0x00: ttbr address size fault\nData abort info:\n  ISV = 0, ISS = 0x00000000\n  CM = 0, WnR = 0\nswapper pgtable: 4k pages, 39-bit VAs, pgdp=0000000020e2e000\n[ffffffc00944d048] pgd=100000003ffff803, p4d=100000003ffff803, pud=100000003ffff803, pmd=100000003fffa803, pte=006800009c090f13\nInternal error: ttbr address size fault: 96000000 [#1] PREEMPT SMP\n...\nCall trace:\n pl011_stop_rx+0x70/0x80\n tty_port_shutdown+0x7c/0xb4\n tty_port_close+0x60/0xcc\n uart_close+0x34/0x8c\n tty_release+0x144/0x4c0\n __fput+0x78/0x220\n ____fput+0x1c/0x30\n task_work_run+0x88/0xc0\n do_notify_resume+0x8d0/0x123c\n el0_svc+0xa8/0xc0\n el0t_64_sync_handler+0xa4/0x130\n el0t_64_sync+0x1a0/0x1a4\nCode: b9000083 b901f001 794038a0 8b000042 (b9000041)\n---[ end trace 83dd93df15c3216f ]---\nnote: bootlogd[132] exited with preempt_count 1\n/etc/rcS.d/S07bootlogd: line 47: 132 Segmentation fault start-stop-daemon\n\nThis has been discussed in the Xen community, and we think it should fix\nthis in Linux. See [2] for more information.\n\n[1] https://developer.arm.com/documentation/den0094/c/?lang=en\n[2] https://lists.xenproject.org/archives/html/xen-devel/2022-11/msg00543.html",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39945",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncnic: Fix use-after-free bugs in cnic_delete_task\n\nThe original code uses cancel_delayed_work() in cnic_cm_stop_bnx2x_hw(),\nwhich does not guarantee that the delayed work item 'delete_task' has\nfully completed if it was already running. Additionally, the delayed work\nitem is cyclic, the flush_workqueue() in cnic_cm_stop_bnx2x_hw() only\nblocks and waits for work items that were already queued to the\nworkqueue prior to its invocation. Any work items submitted after\nflush_workqueue() is called are not included in the set of tasks that the\nflush operation awaits. This means that after the cyclic work items have\nfinished executing, a delayed work item may still exist in the workqueue.\nThis leads to use-after-free scenarios where the cnic_dev is deallocated\nby cnic_free_dev(), while delete_task remains active and attempt to\ndereference cnic_dev in cnic_delete_task().\n\nA typical race condition is illustrated below:\n\nCPU 0 (cleanup)              | CPU 1 (delayed work callback)\ncnic_netdev_event()          |\n  cnic_stop_hw()             | cnic_delete_task()\n    cnic_cm_stop_bnx2x_hw()  | ...\n      cancel_delayed_work()  | /* the queue_delayed_work()\n      flush_workqueue()      |    executes after flush_workqueue()*/\n                             | queue_delayed_work()\n  cnic_free_dev(dev)//free   | cnic_delete_task() //new instance\n                             |   dev = cp->dev; //use\n\nReplace cancel_delayed_work() with cancel_delayed_work_sync() to ensure\nthat the cyclic delayed work item is properly canceled and that any\nongoing execution of the work item completes before the cnic_dev is\ndeallocated. Furthermore, since cancel_delayed_work_sync() uses\n__flush_work(work, true) to synchronously wait for any currently\nexecuting instance of the work item to finish, the flush_workqueue()\nbecomes redundant and should be removed.\n\nThis bug was identified through static analysis. To reproduce the issue\nand validate the fix, I simulated the cnic PCI device in QEMU and\nintroduced intentional delays \u2014 such as inserting calls to ssleep()\nwithin the cnic_delete_task() function \u2014 to increase the likelihood\nof triggering the bug.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53789",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/amd: Improve page fault error reporting\n\nIf IOMMU domain for device group is not setup properly then we may hit\nIOMMU page fault. Current page fault handler assumes that domain is\nalways setup and it will hit NULL pointer derefence (see below sample log).\n\nLets check whether domain is setup or not and log appropriate message.\n\nSample log:\n----------\n amdgpu 0000:00:01.0: amdgpu: SE 1, SH per SE 1, CU per SH 8, active_cu_number 6\n BUG: kernel NULL pointer dereference, address: 0000000000000058\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 2 PID: 56 Comm: irq/24-AMD-Vi Not tainted 6.2.0-rc2+ #89\n Hardware name: xxx\n RIP: 0010:report_iommu_fault+0x11/0x90\n [...]\n Call Trace:\n  <TASK>\n  amd_iommu_int_thread+0x60c/0x760\n  ? __pfx_irq_thread_fn+0x10/0x10\n  irq_thread_fn+0x1f/0x60\n  irq_thread+0xea/0x1a0\n  ? preempt_count_add+0x6a/0xa0\n  ? __pfx_irq_thread_dtor+0x10/0x10\n  ? __pfx_irq_thread+0x10/0x10\n  kthread+0xe9/0x110\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork+0x2c/0x50\n  </TASK>\n\n[joro: Edit commit message]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53525",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/cma: Allow UD qp_type to join multicast only\n\nAs for multicast:\n- The SIDR is the only mode that makes sense;\n- Besides PS_UDP, other port spaces like PS_IB is also allowed, as it is\n  UD compatible. In this case qkey also needs to be set [1].\n\nThis patch allows only UD qp_type to join multicast, and set qkey to\ndefault if it's not set, to fix an uninit-value error: the ib->rec.qkey\nfield is accessed without being initialized.\n\n=====================================================\nBUG: KMSAN: uninit-value in cma_set_qkey drivers/infiniband/core/cma.c:510 [inline]\nBUG: KMSAN: uninit-value in cma_make_mc_event+0xb73/0xe00 drivers/infiniband/core/cma.c:4570\n cma_set_qkey drivers/infiniband/core/cma.c:510 [inline]\n cma_make_mc_event+0xb73/0xe00 drivers/infiniband/core/cma.c:4570\n cma_iboe_join_multicast drivers/infiniband/core/cma.c:4782 [inline]\n rdma_join_multicast+0x2b83/0x30a0 drivers/infiniband/core/cma.c:4814\n ucma_process_join+0xa76/0xf60 drivers/infiniband/core/ucma.c:1479\n ucma_join_multicast+0x1e3/0x250 drivers/infiniband/core/ucma.c:1546\n ucma_write+0x639/0x6d0 drivers/infiniband/core/ucma.c:1732\n vfs_write+0x8ce/0x2030 fs/read_write.c:588\n ksys_write+0x28c/0x520 fs/read_write.c:643\n __do_sys_write fs/read_write.c:655 [inline]\n __se_sys_write fs/read_write.c:652 [inline]\n __ia32_sys_write+0xdb/0x120 fs/read_write.c:652\n do_syscall_32_irqs_on arch/x86/entry/common.c:114 [inline]\n __do_fast_syscall_32+0x96/0xf0 arch/x86/entry/common.c:180\n do_fast_syscall_32+0x34/0x70 arch/x86/entry/common.c:205\n do_SYSENTER_32+0x1b/0x20 arch/x86/entry/common.c:248\n entry_SYSENTER_compat_after_hwframe+0x4d/0x5c\n\nLocal variable ib.i created at:\ncma_iboe_join_multicast drivers/infiniband/core/cma.c:4737 [inline]\nrdma_join_multicast+0x586/0x30a0 drivers/infiniband/core/cma.c:4814\nucma_process_join+0xa76/0xf60 drivers/infiniband/core/ucma.c:1479\n\nCPU: 0 PID: 29874 Comm: syz-executor.3 Not tainted 5.16.0-rc3-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n=====================================================\n\n[1] https://lore.kernel.org/linux-rdma/20220117183832.GD84788@nvidia.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-10-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54236",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/net_failover: fix txq exceeding warning\n\nThe failover txq is inited as 16 queues.\nwhen a packet is transmitted from the failover device firstly,\nthe failover device will select the queue which is returned from\nthe primary device if the primary device is UP and running.\nIf the primary device txq is bigger than the default 16,\nit can lead to the following warning:\neth0 selects TX queue 18, but real number of TX queues is 16\n\nThe warning backtrace is:\n[   32.146376] CPU: 18 PID: 9134 Comm: chronyd Tainted: G            E      6.2.8-1.el7.centos.x86_64 #1\n[   32.147175] Hardware name: Red Hat KVM, BIOS 1.10.2-3.el7_4.1 04/01/2014\n[   32.147730] Call Trace:\n[   32.147971]  <TASK>\n[   32.148183]  dump_stack_lvl+0x48/0x70\n[   32.148514]  dump_stack+0x10/0x20\n[   32.148820]  netdev_core_pick_tx+0xb1/0xe0\n[   32.149180]  __dev_queue_xmit+0x529/0xcf0\n[   32.149533]  ? __check_object_size.part.0+0x21c/0x2c0\n[   32.149967]  ip_finish_output2+0x278/0x560\n[   32.150327]  __ip_finish_output+0x1fe/0x2f0\n[   32.150690]  ip_finish_output+0x2a/0xd0\n[   32.151032]  ip_output+0x7a/0x110\n[   32.151337]  ? __pfx_ip_finish_output+0x10/0x10\n[   32.151733]  ip_local_out+0x5e/0x70\n[   32.152054]  ip_send_skb+0x19/0x50\n[   32.152366]  udp_send_skb.isra.0+0x163/0x3a0\n[   32.152736]  udp_sendmsg+0xba8/0xec0\n[   32.153060]  ? __folio_memcg_unlock+0x25/0x60\n[   32.153445]  ? __pfx_ip_generic_getfrag+0x10/0x10\n[   32.153854]  ? sock_has_perm+0x85/0xa0\n[   32.154190]  inet_sendmsg+0x6d/0x80\n[   32.154508]  ? inet_sendmsg+0x6d/0x80\n[   32.154838]  sock_sendmsg+0x62/0x70\n[   32.155152]  ____sys_sendmsg+0x134/0x290\n[   32.155499]  ___sys_sendmsg+0x81/0xc0\n[   32.155828]  ? _get_random_bytes.part.0+0x79/0x1a0\n[   32.156240]  ? ip4_datagram_release_cb+0x5f/0x1e0\n[   32.156649]  ? get_random_u16+0x69/0xf0\n[   32.156989]  ? __fget_light+0xcf/0x110\n[   32.157326]  __sys_sendmmsg+0xc4/0x210\n[   32.157657]  ? __sys_connect+0xb7/0xe0\n[   32.157995]  ? __audit_syscall_entry+0xce/0x140\n[   32.158388]  ? syscall_trace_enter.isra.0+0x12c/0x1a0\n[   32.158820]  __x64_sys_sendmmsg+0x24/0x30\n[   32.159171]  do_syscall_64+0x38/0x90\n[   32.159493]  entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFix that by reducing txq number as the non-existent primary-dev does.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54141",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: Add missing hw_ops->get_ring_selector() for IPQ5018\n\nDuring sending data after clients connected, hw_ops->get_ring_selector()\nwill be called. But for IPQ5018, this member isn't set, and the\nfollowing NULL pointer exception will be occurred:\n\n\t[   38.840478] 8<--- cut here ---\n\t[   38.840517] Unable to handle kernel NULL pointer dereference at virtual address 00000000\n\t...\n\t[   38.923161] PC is at 0x0\n\t[   38.927930] LR is at ath11k_dp_tx+0x70/0x730 [ath11k]\n\t...\n\t[   39.063264] Process hostapd (pid: 1034, stack limit = 0x801ceb3d)\n\t[   39.068994] Stack: (0x856a9a68 to 0x856aa000)\n\t...\n\t[   39.438467] [<7f323804>] (ath11k_dp_tx [ath11k]) from [<7f314e6c>] (ath11k_mac_op_tx+0x80/0x190 [ath11k])\n\t[   39.446607] [<7f314e6c>] (ath11k_mac_op_tx [ath11k]) from [<7f17dbe0>] (ieee80211_handle_wake_tx_queue+0x7c/0xc0 [mac80211])\n\t[   39.456162] [<7f17dbe0>] (ieee80211_handle_wake_tx_queue [mac80211]) from [<7f174450>] (ieee80211_probereq_get+0x584/0x704 [mac80211])\n\t[   39.467443] [<7f174450>] (ieee80211_probereq_get [mac80211]) from [<7f178c40>] (ieee80211_tx_prepare_skb+0x1f8/0x248 [mac80211])\n\t[   39.479334] [<7f178c40>] (ieee80211_tx_prepare_skb [mac80211]) from [<7f179e28>] (__ieee80211_subif_start_xmit+0x32c/0x3d4 [mac80211])\n\t[   39.491053] [<7f179e28>] (__ieee80211_subif_start_xmit [mac80211]) from [<7f17af08>] (ieee80211_tx_control_port+0x19c/0x288 [mac80211])\n\t[   39.502946] [<7f17af08>] (ieee80211_tx_control_port [mac80211]) from [<7f0fc704>] (nl80211_tx_control_port+0x174/0x1d4 [cfg80211])\n\t[   39.515017] [<7f0fc704>] (nl80211_tx_control_port [cfg80211]) from [<808ceac4>] (genl_rcv_msg+0x154/0x340)\n\t[   39.526814] [<808ceac4>] (genl_rcv_msg) from [<808cdb74>] (netlink_rcv_skb+0xb8/0x11c)\n\t[   39.536446] [<808cdb74>] (netlink_rcv_skb) from [<808ce1d0>] (genl_rcv+0x28/0x34)\n\t[   39.544344] [<808ce1d0>] (genl_rcv) from [<808cd234>] (netlink_unicast+0x174/0x274)\n\t[   39.551895] [<808cd234>] (netlink_unicast) from [<808cd510>] (netlink_sendmsg+0x1dc/0x440)\n\t[   39.559362] [<808cd510>] (netlink_sendmsg) from [<808596e0>] (____sys_sendmsg+0x1a8/0x1fc)\n\t[   39.567697] [<808596e0>] (____sys_sendmsg) from [<8085b1a8>] (___sys_sendmsg+0xa4/0xdc)\n\t[   39.575941] [<8085b1a8>] (___sys_sendmsg) from [<8085b310>] (sys_sendmsg+0x44/0x74)\n\t[   39.583841] [<8085b310>] (sys_sendmsg) from [<80300060>] (ret_fast_syscall+0x0/0x40)\n\t...\n\t[   39.620734] Code: bad PC value\n\t[   39.625869] ---[ end trace 8aef983ad3cbc032 ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40329",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/sched: Fix deadlock in drm_sched_entity_kill_jobs_cb\n\nThe Mesa issue referenced below pointed out a possible deadlock:\n\n[ 1231.611031]  Possible interrupt unsafe locking scenario:\n\n[ 1231.611033]        CPU0                    CPU1\n[ 1231.611034]        ----                    ----\n[ 1231.611035]   lock(&xa->xa_lock#17);\n[ 1231.611038]                                local_irq_disable();\n[ 1231.611039]                                lock(&fence->lock);\n[ 1231.611041]                                lock(&xa->xa_lock#17);\n[ 1231.611044]   <Interrupt>\n[ 1231.611045]     lock(&fence->lock);\n[ 1231.611047]\n                *** DEADLOCK ***\n\nIn this example, CPU0 would be any function accessing job->dependencies\nthrough the xa_* functions that don't disable interrupts (eg:\ndrm_sched_job_add_dependency(), drm_sched_entity_kill_jobs_cb()).\n\nCPU1 is executing drm_sched_entity_kill_jobs_cb() as a fence signalling\ncallback so in an interrupt context. It will deadlock when trying to\ngrab the xa_lock which is already held by CPU0.\n\nReplacing all xa_* usage by their xa_*_irq counterparts would fix\nthis issue, but Christian pointed out another issue: dma_fence_signal\ntakes fence.lock and so does dma_fence_add_callback.\n\n  dma_fence_signal() // locks f1.lock\n  -> drm_sched_entity_kill_jobs_cb()\n  -> foreach dependencies\n     -> dma_fence_add_callback() // locks f2.lock\n\nThis will deadlock if f1 and f2 share the same spinlock.\n\nTo fix both issues, the code iterating on dependencies and re-arming them\nis moved out to drm_sched_entity_kill_jobs_work().\n\n[phasta: commit message nits]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39902",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: avoid accessing metadata when pointer is invalid in object_err()\n\nobject_err() reports details of an object for further debugging, such as\nthe freelist pointer, redzone, etc. However, if the pointer is invalid,\nattempting to access object metadata can lead to a crash since it does\nnot point to a valid object.\n\nOne known path to the crash is when alloc_consistency_checks()\ndetermines the pointer to the allocated object is invalid because of a\nfreelist corruption, and calls object_err() to report it. The debug code\nshould report and handle the corruption gracefully and not crash in the\nprocess.\n\nIn case the pointer is NULL or check_valid_pointer() returns false for\nthe pointer, only print the pointer value and skip accessing metadata.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53706",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/vmemmap/devdax: fix kernel crash when probing devdax devices\n\ncommit 4917f55b4ef9 (\"mm/sparse-vmemmap: improve memory savings for\ncompound devmaps\") added support for using optimized vmmemap for devdax\ndevices.  But how vmemmap mappings are created are architecture specific. \nFor example, powerpc with hash translation doesn't have vmemmap mappings\nin init_mm page table instead they are bolted table entries in the\nhardware page table\n\nvmemmap_populate_compound_pages() used by vmemmap optimization code is not\naware of these architecture-specific mapping.  Hence allow architecture to\nopt for this feature.  I selected architectures supporting\nHUGETLB_PAGE_OPTIMIZE_VMEMMAP option as also supporting this feature.\n\nThis patch fixes the below crash on ppc64.\n\nBUG: Unable to handle kernel data access on write at 0xc00c000100400038\nFaulting instruction address: 0xc000000001269d90\nOops: Kernel access of bad area, sig: 11 [#1]\nLE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries\nModules linked in:\nCPU: 7 PID: 1 Comm: swapper/0 Not tainted 6.3.0-rc5-150500.34-default+ #2 5c90a668b6bbd142599890245c2fb5de19d7d28a\nHardware name: IBM,9009-42G POWER9 (raw) 0x4e0202 0xf000005 of:IBM,FW950.40 (VL950_099) hv:phyp pSeries\nNIP:  c000000001269d90 LR: c0000000004c57d4 CTR: 0000000000000000\nREGS: c000000003632c30 TRAP: 0300   Not tainted  (6.3.0-rc5-150500.34-default+)\nMSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 24842228  XER: 00000000\nCFAR: c0000000004c57d0 DAR: c00c000100400038 DSISR: 42000000 IRQMASK: 0\n....\nNIP [c000000001269d90] __init_single_page.isra.74+0x14/0x4c\nLR [c0000000004c57d4] __init_zone_device_page+0x44/0xd0\nCall Trace:\n[c000000003632ed0] [c000000003632f60] 0xc000000003632f60 (unreliable)\n[c000000003632f10] [c0000000004c5ca0] memmap_init_zone_device+0x170/0x250\n[c000000003632fe0] [c0000000005575f8] memremap_pages+0x2c8/0x7f0\n[c0000000036330c0] [c000000000557b5c] devm_memremap_pages+0x3c/0xa0\n[c000000003633100] [c000000000d458a8] dev_dax_probe+0x108/0x3e0\n[c0000000036331a0] [c000000000d41430] dax_bus_probe+0xb0/0x140\n[c0000000036331d0] [c000000000cef27c] really_probe+0x19c/0x520\n[c000000003633260] [c000000000cef6b4] __driver_probe_device+0xb4/0x230\n[c0000000036332e0] [c000000000cef888] driver_probe_device+0x58/0x120\n[c000000003633320] [c000000000cefa6c] __device_attach_driver+0x11c/0x1e0\n[c0000000036333a0] [c000000000cebc58] bus_for_each_drv+0xa8/0x130\n[c000000003633400] [c000000000ceefcc] __device_attach+0x15c/0x250\n[c0000000036334a0] [c000000000ced458] bus_probe_device+0x108/0x110\n[c0000000036334f0] [c000000000ce92dc] device_add+0x7fc/0xa10\n[c0000000036335b0] [c000000000d447c8] devm_create_dev_dax+0x1d8/0x530\n[c000000003633640] [c000000000d46b60] __dax_pmem_probe+0x200/0x270\n[c0000000036337b0] [c000000000d46bf0] dax_pmem_probe+0x20/0x70\n[c0000000036337d0] [c000000000d2279c] nvdimm_bus_probe+0xac/0x2b0\n[c000000003633860] [c000000000cef27c] really_probe+0x19c/0x520\n[c0000000036338f0] [c000000000cef6b4] __driver_probe_device+0xb4/0x230\n[c000000003633970] [c000000000cef888] driver_probe_device+0x58/0x120\n[c0000000036339b0] [c000000000cefd08] __driver_attach+0x1d8/0x240\n[c000000003633a30] [c000000000cebb04] bus_for_each_dev+0xb4/0x130\n[c000000003633a90] [c000000000cee564] driver_attach+0x34/0x50\n[c000000003633ab0] [c000000000ced878] bus_add_driver+0x218/0x300\n[c000000003633b40] [c000000000cf1144] driver_register+0xa4/0x1b0\n[c000000003633bb0] [c000000000d21a0c] __nd_driver_register+0x5c/0x100\n[c000000003633c10] [c00000000206a2e8] dax_pmem_init+0x34/0x48\n[c000000003633c30] [c0000000000132d0] do_one_initcall+0x60/0x320\n[c000000003633d00] [c0000000020051b0] kernel_init_freeable+0x360/0x400\n[c000000003633de0] [c000000000013764] kernel_init+0x34/0x1d0\n[c000000003633e50] [c00000000000de14] ret_from_kernel_thread+0x5c/0x64",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-22",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50636",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: Fix pci_device_is_present() for VFs by checking PF\n\npci_device_is_present() previously didn't work for VFs because it reads the\nVendor and Device ID, which are 0xffff for VFs, which looks like they\naren't present.  Check the PF instead.\n\nWei Gong reported that if virtio I/O is in progress when the driver is\nunbound or \"0\" is written to /sys/.../sriov_numvfs, the virtio I/O\noperation hangs, which may result in output like this:\n\n  task:bash state:D stack:    0 pid: 1773 ppid:  1241 flags:0x00004002\n  Call Trace:\n   schedule+0x4f/0xc0\n   blk_mq_freeze_queue_wait+0x69/0xa0\n   blk_mq_freeze_queue+0x1b/0x20\n   blk_cleanup_queue+0x3d/0xd0\n   virtblk_remove+0x3c/0xb0 [virtio_blk]\n   virtio_dev_remove+0x4b/0x80\n   ...\n   device_unregister+0x1b/0x60\n   unregister_virtio_device+0x18/0x30\n   virtio_pci_remove+0x41/0x80\n   pci_device_remove+0x3e/0xb0\n\nThis happened because pci_device_is_present(VF) returned \"false\" in\nvirtio_pci_remove(), so it called virtio_break_device().  The broken vq\nmeant that vring_interrupt() skipped the vq.callback() that would have\ncompleted the virtio I/O operation via virtblk_done().\n\n[bhelgaas: commit log, simplify to always use pci_physfn(), add stable tag]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40194",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: intel_pstate: Fix object lifecycle issue in update_qos_request()\n\nThe cpufreq_cpu_put() call in update_qos_request() takes place too early\nbecause the latter subsequently calls freq_qos_update_request() that\nindirectly accesses the policy object in question through the QoS request\nobject passed to it.\n\nFortunately, update_qos_request() is called under intel_pstate_driver_lock,\nso this issue does not matter for changing the intel_pstate operation\nmode, but it theoretically can cause a crash to occur on CPU device hot\nremoval (which currently can only happen in virt, but it is formally\nsupported nevertheless).\n\nAddress this issue by modifying update_qos_request() to drop the\nreference to the policy later.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54176",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: stricter state check in mptcp_worker\n\nAs reported by Christoph, the mptcp protocol can run the\nworker when the relevant msk socket is in an unexpected state:\n\nconnect()\n// incoming reset + fastclose\n// the mptcp worker is scheduled\nmptcp_disconnect()\n// msk is now CLOSED\nlisten()\nmptcp_worker()\n\nLeading to the following splat:\n\ndivide error: 0000 [#1] PREEMPT SMP\nCPU: 1 PID: 21 Comm: kworker/1:0 Not tainted 6.3.0-rc1-gde5e8fd0123c #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014\nWorkqueue: events mptcp_worker\nRIP: 0010:__tcp_select_window+0x22c/0x4b0 net/ipv4/tcp_output.c:3018\nRSP: 0018:ffffc900000b3c98 EFLAGS: 00010293\nRAX: 000000000000ffd7 RBX: 000000000000ffd7 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffffff8214ce97 RDI: 0000000000000004\nRBP: 000000000000ffd7 R08: 0000000000000004 R09: 0000000000010000\nR10: 000000000000ffd7 R11: ffff888005afa148 R12: 000000000000ffd7\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff88803ed00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000405270 CR3: 000000003011e006 CR4: 0000000000370ee0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n tcp_select_window net/ipv4/tcp_output.c:262 [inline]\n __tcp_transmit_skb+0x356/0x1280 net/ipv4/tcp_output.c:1345\n tcp_transmit_skb net/ipv4/tcp_output.c:1417 [inline]\n tcp_send_active_reset+0x13e/0x320 net/ipv4/tcp_output.c:3459\n mptcp_check_fastclose net/mptcp/protocol.c:2530 [inline]\n mptcp_worker+0x6c7/0x800 net/mptcp/protocol.c:2705\n process_one_work+0x3bd/0x950 kernel/workqueue.c:2390\n worker_thread+0x5b/0x610 kernel/workqueue.c:2537\n kthread+0x138/0x170 kernel/kthread.c:376\n ret_from_fork+0x2c/0x50 arch/x86/entry/entry_64.S:308\n </TASK>\n\nThis change addresses the issue explicitly checking for bad states\nbefore running the mptcp worker.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40323",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbcon: Set fb_display[i]->mode to NULL when the mode is released\n\nRecently, we discovered the following issue through syzkaller:\n\nBUG: KASAN: slab-use-after-free in fb_mode_is_equal+0x285/0x2f0\nRead of size 4 at addr ff11000001b3c69c by task syz.xxx\n...\nCall Trace:\n <TASK>\n dump_stack_lvl+0xab/0xe0\n print_address_description.constprop.0+0x2c/0x390\n print_report+0xb9/0x280\n kasan_report+0xb8/0xf0\n fb_mode_is_equal+0x285/0x2f0\n fbcon_mode_deleted+0x129/0x180\n fb_set_var+0xe7f/0x11d0\n do_fb_ioctl+0x6a0/0x750\n fb_ioctl+0xe0/0x140\n __x64_sys_ioctl+0x193/0x210\n do_syscall_64+0x5f/0x9c0\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nBased on experimentation and analysis, during framebuffer unregistration,\nonly the memory of fb_info->modelist is freed, without setting the\ncorresponding fb_display[i]->mode to NULL for the freed modes. This leads\nto UAF issues during subsequent accesses. Here's an example of reproduction\nsteps:\n1. With /dev/fb0 already registered in the system, load a kernel module\n   to register a new device /dev/fb1;\n2. Set fb1's mode to the global fb_display[] array (via FBIOPUT_CON2FBMAP);\n3. Switch console from fb to VGA (to allow normal rmmod of the ko);\n4. Unload the kernel module, at this point fb1's modelist is freed, leaving\n   a wild pointer in fb_display[];\n5. Trigger the bug via system calls through fb0 attempting to delete a mode\n   from fb0.\n\nAdd a check in do_unregister_framebuffer(): if the mode to be freed exists\nin fb_display[], set the corresponding mode pointer to NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54120",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix race condition in hidp_session_thread\n\nThere is a potential race condition in hidp_session_thread that may\nlead to use-after-free. For instance, the timer is active while\nhidp_del_timer is called in hidp_session_thread(). After hidp_session_put,\nthen 'session' will be freed, causing kernel panic when hidp_idle_timeout\nis running.\n\nThe solution is to use del_timer_sync instead of del_timer.\n\nHere is the call trace:\n\n? hidp_session_probe+0x780/0x780\ncall_timer_fn+0x2d/0x1e0\n__run_timers.part.0+0x569/0x940\nhidp_session_probe+0x780/0x780\ncall_timer_fn+0x1e0/0x1e0\nktime_get+0x5c/0xf0\nlapic_next_deadline+0x2c/0x40\nclockevents_program_event+0x205/0x320\nrun_timer_softirq+0xa9/0x1b0\n__do_softirq+0x1b9/0x641\n__irq_exit_rcu+0xdc/0x190\nirq_exit_rcu+0xe/0x20\nsysvec_apic_timer_interrupt+0xa1/0xc0",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-53240",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen/netfront: fix crash when removing device\n\nWhen removing a netfront device directly after a suspend/resume cycle\nit might happen that the queues have not been setup again, causing a\ncrash during the attempt to stop the queues another time.\n\nFix that by checking the queues are existing before trying to stop\nthem.\n\nThis is XSA-465 / CVE-2024-53240.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53240",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-12-24",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 5.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54275",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: Fix memory leak in ath11k_peer_rx_frag_setup\n\ncrypto_alloc_shash() allocates resources, which should be released by\ncrypto_free_shash(). When ath11k_peer_find() fails, there has memory\nleak. Add missing crypto_free_shash() to fix this.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49138",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_event: Ignore multiple conn complete events\n\nWhen one of the three connection complete events is received multiple\ntimes for the same handle, the device is registered multiple times which\nleads to memory corruptions. Therefore, consequent events for a single\nconnection are ignored.\n\nThe conn->state can hold different values, therefore HCI_CONN_HANDLE_UNSET\nis introduced to identify new connections. To make sure the events do not\ncontain this or another invalid handle HCI_CONN_HANDLE_MAX and checks\nare introduced.\n\nBuglink: https://bugzilla.kernel.org/show_bug.cgi?id=215497",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49138",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50651",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nethtool: eeprom: fix null-deref on genl_info in dump\n\nThe similar fix as commit 46cdedf2a0fa (\"ethtool: pse-pd: fix null-deref on\ngenl_info in dump\") is also needed for ethtool eeprom.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-09",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-49569",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-rdma: unquiesce admin_q before destroy it\n\nKernel will hang on destroy admin_q while we create ctrl failed, such\nas following calltrace:\n\nPID: 23644    TASK: ff2d52b40f439fc0  CPU: 2    COMMAND: \"nvme\"\n #0 [ff61d23de260fb78] __schedule at ffffffff8323bc15\n #1 [ff61d23de260fc08] schedule at ffffffff8323c014\n #2 [ff61d23de260fc28] blk_mq_freeze_queue_wait at ffffffff82a3dba1\n #3 [ff61d23de260fc78] blk_freeze_queue at ffffffff82a4113a\n #4 [ff61d23de260fc90] blk_cleanup_queue at ffffffff82a33006\n #5 [ff61d23de260fcb0] nvme_rdma_destroy_admin_queue at ffffffffc12686ce\n #6 [ff61d23de260fcc8] nvme_rdma_setup_ctrl at ffffffffc1268ced\n #7 [ff61d23de260fd28] nvme_rdma_create_ctrl at ffffffffc126919b\n #8 [ff61d23de260fd68] nvmf_dev_write at ffffffffc024f362\n #9 [ff61d23de260fe38] vfs_write at ffffffff827d5f25\n    RIP: 00007fda7891d574  RSP: 00007ffe2ef06958  RFLAGS: 00000202\n    RAX: ffffffffffffffda  RBX: 000055e8122a4d90  RCX: 00007fda7891d574\n    RDX: 000000000000012b  RSI: 000055e8122a4d90  RDI: 0000000000000004\n    RBP: 00007ffe2ef079c0   R8: 000000000000012b   R9: 000055e8122a4d90\n    R10: 0000000000000000  R11: 0000000000000202  R12: 0000000000000004\n    R13: 000055e8122923c0  R14: 000000000000012b  R15: 00007fda78a54500\n    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b\n\nThis due to we have quiesced admi_q before cancel requests, but forgot\nto unquiesce before destroy it, as a result we fail to drain the\npending requests, and hang on blk_mq_freeze_queue_wait() forever. Here\ntry to reuse nvme_rdma_teardown_admin_queue() to fix this issue and\nsimplify the code.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49569",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-01-11",
                    "modification_date": "2025-10-15",
                    "nvd_score_v3": 5.7,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.7,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-50485",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: add EXT4_IGET_BAD flag to prevent unexpected bad inode\n\nThere are many places that will get unhappy (and crash) when ext4_iget()\nreturns a bad inode. However, if iget the boot loader inode, allows a bad\ninode to be returned, because the inode may not be initialized. This\nmechanism can be used to bypass some checks and cause panic. To solve this\nproblem, we add a special iget flag EXT4_IGET_BAD. Only with this flag\nwe'd be returning bad inode from ext4_iget(), otherwise we always return\nthe error code if the inode is bad inode.(suggested by Jan Kara)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39932",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: let smbd_destroy() call disable_work_sync(&info->post_send_credits_work)\n\nIn smbd_destroy() we may destroy the memory so we better\nwait until post_send_credits_work is no longer pending\nand will never be started again.\n\nI actually just hit the case using rxe:\n\nWARNING: CPU: 0 PID: 138 at drivers/infiniband/sw/rxe/rxe_verbs.c:1032 rxe_post_recv+0x1ee/0x480 [rdma_rxe]\n...\n[ 5305.686979] [    T138]  smbd_post_recv+0x445/0xc10 [cifs]\n[ 5305.687135] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687149] [    T138]  ? __kasan_check_write+0x14/0x30\n[ 5305.687185] [    T138]  ? __pfx_smbd_post_recv+0x10/0x10 [cifs]\n[ 5305.687329] [    T138]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[ 5305.687356] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687368] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687378] [    T138]  ? _raw_spin_unlock_irqrestore+0x11/0x60\n[ 5305.687389] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687399] [    T138]  ? get_receive_buffer+0x168/0x210 [cifs]\n[ 5305.687555] [    T138]  smbd_post_send_credits+0x382/0x4b0 [cifs]\n[ 5305.687701] [    T138]  ? __pfx_smbd_post_send_credits+0x10/0x10 [cifs]\n[ 5305.687855] [    T138]  ? __pfx___schedule+0x10/0x10\n[ 5305.687865] [    T138]  ? __pfx__raw_spin_lock_irq+0x10/0x10\n[ 5305.687875] [    T138]  ? queue_delayed_work_on+0x8e/0xa0\n[ 5305.687889] [    T138]  process_one_work+0x629/0xf80\n[ 5305.687908] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5\n[ 5305.687917] [    T138]  ? __kasan_check_write+0x14/0x30\n[ 5305.687933] [    T138]  worker_thread+0x87f/0x1570\n...\n\nIt means rxe_post_recv was called after rdma_destroy_qp().\nThis happened because put_receive_buffer() was triggered\nby ib_drain_qp() and called:\nqueue_work(info->workqueue, &info->post_send_credits_work);",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:A/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:A/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53503",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: allow ext4_get_group_info() to fail\n\nPreviously, ext4_get_group_info() would treat an invalid group number\nas BUG(), since in theory it should never happen.  However, if a\nmalicious attaker (or fuzzer) modifies the superblock via the block\ndevice while it is the file system is mounted, it is possible for\ns_first_data_block to get set to a very large number.  In that case,\nwhen calculating the block group of some block number (such as the\nstarting block of a preallocation region), could result in an\nunderflow and very large block group number.  Then the BUG_ON check in\next4_get_group_info() would fire, resutling in a denial of service\nattack that can be triggered by root or someone with write access to\nthe block device.\n\nFor a quality of implementation perspective, it's best that even if\nthe system administrator does something that they shouldn't, that it\nwill not trigger a BUG.  So instead of BUG'ing, ext4_get_group_info()\nwill call ext4_error and return NULL.  We also add fallback code in\nall of the callers of ext4_get_group_info() that it might NULL.\n\nAlso, since ext4_get_group_info() was already borderline to be an\ninline function, un-inline it.  The results in a next reduction of the\ncompiled text size of ext4 by roughly 2k.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-10-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53655",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrcu: Avoid stack overflow due to __rcu_irq_enter_check_tick() being kprobe-ed\n\nRegistering a kprobe on __rcu_irq_enter_check_tick() can cause kernel\nstack overflow as shown below. This issue can be reproduced by enabling\nCONFIG_NO_HZ_FULL and booting the kernel with argument \"nohz_full=\",\nand then giving the following commands at the shell prompt:\n\n  # cd /sys/kernel/tracing/\n  # echo 'p:mp1 __rcu_irq_enter_check_tick' >> kprobe_events\n  # echo 1 > events/kprobes/enable\n\nThis commit therefore adds __rcu_irq_enter_check_tick() to the kprobes\nblacklist using NOKPROBE_SYMBOL().\n\nInsufficient stack space to handle exception!\nESR: 0x00000000f2000004 -- BRK (AArch64)\nFAR: 0x0000ffffccf3e510\nTask stack:     [0xffff80000ad30000..0xffff80000ad38000]\nIRQ stack:      [0xffff800008050000..0xffff800008058000]\nOverflow stack: [0xffff089c36f9f310..0xffff089c36fa0310]\nCPU: 5 PID: 190 Comm: bash Not tainted 6.2.0-rc2-00320-g1f5abbd77e2c #19\nHardware name: linux,dummy-virt (DT)\npstate: 400003c5 (nZcv DAIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __rcu_irq_enter_check_tick+0x0/0x1b8\nlr : ct_nmi_enter+0x11c/0x138\nsp : ffff80000ad30080\nx29: ffff80000ad30080 x28: ffff089c82e20000 x27: 0000000000000000\nx26: 0000000000000000 x25: ffff089c02a8d100 x24: 0000000000000000\nx23: 00000000400003c5 x22: 0000ffffccf3e510 x21: ffff089c36fae148\nx20: ffff80000ad30120 x19: ffffa8da8fcce148 x18: 0000000000000000\nx17: 0000000000000000 x16: 0000000000000000 x15: ffffa8da8e44ea6c\nx14: ffffa8da8e44e968 x13: ffffa8da8e03136c x12: 1fffe113804d6809\nx11: ffff6113804d6809 x10: 0000000000000a60 x9 : dfff800000000000\nx8 : ffff089c026b404f x7 : 00009eec7fb297f7 x6 : 0000000000000001\nx5 : ffff80000ad30120 x4 : dfff800000000000 x3 : ffffa8da8e3016f4\nx2 : 0000000000000003 x1 : 0000000000000000 x0 : 0000000000000000\nKernel panic - not syncing: kernel stack overflow\nCPU: 5 PID: 190 Comm: bash Not tainted 6.2.0-rc2-00320-g1f5abbd77e2c #19\nHardware name: linux,dummy-virt (DT)\nCall trace:\n dump_backtrace+0xf8/0x108\n show_stack+0x20/0x30\n dump_stack_lvl+0x68/0x84\n dump_stack+0x1c/0x38\n panic+0x214/0x404\n add_taint+0x0/0xf8\n panic_bad_stack+0x144/0x160\n handle_bad_stack+0x38/0x58\n __bad_stack+0x78/0x7c\n __rcu_irq_enter_check_tick+0x0/0x1b8\n arm64_enter_el1_dbg.isra.0+0x14/0x20\n el1_dbg+0x2c/0x90\n el1h_64_sync_handler+0xcc/0xe8\n el1h_64_sync+0x64/0x68\n __rcu_irq_enter_check_tick+0x0/0x1b8\n arm64_enter_el1_dbg.isra.0+0x14/0x20\n el1_dbg+0x2c/0x90\n el1h_64_sync_handler+0xcc/0xe8\n el1h_64_sync+0x64/0x68\n __rcu_irq_enter_check_tick+0x0/0x1b8\n arm64_enter_el1_dbg.isra.0+0x14/0x20\n el1_dbg+0x2c/0x90\n el1h_64_sync_handler+0xcc/0xe8\n el1h_64_sync+0x64/0x68\n __rcu_irq_enter_check_tick+0x0/0x1b8\n [...]\n el1_dbg+0x2c/0x90\n el1h_64_sync_handler+0xcc/0xe8\n el1h_64_sync+0x64/0x68\n __rcu_irq_enter_check_tick+0x0/0x1b8\n arm64_enter_el1_dbg.isra.0+0x14/0x20\n el1_dbg+0x2c/0x90\n el1h_64_sync_handler+0xcc/0xe8\n el1h_64_sync+0x64/0x68\n __rcu_irq_enter_check_tick+0x0/0x1b8\n arm64_enter_el1_dbg.isra.0+0x14/0x20\n el1_dbg+0x2c/0x90\n el1h_64_sync_handler+0xcc/0xe8\n el1h_64_sync+0x64/0x68\n __rcu_irq_enter_check_tick+0x0/0x1b8\n el1_interrupt+0x28/0x60\n el1h_64_irq_handler+0x18/0x28\n el1h_64_irq+0x64/0x68\n __ftrace_set_clr_event_nolock+0x98/0x198\n __ftrace_set_clr_event+0x58/0x80\n system_enable_write+0x144/0x178\n vfs_write+0x174/0x738\n ksys_write+0xd0/0x188\n __arm64_sys_write+0x4c/0x60\n invoke_syscall+0x64/0x180\n el0_svc_common.constprop.0+0x84/0x160\n do_el0_svc+0x48/0xe8\n el0_svc+0x34/0xd0\n el0t_64_sync_handler+0xb8/0xc0\n el0t_64_sync+0x190/0x194\nSMP: stopping secondary CPUs\nKernel Offset: 0x28da86000000 from 0xffff800008000000\nPHYS_OFFSET: 0xfffff76600000000\nCPU features: 0x00000,01a00100,0000421b\nMemory Limit: none",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-07",
                    "modification_date": "2025-10-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:H/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:H/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36350",
                    "description": "A transient execution vulnerability in some AMD processors may allow an attacker to infer data from previous stores, potentially resulting in the leakage of privileged information.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36350",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-08",
                    "modification_date": "2025-11-04",
                    "nvd_score_v3": 5.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-14390",
                    "description": "A flaw was found in the Linux kernel in versions before 5.9-rc6. When changing screen size, an out-of-bounds memory write can occur leading to memory corruption or a denial of service. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.",
                    "nvd_score": 4.6,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-14390",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2020-09-18",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2023-53560",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/histograms: Add histograms to hist_vars if they have referenced variables\n\nHist triggers can have referenced variables without having direct\nvariables fields. This can be the case if referenced variables are added\nfor trigger actions. In this case the newly added references will not\nhave field variables. Not taking such referenced variables into\nconsideration can result in a bug where it would be possible to remove\nhist trigger with variables being refenced. This will result in a bug\nthat is easily reproducable like so\n\n$ cd /sys/kernel/tracing\n$ echo 'synthetic_sys_enter char[] comm; long id' >> synthetic_events\n$ echo 'hist:keys=common_pid.execname,id.syscall:vals=hitcount:comm=common_pid.execname' >> events/raw_syscalls/sys_enter/trigger\n$ echo 'hist:keys=common_pid.execname,id.syscall:onmatch(raw_syscalls.sys_enter).synthetic_sys_enter($comm, id)' >> events/raw_syscalls/sys_enter/trigger\n$ echo '!hist:keys=common_pid.execname,id.syscall:vals=hitcount:comm=common_pid.execname' >> events/raw_syscalls/sys_enter/trigger\n\n[  100.263533] ==================================================================\n[  100.264634] BUG: KASAN: slab-use-after-free in resolve_var_refs+0xc7/0x180\n[  100.265520] Read of size 8 at addr ffff88810375d0f0 by task bash/439\n[  100.266320]\n[  100.266533] CPU: 2 PID: 439 Comm: bash Not tainted 6.5.0-rc1 #4\n[  100.267277] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-20220807_005459-localhost 04/01/2014\n[  100.268561] Call Trace:\n[  100.268902]  <TASK>\n[  100.269189]  dump_stack_lvl+0x4c/0x70\n[  100.269680]  print_report+0xc5/0x600\n[  100.270165]  ? resolve_var_refs+0xc7/0x180\n[  100.270697]  ? kasan_complete_mode_report_info+0x80/0x1f0\n[  100.271389]  ? resolve_var_refs+0xc7/0x180\n[  100.271913]  kasan_report+0xbd/0x100\n[  100.272380]  ? resolve_var_refs+0xc7/0x180\n[  100.272920]  __asan_load8+0x71/0xa0\n[  100.273377]  resolve_var_refs+0xc7/0x180\n[  100.273888]  event_hist_trigger+0x749/0x860\n[  100.274505]  ? kasan_save_stack+0x2a/0x50\n[  100.275024]  ? kasan_set_track+0x29/0x40\n[  100.275536]  ? __pfx_event_hist_trigger+0x10/0x10\n[  100.276138]  ? ksys_write+0xd1/0x170\n[  100.276607]  ? do_syscall_64+0x3c/0x90\n[  100.277099]  ? entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n[  100.277771]  ? destroy_hist_data+0x446/0x470\n[  100.278324]  ? event_hist_trigger_parse+0xa6c/0x3860\n[  100.278962]  ? __pfx_event_hist_trigger_parse+0x10/0x10\n[  100.279627]  ? __kasan_check_write+0x18/0x20\n[  100.280177]  ? mutex_unlock+0x85/0xd0\n[  100.280660]  ? __pfx_mutex_unlock+0x10/0x10\n[  100.281200]  ? kfree+0x7b/0x120\n[  100.281619]  ? ____kasan_slab_free+0x15d/0x1d0\n[  100.282197]  ? event_trigger_write+0xac/0x100\n[  100.282764]  ? __kasan_slab_free+0x16/0x20\n[  100.283293]  ? __kmem_cache_free+0x153/0x2f0\n[  100.283844]  ? sched_mm_cid_remote_clear+0xb1/0x250\n[  100.284550]  ? __pfx_sched_mm_cid_remote_clear+0x10/0x10\n[  100.285221]  ? event_trigger_write+0xbc/0x100\n[  100.285781]  ? __kasan_check_read+0x15/0x20\n[  100.286321]  ? __bitmap_weight+0x66/0xa0\n[  100.286833]  ? _find_next_bit+0x46/0xe0\n[  100.287334]  ? task_mm_cid_work+0x37f/0x450\n[  100.287872]  event_triggers_call+0x84/0x150\n[  100.288408]  trace_event_buffer_commit+0x339/0x430\n[  100.289073]  ? ring_buffer_event_data+0x3f/0x60\n[  100.292189]  trace_event_raw_event_sys_enter+0x8b/0xe0\n[  100.295434]  syscall_trace_enter.constprop.0+0x18f/0x1b0\n[  100.298653]  syscall_enter_from_user_mode+0x32/0x40\n[  100.301808]  do_syscall_64+0x1a/0x90\n[  100.304748]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n[  100.307775] RIP: 0033:0x7f686c75c1cb\n[  100.310617] Code: 73 01 c3 48 8b 0d 65 3c 10 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 21 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 35 3c 10 00 f7 d8 64 89 01 48\n[  100.317847] RSP: 002b:00007ffc60137a38 EFLAGS: 00000246 ORIG_RAX: 0000000000000021\n[  100.321200] RA\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53024",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix pointer-leak due to insufficient speculative store bypass mitigation\n\nTo mitigate Spectre v4, 2039f26f3aca (\"bpf: Fix leakage due to\ninsufficient speculative store bypass mitigation\") inserts lfence\ninstructions after 1) initializing a stack slot and 2) spilling a\npointer to the stack.\n\nHowever, this does not cover cases where a stack slot is first\ninitialized with a pointer (subject to sanitization) but then\noverwritten with a scalar (not subject to sanitization because\nthe slot was already initialized). In this case, the second write\nmay be subject to speculative store bypass (SSB) creating a\nspeculative pointer-as-scalar type confusion. This allows the\nprogram to subsequently leak the numerical pointer value using,\nfor example, a branch-based cache side channel.\n\nTo fix this, also sanitize scalars if they write a stack slot\nthat previously contained a pointer. Assuming that pointer-spills\nare only generated by LLVM on register-pressure, the performance\nimpact on most real-world BPF programs should be small.\n\nThe following unprivileged BPF bytecode drafts a minimal exploit\nand the mitigation:\n\n  [...]\n  // r6 = 0 or 1 (skalar, unknown user input)\n  // r7 = accessible ptr for side channel\n  // r10 = frame pointer (fp), to be leaked\n  //\n  r9 = r10 # fp alias to encourage ssb\n  *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked\n  // lfence added here because of pointer spill to stack.\n  //\n  // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor\n  // for no r9-r10 dependency.\n  //\n  *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr\n  // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID,\n  // store may be subject to SSB\n  //\n  // fix: also add an lfence when the slot contained a ptr\n  //\n  r8 = *(u64 *)(r9 - 8)\n  // r8 = architecturally a scalar, speculatively a ptr\n  //\n  // leak ptr using branch-based cache side channel:\n  r8 &= 1 // choose bit to leak\n  if r8 == 0 goto SLOW // no mispredict\n  // architecturally dead code if input r6 is 0,\n  // only executes speculatively iff ptr bit is 1\n  r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast)\nSLOW:\n  [...]\n\nAfter running this, the program can time the access to *(r7 + 0) to\ndetermine whether the chosen pointer bit was 0 or 1. Repeat this 64\ntimes to recover the whole address on amd64.\n\nIn summary, sanitization can only be skipped if one scalar is\noverwritten with another scalar. Scalar-confusion due to speculative\nstore bypass can not lead to invalid accesses because the pointer\nbounds deducted during verification are enforced using branchless\nlogic. See 979d63d50c0c (\"bpf: prevent out of bounds speculation on\npointer arithmetic\") for details.\n\nDo not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks}\nbecause speculative leaks are likely unexpected if these were enabled.\nFor example, leaking the address to a protected log file may be acceptable\nwhile disabling the mitigation might unintentionally leak the address\ninto the cached-state of a map that is accessible to unprivileged\nprocesses.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-03-27",
                    "modification_date": "2025-03-28",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-54193",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: cls_api: remove block_cb from driver_list before freeing\n\nError handler of tcf_block_bind() frees the whole bo->cb_list on error.\nHowever, by that time the flow_block_cb instances are already in the driver\nlist because driver ndo_setup_tc() callback is called before that up the\ncall chain in tcf_block_offload_cmd(). This leaves dangling pointers to\nfreed objects in the list and causes use-after-free[0]. Fix it by also\nremoving flow_block_cb instances from driver_list before deallocating them.\n\n[0]:\n[  279.868433] ==================================================================\n[  279.869964] BUG: KASAN: slab-use-after-free in flow_block_cb_setup_simple+0x631/0x7c0\n[  279.871527] Read of size 8 at addr ffff888147e2bf20 by task tc/2963\n\n[  279.873151] CPU: 6 PID: 2963 Comm: tc Not tainted 6.3.0-rc6+ #4\n[  279.874273] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[  279.876295] Call Trace:\n[  279.876882]  <TASK>\n[  279.877413]  dump_stack_lvl+0x33/0x50\n[  279.878198]  print_report+0xc2/0x610\n[  279.878987]  ? flow_block_cb_setup_simple+0x631/0x7c0\n[  279.879994]  kasan_report+0xae/0xe0\n[  279.880750]  ? flow_block_cb_setup_simple+0x631/0x7c0\n[  279.881744]  ? mlx5e_tc_reoffload_flows_work+0x240/0x240 [mlx5_core]\n[  279.883047]  flow_block_cb_setup_simple+0x631/0x7c0\n[  279.884027]  tcf_block_offload_cmd.isra.0+0x189/0x2d0\n[  279.885037]  ? tcf_block_setup+0x6b0/0x6b0\n[  279.885901]  ? mutex_lock+0x7d/0xd0\n[  279.886669]  ? __mutex_unlock_slowpath.constprop.0+0x2d0/0x2d0\n[  279.887844]  ? ingress_init+0x1c0/0x1c0 [sch_ingress]\n[  279.888846]  tcf_block_get_ext+0x61c/0x1200\n[  279.889711]  ingress_init+0x112/0x1c0 [sch_ingress]\n[  279.890682]  ? clsact_init+0x2b0/0x2b0 [sch_ingress]\n[  279.891701]  qdisc_create+0x401/0xea0\n[  279.892485]  ? qdisc_tree_reduce_backlog+0x470/0x470\n[  279.893473]  tc_modify_qdisc+0x6f7/0x16d0\n[  279.894344]  ? tc_get_qdisc+0xac0/0xac0\n[  279.895213]  ? mutex_lock+0x7d/0xd0\n[  279.896005]  ? __mutex_lock_slowpath+0x10/0x10\n[  279.896910]  rtnetlink_rcv_msg+0x5fe/0x9d0\n[  279.897770]  ? rtnl_calcit.isra.0+0x2b0/0x2b0\n[  279.898672]  ? __sys_sendmsg+0xb5/0x140\n[  279.899494]  ? do_syscall_64+0x3d/0x90\n[  279.900302]  ? entry_SYSCALL_64_after_hwframe+0x46/0xb0\n[  279.901337]  ? kasan_save_stack+0x2e/0x40\n[  279.902177]  ? kasan_save_stack+0x1e/0x40\n[  279.903058]  ? kasan_set_track+0x21/0x30\n[  279.903913]  ? kasan_save_free_info+0x2a/0x40\n[  279.904836]  ? ____kasan_slab_free+0x11a/0x1b0\n[  279.905741]  ? kmem_cache_free+0x179/0x400\n[  279.906599]  netlink_rcv_skb+0x12c/0x360\n[  279.907450]  ? rtnl_calcit.isra.0+0x2b0/0x2b0\n[  279.908360]  ? netlink_ack+0x1550/0x1550\n[  279.909192]  ? rhashtable_walk_peek+0x170/0x170\n[  279.910135]  ? kmem_cache_alloc_node+0x1af/0x390\n[  279.911086]  ? _copy_from_iter+0x3d6/0xc70\n[  279.912031]  netlink_unicast+0x553/0x790\n[  279.912864]  ? netlink_attachskb+0x6a0/0x6a0\n[  279.913763]  ? netlink_recvmsg+0x416/0xb50\n[  279.914627]  netlink_sendmsg+0x7a1/0xcb0\n[  279.915473]  ? netlink_unicast+0x790/0x790\n[  279.916334]  ? iovec_from_user.part.0+0x4d/0x220\n[  279.917293]  ? netlink_unicast+0x790/0x790\n[  279.918159]  sock_sendmsg+0xc5/0x190\n[  279.918938]  ____sys_sendmsg+0x535/0x6b0\n[  279.919813]  ? import_iovec+0x7/0x10\n[  279.920601]  ? kernel_sendmsg+0x30/0x30\n[  279.921423]  ? __copy_msghdr+0x3c0/0x3c0\n[  279.922254]  ? import_iovec+0x7/0x10\n[  279.923041]  ___sys_sendmsg+0xeb/0x170\n[  279.923854]  ? copy_msghdr_from_user+0x110/0x110\n[  279.924797]  ? ___sys_recvmsg+0xd9/0x130\n[  279.925630]  ? __perf_event_task_sched_in+0x183/0x470\n[  279.926656]  ? ___sys_sendmsg+0x170/0x170\n[  279.927529]  ? ctx_sched_in+0x530/0x530\n[  279.928369]  ? update_curr+0x283/0x4f0\n[  279.929185]  ? perf_event_update_userpage+0x570/0x570\n[  279.930201]  ? __fget_light+0x57/0x520\n[  279.931023]  ? __switch_to+0x53d/0xe70\n[  27\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-30",
                    "modification_date": "2025-12-31",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-36357",
                    "description": "A transient execution vulnerability in some AMD processors may allow an attacker to infer data in the L1D cache, potentially resulting in the leakage of sensitive information across privileged boundaries.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-36357",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-08",
                    "modification_date": "2025-11-04",
                    "nvd_score_v3": 5.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2024-28956",
                    "description": "Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-28956",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-13",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 5.6,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.6,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48961",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mdio: fix unbalanced fwnode reference count in mdio_device_release()\n\nThere is warning report about of_node refcount leak\nwhile probing mdio device:\n\nOF: ERROR: memory leak, expected refcount 1 instead of 2,\nof_node_get()/of_node_put() unbalanced - destroy cset entry:\nattach overlay node /spi/soc@0/mdio@710700c0/ethernet@4\n\nIn of_mdiobus_register_device(), we increase fwnode refcount\nby fwnode_handle_get() before associating the of_node with\nmdio device, but it has never been decreased in normal path.\nSince that, in mdio_device_release(), it needs to call\nfwnode_handle_put() in addition instead of calling kfree()\ndirectly.\n\nAfter above, just calling mdio_device_free() in the error handle\npath of of_mdiobus_register_device() is enough to keep the\nrefcount balanced.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48961",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38601",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: clear initialized flag for deinit-ed srng lists\n\nIn a number of cases we see kernel panics on resume due\nto ath11k kernel page fault, which happens under the\nfollowing circumstances:\n\n1) First ath11k_hal_dump_srng_stats() call\n\n Last interrupt received for each group:\n ath11k_pci 0000:01:00.0: group_id 0 22511ms before\n ath11k_pci 0000:01:00.0: group_id 1 14440788ms before\n [..]\n ath11k_pci 0000:01:00.0: failed to receive control response completion, polling..\n ath11k_pci 0000:01:00.0: Service connect timeout\n ath11k_pci 0000:01:00.0: failed to connect to HTT: -110\n ath11k_pci 0000:01:00.0: failed to start core: -110\n ath11k_pci 0000:01:00.0: firmware crashed: MHI_CB_EE_RDDM\n ath11k_pci 0000:01:00.0: already resetting count 2\n ath11k_pci 0000:01:00.0: failed to wait wlan mode request (mode 4): -110\n ath11k_pci 0000:01:00.0: qmi failed to send wlan mode off: -110\n ath11k_pci 0000:01:00.0: failed to reconfigure driver on crash recovery\n [..]\n\n2) At this point reconfiguration fails (we have 2 resets) and\n  ath11k_core_reconfigure_on_crash() calls ath11k_hal_srng_deinit()\n  which destroys srng lists.  However, it does not reset per-list\n  ->initialized flag.\n\n3) Second ath11k_hal_dump_srng_stats() call sees stale ->initialized\n  flag and attempts to dump srng stats:\n\n Last interrupt received for each group:\n ath11k_pci 0000:01:00.0: group_id 0 66785ms before\n ath11k_pci 0000:01:00.0: group_id 1 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 2 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 3 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 4 14780845ms before\n ath11k_pci 0000:01:00.0: group_id 5 14780845ms before\n ath11k_pci 0000:01:00.0: group_id 6 14485062ms before\n ath11k_pci 0000:01:00.0: group_id 7 66814ms before\n ath11k_pci 0000:01:00.0: group_id 8 68997ms before\n ath11k_pci 0000:01:00.0: group_id 9 67588ms before\n ath11k_pci 0000:01:00.0: group_id 10 69511ms before\n BUG: unable to handle page fault for address: ffffa007404eb010\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 100000067 P4D 100000067 PUD 10022d067 PMD 100b01067 PTE 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n RIP: 0010:ath11k_hal_dump_srng_stats+0x2b4/0x3b0 [ath11k]\n Call Trace:\n <TASK>\n ? __die_body+0xae/0xb0\n ? page_fault_oops+0x381/0x3e0\n ? exc_page_fault+0x69/0xa0\n ? asm_exc_page_fault+0x22/0x30\n ? ath11k_hal_dump_srng_stats+0x2b4/0x3b0 [ath11k (HASH:6cea 4)]\n ath11k_qmi_driver_event_work+0xbd/0x1050 [ath11k (HASH:6cea 4)]\n worker_thread+0x389/0x930\n kthread+0x149/0x170\n\nClear per-list ->initialized flag in ath11k_hal_srng_deinit().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38601",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40319",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Sync pending IRQ work before freeing ring buffer\n\nFix a race where irq_work can be queued in bpf_ringbuf_commit()\nbut the ring buffer is freed before the work executes.\nIn the syzbot reproducer, a BPF program attached to sched_switch\ntriggers bpf_ringbuf_commit(), queuing an irq_work. If the ring buffer\nis freed before this work executes, the irq_work thread may accesses\nfreed memory.\nCalling `irq_work_sync(&rb->work)` ensures that all pending irq_work\ncomplete before freeing the buffer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68291",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: Initialise rcv_mss before calling tcp_send_active_reset() in mptcp_do_fastclose().\n\nsyzbot reported divide-by-zero in __tcp_select_window() by\nMPTCP socket. [0]\n\nWe had a similar issue for the bare TCP and fixed in commit\n499350a5a6e7 (\"tcp: initialize rcv_mss to TCP_MIN_MSS instead\nof 0\").\n\nLet's apply the same fix to mptcp_do_fastclose().\n\n[0]:\nOops: divide error: 0000 [#1] SMP KASAN PTI\nCPU: 0 UID: 0 PID: 6068 Comm: syz.0.17 Not tainted syzkaller #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/25/2025\nRIP: 0010:__tcp_select_window+0x824/0x1320 net/ipv4/tcp_output.c:3336\nCode: ff ff ff 44 89 f1 d3 e0 89 c1 f7 d1 41 01 cc 41 21 c4 e9 a9 00 00 00 e8 ca 49 01 f8 e9 9c 00 00 00 e8 c0 49 01 f8 44 89 e0 99 <f7> 7c 24 1c 41 29 d4 48 bb 00 00 00 00 00 fc ff df e9 80 00 00 00\nRSP: 0018:ffffc90003017640 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff88807b469e40\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ffffc90003017730 R08: ffff888033268143 R09: 1ffff1100664d028\nR10: dffffc0000000000 R11: ffffed100664d029 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\nFS:  000055557faa0500(0000) GS:ffff888126135000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f64a1912ff8 CR3: 0000000072122000 CR4: 00000000003526f0\nCall Trace:\n <TASK>\n tcp_select_window net/ipv4/tcp_output.c:281 [inline]\n __tcp_transmit_skb+0xbc7/0x3aa0 net/ipv4/tcp_output.c:1568\n tcp_transmit_skb net/ipv4/tcp_output.c:1649 [inline]\n tcp_send_active_reset+0x2d1/0x5b0 net/ipv4/tcp_output.c:3836\n mptcp_do_fastclose+0x27e/0x380 net/mptcp/protocol.c:2793\n mptcp_disconnect+0x238/0x710 net/mptcp/protocol.c:3253\n mptcp_sendmsg_fastopen+0x2f8/0x580 net/mptcp/protocol.c:1776\n mptcp_sendmsg+0x1774/0x1980 net/mptcp/protocol.c:1855\n sock_sendmsg_nosec net/socket.c:727 [inline]\n __sock_sendmsg+0xe5/0x270 net/socket.c:742\n __sys_sendto+0x3bd/0x520 net/socket.c:2244\n __do_sys_sendto net/socket.c:2251 [inline]\n __se_sys_sendto net/socket.c:2247 [inline]\n __x64_sys_sendto+0xde/0x100 net/socket.c:2247\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0xfa0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f66e998f749\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffff9acedb8 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\nRAX: ffffffffffffffda RBX: 00007f66e9be5fa0 RCX: 00007f66e998f749\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\nRBP: 00007ffff9acee10 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001\nR13: 00007f66e9be5fa0 R14: 00007f66e9be5fa0 R15: 0000000000000006\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2022-48839",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/packet: fix slab-out-of-bounds access in packet_recvmsg()\n\nsyzbot found that when an AF_PACKET socket is using PACKET_COPY_THRESH\nand mmap operations, tpacket_rcv() is queueing skbs with\ngarbage in skb->cb[], triggering a too big copy [1]\n\nPresumably, users of af_packet using mmap() already gets correct\nmetadata from the mapped buffer, we can simply make sure\nto clear 12 bytes that might be copied to user space later.\n\nBUG: KASAN: stack-out-of-bounds in memcpy include/linux/fortify-string.h:225 [inline]\nBUG: KASAN: stack-out-of-bounds in packet_recvmsg+0x56c/0x1150 net/packet/af_packet.c:3489\nWrite of size 165 at addr ffffc9000385fb78 by task syz-executor233/3631\n\nCPU: 0 PID: 3631 Comm: syz-executor233 Not tainted 5.17.0-rc7-syzkaller-02396-g0b3660695e80 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0xf/0x336 mm/kasan/report.c:255\n __kasan_report mm/kasan/report.c:442 [inline]\n kasan_report.cold+0x83/0xdf mm/kasan/report.c:459\n check_region_inline mm/kasan/generic.c:183 [inline]\n kasan_check_range+0x13d/0x180 mm/kasan/generic.c:189\n memcpy+0x39/0x60 mm/kasan/shadow.c:66\n memcpy include/linux/fortify-string.h:225 [inline]\n packet_recvmsg+0x56c/0x1150 net/packet/af_packet.c:3489\n sock_recvmsg_nosec net/socket.c:948 [inline]\n sock_recvmsg net/socket.c:966 [inline]\n sock_recvmsg net/socket.c:962 [inline]\n ____sys_recvmsg+0x2c4/0x600 net/socket.c:2632\n ___sys_recvmsg+0x127/0x200 net/socket.c:2674\n __sys_recvmsg+0xe2/0x1a0 net/socket.c:2704\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7fdfd5954c29\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 41 15 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffcf8e71e48 EFLAGS: 00000246 ORIG_RAX: 000000000000002f\nRAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fdfd5954c29\nRDX: 0000000000000000 RSI: 0000000020000500 RDI: 0000000000000005\nRBP: 0000000000000000 R08: 000000000000000d R09: 000000000000000d\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007ffcf8e71e60\nR13: 00000000000f4240 R14: 000000000000c1ff R15: 00007ffcf8e71e54\n </TASK>\n\naddr ffffc9000385fb78 is located in stack of task syz-executor233/3631 at offset 32 in frame:\n ____sys_recvmsg+0x0/0x600 include/linux/uio.h:246\n\nthis frame has 1 object:\n [32, 160) 'addr'\n\nMemory state around the buggy address:\n ffffc9000385fa80: 00 04 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00 00\n ffffc9000385fb00: 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00\n>ffffc9000385fb80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f3\n                                                                ^\n ffffc9000385fc00: f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 f1\n ffffc9000385fc80: f1 f1 f1 00 f2 f2 f2 00 f2 f2 f2 00 00 00 00 00\n==================================================================",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48839",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47223",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix vlan tunnel dst null pointer dereference\n\nThis patch fixes a tunnel_dst null pointer dereference due to lockless\naccess in the tunnel egress path. When deleting a vlan tunnel the\ntunnel_dst pointer is set to NULL without waiting a grace period (i.e.\nwhile it's still usable) and packets egressing are dereferencing it\nwithout checking. Use READ/WRITE_ONCE to annotate the lockless use of\ntunnel_id, use RCU for accessing tunnel_dst and make sure it is read\nonly once and checked in the egress path. The dst is already properly RCU\nprotected so we don't need to do anything fancy than to make sure\ntunnel_id and tunnel_dst are read only once and checked in the egress path.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47223",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-02-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47041",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet-tcp: fix incorrect locking in state_change sk callback\n\nWe are not changing anything in the TCP connection state so\nwe should not take a write_lock but rather a read lock.\n\nThis caused a deadlock when running nvmet-tcp and nvme-tcp\non the same system, where state_change callbacks on the\nhost and on the controller side have causal relationship\nand made lockdep report on this with blktests:\n\n================================\nWARNING: inconsistent lock state\n5.12.0-rc3 #1 Tainted: G          I\n--------------------------------\ninconsistent {IN-SOFTIRQ-W} -> {SOFTIRQ-ON-R} usage.\nnvme/1324 [HC0[0]:SC0[0]:HE1:SE1] takes:\nffff888363151000 (clock-AF_INET){++-?}-{2:2}, at: nvme_tcp_state_change+0x21/0x150 [nvme_tcp]\n{IN-SOFTIRQ-W} state was registered at:\n  __lock_acquire+0x79b/0x18d0\n  lock_acquire+0x1ca/0x480\n  _raw_write_lock_bh+0x39/0x80\n  nvmet_tcp_state_change+0x21/0x170 [nvmet_tcp]\n  tcp_fin+0x2a8/0x780\n  tcp_data_queue+0xf94/0x1f20\n  tcp_rcv_established+0x6ba/0x1f00\n  tcp_v4_do_rcv+0x502/0x760\n  tcp_v4_rcv+0x257e/0x3430\n  ip_protocol_deliver_rcu+0x69/0x6a0\n  ip_local_deliver_finish+0x1e2/0x2f0\n  ip_local_deliver+0x1a2/0x420\n  ip_rcv+0x4fb/0x6b0\n  __netif_receive_skb_one_core+0x162/0x1b0\n  process_backlog+0x1ff/0x770\n  __napi_poll.constprop.0+0xa9/0x5c0\n  net_rx_action+0x7b3/0xb30\n  __do_softirq+0x1f0/0x940\n  do_softirq+0xa1/0xd0\n  __local_bh_enable_ip+0xd8/0x100\n  ip_finish_output2+0x6b7/0x18a0\n  __ip_queue_xmit+0x706/0x1aa0\n  __tcp_transmit_skb+0x2068/0x2e20\n  tcp_write_xmit+0xc9e/0x2bb0\n  __tcp_push_pending_frames+0x92/0x310\n  inet_shutdown+0x158/0x300\n  __nvme_tcp_stop_queue+0x36/0x270 [nvme_tcp]\n  nvme_tcp_stop_queue+0x87/0xb0 [nvme_tcp]\n  nvme_tcp_teardown_admin_queue+0x69/0xe0 [nvme_tcp]\n  nvme_do_delete_ctrl+0x100/0x10c [nvme_core]\n  nvme_sysfs_delete.cold+0x8/0xd [nvme_core]\n  kernfs_fop_write_iter+0x2c7/0x460\n  new_sync_write+0x36c/0x610\n  vfs_write+0x5c0/0x870\n  ksys_write+0xf9/0x1d0\n  do_syscall_64+0x33/0x40\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\nirq event stamp: 10687\nhardirqs last  enabled at (10687): [<ffffffff9ec376bd>] _raw_spin_unlock_irqrestore+0x2d/0x40\nhardirqs last disabled at (10686): [<ffffffff9ec374d8>] _raw_spin_lock_irqsave+0x68/0x90\nsoftirqs last  enabled at (10684): [<ffffffff9f000608>] __do_softirq+0x608/0x940\nsoftirqs last disabled at (10649): [<ffffffff9cdedd31>] do_softirq+0xa1/0xd0\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(clock-AF_INET);\n  <Interrupt>\n    lock(clock-AF_INET);\n\n *** DEADLOCK ***\n\n5 locks held by nvme/1324:\n #0: ffff8884a01fe470 (sb_writers#4){.+.+}-{0:0}, at: ksys_write+0xf9/0x1d0\n #1: ffff8886e435c090 (&of->mutex){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x216/0x460\n #2: ffff888104d90c38 (kn->active#255){++++}-{0:0}, at: kernfs_remove_self+0x22d/0x330\n #3: ffff8884634538d0 (&queue->queue_lock){+.+.}-{3:3}, at: nvme_tcp_stop_queue+0x52/0xb0 [nvme_tcp]\n #4: ffff888363150d30 (sk_lock-AF_INET){+.+.}-{0:0}, at: inet_shutdown+0x59/0x300\n\nstack backtrace:\nCPU: 26 PID: 1324 Comm: nvme Tainted: G          I       5.12.0-rc3 #1\nHardware name: Dell Inc. PowerEdge R640/06NR82, BIOS 2.10.0 11/12/2020\nCall Trace:\n dump_stack+0x93/0xc2\n mark_lock_irq.cold+0x2c/0xb3\n ? verify_lock_unused+0x390/0x390\n ? stack_trace_consume_entry+0x160/0x160\n ? lock_downgrade+0x100/0x100\n ? save_trace+0x88/0x5e0\n ? _raw_spin_unlock_irqrestore+0x2d/0x40\n mark_lock+0x530/0x1470\n ? mark_lock_irq+0x1d10/0x1d10\n ? enqueue_timer+0x660/0x660\n mark_usage+0x215/0x2a0\n __lock_acquire+0x79b/0x18d0\n ? tcp_schedule_loss_probe.part.0+0x38c/0x520\n lock_acquire+0x1ca/0x480\n ? nvme_tcp_state_change+0x21/0x150 [nvme_tcp]\n ? rcu_read_unlock+0x40/0x40\n ? tcp_mtu_probe+0x1ae0/0x1ae0\n ? kmalloc_reserve+0xa0/0xa0\n ? sysfs_file_ops+0x170/0x170\n _raw_read_lock+0x3d/0xa0\n ? nvme_tcp_state_change+0x21/0x150 [nvme_tcp]\n nvme_tcp_state_change+0x21/0x150 [nvme_tcp]\n ? sysfs_file_ops\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47041",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2024-12-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38664",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: Fix a null pointer dereference in ice_copy_and_init_pkg()\n\nAdd check for the return value of devm_kmemdup()\nto prevent potential null pointer dereference.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38664",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38602",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niwlwifi: Add missing check for alloc_ordered_workqueue\n\nAdd check for the return value of alloc_ordered_workqueue since it may\nreturn NULL pointer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38602",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47650",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: soc-compress: prevent the potentially use of null pointer\n\nThere is one call trace that snd_soc_register_card()\n->snd_soc_bind_card()->soc_init_pcm_runtime()\n->snd_soc_dai_compress_new()->snd_soc_new_compress().\nIn the trace the 'codec_dai' transfers from card->dai_link,\nand we can see from the snd_soc_add_pcm_runtime() in\nsnd_soc_bind_card() that, if value of card->dai_link->num_codecs\nis 0, then 'codec_dai' could be null pointer caused\nby index out of bound in 'asoc_rtd_to_codec(rtd, 0)'.\nAnd snd_soc_register_card() is called by various platforms.\nTherefore, it is better to add the check in the case of misusing.\nAnd because 'cpu_dai' has already checked in soc_init_pcm_runtime(),\nthere is no need to check again.\nAdding the check as follow, then if 'codec_dai' is null,\nsnd_soc_new_compress() will not pass through the check\n'if (playback + capture != 1)', avoiding the leftover use of\n'codec_dai'.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47650",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38540",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: quirks: Add quirk for 2 Chicony Electronics HP 5MP Cameras\n\nThe Chicony Electronics HP 5MP Cameras (USB ID 04F2:B824 & 04F2:B82C)\nreport a HID sensor interface that is not actually implemented.\nAttempting to access this non-functional sensor via iio_info causes\nsystem hangs as runtime PM tries to wake up an unresponsive sensor.\n\nAdd these 2 devices to the HID ignore list since the sensor interface is\nnon-functional by design and should not be exposed to userspace.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-16",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48987",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-dv-timings.c: fix too strict blanking sanity checks\n\nSanity checks were added to verify the v4l2_bt_timings blanking fields\nin order to avoid integer overflows when userspace passes weird values.\n\nBut that assumed that userspace would correctly fill in the front porch,\nbackporch and sync values, but sometimes all you know is the total\nblanking, which is then assigned to just one of these fields.\n\nAnd that can fail with these checks.\n\nSo instead set a maximum for the total horizontal and vertical\nblanking and check that each field remains below that.\n\nThat is still sufficient to avoid integer overflows, but it also\nallows for more flexibility in how userspace fills in these fields.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48987",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-11-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47415",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niwlwifi: mvm: Fix possible NULL dereference\n\nIn __iwl_mvm_remove_time_event() check that 'te_data->vif' is NULL\nbefore dereferencing it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47415",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-31",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40115",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpt3sas: Fix crash in transport port remove by using ioc_info()\n\nDuring mpt3sas_transport_port_remove(), messages were logged with\ndev_printk() against &mpt3sas_port->port->dev. At this point the SAS\ntransport device may already be partially unregistered or freed, leading\nto a crash when accessing its struct device.\n\nUsing ioc_info(), which logs via the PCI device (ioc->pdev->dev),\nguaranteed to remain valid until driver removal.\n\n[83428.295776] Oops: general protection fault, probably for non-canonical address 0x6f702f323a33312d: 0000 [#1] SMP NOPTI\n[83428.295785] CPU: 145 UID: 0 PID: 113296 Comm: rmmod Kdump: loaded Tainted: G           OE       6.16.0-rc1+ #1 PREEMPT(voluntary)\n[83428.295792] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\n[83428.295795] Hardware name: Dell Inc. Precision 7875 Tower/, BIOS 89.1.67 02/23/2024\n[83428.295799] RIP: 0010:__dev_printk+0x1f/0x70\n[83428.295805] Code: 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 49 89 d1 48 85 f6 74 52 4c 8b 46 50 4d 85 c0 74 1f 48 8b 46 68 48 85 c0 74 22 <48> 8b 08 0f b6 7f 01 48 c7 c2 db e8 42 ad 83 ef 30 e9 7b f8 ff ff\n[83428.295813] RSP: 0018:ff85aeafc3137bb0 EFLAGS: 00010206\n[83428.295817] RAX: 6f702f323a33312d RBX: ff4290ee81292860 RCX: 5000cca25103be32\n[83428.295820] RDX: ff85aeafc3137bb8 RSI: ff4290eeb1966c00 RDI: ffffffffc1560845\n[83428.295823] RBP: ff85aeafc3137c18 R08: 74726f702f303a33 R09: ff85aeafc3137bb8\n[83428.295826] R10: ff85aeafc3137b18 R11: ff4290f5bd60fe68 R12: ff4290ee81290000\n[83428.295830] R13: ff4290ee6e345de0 R14: ff4290ee81290000 R15: ff4290ee6e345e30\n[83428.295833] FS:  00007fd9472a6740(0000) GS:ff4290f5ce96b000(0000) knlGS:0000000000000000\n[83428.295837] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[83428.295840] CR2: 00007f242b4db238 CR3: 00000002372b8006 CR4: 0000000000771ef0\n[83428.295844] PKRU: 55555554\n[83428.295846] Call Trace:\n[83428.295848]  <TASK>\n[83428.295850]  _dev_printk+0x5c/0x80\n[83428.295857]  ? srso_alias_return_thunk+0x5/0xfbef5\n[83428.295863]  mpt3sas_transport_port_remove+0x1c7/0x420 [mpt3sas]\n[83428.295882]  _scsih_remove_device+0x21b/0x280 [mpt3sas]\n[83428.295894]  ? _scsih_expander_node_remove+0x108/0x140 [mpt3sas]\n[83428.295906]  ? srso_alias_return_thunk+0x5/0xfbef5\n[83428.295910]  mpt3sas_device_remove_by_sas_address.part.0+0x8f/0x110 [mpt3sas]\n[83428.295921]  _scsih_expander_node_remove+0x129/0x140 [mpt3sas]\n[83428.295933]  _scsih_expander_node_remove+0x6a/0x140 [mpt3sas]\n[83428.295944]  scsih_remove+0x3f0/0x4a0 [mpt3sas]\n[83428.295957]  pci_device_remove+0x3b/0xb0\n[83428.295962]  device_release_driver_internal+0x193/0x200\n[83428.295968]  driver_detach+0x44/0x90\n[83428.295971]  bus_remove_driver+0x69/0xf0\n[83428.295975]  pci_unregister_driver+0x2a/0xb0\n[83428.295979]  _mpt3sas_exit+0x1f/0x300 [mpt3sas]\n[83428.295991]  __do_sys_delete_module.constprop.0+0x174/0x310\n[83428.295997]  ? srso_alias_return_thunk+0x5/0xfbef5\n[83428.296000]  ? __x64_sys_getdents64+0x9a/0x110\n[83428.296005]  ? srso_alias_return_thunk+0x5/0xfbef5\n[83428.296009]  ? syscall_trace_enter+0xf6/0x1b0\n[83428.296014]  do_syscall_64+0x7b/0x2c0\n[83428.296019]  ? srso_alias_return_thunk+0x5/0xfbef5\n[83428.296023]  entry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38474",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: net: sierra: check for no status endpoint\n\nThe driver checks for having three endpoints and\nhaving bulk in and out endpoints, but not that\nthe third endpoint is interrupt input.\nRectify the omission.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38474",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-28",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47659",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/plane: Move range check for format_count earlier\n\nWhile the check for format_count > 64 in __drm_universal_plane_init()\nshouldn't be hit (it's a WARN_ON), in its current position it will then\nleak the plane->format_types array and fail to call\ndrm_mode_object_unregister() leaking the modeset identifier. Move it to\nthe start of the function to avoid allocating those resources in the\nfirst place.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47659",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-34556",
                    "description": "In the Linux kernel through 5.13.7, an unprivileged BPF program can obtain sensitive information from kernel memory via a Speculative Store Bypass side-channel attack because the protection mechanism neglects the possibility of uninitialized memory locations on the BPF stack.",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-34556",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-08-02",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49113",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/secvar: fix refcount leak in format_show()\n\nRefcount leak will happen when format_show returns failure in multiple\ncases. Unified management of of_node_put can fix this problem.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49113",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38386",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: Refuse to evaluate a method if arguments are missing\n\nAs reported in [1], a platform firmware update that increased the number\nof method parameters and forgot to update a least one of its callers,\ncaused ACPICA to crash due to use-after-free.\n\nSince this a result of a clear AML issue that arguably cannot be fixed\nup by the interpreter (it cannot produce missing data out of thin air),\naddress it by making ACPICA refuse to evaluate a method if the caller\nattempts to pass fewer arguments than expected to it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38386",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47492",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm, thp: bail out early in collapse_file for writeback page\n\nCurrently collapse_file does not explicitly check PG_writeback, instead,\npage_has_private and try_to_release_page are used to filter writeback\npages.  This does not work for xfs with blocksize equal to or larger\nthan pagesize, because in such case xfs has no page->private.\n\nThis makes collapse_file bail out early for writeback page.  Otherwise,\nxfs end_page_writeback will panic as follows.\n\n  page:fffffe00201bcc80 refcount:0 mapcount:0 mapping:ffff0003f88c86a8 index:0x0 pfn:0x84ef32\n  aops:xfs_address_space_operations [xfs] ino:30000b7 dentry name:\"libtest.so\"\n  flags: 0x57fffe0000008027(locked|referenced|uptodate|active|writeback)\n  raw: 57fffe0000008027 ffff80001b48bc28 ffff80001b48bc28 ffff0003f88c86a8\n  raw: 0000000000000000 0000000000000000 00000000ffffffff ffff0000c3e9a000\n  page dumped because: VM_BUG_ON_PAGE(((unsigned int) page_ref_count(page) + 127u <= 127u))\n  page->mem_cgroup:ffff0000c3e9a000\n  ------------[ cut here ]------------\n  kernel BUG at include/linux/mm.h:1212!\n  Internal error: Oops - BUG: 0 [#1] SMP\n  Modules linked in:\n  BUG: Bad page state in process khugepaged  pfn:84ef32\n   xfs(E)\n  page:fffffe00201bcc80 refcount:0 mapcount:0 mapping:0 index:0x0 pfn:0x84ef32\n   libcrc32c(E) rfkill(E) aes_ce_blk(E) crypto_simd(E) ...\n  CPU: 25 PID: 0 Comm: swapper/25 Kdump: loaded Tainted: ...\n  pstate: 60400005 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n  Call trace:\n    end_page_writeback+0x1c0/0x214\n    iomap_finish_page_writeback+0x13c/0x204\n    iomap_finish_ioend+0xe8/0x19c\n    iomap_writepage_end_bio+0x38/0x50\n    bio_endio+0x168/0x1ec\n    blk_update_request+0x278/0x3f0\n    blk_mq_end_request+0x34/0x15c\n    virtblk_request_done+0x38/0x74 [virtio_blk]\n    blk_done_softirq+0xc4/0x110\n    __do_softirq+0x128/0x38c\n    __irq_exit_rcu+0x118/0x150\n    irq_exit+0x1c/0x30\n    __handle_domain_irq+0x8c/0xf0\n    gic_handle_irq+0x84/0x108\n    el1_irq+0xcc/0x180\n    arch_cpu_idle+0x18/0x40\n    default_idle_call+0x4c/0x1a0\n    cpuidle_idle_call+0x168/0x1e0\n    do_idle+0xb4/0x104\n    cpu_startup_entry+0x30/0x9c\n    secondary_start_kernel+0x104/0x180\n  Code: d4210000 b0006161 910c8021 94013f4d (d4210000)\n  ---[ end trace 4a88c6a074082f8c ]---\n  Kernel panic - not syncing: Oops - BUG: Fatal exception in interrupt",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47492",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-09-29",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40195",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmount: handle NULL values in mnt_ns_release()\n\nWhen calling in listmount() mnt_ns_release() may be passed a NULL\npointer. Handle that case gracefully.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "modification_date": "2025-11-14",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48946",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Fix preallocation discarding at indirect extent boundary\n\nWhen preallocation extent is the first one in the extent block, the\ncode would corrupt extent tree header instead. Fix the problem and use\nudf_delete_aext() for deleting extent to avoid some code duplication.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48946",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48953",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nrtc: cmos: Fix event handler registration ordering issue\n\nBecause acpi_install_fixed_event_handler() enables the event\nautomatically on success, it is incorrect to call it before the\nhandler routine passed to it is ready to handle events.\n\nUnfortunately, the rtc-cmos driver does exactly the incorrect thing\nby calling cmos_wake_setup(), which passes rtc_handler() to\nacpi_install_fixed_event_handler(), before cmos_do_probe(), because\nrtc_handler() uses dev_get_drvdata() to get to the cmos object\npointer and the driver data pointer is only populated in\ncmos_do_probe().\n\nThis leads to a NULL pointer dereference in rtc_handler() on boot\nif the RTC fixed event happens to be active at the init time.\n\nTo address this issue, change the initialization ordering of the\ndriver so that cmos_wake_setup() is always called after a successful\ncmos_do_probe() call.\n\nWhile at it, change cmos_pnp_probe() to call cmos_do_probe() after\nthe initial if () statement used for computing the IRQ argument to\nbe passed to cmos_do_probe() which is cleaner than calling it in\neach branch of that if () (local variable \"irq\" can be of type int,\nbecause it is passed to that function as an argument of type int).\n\nNote that commit 6492fed7d8c9 (\"rtc: rtc-cmos: Do not check\nACPI_FADT_LOW_POWER_S0\") caused this issue to affect a larger number\nof systems, because previously it only affected systems with\nACPI_FADT_LOW_POWER_S0 set, but it is present regardless of that\ncommit.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48953",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39763",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: APEI: send SIGBUS to current task if synchronous memory error not recovered\n\nIf a synchronous error is detected as a result of user-space process\ntriggering a 2-bit uncorrected error, the CPU will take a synchronous\nerror exception such as Synchronous External Abort (SEA) on Arm64. The\nkernel will queue a memory_failure() work which poisons the related\npage, unmaps the page, and then sends a SIGBUS to the process, so that\na system wide panic can be avoided.\n\nHowever, no memory_failure() work will be queued when abnormal\nsynchronous errors occur. These errors can include situations like\ninvalid PA, unexpected severity, no memory failure config support,\ninvalid GUID section, etc. In such a case, the user-space process will\ntrigger SEA again.  This loop can potentially exceed the platform\nfirmware threshold or even trigger a kernel hard lockup, leading to a\nsystem reboot.\n\nFix it by performing a force kill if no memory_failure() work is queued\nfor synchronous errors.\n\n[ rjw: Changelog edits ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39763",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38470",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: vlan: fix VLAN 0 refcount imbalance of toggling filtering during runtime\n\nAssuming the \"rx-vlan-filter\" feature is enabled on a net device, the\n8021q module will automatically add or remove VLAN 0 when the net device\nis put administratively up or down, respectively. There are a couple of\nproblems with the above scheme.\n\nThe first problem is a memory leak that can happen if the \"rx-vlan-filter\"\nfeature is disabled while the device is running:\n\n # ip link add bond1 up type bond mode 0\n # ethtool -K bond1 rx-vlan-filter off\n # ip link del dev bond1\n\nWhen the device is put administratively down the \"rx-vlan-filter\"\nfeature is disabled, so the 8021q module will not remove VLAN 0 and the\nmemory will be leaked [1].\n\nAnother problem that can happen is that the kernel can automatically\ndelete VLAN 0 when the device is put administratively down despite not\nadding it when the device was put administratively up since during that\ntime the \"rx-vlan-filter\" feature was disabled. null-ptr-unref or\nbug_on[2] will be triggered by unregister_vlan_dev() for refcount\nimbalance if toggling filtering during runtime:\n\n$ ip link add bond0 type bond mode 0\n$ ip link add link bond0 name vlan0 type vlan id 0 protocol 802.1q\n$ ethtool -K bond0 rx-vlan-filter off\n$ ifconfig bond0 up\n$ ethtool -K bond0 rx-vlan-filter on\n$ ifconfig bond0 down\n$ ip link del vlan0\n\nRoot cause is as below:\nstep1: add vlan0 for real_dev, such as bond, team.\nregister_vlan_dev\n    vlan_vid_add(real_dev,htons(ETH_P_8021Q),0) //refcnt=1\nstep2: disable vlan filter feature and enable real_dev\nstep3: change filter from 0 to 1\nvlan_device_event\n    vlan_filter_push_vids\n        ndo_vlan_rx_add_vid //No refcnt added to real_dev vlan0\nstep4: real_dev down\nvlan_device_event\n    vlan_vid_del(dev, htons(ETH_P_8021Q), 0); //refcnt=0\n        vlan_info_rcu_free //free vlan0\nstep5: delete vlan0\nunregister_vlan_dev\n    BUG_ON(!vlan_info); //vlan_info is null\n\nFix both problems by noting in the VLAN info whether VLAN 0 was\nautomatically added upon NETDEV_UP and based on that decide whether it\nshould be deleted upon NETDEV_DOWN, regardless of the state of the\n\"rx-vlan-filter\" feature.\n\n[1]\nunreferenced object 0xffff8880068e3100 (size 256):\n  comm \"ip\", pid 384, jiffies 4296130254\n  hex dump (first 32 bytes):\n    00 20 30 0d 80 88 ff ff 00 00 00 00 00 00 00 00  . 0.............\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace (crc 81ce31fa):\n    __kmalloc_cache_noprof+0x2b5/0x340\n    vlan_vid_add+0x434/0x940\n    vlan_device_event.cold+0x75/0xa8\n    notifier_call_chain+0xca/0x150\n    __dev_notify_flags+0xe3/0x250\n    rtnl_configure_link+0x193/0x260\n    rtnl_newlink_create+0x383/0x8e0\n    __rtnl_newlink+0x22c/0xa40\n    rtnl_newlink+0x627/0xb00\n    rtnetlink_rcv_msg+0x6fb/0xb70\n    netlink_rcv_skb+0x11f/0x350\n    netlink_unicast+0x426/0x710\n    netlink_sendmsg+0x75a/0xc20\n    __sock_sendmsg+0xc1/0x150\n    ____sys_sendmsg+0x5aa/0x7b0\n    ___sys_sendmsg+0xfc/0x180\n\n[2]\nkernel BUG at net/8021q/vlan.c:99!\nOops: invalid opcode: 0000 [#1] SMP KASAN PTI\nCPU: 0 UID: 0 PID: 382 Comm: ip Not tainted 6.16.0-rc3 #61 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996),\nBIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\nRIP: 0010:unregister_vlan_dev (net/8021q/vlan.c:99 (discriminator 1))\nRSP: 0018:ffff88810badf310 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: ffff88810da84000 RCX: ffffffffb47ceb9a\nRDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88810e8b43c8\nRBP: 0000000000000000 R08: 0000000000000000 R09: fffffbfff6cefe80\nR10: ffffffffb677f407 R11: ffff88810badf3c0 R12: ffff88810e8b4000\nR13: 0000000000000000 R14: ffff88810642a5c0 R15: 000000000000017e\nFS:  00007f1ff68c20c0(0000) GS:ffff888163a24000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f1ff5dad240 CR3: 0000000107e56000 CR4: 00000000000006f0\nCall Trace:\n <TASK\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38470",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-28",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-36790",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet: fix a memory leak\n\nWe forgot to free new_model_number",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-36790",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-05-01",
                    "modification_date": "2025-11-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38324",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmpls: Use rcu_dereference_rtnl() in mpls_route_input_rcu().\n\nAs syzbot reported [0], mpls_route_input_rcu() can be called\nfrom mpls_getroute(), where is under RTNL.\n\nnet->mpls.platform_label is only updated under RTNL.\n\nLet's use rcu_dereference_rtnl() in mpls_route_input_rcu() to\nsilence the splat.\n\n[0]:\nWARNING: suspicious RCU usage\n6.15.0-rc7-syzkaller-00082-g5cdb2c77c4c3 #0 Not tainted\n ----------------------------\nnet/mpls/af_mpls.c:84 suspicious rcu_dereference_check() usage!\n\nother info that might help us debug this:\n\nrcu_scheduler_active = 2, debug_locks = 1\n1 lock held by syz.2.4451/17730:\n #0: ffffffff9012a3e8 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_lock net/core/rtnetlink.c:80 [inline]\n #0: ffffffff9012a3e8 (rtnl_mutex){+.+.}-{4:4}, at: rtnetlink_rcv_msg+0x371/0xe90 net/core/rtnetlink.c:6961\n\nstack backtrace:\nCPU: 1 UID: 0 PID: 17730 Comm: syz.2.4451 Not tainted 6.15.0-rc7-syzkaller-00082-g5cdb2c77c4c3 #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x16c/0x1f0 lib/dump_stack.c:120\n lockdep_rcu_suspicious+0x166/0x260 kernel/locking/lockdep.c:6865\n mpls_route_input_rcu+0x1d4/0x200 net/mpls/af_mpls.c:84\n mpls_getroute+0x621/0x1ea0 net/mpls/af_mpls.c:2381\n rtnetlink_rcv_msg+0x3c9/0xe90 net/core/rtnetlink.c:6964\n netlink_rcv_skb+0x16d/0x440 net/netlink/af_netlink.c:2534\n netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]\n netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339\n netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg net/socket.c:727 [inline]\n ____sys_sendmsg+0xa98/0xc70 net/socket.c:2566\n ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620\n __sys_sendmmsg+0x200/0x420 net/socket.c:2709\n __do_sys_sendmmsg net/socket.c:2736 [inline]\n __se_sys_sendmmsg net/socket.c:2733 [inline]\n __x64_sys_sendmmsg+0x9c/0x100 net/socket.c:2733\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xcd/0x230 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f0a2818e969\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f0a28f52038 EFLAGS: 00000246 ORIG_RAX: 0000000000000133\nRAX: ffffffffffffffda RBX: 00007f0a283b5fa0 RCX: 00007f0a2818e969\nRDX: 0000000000000003 RSI: 0000200000000080 RDI: 0000000000000003\nRBP: 00007f0a28210ab1 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007f0a283b5fa0 R15: 00007ffce5e9f268\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38324",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-19",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49097",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Avoid writeback threads getting stuck in mempool_alloc()\n\nIn a low memory situation, allow the NFS writeback code to fail without\ngetting stuck in infinite loops in mempool_alloc().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49097",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40053",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dlink: handle copy_thresh allocation failure\n\nThe driver did not handle failure of `netdev_alloc_skb_ip_align()`.\nIf the allocation failed, dereferencing `skb->protocol` could lead to\na NULL pointer dereference.\n\nThis patch tries to allocate `skb`. If the allocation fails, it falls\nback to the normal path.\n\nTested-on: D-Link DGE-550T Rev-A3",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68379",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/rxe: Fix null deref on srq->rq.queue after resize failure\n\nA NULL pointer dereference can occur in rxe_srq_chk_attr() when\nibv_modify_srq() is invoked twice in succession under certain error\nconditions. The first call may fail in rxe_queue_resize(), which leads\nrxe_srq_from_attr() to set srq->rq.queue = NULL. The second call then\ntriggers a crash (null deref) when accessing\nsrq->rq.queue->buf->index_mask.\n\nCall Trace:\n<TASK>\nrxe_modify_srq+0x170/0x480 [rdma_rxe]\n? __pfx_rxe_modify_srq+0x10/0x10 [rdma_rxe]\n? uverbs_try_lock_object+0x4f/0xa0 [ib_uverbs]\n? rdma_lookup_get_uobject+0x1f0/0x380 [ib_uverbs]\nib_uverbs_modify_srq+0x204/0x290 [ib_uverbs]\n? __pfx_ib_uverbs_modify_srq+0x10/0x10 [ib_uverbs]\n? tryinc_node_nr_active+0xe6/0x150\n? uverbs_fill_udata+0xed/0x4f0 [ib_uverbs]\nib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x2c0/0x470 [ib_uverbs]\n? __pfx_ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x10/0x10 [ib_uverbs]\n? uverbs_fill_udata+0xed/0x4f0 [ib_uverbs]\nib_uverbs_run_method+0x55a/0x6e0 [ib_uverbs]\n? __pfx_ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0x10/0x10 [ib_uverbs]\nib_uverbs_cmd_verbs+0x54d/0x800 [ib_uverbs]\n? __pfx_ib_uverbs_cmd_verbs+0x10/0x10 [ib_uverbs]\n? __pfx___raw_spin_lock_irqsave+0x10/0x10\n? __pfx_do_vfs_ioctl+0x10/0x10\n? ioctl_has_perm.constprop.0.isra.0+0x2c7/0x4c0\n? __pfx_ioctl_has_perm.constprop.0.isra.0+0x10/0x10\nib_uverbs_ioctl+0x13e/0x220 [ib_uverbs]\n? __pfx_ib_uverbs_ioctl+0x10/0x10 [ib_uverbs]\n__x64_sys_ioctl+0x138/0x1c0\ndo_syscall_64+0x82/0x250\n? fdget_pos+0x58/0x4c0\n? ksys_write+0xf3/0x1c0\n? __pfx_ksys_write+0x10/0x10\n? do_syscall_64+0xc8/0x250\n? __pfx_vm_mmap_pgoff+0x10/0x10\n? fget+0x173/0x230\n? fput+0x2a/0x80\n? ksys_mmap_pgoff+0x224/0x4c0\n? do_syscall_64+0xc8/0x250\n? do_user_addr_fault+0x37b/0xfe0\n? clear_bhb_loop+0x50/0xa0\n? clear_bhb_loop+0x50/0xa0\n? clear_bhb_loop+0x50/0xa0\nentry_SYSCALL_64_after_hwframe+0x76/0x7e",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48849",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: bypass tiling flag check in virtual display case (v2)\n\nvkms leverages common amdgpu framebuffer creation, and\nalso as it does not support FB modifier, there is no need\nto check tiling flags when initing framebuffer when virtual\ndisplay is enabled.\n\nThis can fix below calltrace:\n\namdgpu 0000:00:08.0: GFX9+ requires FB check based on format modifier\nWARNING: CPU: 0 PID: 1023 at drivers/gpu/drm/amd/amdgpu/amdgpu_display.c:1150 amdgpu_display_framebuffer_init+0x8e7/0xb40 [amdgpu]\n\nv2: check adev->enable_virtual_display instead as vkms can be\n\tenabled in bare metal as well.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48849",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-06-19",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47343",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm btree remove: assign new_root only when removal succeeds\n\nremove_raw() in dm_btree_remove() may fail due to IO read error\n(e.g. read the content of origin block fails during shadowing),\nand the value of shadow_spine::root is uninitialized, but\nthe uninitialized value is still assign to new_root in the\nend of dm_btree_remove().\n\nFor dm-thin, the value of pmd->details_root or pmd->root will become\nan uninitialized value, so if trying to read details_info tree again\nout-of-bound memory may occur as showed below:\n\n  general protection fault, probably for non-canonical address 0x3fdcb14c8d7520\n  CPU: 4 PID: 515 Comm: dmsetup Not tainted 5.13.0-rc6\n  Hardware name: QEMU Standard PC\n  RIP: 0010:metadata_ll_load_ie+0x14/0x30\n  Call Trace:\n   sm_metadata_count_is_more_than_one+0xb9/0xe0\n   dm_tm_shadow_block+0x52/0x1c0\n   shadow_step+0x59/0xf0\n   remove_raw+0xb2/0x170\n   dm_btree_remove+0xf4/0x1c0\n   dm_pool_delete_thin_device+0xc3/0x140\n   pool_message+0x218/0x2b0\n   target_message+0x251/0x290\n   ctl_ioctl+0x1c4/0x4d0\n   dm_ctl_ioctl+0xe/0x20\n   __x64_sys_ioctl+0x7b/0xb0\n   do_syscall_64+0x40/0xb0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nFixing it by only assign new_root when removal succeeds",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47343",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-05-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38424",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix sample vs do_exit()\n\nBaisheng Gao reported an ARM64 crash, which Mark decoded as being a\nsynchronous external abort -- most likely due to trying to access\nMMIO in bad ways.\n\nThe crash further shows perf trying to do a user stack sample while in\nexit_mmap()'s tlb_finish_mmu() -- i.e. while tearing down the address\nspace it is trying to access.\n\nIt turns out that we stop perf after we tear down the userspace mm; a\nreceipie for disaster, since perf likes to access userspace for\nvarious reasons.\n\nFlip this order by moving up where we stop perf in do_exit().\n\nAdditionally, harden PERF_SAMPLE_CALLCHAIN and PERF_SAMPLE_STACK_USER\nto abort when the current task does not have an mm (exit_mm() makes\nsure to set current->mm = NULL; before commencing with the actual\nteardown). Such that CPU wide events don't trip on this same problem.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38424",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49074",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/gic-v3: Fix GICR_CTLR.RWP polling\n\nIt turns out that our polling of RWP is totally wrong when checking\nfor it in the redistributors, as we test the *distributor* bit index,\nwhereas it is a different bit number in the RDs... Oopsie boo.\n\nThis is embarassing. Not only because it is wrong, but also because\nit took *8 years* to notice the blunder...\n\nJust fix the damn thing.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49074",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-46960",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Return correct error code from smb2_get_enc_key\n\nAvoid a warning if the error percolates back up:\n\n[440700.376476] CIFS VFS: \\\\otters.example.com crypt_message: Could not get encryption key\n[440700.386947] ------------[ cut here ]------------\n[440700.386948] err = 1\n[440700.386977] WARNING: CPU: 11 PID: 2733 at /build/linux-hwe-5.4-p6lk6L/linux-hwe-5.4-5.4.0/lib/errseq.c:74 errseq_set+0x5c/0x70\n...\n[440700.397304] CPU: 11 PID: 2733 Comm: tar Tainted: G           OE     5.4.0-70-generic #78~18.04.1-Ubuntu\n...\n[440700.397334] Call Trace:\n[440700.397346]  __filemap_set_wb_err+0x1a/0x70\n[440700.397419]  cifs_writepages+0x9c7/0xb30 [cifs]\n[440700.397426]  do_writepages+0x4b/0xe0\n[440700.397444]  __filemap_fdatawrite_range+0xcb/0x100\n[440700.397455]  filemap_write_and_wait+0x42/0xa0\n[440700.397486]  cifs_setattr+0x68b/0xf30 [cifs]\n[440700.397493]  notify_change+0x358/0x4a0\n[440700.397500]  utimes_common+0xe9/0x1c0\n[440700.397510]  do_utimes+0xc5/0x150\n[440700.397520]  __x64_sys_utimensat+0x88/0xd0",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46960",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-27",
                    "modification_date": "2024-12-11",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39732",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath11k: fix sleeping-in-atomic in ath11k_mac_op_set_bitrate_mask()\n\nath11k_mac_disable_peer_fixed_rate() is passed as the iterator to\nieee80211_iterate_stations_atomic(). Note in this case the iterator is\nrequired to be atomic, however ath11k_mac_disable_peer_fixed_rate() does\nnot follow it as it might sleep. Consequently below warning is seen:\n\nBUG: sleeping function called from invalid context at wmi.c:304\nCall Trace:\n <TASK>\n dump_stack_lvl\n __might_resched.cold\n ath11k_wmi_cmd_send\n ath11k_wmi_set_peer_param\n ath11k_mac_disable_peer_fixed_rate\n ieee80211_iterate_stations_atomic\n ath11k_mac_op_set_bitrate_mask.cold\n\nChange to ieee80211_iterate_stations_mtx() to fix this issue.\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39732",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-07",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38466",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Revert to requiring CAP_SYS_ADMIN for uprobes\n\nJann reports that uprobes can be used destructively when used in the\nmiddle of an instruction. The kernel only verifies there is a valid\ninstruction at the requested offset, but due to variable instruction\nlength cannot determine if this is an instruction as seen by the\nintended execution stream.\n\nAdditionally, Mark Rutland notes that on architectures that mix data\nin the text segment (like arm64), a similar things can be done if the\ndata word is 'mistaken' for an instruction.\n\nAs such, require CAP_SYS_ADMIN for uprobes.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38466",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38516",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: qcom: msm: mark certain pins as invalid for interrupts\n\nOn some platforms, the UFS-reset pin has no interrupt logic in TLMM but\nis nevertheless registered as a GPIO in the kernel. This enables the\nuser-space to trigger a BUG() in the pinctrl-msm driver by running, for\nexample: `gpiomon -c 0 113` on RB2.\n\nThe exact culprit is requesting pins whose intr_detection_width setting\nis not 1 or 2 for interrupts. This hits a BUG() in\nmsm_gpio_irq_set_type(). Potentially crashing the kernel due to an\ninvalid request from user-space is not optimal, so let's go through the\npins and mark those that would fail the check as invalid for the irq chip\nas we should not even register them as available irqs.\n\nThis function can be extended if we determine that there are more\ncorner-cases like this.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38516",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-16",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38691",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npNFS: Fix uninited ptr deref in block/scsi layout\n\nThe error occurs on the third attempt to encode extents. When function\next_tree_prepare_commit() reallocates a larger buffer to retry encoding\nextents, the \"layoutupdate_pages\" page array is initialized only after the\nretry loop. But ext_tree_free_commitdata() is called on every iteration\nand tries to put pages in the array, thus dereferencing uninitialized\npointers.\n\nAn additional problem is that there is no limit on the maximum possible\nbuffer_size. When there are too many extents, the client may create a\nlayoutcommit that is larger than the maximum possible RPC size accepted\nby the server.\n\nDuring testing, we observed two typical scenarios. First, one memory page\nfor extents is enough when we work with small files, append data to the\nend of the file, or preallocate extents before writing. But when we fill\na new large file without preallocating, the number of extents can be huge,\nand counting the number of written extents in ext_tree_encode_commit()\ndoes not help much. Since this number increases even more between\nunlocking and locking of ext_tree, the reallocated buffer may not be\nlarge enough again and again.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38691",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38659",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: No more self recovery\n\nWhen a node withdraws and it turns out that it is the only node that has\nthe filesystem mounted, gfs2 currently tries to replay the local journal\nto bring the filesystem back into a consistent state.  Not only is that\na very bad idea, it has also never worked because gfs2_recover_func()\nwill refuse to do anything during a withdraw.\n\nHowever, before even getting to this point, gfs2_recover_func()\ndereferences sdp->sd_jdesc->jd_inode.  This was a use-after-free before\ncommit 04133b607a78 (\"gfs2: Prevent double iput for journal on error\")\nand is a NULL pointer dereference since then.\n\nSimply get rid of self recovery to fix that.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38659",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2025-11-26",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38706",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: core: Check for rtd == NULL in snd_soc_remove_pcm_runtime()\n\nsnd_soc_remove_pcm_runtime() might be called with rtd == NULL which will\nleads to null pointer dereference.\nThis was reproduced with topology loading and marking a link as ignore\ndue to missing hardware component on the system.\nOn module removal the soc_tplg_remove_link() would call\nsnd_soc_remove_pcm_runtime() with rtd == NULL since the link was ignored,\nno runtime was created.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48933",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: fix memory leak during stateful obj update\n\nstateful objects can be updated from the control plane.\nThe transaction logic allocates a temporary object for this purpose.\n\nThe ->init function was called for this object, so plain kfree() leaks\nresources. We must call ->destroy function of the object.\n\nnft_obj_destroy does this, but it also decrements the module refcount,\nbut the update path doesn't increment it.\n\nTo avoid special-casing the update object release, do module_get for\nthe update case too and release it via nft_obj_destroy().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48933",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-08-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38622",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: drop UFO packets in udp_rcv_segment()\n\nWhen sending a packet with virtio_net_hdr to tun device, if the gso_type\nin virtio_net_hdr is SKB_GSO_UDP and the gso_size is less than udphdr\nsize, below crash may happen.\n\n  ------------[ cut here ]------------\n  kernel BUG at net/core/skbuff.c:4572!\n  Oops: invalid opcode: 0000 [#1] SMP NOPTI\n  CPU: 0 UID: 0 PID: 62 Comm: mytest Not tainted 6.16.0-rc7 #203 PREEMPT(voluntary)\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  RIP: 0010:skb_pull_rcsum+0x8e/0xa0\n  Code: 00 00 5b c3 cc cc cc cc 8b 93 88 00 00 00 f7 da e8 37 44 38 00 f7 d8 89 83 88 00 00 00 48 8b 83 c8 00 00 00 5b c3 cc cc cc cc <0f> 0b 0f 0b 66 66 2e 0f 1f 84 00 000\n  RSP: 0018:ffffc900001fba38 EFLAGS: 00000297\n  RAX: 0000000000000004 RBX: ffff8880040c1000 RCX: ffffc900001fb948\n  RDX: ffff888003e6d700 RSI: 0000000000000008 RDI: ffff88800411a062\n  RBP: ffff8880040c1000 R08: 0000000000000000 R09: 0000000000000001\n  R10: ffff888003606c00 R11: 0000000000000001 R12: 0000000000000000\n  R13: ffff888004060900 R14: ffff888004050000 R15: ffff888004060900\n  FS:  000000002406d3c0(0000) GS:ffff888084a19000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000020000040 CR3: 0000000004007000 CR4: 00000000000006f0\n  Call Trace:\n   <TASK>\n   udp_queue_rcv_one_skb+0x176/0x4b0 net/ipv4/udp.c:2445\n   udp_queue_rcv_skb+0x155/0x1f0 net/ipv4/udp.c:2475\n   udp_unicast_rcv_skb+0x71/0x90 net/ipv4/udp.c:2626\n   __udp4_lib_rcv+0x433/0xb00 net/ipv4/udp.c:2690\n   ip_protocol_deliver_rcu+0xa6/0x160 net/ipv4/ip_input.c:205\n   ip_local_deliver_finish+0x72/0x90 net/ipv4/ip_input.c:233\n   ip_sublist_rcv_finish+0x5f/0x70 net/ipv4/ip_input.c:579\n   ip_sublist_rcv+0x122/0x1b0 net/ipv4/ip_input.c:636\n   ip_list_rcv+0xf7/0x130 net/ipv4/ip_input.c:670\n   __netif_receive_skb_list_core+0x21d/0x240 net/core/dev.c:6067\n   netif_receive_skb_list_internal+0x186/0x2b0 net/core/dev.c:6210\n   napi_complete_done+0x78/0x180 net/core/dev.c:6580\n   tun_get_user+0xa63/0x1120 drivers/net/tun.c:1909\n   tun_chr_write_iter+0x65/0xb0 drivers/net/tun.c:1984\n   vfs_write+0x300/0x420 fs/read_write.c:593\n   ksys_write+0x60/0xd0 fs/read_write.c:686\n   do_syscall_64+0x50/0x1c0 arch/x86/entry/syscall_64.c:63\n   </TASK>\n\nTo trigger gso segment in udp_queue_rcv_skb(), we should also set option\nUDP_ENCAP_ESPINUDP to enable udp_sk(sk)->encap_rcv. When the encap_rcv\nhook return 1 in udp_queue_rcv_one_skb(), udp_csum_pull_header() will try\nto pull udphdr, but the skb size has been segmented to gso size, which\nleads to this crash.\n\nPrevious commit cf329aa42b66 (\"udp: cope with UDP GRO packet misdirection\")\nintroduces segmentation in UDP receive path only for GRO, which was never\nintended to be used for UFO, so drop UFO packets in udp_rcv_segment().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38622",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40153",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: hugetlb: avoid soft lockup when mprotect to large memory area\n\nWhen calling mprotect() to a large hugetlb memory area in our customer's\nworkload (~300GB hugetlb memory), soft lockup was observed:\n\nwatchdog: BUG: soft lockup - CPU#98 stuck for 23s! [t2_new_sysv:126916]\n\nCPU: 98 PID: 126916 Comm: t2_new_sysv Kdump: loaded Not tainted 6.17-rc7\nHardware name: GIGACOMPUTING R2A3-T40-AAV1/Jefferson CIO, BIOS 5.4.4.1 07/15/2025\npstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc\u00a0: mte_clear_page_tags+0x14/0x24\nlr\u00a0: mte_sync_tags+0x1c0/0x240\nsp\u00a0: ffff80003150bb80\nx29: ffff80003150bb80 x28: ffff00739e9705a8 x27: 0000ffd2d6a00000\nx26: 0000ff8e4bc00000 x25: 00e80046cde00f45 x24: 0000000000022458\nx23: 0000000000000000 x22: 0000000000000004 x21: 000000011b380000\nx20: ffff000000000000 x19: 000000011b379f40 x18: 0000000000000000\nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\nx14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\nx11: 0000000000000000 x10: 0000000000000000 x9 : ffffc875e0aa5e2c\nx8\u00a0: 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000\nx5\u00a0: fffffc01ce7a5c00 x4 : 00000000046cde00 x3 : fffffc0000000000\nx2\u00a0: 0000000000000004 x1 : 0000000000000040 x0 : ffff0046cde7c000\n\nCall trace:\n\u00a0\u00a0mte_clear_page_tags+0x14/0x24\n\u00a0\u00a0set_huge_pte_at+0x25c/0x280\n\u00a0\u00a0hugetlb_change_protection+0x220/0x430\n\u00a0\u00a0change_protection+0x5c/0x8c\n\u00a0\u00a0mprotect_fixup+0x10c/0x294\n\u00a0\u00a0do_mprotect_pkey.constprop.0+0x2e0/0x3d4\n\u00a0\u00a0__arm64_sys_mprotect+0x24/0x44\n\u00a0\u00a0invoke_syscall+0x50/0x160\n\u00a0\u00a0el0_svc_common+0x48/0x144\n\u00a0\u00a0do_el0_svc+0x30/0xe0\n\u00a0\u00a0el0_svc+0x30/0xf0\n\u00a0\u00a0el0t_64_sync_handler+0xc4/0x148\n\u00a0\u00a0el0t_64_sync+0x1a4/0x1a8\n\nSoft lockup is not triggered with THP or base page because there is\ncond_resched() called for each PMD size.\n\nAlthough the soft lockup was triggered by MTE, it should be not MTE\nspecific.  The other processing which takes long time in the loop may\ntrigger soft lockup too.\n\nSo add cond_resched() for hugetlb to avoid soft lockup.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40264",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbe2net: pass wrb_params in case of OS2BMC\n\nbe_insert_vlan_in_pkt() is called with the wrb_params argument being NULL\nat be_send_pkt_to_bmc() call site.\u00a0 This may lead to dereferencing a NULL\npointer when processing a workaround for specific packet, as commit\nbc0c3405abbb (\"be2net: fix a Tx stall bug caused by a specific ipv6\npacket\") states.\n\nThe correct way would be to pass the wrb_params from be_xmit().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48929",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix crash due to out of bounds access into reg2btf_ids.\n\nWhen commit e6ac2450d6de (\"bpf: Support bpf program calling kernel function\") added\nkfunc support, it defined reg2btf_ids as a cheap way to translate the verifier\nreg type to the appropriate btf_vmlinux BTF ID, however\ncommit c25b2ae13603 (\"bpf: Replace PTR_TO_XXX_OR_NULL with PTR_TO_XXX | PTR_MAYBE_NULL\")\nmoved the __BPF_REG_TYPE_MAX from the last member of bpf_reg_type enum to after\nthe base register types, and defined other variants using type flag\ncomposition. However, now, the direct usage of reg->type to index into\nreg2btf_ids may no longer fall into __BPF_REG_TYPE_MAX range, and hence lead to\nout of bounds access and kernel crash on dereference of bad pointer.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48929",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-08-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39678",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86/amd/hsmp: Ensure sock->metric_tbl_addr is non-NULL\n\nIf metric table address is not allocated, accessing metrics_bin will\nresult in a NULL pointer dereference, so add a check.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39678",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-05",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47563",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: avoid bpf_prog refcount underflow\n\nIce driver has the routines for managing XDP resources that are shared\nbetween ndo_bpf op and VSI rebuild flow. The latter takes place for\nexample when user changes queue count on an interface via ethtool's\nset_channels().\n\nThere is an issue around the bpf_prog refcounting when VSI is being\nrebuilt - since ice_prepare_xdp_rings() is called with vsi->xdp_prog as\nan argument that is used later on by ice_vsi_assign_bpf_prog(), same\nbpf_prog pointers are swapped with each other. Then it is also\ninterpreted as an 'old_prog' which in turn causes us to call\nbpf_prog_put on it that will decrement its refcount.\n\nBelow splat can be interpreted in a way that due to zero refcount of a\nbpf_prog it is wiped out from the system while kernel still tries to\nrefer to it:\n\n[  481.069429] BUG: unable to handle page fault for address: ffffc9000640f038\n[  481.077390] #PF: supervisor read access in kernel mode\n[  481.083335] #PF: error_code(0x0000) - not-present page\n[  481.089276] PGD 100000067 P4D 100000067 PUD 1001cb067 PMD 106d2b067 PTE 0\n[  481.097141] Oops: 0000 [#1] PREEMPT SMP PTI\n[  481.101980] CPU: 12 PID: 3339 Comm: sudo Tainted: G           OE     5.15.0-rc5+ #1\n[  481.110840] Hardware name: Intel Corp. GRANTLEY/GRANTLEY, BIOS GRRFCRB1.86B.0276.D07.1605190235 05/19/2016\n[  481.122021] RIP: 0010:dev_xdp_prog_id+0x25/0x40\n[  481.127265] Code: 80 00 00 00 00 0f 1f 44 00 00 89 f6 48 c1 e6 04 48 01 fe 48 8b 86 98 08 00 00 48 85 c0 74 13 48 8b 50 18 31 c0 48 85 d2 74 07 <48> 8b 42 38 8b 40 20 c3 48 8b 96 90 08 00 00 eb e8 66 2e 0f 1f 84\n[  481.148991] RSP: 0018:ffffc90007b63868 EFLAGS: 00010286\n[  481.155034] RAX: 0000000000000000 RBX: ffff889080824000 RCX: 0000000000000000\n[  481.163278] RDX: ffffc9000640f000 RSI: ffff889080824010 RDI: ffff889080824000\n[  481.171527] RBP: ffff888107af7d00 R08: 0000000000000000 R09: ffff88810db5f6e0\n[  481.179776] R10: 0000000000000000 R11: ffff8890885b9988 R12: ffff88810db5f4bc\n[  481.188026] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[  481.196276] FS:  00007f5466d5bec0(0000) GS:ffff88903fb00000(0000) knlGS:0000000000000000\n[  481.205633] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  481.212279] CR2: ffffc9000640f038 CR3: 000000014429c006 CR4: 00000000003706e0\n[  481.220530] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  481.228771] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  481.237029] Call Trace:\n[  481.239856]  rtnl_fill_ifinfo+0x768/0x12e0\n[  481.244602]  rtnl_dump_ifinfo+0x525/0x650\n[  481.249246]  ? __alloc_skb+0xa5/0x280\n[  481.253484]  netlink_dump+0x168/0x3c0\n[  481.257725]  netlink_recvmsg+0x21e/0x3e0\n[  481.262263]  ____sys_recvmsg+0x87/0x170\n[  481.266707]  ? __might_fault+0x20/0x30\n[  481.271046]  ? _copy_from_user+0x66/0xa0\n[  481.275591]  ? iovec_from_user+0xf6/0x1c0\n[  481.280226]  ___sys_recvmsg+0x82/0x100\n[  481.284566]  ? sock_sendmsg+0x5e/0x60\n[  481.288791]  ? __sys_sendto+0xee/0x150\n[  481.293129]  __sys_recvmsg+0x56/0xa0\n[  481.297267]  do_syscall_64+0x3b/0xc0\n[  481.301395]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  481.307238] RIP: 0033:0x7f5466f39617\n[  481.311373] Code: 0c 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb bd 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2f 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 89 74 24 10\n[  481.342944] RSP: 002b:00007ffedc7f4308 EFLAGS: 00000246 ORIG_RAX: 000000000000002f\n[  481.361783] RAX: ffffffffffffffda RBX: 00007ffedc7f5460 RCX: 00007f5466f39617\n[  481.380278] RDX: 0000000000000000 RSI: 00007ffedc7f5360 RDI: 0000000000000003\n[  481.398500] RBP: 00007ffedc7f53f0 R08: 0000000000000000 R09: 000055d556f04d50\n[  481.416463] R10: 0000000000000077 R11: 0000000000000246 R12: 00007ffedc7f5360\n[  481.434131] R13: 00007ffedc7f5350 R14: 00007ffedc7f5344 R15: 0000000000000e98\n[  481.451520] Modules linked in: ice\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47563",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-04-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48862",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvhost: fix hung thread due to erroneous iotlb entries\n\nIn vhost_iotlb_add_range_ctx(), range size can overflow to 0 when\nstart is 0 and last is ULONG_MAX. One instance where it can happen\nis when userspace sends an IOTLB message with iova=size=uaddr=0\n(vhost_process_iotlb_msg). So, an entry with size = 0, start = 0,\nlast = ULONG_MAX ends up in the iotlb. Next time a packet is sent,\niotlb_access_ok() loops indefinitely due to that erroneous entry.\n\n\tCall Trace:\n\t <TASK>\n\t iotlb_access_ok+0x21b/0x3e0 drivers/vhost/vhost.c:1340\n\t vq_meta_prefetch+0xbc/0x280 drivers/vhost/vhost.c:1366\n\t vhost_transport_do_send_pkt+0xe0/0xfd0 drivers/vhost/vsock.c:104\n\t vhost_worker+0x23d/0x3d0 drivers/vhost/vhost.c:372\n\t kthread+0x2e9/0x3a0 kernel/kthread.c:377\n\t ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295\n\t </TASK>\n\nReported by syzbot at:\n\thttps://syzkaller.appspot.com/bug?extid=0abd373e2e50d704db87\n\nTo fix this, do two things:\n\n1. Return -EINVAL in vhost_chr_write_iter() when userspace asks to map\n   a range with size 0.\n2. Fix vhost_iotlb_add_range_ctx() to handle the range [0, ULONG_MAX]\n   by splitting it into two entries.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48862",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48841",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix NULL pointer dereference in ice_update_vsi_tx_ring_stats()\n\nIt is possible to do NULL pointer dereference in routine that updates\nTx ring stats. Currently only stats and bytes are updated when ring\npointer is valid, but later on ring is accessed to propagate gathered Tx\nstats onto VSI stats.\n\nChange the existing logic to move to next ring when ring is NULL.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48841",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49052",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: fix unexpected zeroed page mapping with zram swap\n\nTwo processes under CLONE_VM cloning, user process can be corrupted by\nseeing zeroed page unexpectedly.\n\n      CPU A                        CPU B\n\n  do_swap_page                do_swap_page\n  SWP_SYNCHRONOUS_IO path     SWP_SYNCHRONOUS_IO path\n  swap_readpage valid data\n    swap_slot_free_notify\n      delete zram entry\n                              swap_readpage zeroed(invalid) data\n                              pte_lock\n                              map the *zero data* to userspace\n                              pte_unlock\n  pte_lock\n  if (!pte_same)\n    goto out_nomap;\n  pte_unlock\n  return and next refault will\n  read zeroed data\n\nThe swap_slot_free_notify is bogus for CLONE_VM case since it doesn't\nincrease the refcount of swap slot at copy_mm so it couldn't catch up\nwhether it's safe or not to discard data from backing device.  In the\ncase, only the lock it could rely on to synchronize swap slot freeing is\npage table lock.  Thus, this patch gets rid of the swap_slot_free_notify\nfunction.  With this patch, CPU A will see correct data.\n\n      CPU A                        CPU B\n\n  do_swap_page                do_swap_page\n  SWP_SYNCHRONOUS_IO path     SWP_SYNCHRONOUS_IO path\n                              swap_readpage original data\n                              pte_lock\n                              map the original data\n                              swap_free\n                                swap_range_free\n                                  bd_disk->fops->swap_slot_free_notify\n  swap_readpage read zeroed data\n                              pte_unlock\n  pte_lock\n  if (!pte_same)\n    goto out_nomap;\n  pte_unlock\n  return\n  on next refault will see mapped data by CPU B\n\nThe concern of the patch would increase memory consumption since it\ncould keep wasted memory with compressed form in zram as well as\nuncompressed form in address space.  However, most of cases of zram uses\nno readahead and do_swap_page is followed by swap_free so it will free\nthe compressed form from in zram quickly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49052",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38436",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/scheduler: signal scheduled fence when kill job\n\nWhen an entity from application B is killed, drm_sched_entity_kill()\nremoves all jobs belonging to that entity through\ndrm_sched_entity_kill_jobs_work(). If application A's job depends on a\nscheduled fence from application B's job, and that fence is not properly\nsignaled during the killing process, application A's dependency cannot be\ncleared.\n\nThis leads to application A hanging indefinitely while waiting for a\ndependency that will never be resolved. Fix this issue by ensuring that\nscheduled fences are properly signaled when an entity is killed, allowing\ndependent applications to continue execution.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38436",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-11-19",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40030",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: check the return value of pinmux_ops::get_function_name()\n\nWhile the API contract in docs doesn't specify it explicitly, the\ngeneric implementation of the get_function_name() callback from struct\npinmux_ops - pinmux_generic_get_function_name() - can fail and return\nNULL. This is already checked in pinmux_check_ops() so add a similar\ncheck in pinmux_func_name_to_selector() instead of passing the returned\npointer right down to strcmp() where the NULL can get dereferenced. This\nis normal operation when adding new pinfunctions.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38430",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: nfsd4_spo_must_allow() must check this is a v4 compound request\n\nIf the request being processed is not a v4 compound request, then\nexamining the cstate can have undefined results.\n\nThis patch adds a check that the rpc procedure being executed\n(rq_procinfo) is the NFSPROC4_COMPOUND procedure.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38430",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68229",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: tcm_loop: Fix segfault in tcm_loop_tpg_address_show()\n\nIf the allocation of tl_hba->sh fails in tcm_loop_driver_probe() and we\nattempt to dereference it in tcm_loop_tpg_address_show() we will get a\nsegfault, see below for an example. So, check tl_hba->sh before\ndereferencing it.\n\n  Unable to allocate struct scsi_host\n  BUG: kernel NULL pointer dereference, address: 0000000000000194\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 1 PID: 8356 Comm: tokio-runtime-w Not tainted 6.6.104.2-4.azl3 #1\n  Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 09/28/2024\n  RIP: 0010:tcm_loop_tpg_address_show+0x2e/0x50 [tcm_loop]\n...\n  Call Trace:\n   <TASK>\n   configfs_read_iter+0x12d/0x1d0 [configfs]\n   vfs_read+0x1b5/0x300\n   ksys_read+0x6f/0xf0\n...",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38399",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: Fix NULL pointer dereference in core_scsi3_decode_spec_i_port()\n\nThe function core_scsi3_decode_spec_i_port(), in its error code path,\nunconditionally calls core_scsi3_lunacl_undepend_item() passing the\ndest_se_deve pointer, which may be NULL.\n\nThis can lead to a NULL pointer dereference if dest_se_deve remains\nunset.\n\nSPC-3 PR SPEC_I_PT: Unable to locate dest_tpg\nUnable to handle kernel paging request at virtual address dfff800000000012\nCall trace:\n  core_scsi3_lunacl_undepend_item+0x2c/0xf0 [target_core_mod] (P)\n  core_scsi3_decode_spec_i_port+0x120c/0x1c30 [target_core_mod]\n  core_scsi3_emulate_pro_register+0x6b8/0xcd8 [target_core_mod]\n  target_scsi3_emulate_pr_out+0x56c/0x840 [target_core_mod]\n\nFix this by adding a NULL check before calling\ncore_scsi3_lunacl_undepend_item()",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38399",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48835",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpt3sas: Page fault in reply q processing\n\nA page fault was encountered in mpt3sas on a LUN reset error path:\n\n[  145.763216] mpt3sas_cm1: Task abort tm failed: handle(0x0002),timeout(30) tr_method(0x0) smid(3) msix_index(0)\n[  145.778932] scsi 1:0:0:0: task abort: FAILED scmd(0x0000000024ba29a2)\n[  145.817307] scsi 1:0:0:0: attempting device reset! scmd(0x0000000024ba29a2)\n[  145.827253] scsi 1:0:0:0: [sg1] tag#2 CDB: Receive Diagnostic 1c 01 01 ff fc 00\n[  145.837617] scsi target1:0:0: handle(0x0002), sas_address(0x500605b0000272b9), phy(0)\n[  145.848598] scsi target1:0:0: enclosure logical id(0x500605b0000272b8), slot(0)\n[  149.858378] mpt3sas_cm1: Poll ReplyDescriptor queues for completion of smid(0), task_type(0x05), handle(0x0002)\n[  149.875202] BUG: unable to handle page fault for address: 00000007fffc445d\n[  149.885617] #PF: supervisor read access in kernel mode\n[  149.894346] #PF: error_code(0x0000) - not-present page\n[  149.903123] PGD 0 P4D 0\n[  149.909387] Oops: 0000 [#1] PREEMPT SMP NOPTI\n[  149.917417] CPU: 24 PID: 3512 Comm: scsi_eh_1 Kdump: loaded Tainted: G S         O      5.10.89-altav-1 #1\n[  149.934327] Hardware name: DDN           200NVX2             /200NVX2-MB          , BIOS ATHG2.2.02.01 09/10/2021\n[  149.951871] RIP: 0010:_base_process_reply_queue+0x4b/0x900 [mpt3sas]\n[  149.961889] Code: 0f 84 22 02 00 00 8d 48 01 49 89 fd 48 8d 57 38 f0 0f b1 4f 38 0f 85 d8 01 00 00 49 8b 45 10 45 31 e4 41 8b 55 0c 48 8d 1c d0 <0f> b6 03 83 e0 0f 3c 0f 0f 85 a2 00 00 00 e9 e6 01 00 00 0f b7 ee\n[  149.991952] RSP: 0018:ffffc9000f1ebcb8 EFLAGS: 00010246\n[  150.000937] RAX: 0000000000000055 RBX: 00000007fffc445d RCX: 000000002548f071\n[  150.011841] RDX: 00000000ffff8881 RSI: 0000000000000001 RDI: ffff888125ed50d8\n[  150.022670] RBP: 0000000000000000 R08: 0000000000000000 R09: c0000000ffff7fff\n[  150.033445] R10: ffffc9000f1ebb68 R11: ffffc9000f1ebb60 R12: 0000000000000000\n[  150.044204] R13: ffff888125ed50d8 R14: 0000000000000080 R15: 34cdc00034cdea80\n[  150.054963] FS:  0000000000000000(0000) GS:ffff88dfaf200000(0000) knlGS:0000000000000000\n[  150.066715] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  150.076078] CR2: 00000007fffc445d CR3: 000000012448a006 CR4: 0000000000770ee0\n[  150.086887] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  150.097670] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  150.108323] PKRU: 55555554\n[  150.114690] Call Trace:\n[  150.120497]  ? printk+0x48/0x4a\n[  150.127049]  mpt3sas_scsih_issue_tm.cold.114+0x2e/0x2b3 [mpt3sas]\n[  150.136453]  mpt3sas_scsih_issue_locked_tm+0x86/0xb0 [mpt3sas]\n[  150.145759]  scsih_dev_reset+0xea/0x300 [mpt3sas]\n[  150.153891]  scsi_eh_ready_devs+0x541/0x9e0 [scsi_mod]\n[  150.162206]  ? __scsi_host_match+0x20/0x20 [scsi_mod]\n[  150.170406]  ? scsi_try_target_reset+0x90/0x90 [scsi_mod]\n[  150.178925]  ? blk_mq_tagset_busy_iter+0x45/0x60\n[  150.186638]  ? scsi_try_target_reset+0x90/0x90 [scsi_mod]\n[  150.195087]  scsi_error_handler+0x3a5/0x4a0 [scsi_mod]\n[  150.203206]  ? __schedule+0x1e9/0x610\n[  150.209783]  ? scsi_eh_get_sense+0x210/0x210 [scsi_mod]\n[  150.217924]  kthread+0x12e/0x150\n[  150.224041]  ? kthread_worker_fn+0x130/0x130\n[  150.231206]  ret_from_fork+0x1f/0x30\n\nThis is caused by mpt3sas_base_sync_reply_irqs() using an invalid reply_q\npointer outside of the list_for_each_entry() loop. At the end of the full\nlist traversal the pointer is invalid.\n\nMove the _base_process_reply_queue() call inside of the loop.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48835",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40362",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: fix multifs mds auth caps issue\n\nThe mds auth caps check should also validate the\nfsname along with the associated caps. Not doing\nso would result in applying the mds auth caps of\none fs on to the other fs in a multifs ceph cluster.\nThe bug causes multiple issues w.r.t user\nauthentication, following is one such example.\n\nSteps to Reproduce (on vstart cluster):\n1. Create two file systems in a cluster, say 'fsname1' and 'fsname2'\n2. Authorize read only permission to the user 'client.usr' on fs 'fsname1'\n    $ceph fs authorize fsname1 client.usr / r\n3. Authorize read and write permission to the same user 'client.usr' on fs 'fsname2'\n    $ceph fs authorize fsname2 client.usr / rw\n4. Update the keyring\n    $ceph auth get client.usr >> ./keyring\n\nWith above permssions for the user 'client.usr', following is the\nexpectation.\n  a. The 'client.usr' should be able to only read the contents\n     and not allowed to create or delete files on file system 'fsname1'.\n  b. The 'client.usr' should be able to read/write on file system 'fsname2'.\n\nBut, with this bug, the 'client.usr' is allowed to read/write on file\nsystem 'fsname1'. See below.\n\n5. Mount the file system 'fsname1' with the user 'client.usr'\n     $sudo bin/mount.ceph usr@.fsname1=/ /kmnt_fsname1_usr/\n6. Try creating a file on file system 'fsname1' with user 'client.usr'. This\n   should fail but passes with this bug.\n     $touch /kmnt_fsname1_usr/file1\n7. Mount the file system 'fsname1' with the user 'client.admin' and create a\n   file.\n     $sudo bin/mount.ceph admin@.fsname1=/ /kmnt_fsname1_admin\n     $echo \"data\" > /kmnt_fsname1_admin/admin_file1\n8. Try removing an existing file on file system 'fsname1' with the user\n   'client.usr'. This shoudn't succeed but succeeds with the bug.\n     $rm -f /kmnt_fsname1_usr/admin_file1\n\nFor more information, please take a look at the corresponding mds/fuse patch\nand tests added by looking into the tracker mentioned below.\n\nv2: Fix a possible null dereference in doutc\nv3: Don't store fsname from mdsmap, validate against\n    ceph_mount_options's fsname and use it\nv4: Code refactor, better warning message and\n    fix possible compiler warning\n\n[ Slava.Dubeyko: \"fsname check failed\" -> \"fsname mismatch\" ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49100",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_console: eliminate anonymous module_init & module_exit\n\nEliminate anonymous module_init() and module_exit(), which can lead to\nconfusion or ambiguity when reading System.map, crashes/oops/bugs,\nor an initcall_debug log.\n\nGive each of these init and exit functions unique driver-specific\nnames to eliminate the anonymous names.\n\nExample 1: (System.map)\n ffffffff832fc78c t init\n ffffffff832fc79e t init\n ffffffff832fc8f8 t init\n\nExample 2: (initcall_debug log)\n calling  init+0x0/0x12 @ 1\n initcall init+0x0/0x12 returned 0 after 15 usecs\n calling  init+0x0/0x60 @ 1\n initcall init+0x0/0x60 returned 0 after 2 usecs\n calling  init+0x0/0x9a @ 1\n initcall init+0x0/0x9a returned 0 after 74 usecs",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49100",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48875",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: sdata can be NULL during AMPDU start\n\nieee80211_tx_ba_session_handle_start() may get NULL for sdata when a\ndeauthentication is ongoing.\n\nHere a trace triggering the race with the hostapd test\nmulti_ap_fronthaul_on_ap:\n\n(gdb) list *drv_ampdu_action+0x46\n0x8b16 is in drv_ampdu_action (net/mac80211/driver-ops.c:396).\n391             int ret = -EOPNOTSUPP;\n392\n393             might_sleep();\n394\n395             sdata = get_bss_sdata(sdata);\n396             if (!check_sdata_in_driver(sdata))\n397                     return -EIO;\n398\n399             trace_drv_ampdu_action(local, sdata, params);\n400\n\nwlan0: moving STA 02:00:00:00:03:00 to state 3\nwlan0: associated\nwlan0: deauthenticating from 02:00:00:00:03:00 by local choice (Reason: 3=DEAUTH_LEAVING)\nwlan3.sta1: Open BA session requested for 02:00:00:00:00:00 tid 0\nwlan3.sta1: dropped frame to 02:00:00:00:00:00 (unauthorized port)\nwlan0: moving STA 02:00:00:00:03:00 to state 2\nwlan0: moving STA 02:00:00:00:03:00 to state 1\nwlan0: Removed STA 02:00:00:00:03:00\nwlan0: Destroyed STA 02:00:00:00:03:00\nBUG: unable to handle page fault for address: fffffffffffffb48\nPGD 11814067 P4D 11814067 PUD 11816067 PMD 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 2 PID: 133397 Comm: kworker/u16:1 Tainted: G        W          6.1.0-rc8-wt+ #59\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014\nWorkqueue: phy3 ieee80211_ba_session_work [mac80211]\nRIP: 0010:drv_ampdu_action+0x46/0x280 [mac80211]\nCode: 53 48 89 f3 be 89 01 00 00 e8 d6 43 bf ef e8 21 46 81 f0 83 bb a0 1b 00 00 04 75 0e 48 8b 9b 28 0d 00 00 48 81 eb 10 0e 00 00 <8b> 93 58 09 00 00 f6 c2 20 0f 84 3b 01 00 00 8b 05 dd 1c 0f 00 85\nRSP: 0018:ffffc900025ebd20 EFLAGS: 00010287\nRAX: 0000000000000000 RBX: fffffffffffff1f0 RCX: ffff888102228240\nRDX: 0000000080000000 RSI: ffffffff918c5de0 RDI: ffff888102228b40\nRBP: ffffc900025ebd40 R08: 0000000000000001 R09: 0000000000000001\nR10: 0000000000000001 R11: 0000000000000000 R12: ffff888118c18ec0\nR13: 0000000000000000 R14: ffffc900025ebd60 R15: ffff888018b7efb8\nFS:  0000000000000000(0000) GS:ffff88817a600000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: fffffffffffffb48 CR3: 0000000105228006 CR4: 0000000000170ee0\nCall Trace:\n <TASK>\n ieee80211_tx_ba_session_handle_start+0xd0/0x190 [mac80211]\n ieee80211_ba_session_work+0xff/0x2e0 [mac80211]\n process_one_work+0x29f/0x620\n worker_thread+0x4d/0x3d0\n ? process_one_work+0x620/0x620\n kthread+0xfb/0x120\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x22/0x30\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48875",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-21",
                    "modification_date": "2024-09-04",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40231",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: fix lock inversion in vsock_assign_transport()\n\nSyzbot reported a potential lock inversion deadlock between\nvsock_register_mutex and sk_lock-AF_VSOCK when vsock_linger() is called.\n\nThe issue was introduced by commit 687aa0c5581b (\"vsock: Fix\ntransport_* TOCTOU\") which added vsock_register_mutex locking in\nvsock_assign_transport() around the transport->release() call, that can\ncall vsock_linger(). vsock_assign_transport() can be called with sk_lock\nheld. vsock_linger() calls sk_wait_event() that temporarily releases and\nre-acquires sk_lock. During this window, if another thread hold\nvsock_register_mutex while trying to acquire sk_lock, a circular\ndependency is created.\n\nFix this by releasing vsock_register_mutex before calling\ntransport->release() and vsock_deassign_transport(). This is safe\nbecause we don't need to hold vsock_register_mutex while releasing the\nold transport, and we ensure the new transport won't disappear by\nobtaining a module reference first via try_module_get().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-04",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-34693",
                    "description": "net/can/bcm.c in the Linux kernel through 5.12.10 allows local users to obtain sensitive information from kernel stack memory because parts of a data structure are uninitialized.",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-34693",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-06-14",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38695",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Check for hdwq null ptr when cleaning up lpfc_vport structure\n\nIf a call to lpfc_sli4_read_rev() from lpfc_sli4_hba_setup() fails, the\nresultant cleanup routine lpfc_sli4_vport_delete_fcp_xri_aborted() may\noccur before sli4_hba.hdwqs are allocated.  This may result in a null\npointer dereference when attempting to take the abts_io_buf_list_lock for\nthe first hardware queue.  Fix by adding a null ptr check on\nphba->sli4_hba.hdwq and early return because this situation means there\nmust have been an error during port initialization.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38695",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48915",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nthermal: core: Fix TZ_GET_TRIP NULL pointer dereference\n\nDo not call get_trip_hyst() from thermal_genl_cmd_tz_get_trip() if\nthe thermal zone does not define one.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48915",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-08-27",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38700",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: libiscsi: Initialize iscsi_conn->dd_data only if memory is allocated\n\nIn case of an ib_fast_reg_mr allocation failure during iSER setup, the\nmachine hits a panic because iscsi_conn->dd_data is initialized\nunconditionally, even when no memory is allocated (dd_size == 0).  This\nleads invalid pointer dereference during connection teardown.\n\nFix by setting iscsi_conn->dd_data only if memory is actually allocated.\n\nPanic trace:\n------------\n iser: iser_create_fastreg_desc: Failed to allocate ib_fast_reg_mr err=-12\n iser: iser_alloc_rx_descriptors: failed allocating rx descriptors / data buffers\n BUG: unable to handle page fault for address: fffffffffffffff8\n RIP: 0010:swake_up_locked.part.5+0xa/0x40\n Call Trace:\n  complete+0x31/0x40\n  iscsi_iser_conn_stop+0x88/0xb0 [ib_iser]\n  iscsi_stop_conn+0x66/0xc0 [scsi_transport_iscsi]\n  iscsi_if_stop_conn+0x14a/0x150 [scsi_transport_iscsi]\n  iscsi_if_rx+0x1135/0x1834 [scsi_transport_iscsi]\n  ? netlink_lookup+0x12f/0x1b0\n  ? netlink_deliver_tap+0x2c/0x200\n  netlink_unicast+0x1ab/0x280\n  netlink_sendmsg+0x257/0x4f0\n  ? _copy_from_user+0x29/0x60\n  sock_sendmsg+0x5f/0x70",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38700",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49028",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nixgbevf: Fix resource leak in ixgbevf_init_module()\n\nixgbevf_init_module() won't destroy the workqueue created by\ncreate_singlethread_workqueue() when pci_register_driver() failed. Add\ndestroy_workqueue() in fail path to prevent the resource leak.\n\nSimilar to the handling of u132_hcd_init in commit f276e002793c\n(\"usb: u132-hcd: fix resource leak\")",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49028",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48994",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: seq: Fix function prototype mismatch in snd_seq_expand_var_event\n\nWith clang's kernel control flow integrity (kCFI, CONFIG_CFI_CLANG),\nindirect call targets are validated against the expected function\npointer prototype to make sure the call target is valid to help mitigate\nROP attacks. If they are not identical, there is a failure at run time,\nwhich manifests as either a kernel panic or thread getting killed.\n\nseq_copy_in_user() and seq_copy_in_kernel() did not have prototypes\nmatching snd_seq_dump_func_t. Adjust this and remove the casts. There\nare not resulting binary output differences.\n\nThis was found as a result of Clang's new -Wcast-function-type-strict\nflag, which is more sensitive than the simpler -Wcast-function-type,\nwhich only checks for type width mismatches.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48994",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-11-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38468",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Return NULL when htb_lookup_leaf encounters an empty rbtree\n\nhtb_lookup_leaf has a BUG_ON that can trigger with the following:\n\ntc qdisc del dev lo root\ntc qdisc add dev lo root handle 1: htb default 1\ntc class add dev lo parent 1: classid 1:1 htb rate 64bit\ntc qdisc add dev lo parent 1:1 handle 2: netem\ntc qdisc add dev lo parent 2:1 handle 3: blackhole\nping -I lo -c1 -W0.001 127.0.0.1\n\nThe root cause is the following:\n\n1. htb_dequeue calls htb_dequeue_tree which calls the dequeue handler on\n   the selected leaf qdisc\n2. netem_dequeue calls enqueue on the child qdisc\n3. blackhole_enqueue drops the packet and returns a value that is not\n   just NET_XMIT_SUCCESS\n4. Because of this, netem_dequeue calls qdisc_tree_reduce_backlog, and\n   since qlen is now 0, it calls htb_qlen_notify -> htb_deactivate ->\n   htb_deactiviate_prios -> htb_remove_class_from_row -> htb_safe_rb_erase\n5. As this is the only class in the selected hprio rbtree,\n   __rb_change_child in __rb_erase_augmented sets the rb_root pointer to\n   NULL\n6. Because blackhole_dequeue returns NULL, netem_dequeue returns NULL,\n   which causes htb_dequeue_tree to call htb_lookup_leaf with the same\n   hprio rbtree, and fail the BUG_ON\n\nThe function graph for this scenario is shown here:\n 0)               |  htb_enqueue() {\n 0) + 13.635 us   |    netem_enqueue();\n 0)   4.719 us    |    htb_activate_prios();\n 0) # 2249.199 us |  }\n 0)               |  htb_dequeue() {\n 0)   2.355 us    |    htb_lookup_leaf();\n 0)               |    netem_dequeue() {\n 0) + 11.061 us   |      blackhole_enqueue();\n 0)               |      qdisc_tree_reduce_backlog() {\n 0)               |        qdisc_lookup_rcu() {\n 0)   1.873 us    |          qdisc_match_from_root();\n 0)   6.292 us    |        }\n 0)   1.894 us    |        htb_search();\n 0)               |        htb_qlen_notify() {\n 0)   2.655 us    |          htb_deactivate_prios();\n 0)   6.933 us    |        }\n 0) + 25.227 us   |      }\n 0)   1.983 us    |      blackhole_dequeue();\n 0) + 86.553 us   |    }\n 0) # 2932.761 us |    qdisc_warn_nonwc();\n 0)               |    htb_lookup_leaf() {\n 0)               |      BUG_ON();\n ------------------------------------------\n\nThe full original bug report can be seen here [1].\n\nWe can fix this just by returning NULL instead of the BUG_ON,\nas htb_dequeue_tree returns NULL when htb_lookup_leaf returns\nNULL.\n\n[1] https://lore.kernel.org/netdev/pF5XOOIim0IuEfhI-SOxTgRvNoDwuux7UHKnE_Y5-zVd4wmGvNk2ceHjKb8ORnzw0cGwfmVu42g9dL7XyJLf1NEzaztboTWcm0Ogxuojoeo=@willsroot.io/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38468",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-28",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47036",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nudp: skip L4 aggregation for UDP tunnel packets\n\nIf NETIF_F_GRO_FRAGLIST or NETIF_F_GRO_UDP_FWD are enabled, and there\nare UDP tunnels available in the system, udp_gro_receive() could end-up\ndoing L4 aggregation (either SKB_GSO_UDP_L4 or SKB_GSO_FRAGLIST) at\nthe outer UDP tunnel level for packets effectively carrying and UDP\ntunnel header.\n\nThat could cause inner protocol corruption. If e.g. the relevant\npackets carry a vxlan header, different vxlan ids will be ignored/\naggregated to the same GSO packet. Inner headers will be ignored, too,\nso that e.g. TCP over vxlan push packets will be held in the GRO\nengine till the next flush, etc.\n\nJust skip the SKB_GSO_UDP_L4 and SKB_GSO_FRAGLIST code path if the\ncurrent packet could land in a UDP tunnel, and let udp_gro_receive()\ndo GRO via udp_sk(sk)->gro_receive.\n\nThe check implemented in this patch is broader than what is strictly\nneeded, as the existing UDP tunnel could be e.g. configured on top of\na different device: we could end-up skipping GRO at-all for some packets.\n\nAnyhow, that is a very thin corner case and covering it will add quite\na bit of complexity.\n\nv1 -> v2:\n - hopefully clarify the commit message",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47036",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53450",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: remove a BUG_ON in ext4_mb_release_group_pa()\n\nIf a malicious fuzzer overwrites the ext4 superblock while it is\nmounted such that the s_first_data_block is set to a very large\nnumber, the calculation of the block group can underflow, and trigger\na BUG_ON check.  Change this to be an ext4_warning so that we don't\ncrash the kernel.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-01",
                    "modification_date": "2025-10-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-38646",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: avoid NULL dereference when RX problematic packet on unsupported 6 GHz band\n\nWith a quite rare chance, RX report might be problematic to make SW think\na packet is received on 6 GHz band even if the chip does not support 6 GHz\nband actually. Since SW won't initialize stuffs for unsupported bands, NULL\ndereference will happen then in the sequence, rtw89_vif_rx_stats_iter() ->\nrtw89_core_cancel_6ghz_probe_tx(). So, add a check to avoid it.\n\nThe following is a crash log for this case.\n\n BUG: kernel NULL pointer dereference, address: 0000000000000032\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 1 PID: 1907 Comm: irq/131-rtw89_p Tainted: G     U             6.6.56-05896-g89f5fb0eb30b #1 (HASH:1400 4)\n Hardware name: Google Telith/Telith, BIOS Google_Telith.15217.747.0 11/12/2024\n RIP: 0010:rtw89_vif_rx_stats_iter+0xd2/0x310 [rtw89_core]\n Code: 4c 89 7d c8 48 89 55 c0 49 8d 44 24 02 48 89 45 b8 45 31 ff eb 11\n 41 c6 45 3a 01 41 b7 01 4d 8b 6d 00 4d 39 f5 74 42 8b 43 10 <41> 33 45\n 32 0f b7 4b 14 66 41 33 4d 36 0f b7 c9 09 c1 74 d8 4d 85\n RSP: 0018:ffff9f3080138ca0 EFLAGS: 00010246\n RAX: 00000000b8bf5770 RBX: ffff91b5e8c639c0 RCX: 0000000000000011\n RDX: ffff91b582de1be8 RSI: 0000000000000000 RDI: ffff91b5e8c639e6\n RBP: ffff9f3080138d00 R08: 0000000000000000 R09: 0000000000000000\n R10: ffff91b59de70000 R11: ffffffffc069be50 R12: ffff91b5e8c639e4\n R13: 0000000000000000 R14: ffff91b5828020b8 R15: 0000000000000000\n FS:  0000000000000000(0000) GS:ffff91b8efa40000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000032 CR3: 00000002bf838000 CR4: 0000000000750ee0\n PKRU: 55555554\n Call Trace:\n  <IRQ>\n  ? __die_body+0x68/0xb0\n  ? page_fault_oops+0x379/0x3e0\n  ? exc_page_fault+0x4f/0xa0\n  ? asm_exc_page_fault+0x22/0x30\n  ? __pfx_rtw89_vif_rx_stats_iter+0x10/0x10 [rtw89_core (HASH:1400 5)]\n  ? rtw89_vif_rx_stats_iter+0xd2/0x310 [rtw89_core (HASH:1400 5)]\n  __iterate_interfaces+0x59/0x110 [mac80211 (HASH:1400 6)]\n  ? __pfx_rtw89_vif_rx_stats_iter+0x10/0x10 [rtw89_core (HASH:1400 5)]\n  ? __pfx_rtw89_vif_rx_stats_iter+0x10/0x10 [rtw89_core (HASH:1400 5)]\n  ieee80211_iterate_active_interfaces_atomic+0x36/0x50 [mac80211 (HASH:1400 6)]\n  rtw89_core_rx_to_mac80211+0xfd/0x1b0 [rtw89_core (HASH:1400 5)]\n  rtw89_core_rx+0x43a/0x980 [rtw89_core (HASH:1400 5)]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38646",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2025-11-26",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47421",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: handle the case of pci_channel_io_frozen only in amdgpu_pci_resume\n\nIn current code, when a PCI error state pci_channel_io_normal is detectd,\nit will report PCI_ERS_RESULT_CAN_RECOVER status to PCI driver, and PCI\ndriver will continue the execution of PCI resume callback report_resume by\npci_walk_bridge, and the callback will go into amdgpu_pci_resume\nfinally, where write lock is releasd unconditionally without acquiring\nsuch lock first. In this case, a deadlock will happen when other threads\nstart to acquire the read lock.\n\nTo fix this, add a member in amdgpu_device strucutre to cache\npci_channel_state, and only continue the execution in amdgpu_pci_resume\nwhen it's pci_channel_io_frozen.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47421",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39889",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: l2cap: Check encryption key size on incoming connection\n\nThis is required for passing GAP/SEC/SEM/BI-04-C PTS test case:\n  Security Mode 4 Level 4, Responder - Invalid Encryption Key Size\n  - 128 bit\n\nThis tests the security key with size from 1 to 15 bytes while the\nSecurity Mode 4 Level 4 requests 16 bytes key size.\n\nCurrently PTS fails with the following logs:\n- expected:Connection Response:\n    Code: [3 (0x03)] Code\n    Identifier: (lt)WildCard: Exists(gt)\n    Length: [8 (0x0008)]\n    Destination CID: (lt)WildCard: Exists(gt)\n    Source CID: [64 (0x0040)]\n    Result: [3 (0x0003)] Connection refused - Security block\n    Status: (lt)WildCard: Exists(gt),\nbut received:Connection Response:\n    Code: [3 (0x03)] Code\n    Identifier: [1 (0x01)]\n    Length: [8 (0x0008)]\n    Destination CID: [64 (0x0040)]\n    Source CID: [64 (0x0040)]\n    Result: [0 (0x0000)] Connection Successful\n    Status: [0 (0x0000)] No further information available\n\nAnd HCI logs:\n< HCI Command: Read Encrypti.. (0x05|0x0008) plen 2\n        Handle: 14 Address: 00:1B:DC:F2:24:10 (Vencer Co., Ltd.)\n> HCI Event: Command Complete (0x0e) plen 7\n      Read Encryption Key Size (0x05|0x0008) ncmd 1\n        Status: Success (0x00)\n        Handle: 14 Address: 00:1B:DC:F2:24:10 (Vencer Co., Ltd.)\n        Key size: 7\n> ACL Data RX: Handle 14 flags 0x02 dlen 12\n      L2CAP: Connection Request (0x02) ident 1 len 4\n        PSM: 4097 (0x1001)\n        Source CID: 64\n< ACL Data TX: Handle 14 flags 0x00 dlen 16\n      L2CAP: Connection Response (0x03) ident 1 len 8\n        Destination CID: 64\n        Source CID: 64\n        Result: Connection successful (0x0000)\n        Status: No further information available (0x0000)",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39889",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-24",
                    "modification_date": "2025-12-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48687",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: sr: fix out-of-bounds read when setting HMAC data.\n\nThe SRv6 layer allows defining HMAC data that can later be used to sign IPv6\nSegment Routing Headers. This configuration is realised via netlink through\nfour attributes: SEG6_ATTR_HMACKEYID, SEG6_ATTR_SECRET, SEG6_ATTR_SECRETLEN and\nSEG6_ATTR_ALGID. Because the SECRETLEN attribute is decoupled from the actual\nlength of the SECRET attribute, it is possible to provide invalid combinations\n(e.g., secret = \"\", secretlen = 64). This case is not checked in the code and\nwith an appropriately crafted netlink message, an out-of-bounds read of up\nto 64 bytes (max secret length) can occur past the skb end pointer and into\nskb_shared_info:\n\nBreakpoint 1, seg6_genl_sethmac (skb=<optimized out>, info=<optimized out>) at net/ipv6/seg6.c:208\n208\t\tmemcpy(hinfo->secret, secret, slen);\n(gdb) bt\n #0  seg6_genl_sethmac (skb=<optimized out>, info=<optimized out>) at net/ipv6/seg6.c:208\n #1  0xffffffff81e012e9 in genl_family_rcv_msg_doit (skb=skb@entry=0xffff88800b1f9f00, nlh=nlh@entry=0xffff88800b1b7600,\n    extack=extack@entry=0xffffc90000ba7af0, ops=ops@entry=0xffffc90000ba7a80, hdrlen=4, net=0xffffffff84237580 <init_net>, family=<optimized out>,\n    family=<optimized out>) at net/netlink/genetlink.c:731\n #2  0xffffffff81e01435 in genl_family_rcv_msg (extack=0xffffc90000ba7af0, nlh=0xffff88800b1b7600, skb=0xffff88800b1f9f00,\n    family=0xffffffff82fef6c0 <seg6_genl_family>) at net/netlink/genetlink.c:775\n #3  genl_rcv_msg (skb=0xffff88800b1f9f00, nlh=0xffff88800b1b7600, extack=0xffffc90000ba7af0) at net/netlink/genetlink.c:792\n #4  0xffffffff81dfffc3 in netlink_rcv_skb (skb=skb@entry=0xffff88800b1f9f00, cb=cb@entry=0xffffffff81e01350 <genl_rcv_msg>)\n    at net/netlink/af_netlink.c:2501\n #5  0xffffffff81e00919 in genl_rcv (skb=0xffff88800b1f9f00) at net/netlink/genetlink.c:803\n #6  0xffffffff81dff6ae in netlink_unicast_kernel (ssk=0xffff888010eec800, skb=0xffff88800b1f9f00, sk=0xffff888004aed000)\n    at net/netlink/af_netlink.c:1319\n #7  netlink_unicast (ssk=ssk@entry=0xffff888010eec800, skb=skb@entry=0xffff88800b1f9f00, portid=portid@entry=0, nonblock=<optimized out>)\n    at net/netlink/af_netlink.c:1345\n #8  0xffffffff81dff9a4 in netlink_sendmsg (sock=<optimized out>, msg=0xffffc90000ba7e48, len=<optimized out>) at net/netlink/af_netlink.c:1921\n...\n(gdb) p/x ((struct sk_buff *)0xffff88800b1f9f00)->head + ((struct sk_buff *)0xffff88800b1f9f00)->end\n$1 = 0xffff88800b1b76c0\n(gdb) p/x secret\n$2 = 0xffff88800b1b76c0\n(gdb) p slen\n$3 = 64 '@'\n\nThe OOB data can then be read back from userspace by dumping HMAC state. This\ncommit fixes this by ensuring SECRETLEN cannot exceed the actual length of\nSECRET.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48687",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38444",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nraid10: cleanup memleak at raid10_make_request\n\nIf raid10_read_request or raid10_write_request registers a new\nrequest and the REQ_NOWAIT flag is set, the code does not\nfree the malloc from the mempool.\n\nunreferenced object 0xffff8884802c3200 (size 192):\n   comm \"fio\", pid 9197, jiffies 4298078271\n   hex dump (first 32 bytes):\n     00 00 00 00 00 00 00 00 88 41 02 00 00 00 00 00  .........A......\n     08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n   backtrace (crc c1a049a2):\n     __kmalloc+0x2bb/0x450\n     mempool_alloc+0x11b/0x320\n     raid10_make_request+0x19e/0x650 [raid10]\n     md_handle_request+0x3b3/0x9e0\n     __submit_bio+0x394/0x560\n     __submit_bio_noacct+0x145/0x530\n     submit_bio_noacct_nocheck+0x682/0x830\n     __blkdev_direct_IO_async+0x4dc/0x6b0\n     blkdev_read_iter+0x1e5/0x3b0\n     __io_read+0x230/0x1110\n     io_read+0x13/0x30\n     io_issue_sqe+0x134/0x1180\n     io_submit_sqes+0x48c/0xe90\n     __do_sys_io_uring_enter+0x574/0x8b0\n     do_syscall_64+0x5c/0xe0\n     entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nV4: changing backing tree to see if CKI tests will pass.\nThe patch code has not changed between any versions.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38444",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49060",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: Fix NULL pointer dereference in smc_pnet_find_ib()\n\ndev_name() was called with dev.parent as argument but without to\nNULL-check it before.\nSolve this by checking the pointer before the call to dev_name().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49060",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49013",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: fix memory leak in sctp_stream_outq_migrate()\n\nWhen sctp_stream_outq_migrate() is called to release stream out resources,\nthe memory pointed to by prio_head in stream out is not released.\n\nThe memory leak information is as follows:\n unreferenced object 0xffff88801fe79f80 (size 64):\n   comm \"sctp_repo\", pid 7957, jiffies 4294951704 (age 36.480s)\n   hex dump (first 32 bytes):\n     80 9f e7 1f 80 88 ff ff 80 9f e7 1f 80 88 ff ff  ................\n     90 9f e7 1f 80 88 ff ff 90 9f e7 1f 80 88 ff ff  ................\n   backtrace:\n     [<ffffffff81b215c6>] kmalloc_trace+0x26/0x60\n     [<ffffffff88ae517c>] sctp_sched_prio_set+0x4cc/0x770\n     [<ffffffff88ad64f2>] sctp_stream_init_ext+0xd2/0x1b0\n     [<ffffffff88aa2604>] sctp_sendmsg_to_asoc+0x1614/0x1a30\n     [<ffffffff88ab7ff1>] sctp_sendmsg+0xda1/0x1ef0\n     [<ffffffff87f765ed>] inet_sendmsg+0x9d/0xe0\n     [<ffffffff8754b5b3>] sock_sendmsg+0xd3/0x120\n     [<ffffffff8755446a>] __sys_sendto+0x23a/0x340\n     [<ffffffff87554651>] __x64_sys_sendto+0xe1/0x1b0\n     [<ffffffff89978b49>] do_syscall_64+0x39/0xb0\n     [<ffffffff89a0008b>] entry_SYSCALL_64_after_hwframe+0x63/0xcd",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49013",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47238",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv4: fix memory leak in ip_mc_add1_src\n\nBUG: memory leak\nunreferenced object 0xffff888101bc4c00 (size 32):\n  comm \"syz-executor527\", pid 360, jiffies 4294807421 (age 19.329s)\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n    01 00 00 00 00 00 00 00 ac 14 14 bb 00 00 02 00 ................\n  backtrace:\n    [<00000000f17c5244>] kmalloc include/linux/slab.h:558 [inline]\n    [<00000000f17c5244>] kzalloc include/linux/slab.h:688 [inline]\n    [<00000000f17c5244>] ip_mc_add1_src net/ipv4/igmp.c:1971 [inline]\n    [<00000000f17c5244>] ip_mc_add_src+0x95f/0xdb0 net/ipv4/igmp.c:2095\n    [<000000001cb99709>] ip_mc_source+0x84c/0xea0 net/ipv4/igmp.c:2416\n    [<0000000052cf19ed>] do_ip_setsockopt net/ipv4/ip_sockglue.c:1294 [inline]\n    [<0000000052cf19ed>] ip_setsockopt+0x114b/0x30c0 net/ipv4/ip_sockglue.c:1423\n    [<00000000477edfbc>] raw_setsockopt+0x13d/0x170 net/ipv4/raw.c:857\n    [<00000000e75ca9bb>] __sys_setsockopt+0x158/0x270 net/socket.c:2117\n    [<00000000bdb993a8>] __do_sys_setsockopt net/socket.c:2128 [inline]\n    [<00000000bdb993a8>] __se_sys_setsockopt net/socket.c:2125 [inline]\n    [<00000000bdb993a8>] __x64_sys_setsockopt+0xba/0x150 net/socket.c:2125\n    [<000000006a1ffdbd>] do_syscall_64+0x40/0x80 arch/x86/entry/common.c:47\n    [<00000000b11467c4>] entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nIn commit 24803f38a5c0 (\"igmp: do not remove igmp souce list info when set\nlink down\"), the ip_mc_clear_src() in ip_mc_destroy_dev() was removed,\nbecause it was also called in igmpv3_clear_delrec().\n\nRough callgraph:\n\ninetdev_destroy\n-> ip_mc_destroy_dev\n     -> igmpv3_clear_delrec\n        -> ip_mc_clear_src\n-> RCU_INIT_POINTER(dev->ip_ptr, NULL)\n\nHowever, ip_mc_clear_src() called in igmpv3_clear_delrec() doesn't\nrelease in_dev->mc_list->sources. And RCU_INIT_POINTER() assigns the\nNULL to dev->ip_ptr. As a result, in_dev cannot be obtained through\ninetdev_by_index() and then in_dev->mc_list->sources cannot be released\nby ip_mc_del1_src() in the sock_close. Rough call sequence goes like:\n\nsock_close\n-> __sock_release\n   -> inet_release\n      -> ip_mc_drop_socket\n         -> inetdev_by_index\n         -> ip_mc_leave_src\n            -> ip_mc_del_src\n               -> ip_mc_del1_src\n\nSo we still need to call ip_mc_clear_src() in ip_mc_destroy_dev() to free\nin_dev->mc_list->sources.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47238",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-04",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48780",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: Avoid overwriting the copies of clcsock callback functions\n\nThe callback functions of clcsock will be saved and replaced during\nthe fallback. But if the fallback happens more than once, then the\ncopies of these callback functions will be overwritten incorrectly,\nresulting in a loop call issue:\n\nclcsk->sk_error_report\n |- smc_fback_error_report() <------------------------------|\n     |- smc_fback_forward_wakeup()                          | (loop)\n         |- clcsock_callback()  (incorrectly overwritten)   |\n             |- smc->clcsk_error_report() ------------------|\n\nSo this patch fixes the issue by saving these function pointers only\nonce in the fallback and avoiding overwriting.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48780",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-10-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38458",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: clip: Fix NULL pointer dereference in vcc_sendmsg()\n\natmarpd_dev_ops does not implement the send method, which may cause crash\nas bellow.\n\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 0 P4D 0\nOops: Oops: 0010 [#1] SMP KASAN NOPTI\nCPU: 0 UID: 0 PID: 5324 Comm: syz.0.0 Not tainted 6.15.0-rc6-syzkaller-00346-g5723cc3450bc #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at 0xffffffffffffffd6.\nRSP: 0018:ffffc9000d3cf778 EFLAGS: 00010246\nRAX: 1ffffffff1910dd1 RBX: 00000000000000c0 RCX: dffffc0000000000\nRDX: ffffc9000dc82000 RSI: ffff88803e4c4640 RDI: ffff888052cd0000\nRBP: ffffc9000d3cf8d0 R08: ffff888052c9143f R09: 1ffff1100a592287\nR10: dffffc0000000000 R11: 0000000000000000 R12: 1ffff92001a79f00\nR13: ffff888052cd0000 R14: ffff88803e4c4640 R15: ffffffff8c886e88\nFS:  00007fbc762566c0(0000) GS:ffff88808d6c2000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffffffffd6 CR3: 0000000041f1b000 CR4: 0000000000352ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n vcc_sendmsg+0xa10/0xc50 net/atm/common.c:644\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg+0x219/0x270 net/socket.c:727\n ____sys_sendmsg+0x52d/0x830 net/socket.c:2566\n ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2620\n __sys_sendmmsg+0x227/0x430 net/socket.c:2709\n __do_sys_sendmmsg net/socket.c:2736 [inline]\n __se_sys_sendmmsg net/socket.c:2733 [inline]\n __x64_sys_sendmmsg+0xa0/0xc0 net/socket.c:2733\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xf6/0x210 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38458",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38391",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: altmodes/displayport: do not index invalid pin_assignments\n\nA poorly implemented DisplayPort Alt Mode port partner can indicate\nthat its pin assignment capabilities are greater than the maximum\nvalue, DP_PIN_ASSIGN_F. In this case, calls to pin_assignment_show\nwill cause a BRK exception due to an out of bounds array access.\n\nPrevent for loop in pin_assignment_show from accessing\ninvalid values in pin_assignments by adding DP_PIN_ASSIGN_MAX\nvalue in typec_dp.h and using i < DP_PIN_ASSIGN_MAX as a loop\ncondition.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38391",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-36280",
                    "description": "An out-of-bounds(OOB) memory access vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_kms.c in GPU component in the Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-36280",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-09-09",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47218",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nselinux: fix NULL-pointer dereference when hashtab allocation fails\n\nWhen the hash table slot array allocation fails in hashtab_init(),\nh->size is left initialized with a non-zero value, but the h->htable\npointer is NULL. This may then cause a NULL pointer dereference, since\nthe policydb code relies on the assumption that even after a failed\nhashtab_init(), hashtab_map() and hashtab_destroy() can be safely called\non it. Yet, these detect an empty hashtab only by looking at the size.\n\nFix this by making sure that hashtab_init() always leaves behind a valid\nempty hashtab when the allocation fails.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47218",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-10",
                    "modification_date": "2025-01-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39746",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath10k: shutdown driver when hardware is unreliable\n\nIn rare cases, ath10k may lose connection with the PCIe bus due to\nsome unknown reasons, which could further lead to system crashes during\nresuming due to watchdog timeout:\n\nath10k_pci 0000:01:00.0: wmi command 20486 timeout, restarting hardware\nath10k_pci 0000:01:00.0: already restarting\nath10k_pci 0000:01:00.0: failed to stop WMI vdev 0: -11\nath10k_pci 0000:01:00.0: failed to stop vdev 0: -11\nieee80211 phy0: PM: **** DPM device timeout ****\nCall Trace:\n panic+0x125/0x315\n dpm_watchdog_set+0x54/0x54\n dpm_watchdog_handler+0x57/0x57\n call_timer_fn+0x31/0x13c\n\nAt this point, all WMI commands will timeout and attempt to restart\ndevice. So set a threshold for consecutive restart failures. If the\nthreshold is exceeded, consider the hardware is unreliable and all\nath10k operations should be skipped to avoid system crash.\n\nfail_cont_count and pending_recovery are atomic variables, and\ndo not involve complex conditional logic. Therefore, even if recovery\ncheck and reconfig complete are executed concurrently, the recovery\nmechanism will not be broken.\n\nTested-on: QCA6174 hw3.2 PCI WLAN.RM.4.4.1-00288-QCARMSWPZ-1",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39746",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40348",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nslab: Avoid race on slab->obj_exts in alloc_slab_obj_exts\n\nIf two competing threads enter alloc_slab_obj_exts() and one of them\nfails to allocate the object extension vector, it might override the\nvalid slab->obj_exts allocated by the other thread with\nOBJEXTS_ALLOC_FAIL. This will cause the thread that lost this race and\nexpects a valid pointer to dereference a NULL pointer later on.\n\nUpdate slab->obj_exts atomically using cmpxchg() to avoid\nslab->obj_exts overrides by racing threads.\n\nThanks for Vlastimil and Suren's help with debugging.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-39996",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: b2c2: Fix use-after-free causing by irq_check_work in flexcop_pci_remove\n\nThe original code uses cancel_delayed_work() in flexcop_pci_remove(), which\ndoes not guarantee that the delayed work item irq_check_work has fully\ncompleted if it was already running. This leads to use-after-free scenarios\nwhere flexcop_pci_remove() may free the flexcop_device while irq_check_work\nis still active and attempts to dereference the device.\n\nA typical race condition is illustrated below:\n\nCPU 0 (remove)                         | CPU 1 (delayed work callback)\nflexcop_pci_remove()                   | flexcop_pci_irq_check_work()\n  cancel_delayed_work()                |\n  flexcop_device_kfree(fc_pci->fc_dev) |\n                                       |   fc = fc_pci->fc_dev; // UAF\n\nThis is confirmed by a KASAN report:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in __run_timer_base.part.0+0x7d7/0x8c0\nWrite of size 8 at addr ffff8880093aa8c8 by task bash/135\n...\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x55/0x70\n print_report+0xcf/0x610\n ? __run_timer_base.part.0+0x7d7/0x8c0\n kasan_report+0xb8/0xf0\n ? __run_timer_base.part.0+0x7d7/0x8c0\n __run_timer_base.part.0+0x7d7/0x8c0\n ? __pfx___run_timer_base.part.0+0x10/0x10\n ? __pfx_read_tsc+0x10/0x10\n ? ktime_get+0x60/0x140\n ? lapic_next_event+0x11/0x20\n ? clockevents_program_event+0x1d4/0x2a0\n run_timer_softirq+0xd1/0x190\n handle_softirqs+0x16a/0x550\n irq_exit_rcu+0xaf/0xe0\n sysvec_apic_timer_interrupt+0x70/0x80\n </IRQ>\n...\n\nAllocated by task 1:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x7f/0x90\n __kmalloc_noprof+0x1be/0x460\n flexcop_device_kmalloc+0x54/0xe0\n flexcop_pci_probe+0x1f/0x9d0\n local_pci_probe+0xdc/0x190\n pci_device_probe+0x2fe/0x470\n really_probe+0x1ca/0x5c0\n __driver_probe_device+0x248/0x310\n driver_probe_device+0x44/0x120\n __driver_attach+0xd2/0x310\n bus_for_each_dev+0xed/0x170\n bus_add_driver+0x208/0x500\n driver_register+0x132/0x460\n do_one_initcall+0x89/0x300\n kernel_init_freeable+0x40d/0x720\n kernel_init+0x1a/0x150\n ret_from_fork+0x10c/0x1a0\n ret_from_fork_asm+0x1a/0x30\n\nFreed by task 135:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3a/0x60\n __kasan_slab_free+0x3f/0x50\n kfree+0x137/0x370\n flexcop_device_kfree+0x32/0x50\n pci_device_remove+0xa6/0x1d0\n device_release_driver_internal+0xf8/0x210\n pci_stop_bus_device+0x105/0x150\n pci_stop_and_remove_bus_device_locked+0x15/0x30\n remove_store+0xcc/0xe0\n kernfs_fop_write_iter+0x2c3/0x440\n vfs_write+0x871/0xd70\n ksys_write+0xee/0x1c0\n do_syscall_64+0xac/0x280\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n...\n\nReplace cancel_delayed_work() with cancel_delayed_work_sync() to ensure\nthat the delayed work item is properly canceled and any executing delayed\nwork has finished before the device memory is deallocated.\n\nThis bug was initially identified through static analysis. To reproduce\nand test it, I simulated the B2C2 FlexCop PCI device in QEMU and introduced\nartificial delays within the flexcop_pci_irq_check_work() function to\nincrease the likelihood of triggering the bug.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-15",
                    "modification_date": "2025-10-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39964",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: af_alg - Disallow concurrent writes in af_alg_sendmsg\n\nIssuing two writes to the same af_alg socket is bogus as the\ndata will be interleaved in an unpredictable fashion.  Furthermore,\nconcurrent writes may create inconsistencies in the internal\nsocket state.\n\nDisallow this by adding a new ctx->write field that indiciates\nexclusive ownership for writing.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-13",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49132",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: pci: fix crash on suspend if board file is not found\n\nMario reported that the kernel was crashing on suspend if ath11k was not able\nto find a board file:\n\n[  473.693286] PM: Suspending system (s2idle)\n[  473.693291] printk: Suspending console(s) (use no_console_suspend to debug)\n[  474.407787] BUG: unable to handle page fault for address: 0000000000002070\n[  474.407791] #PF: supervisor read access in kernel mode\n[  474.407794] #PF: error_code(0x0000) - not-present page\n[  474.407798] PGD 0 P4D 0\n[  474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTI\n[  474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G        W         5.16.0 #248\n[...]\n[  474.407868] Call Trace:\n[  474.407870]  <TASK>\n[  474.407874]  ? _raw_spin_lock_irqsave+0x2a/0x60\n[  474.407882]  ? lock_timer_base+0x72/0xa0\n[  474.407889]  ? _raw_spin_unlock_irqrestore+0x29/0x3d\n[  474.407892]  ? try_to_del_timer_sync+0x54/0x80\n[  474.407896]  ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]\n[  474.407912]  ath11k_core_suspend+0x34/0x130 [ath11k]\n[  474.407923]  ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]\n[  474.407928]  pci_pm_suspend+0x7e/0x170\n[  474.407935]  ? pci_pm_freeze+0xc0/0xc0\n[  474.407939]  dpm_run_callback+0x4e/0x150\n[  474.407947]  __device_suspend+0x148/0x4c0\n[  474.407951]  async_suspend+0x20/0x90\ndmesg-efi-164255130401001:\nOops#1 Part1\n[  474.407955]  async_run_entry_fn+0x33/0x120\n[  474.407959]  process_one_work+0x220/0x3f0\n[  474.407966]  worker_thread+0x4a/0x3d0\n[  474.407971]  kthread+0x17a/0x1a0\n[  474.407975]  ? process_one_work+0x3f0/0x3f0\n[  474.407979]  ? set_kthread_struct+0x40/0x40\n[  474.407983]  ret_from_fork+0x22/0x30\n[  474.407991]  </TASK>\n\nThe issue here is that board file loading happens after ath11k_pci_probe()\nsuccesfully returns (ath11k initialisation happends asynchronously) and the\nsuspend handler is still enabled, of course failing as ath11k is not properly\ninitialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend and\nresume.\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49132",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-35477",
                    "description": "In the Linux kernel through 5.13.7, an unprivileged BPF program can obtain sensitive information from kernel memory via a Speculative Store Bypass side-channel attack because a certain preempting store operation does not necessarily occur before a store operation that has an attacker-controlled value.",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-35477",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-08-02",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40078",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Explicitly check accesses to bpf_sock_addr\n\nSyzkaller found a kernel warning on the following sock_addr program:\n\n    0: r0 = 0\n    1: r2 = *(u32 *)(r1 +60)\n    2: exit\n\nwhich triggers:\n\n    verifier bug: error during ctx access conversion (0)\n\nThis is happening because offset 60 in bpf_sock_addr corresponds to an\nimplicit padding of 4 bytes, right after msg_src_ip4. Access to this\npadding isn't rejected in sock_addr_is_valid_access and it thus later\nfails to convert the access.\n\nThis patch fixes it by explicitly checking the various fields of\nbpf_sock_addr in sock_addr_is_valid_access.\n\nI checked the other ctx structures and is_valid_access functions and\ndidn't find any other similar cases. Other cases of (properly handled)\npadding are covered in new tests in a subsequent patch.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2018-7273",
                    "description": "In the Linux kernel through 4.15.4, the floppy driver reveals the addresses of kernel functions and global variables using printk calls within the function show_floppy in drivers/block/floppy.c. An attacker can read this information from dmesg and use the addresses to find the locations of kernel code and data and bypass kernel security protections such as KASLR.",
                    "nvd_score": 4.9,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:C/I:N/A:N",
                    "nvd_severity": "medium",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-7273",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2018-02-21",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: low",
                    "aqua_score_classification": "Vendor Severity: low"
                },
                {
                    "name": "CVE-2025-39764",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: ctnetlink: remove refcounting in expectation dumpers\n\nSame pattern as previous patch: do not keep the expectation object\nalive via refcount, only store a cookie value and then use that\nas the skip hint for dump resumption.\n\nAFAICS this has the same issue as the one resolved in the conntrack\ndumper, when we do\n  if (!refcount_inc_not_zero(&exp->use))\n\nto increment the refcount, there is a chance that exp == last, which\ncauses a double-increment of the refcount and subsequent memory leak.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39764",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68372",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: defer config put in recv_work\n\nThere is one uaf issue in recv_work when running NBD_CLEAR_SOCK and\nNBD_CMD_RECONFIGURE:\n  nbd_genl_connect     // conf_ref=2 (connect and recv_work A)\n  nbd_open\t       // conf_ref=3\n  recv_work A done     // conf_ref=2\n  NBD_CLEAR_SOCK       // conf_ref=1\n  nbd_genl_reconfigure // conf_ref=2 (trigger recv_work B)\n  close nbd\t       // conf_ref=1\n  recv_work B\n    config_put         // conf_ref=0\n    atomic_dec(&config->recv_threads); -> UAF\n\nOr only running NBD_CLEAR_SOCK:\n  nbd_genl_connect   // conf_ref=2\n  nbd_open \t     // conf_ref=3\n  NBD_CLEAR_SOCK     // conf_ref=2\n  close nbd\n    nbd_release\n      config_put     // conf_ref=1\n  recv_work\n    config_put \t     // conf_ref=0\n    atomic_dec(&config->recv_threads); -> UAF\n\nCommit 87aac3a80af5 (\"nbd: call nbd_config_put() before notifying the\nwaiter\") moved nbd_config_put() to run before waking up the waiter in\nrecv_work, in order to ensure that nbd_start_device_ioctl() would not\nbe woken up while nbd->task_recv was still uncleared.\n\nHowever, in nbd_start_device_ioctl(), after being woken up it explicitly\ncalls flush_workqueue() to make sure all current works are finished.\nTherefore, there is no need to move the config put ahead of the wakeup.\n\nMove nbd_config_put() to the end of recv_work, so that the reference is\nheld for the whole lifetime of the worker thread. This makes sure the\nconfig cannot be freed while recv_work is still running, even if clear\n+ reconfigure interleave.\n\nIn addition, we don't need to worry about recv_work dropping the last\nnbd_put (which causes deadlock):\n\npath A (netlink with NBD_CFLAG_DESTROY_ON_DISCONNECT):\n  connect  // nbd_refs=1 (trigger recv_work)\n  open nbd // nbd_refs=2\n  NBD_CLEAR_SOCK\n  close nbd\n    nbd_release\n      nbd_disconnect_and_put\n        flush_workqueue // recv_work done\n      nbd_config_put\n        nbd_put // nbd_refs=1\n      nbd_put // nbd_refs=0\n        queue_work\n\npath B (netlink without NBD_CFLAG_DESTROY_ON_DISCONNECT):\n  connect  // nbd_refs=2 (trigger recv_work)\n  open nbd // nbd_refs=3\n  NBD_CLEAR_SOCK // conf_refs=2\n  close nbd\n    nbd_release\n      nbd_config_put // conf_refs=1\n      nbd_put // nbd_refs=2\n  recv_work done // conf_refs=0, nbd_refs=1\n  rmmod // nbd_refs=0\n\nDepends-on: e2daec488c57 (\"nbd: Fix hungtask when nbd_config_put\")",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49118",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: hisi_sas: Free irq vectors in order for v3 HW\n\nIf the driver probe fails to request the channel IRQ or fatal IRQ, the\ndriver will free the IRQ vectors before freeing the IRQs in free_irq(),\nand this will cause a kernel BUG like this:\n\n------------[ cut here ]------------\nkernel BUG at drivers/pci/msi.c:369!\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nCall trace:\n   free_msi_irqs+0x118/0x13c\n   pci_disable_msi+0xfc/0x120\n   pci_free_irq_vectors+0x24/0x3c\n   hisi_sas_v3_probe+0x360/0x9d0 [hisi_sas_v3_hw]\n   local_pci_probe+0x44/0xb0\n   work_for_cpu_fn+0x20/0x34\n   process_one_work+0x1d0/0x340\n   worker_thread+0x2e0/0x460\n   kthread+0x180/0x190\n   ret_from_fork+0x10/0x20\n---[ end trace b88990335b610c11 ]---\n\nSo we use devm_add_action() to control the order in which we free the\nvectors.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49118",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-15",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48972",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac802154: fix missing INIT_LIST_HEAD in ieee802154_if_add()\n\nKernel fault injection test reports null-ptr-deref as follows:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000008\nRIP: 0010:cfg802154_netdev_notifier_call+0x120/0x310 include/linux/list.h:114\nCall Trace:\n <TASK>\n raw_notifier_call_chain+0x6d/0xa0 kernel/notifier.c:87\n call_netdevice_notifiers_info+0x6e/0xc0 net/core/dev.c:1944\n unregister_netdevice_many_notify+0x60d/0xcb0 net/core/dev.c:1982\n unregister_netdevice_queue+0x154/0x1a0 net/core/dev.c:10879\n register_netdevice+0x9a8/0xb90 net/core/dev.c:10083\n ieee802154_if_add+0x6ed/0x7e0 net/mac802154/iface.c:659\n ieee802154_register_hw+0x29c/0x330 net/mac802154/main.c:229\n mcr20a_probe+0xaaa/0xcb1 drivers/net/ieee802154/mcr20a.c:1316\n\nieee802154_if_add() allocates wpan_dev as netdev's private data, but not\ninit the list in struct wpan_dev. cfg802154_netdev_notifier_call() manage\nthe list when device register/unregister, and may lead to null-ptr-deref.\n\nUse INIT_LIST_HEAD() on it to initialize it correctly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48972",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-4442",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: add sanity tests to TCP_QUEUE_SEQ\n\nQingyu Li reported a syzkaller bug where the repro\nchanges RCV SEQ _after_ restoring data in the receive queue.\n\nmprotect(0x4aa000, 12288, PROT_READ)    = 0\nmmap(0x1ffff000, 4096, PROT_NONE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x1ffff000\nmmap(0x20000000, 16777216, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x20000000\nmmap(0x21000000, 4096, PROT_NONE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x21000000\nsocket(AF_INET6, SOCK_STREAM, IPPROTO_IP) = 3\nsetsockopt(3, SOL_TCP, TCP_REPAIR, [1], 4) = 0\nconnect(3, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, \"::1\", &sin6_addr), sin6_scope_id=0}, 28) = 0\nsetsockopt(3, SOL_TCP, TCP_REPAIR_QUEUE, [1], 4) = 0\nsendmsg(3, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base=\"0x0000000000000003\\0\\0\", iov_len=20}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 20\nsetsockopt(3, SOL_TCP, TCP_REPAIR, [0], 4) = 0\nsetsockopt(3, SOL_TCP, TCP_QUEUE_SEQ, [128], 4) = 0\nrecvfrom(3, NULL, 20, 0, NULL, NULL)    = -1 ECONNRESET (Connection reset by peer)\n\nsyslog shows:\n[  111.205099] TCP recvmsg seq # bug 2: copied 80, seq 0, rcvnxt 80, fl 0\n[  111.207894] WARNING: CPU: 1 PID: 356 at net/ipv4/tcp.c:2343 tcp_recvmsg_locked+0x90e/0x29a0\n\nThis should not be allowed. TCP_QUEUE_SEQ should only be used\nwhen queues are empty.\n\nThis patch fixes this case, and the tx path as well.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4442",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-29",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48863",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmISDN: Fix memory leak in dsp_pipeline_build()\n\ndsp_pipeline_build() allocates dup pointer by kstrdup(cfg),\nbut then it updates dup variable by strsep(&dup, \"|\").\nAs a result when it calls kfree(dup), the dup variable contains NULL.\n\nFound by Linux Driver Verification project (linuxtesting.org) with SVACE.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48863",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48652",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: Fix crash by keep old cfg when update TCs more than queues\n\nThere are problems if allocated queues less than Traffic Classes.\n\nCommit a632b2a4c920 (\"ice: ethtool: Prohibit improper channel config\nfor DCB\") already disallow setting less queues than TCs.\n\nAnother case is if we first set less queues, and later update more TCs\nconfig due to LLDP, ice_vsi_cfg_tc() will failed but left dirty\nnum_txq/rxq and tc_cfg in vsi, that will cause invalid pointer access.\n\n[   95.968089] ice 0000:3b:00.1: More TCs defined than queues/rings allocated.\n[   95.968092] ice 0000:3b:00.1: Trying to use more Rx queues (8), than were allocated (1)!\n[   95.968093] ice 0000:3b:00.1: Failed to config TC for VSI index: 0\n[   95.969621] general protection fault: 0000 [#1] SMP NOPTI\n[   95.969705] CPU: 1 PID: 58405 Comm: lldpad Kdump: loaded Tainted: G     U  W  O     --------- -t - 4.18.0 #1\n[   95.969867] Hardware name: O.E.M/BC11SPSCB10, BIOS 8.23 12/30/2021\n[   95.969992] RIP: 0010:devm_kmalloc+0xa/0x60\n[   95.970052] Code: 5c ff ff ff 31 c0 5b 5d 41 5c c3 b8 f4 ff ff ff eb f4 0f 1f 40 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 89 d1 <8b> 97 60 02 00 00 48 8d 7e 18 48 39 f7 72 3f 55 89 ce 53 48 8b 4c\n[   95.970344] RSP: 0018:ffffc9003f553888 EFLAGS: 00010206\n[   95.970425] RAX: dead000000000200 RBX: ffffea003c425b00 RCX: 00000000006080c0\n[   95.970536] RDX: 00000000006080c0 RSI: 0000000000000200 RDI: dead000000000200\n[   95.970648] RBP: dead000000000200 R08: 00000000000463c0 R09: ffff888ffa900000\n[   95.970760] R10: 0000000000000000 R11: 0000000000000002 R12: ffff888ff6b40100\n[   95.970870] R13: ffff888ff6a55018 R14: 0000000000000000 R15: ffff888ff6a55460\n[   95.970981] FS:  00007f51b7d24700(0000) GS:ffff88903ee80000(0000) knlGS:0000000000000000\n[   95.971108] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   95.971197] CR2: 00007fac5410d710 CR3: 0000000f2c1de002 CR4: 00000000007606e0\n[   95.971309] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   95.971419] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[   95.971530] PKRU: 55555554\n[   95.971573] Call Trace:\n[   95.971622]  ice_setup_rx_ring+0x39/0x110 [ice]\n[   95.971695]  ice_vsi_setup_rx_rings+0x54/0x90 [ice]\n[   95.971774]  ice_vsi_open+0x25/0x120 [ice]\n[   95.971843]  ice_open_internal+0xb8/0x1f0 [ice]\n[   95.971919]  ice_ena_vsi+0x4f/0xd0 [ice]\n[   95.971987]  ice_dcb_ena_dis_vsi.constprop.5+0x29/0x90 [ice]\n[   95.972082]  ice_pf_dcb_cfg+0x29a/0x380 [ice]\n[   95.972154]  ice_dcbnl_setets+0x174/0x1b0 [ice]\n[   95.972220]  dcbnl_ieee_set+0x89/0x230\n[   95.972279]  ? dcbnl_ieee_del+0x150/0x150\n[   95.972341]  dcb_doit+0x124/0x1b0\n[   95.972392]  rtnetlink_rcv_msg+0x243/0x2f0\n[   95.972457]  ? dcb_doit+0x14d/0x1b0\n[   95.972510]  ? __kmalloc_node_track_caller+0x1d3/0x280\n[   95.972591]  ? rtnl_calcit.isra.31+0x100/0x100\n[   95.972661]  netlink_rcv_skb+0xcf/0xf0\n[   95.972720]  netlink_unicast+0x16d/0x220\n[   95.972781]  netlink_sendmsg+0x2ba/0x3a0\n[   95.975891]  sock_sendmsg+0x4c/0x50\n[   95.979032]  ___sys_sendmsg+0x2e4/0x300\n[   95.982147]  ? kmem_cache_alloc+0x13e/0x190\n[   95.985242]  ? __wake_up_common_lock+0x79/0x90\n[   95.988338]  ? __check_object_size+0xac/0x1b0\n[   95.991440]  ? _copy_to_user+0x22/0x30\n[   95.994539]  ? move_addr_to_user+0xbb/0xd0\n[   95.997619]  ? __sys_sendmsg+0x53/0x80\n[   96.000664]  __sys_sendmsg+0x53/0x80\n[   96.003747]  do_syscall_64+0x5b/0x1d0\n[   96.006862]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n\nOnly update num_txq/rxq when passed check, and restore tc_cfg if setup\nqueue map failed.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48652",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-09-19",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47465",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: PPC: Book3S HV: Fix stack handling in idle_kvm_start_guest()\n\nIn commit 10d91611f426 (\"powerpc/64s: Reimplement book3s idle code in\nC\") kvm_start_guest() became idle_kvm_start_guest(). The old code\nallocated a stack frame on the emergency stack, but didn't use the\nframe to store anything, and also didn't store anything in its caller's\nframe.\n\nidle_kvm_start_guest() on the other hand is written more like a normal C\nfunction, it creates a frame on entry, and also stores CR/LR into its\ncallers frame (per the ABI). The problem is that there is no caller\nframe on the emergency stack.\n\nThe emergency stack for a given CPU is allocated with:\n\n  paca_ptrs[i]->emergency_sp = alloc_stack(limit, i) + THREAD_SIZE;\n\nSo emergency_sp actually points to the first address above the emergency\nstack allocation for a given CPU, we must not store above it without\nfirst decrementing it to create a frame. This is different to the\nregular kernel stack, paca->kstack, which is initialised to point at an\ninitial frame that is ready to use.\n\nidle_kvm_start_guest() stores the backchain, CR and LR all of which\nwrite outside the allocation for the emergency stack. It then creates a\nstack frame and saves the non-volatile registers. Unfortunately the\nframe it creates is not large enough to fit the non-volatiles, and so\nthe saving of the non-volatile registers also writes outside the\nemergency stack allocation.\n\nThe end result is that we corrupt whatever is at 0-24 bytes, and 112-248\nbytes above the emergency stack allocation.\n\nIn practice this has gone unnoticed because the memory immediately above\nthe emergency stack happens to be used for other stack allocations,\neither another CPUs mc_emergency_sp or an IRQ stack. See the order of\ncalls to irqstack_early_init() and emergency_stack_init().\n\nThe low addresses of another stack are the top of that stack, and so are\nonly used if that stack is under extreme pressue, which essentially\nnever happens in practice - and if it did there's a high likelyhood we'd\ncrash due to that stack overflowing.\n\nStill, we shouldn't be corrupting someone else's stack, and it is purely\nluck that we aren't corrupting something else.\n\nTo fix it we save CR/LR into the caller's frame using the existing r1 on\nentry, we then create a SWITCH_FRAME_SIZE frame (which has space for\npt_regs) on the emergency stack with the backchain pointing to the\nexisting stack, and then finally we switch to the new frame on the\nemergency stack.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47465",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-09-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48971",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix not cleanup led when bt_init fails\n\nbt_init() calls bt_leds_init() to register led, but if it fails later,\nbt_leds_cleanup() is not called to unregister it.\n\nThis can cause panic if the argument \"bluetooth-power\" in text is freed\nand then another led_trigger_register() tries to access it:\n\nBUG: unable to handle page fault for address: ffffffffc06d3bc0\nRIP: 0010:strcmp+0xc/0x30\n  Call Trace:\n    <TASK>\n    led_trigger_register+0x10d/0x4f0\n    led_trigger_register_simple+0x7d/0x100\n    bt_init+0x39/0xf7 [bluetooth]\n    do_one_initcall+0xd0/0x4e0",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48971",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39677",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Fix backlog accounting in qdisc_dequeue_internal\n\nThis issue applies for the following qdiscs: hhf, fq, fq_codel, and\nfq_pie, and occurs in their change handlers when adjusting to the new\nlimit. The problem is the following in the values passed to the\nsubsequent qdisc_tree_reduce_backlog call given a tbf parent:\n\n   When the tbf parent runs out of tokens, skbs of these qdiscs will\n   be placed in gso_skb. Their peek handlers are qdisc_peek_dequeued,\n   which accounts for both qlen and backlog. However, in the case of\n   qdisc_dequeue_internal, ONLY qlen is accounted for when pulling\n   from gso_skb. This means that these qdiscs are missing a\n   qdisc_qstats_backlog_dec when dropping packets to satisfy the\n   new limit in their change handlers.\n\n   One can observe this issue with the following (with tc patched to\n   support a limit of 0):\n\n   export TARGET=fq\n   tc qdisc del dev lo root\n   tc qdisc add dev lo root handle 1: tbf rate 8bit burst 100b latency 1ms\n   tc qdisc replace dev lo handle 3: parent 1:1 $TARGET limit 1000\n   echo ''; echo 'add child'; tc -s -d qdisc show dev lo\n   ping -I lo -f -c2 -s32 -W0.001 127.0.0.1 2>&1 >/dev/null\n   echo ''; echo 'after ping'; tc -s -d qdisc show dev lo\n   tc qdisc change dev lo handle 3: parent 1:1 $TARGET limit 0\n   echo ''; echo 'after limit drop'; tc -s -d qdisc show dev lo\n   tc qdisc replace dev lo handle 2: parent 1:1 sfq\n   echo ''; echo 'post graft'; tc -s -d qdisc show dev lo\n\n   The second to last show command shows 0 packets but a positive\n   number (74) of backlog bytes. The problem becomes clearer in the\n   last show command, where qdisc_purge_queue triggers\n   qdisc_tree_reduce_backlog with the positive backlog and causes an\n   underflow in the tbf parent's backlog (4096 Mb instead of 0).\n\nTo fix this issue, the codepath for all clients of qdisc_dequeue_internal\nhas been simplified: codel, pie, hhf, fq, fq_pie, and fq_codel.\nqdisc_dequeue_internal handles the backlog adjustments for all cases that\ndo not directly use the dequeue handler.\n\nThe old fq_codel_change limit adjustment loop accumulated the arguments to\nthe subsequent qdisc_tree_reduce_backlog call through the cstats field.\nHowever, this is confusing and error prone as fq_codel_dequeue could also\npotentially mutate this field (which qdisc_dequeue_internal calls in the\nnon gso_skb case), so we have unified the code here with other qdiscs.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39677",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-05",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39853",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: Fix potential invalid access when MAC list is empty\n\nlist_first_entry() never returns NULL - if the list is empty, it still\nreturns a pointer to an invalid object, leading to potential invalid\nmemory access when dereferenced.\n\nFix this by using list_first_entry_or_null instead of list_first_entry.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-8694",
                    "description": "Insufficient access control in the Linux kernel driver for some Intel(R) Processors may allow an authenticated user to potentially enable information disclosure via local access.",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-8694",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2020-11-12",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47011",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: memcontrol: slab: fix obtain a reference to a freeing memcg\n\nPatch series \"Use obj_cgroup APIs to charge kmem pages\", v5.\n\nSince Roman's series \"The new cgroup slab memory controller\" applied.\nAll slab objects are charged with the new APIs of obj_cgroup.  The new\nAPIs introduce a struct obj_cgroup to charge slab objects.  It prevents\nlong-living objects from pinning the original memory cgroup in the\nmemory.  But there are still some corner objects (e.g.  allocations\nlarger than order-1 page on SLUB) which are not charged with the new\nAPIs.  Those objects (include the pages which are allocated from buddy\nallocator directly) are charged as kmem pages which still hold a\nreference to the memory cgroup.\n\nE.g.  We know that the kernel stack is charged as kmem pages because the\nsize of the kernel stack can be greater than 2 pages (e.g.  16KB on\nx86_64 or arm64).  If we create a thread (suppose the thread stack is\ncharged to memory cgroup A) and then move it from memory cgroup A to\nmemory cgroup B.  Because the kernel stack of the thread hold a\nreference to the memory cgroup A.  The thread can pin the memory cgroup\nA in the memory even if we remove the cgroup A.  If we want to see this\nscenario by using the following script.  We can see that the system has\nadded 500 dying cgroups (This is not a real world issue, just a script\nto show that the large kmallocs are charged as kmem pages which can pin\nthe memory cgroup in the memory).\n\n\t#!/bin/bash\n\n\tcat /proc/cgroups | grep memory\n\n\tcd /sys/fs/cgroup/memory\n\techo 1 > memory.move_charge_at_immigrate\n\n\tfor i in range{1..500}\n\tdo\n\t\tmkdir kmem_test\n\t\techo $$ > kmem_test/cgroup.procs\n\t\tsleep 3600 &\n\t\techo $$ > cgroup.procs\n\t\techo `cat kmem_test/cgroup.procs` > cgroup.procs\n\t\trmdir kmem_test\n\tdone\n\n\tcat /proc/cgroups | grep memory\n\nThis patchset aims to make those kmem pages to drop the reference to\nmemory cgroup by using the APIs of obj_cgroup.  Finally, we can see that\nthe number of the dying cgroups will not increase if we run the above test\nscript.\n\nThis patch (of 7):\n\nThe rcu_read_lock/unlock only can guarantee that the memcg will not be\nfreed, but it cannot guarantee the success of css_get (which is in the\nrefill_stock when cached memcg changed) to memcg.\n\n  rcu_read_lock()\n  memcg = obj_cgroup_memcg(old)\n  __memcg_kmem_uncharge(memcg)\n      refill_stock(memcg)\n          if (stock->cached != memcg)\n              // css_get can change the ref counter from 0 back to 1.\n              css_get(&memcg->css)\n  rcu_read_unlock()\n\nThis fix is very like the commit:\n\n  eefbfa7fd678 (\"mm: memcg/slab: fix use after free in obj_cgroup_charge\")\n\nFix this by holding a reference to the memcg which is passed to the\n__memcg_kmem_uncharge() before calling __memcg_kmem_uncharge().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47011",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-01-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49084",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nqede: confirm skb is allocated before using\n\nqede_build_skb() assumes build_skb() always works and goes straight\nto skb_reserve(). However, build_skb() can fail under memory pressure.\nThis results in a kernel panic because the skb to reserve is NULL.\n\nAdd a check in case build_skb() failed to allocate and return NULL.\n\nThe NULL return is handled correctly in callers to qede_build_skb().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49084",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47494",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncfg80211: fix management registrations locking\n\nThe management registrations locking was broken, the list was\nlocked for each wdev, but cfg80211_mgmt_registrations_update()\niterated it without holding all the correct spinlocks, causing\nlist corruption.\n\nRather than trying to fix it with fine-grained locking, just\nmove the lock to the wiphy/rdev (still need the list on each\nwdev), we already need to hold the wdev lock to change it, so\nthere's no contention on the lock in any case. This trivially\nfixes the bug since we hold one wdev's lock already, and now\nwill hold the lock that protects all lists.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47494",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-22",
                    "modification_date": "2025-09-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47167",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix an Oopsable condition in __nfs_pageio_add_request()\n\nEnsure that nfs_pageio_error_cleanup() resets the mirror array contents,\nso that the structure reflects the fact that it is now empty.\nAlso change the test in nfs_pageio_do_add_request() to be more robust by\nchecking whether or not the list is empty rather than relying on the\nvalue of pg_count.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47167",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-25",
                    "modification_date": "2025-03-17",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38457",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Abort __tc_modify_qdisc if parent class does not exist\n\nLion's patch [1] revealed an ancient bug in the qdisc API.\nWhenever a user creates/modifies a qdisc specifying as a parent another\nqdisc, the qdisc API will, during grafting, detect that the user is\nnot trying to attach to a class and reject. However grafting is\nperformed after qdisc_create (and thus the qdiscs' init callback) is\nexecuted. In qdiscs that eventually call qdisc_tree_reduce_backlog\nduring init or change (such as fq, hhf, choke, etc), an issue\narises. For example, executing the following commands:\n\nsudo tc qdisc add dev lo root handle a: htb default 2\nsudo tc qdisc add dev lo parent a: handle beef fq\n\nQdiscs such as fq, hhf, choke, etc unconditionally invoke\nqdisc_tree_reduce_backlog() in their control path init() or change() which\nthen causes a failure to find the child class; however, that does not stop\nthe unconditional invocation of the assumed child qdisc's qlen_notify with\na null class. All these qdiscs make the assumption that class is non-null.\n\nThe solution is ensure that qdisc_leaf() which looks up the parent\nclass, and is invoked prior to qdisc_create(), should return failure on\nnot finding the class.\nIn this patch, we leverage qdisc_leaf to return ERR_PTRs whenever the\nparentid doesn't correspond to a class, so that we can detect it\nearlier on and abort before qdisc_create is called.\n\n[1] https://lore.kernel.org/netdev/d912cbd7-193b-4269-9857-525bee8bbb6a@gmail.com/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38457",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40044",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: udf: fix OOB read in lengthAllocDescs handling\n\nWhen parsing Allocation Extent Descriptor, lengthAllocDescs comes from\non-disk data and must be validated against the block size. Crafted or\ncorrupted images may set lengthAllocDescs so that the total descriptor\nlength (sizeof(allocExtDesc) + lengthAllocDescs) exceeds the buffer,\nleading udf_update_tag() to call crc_itu_t() on out-of-bounds memory and\ntrigger a KASAN use-after-free read.\n\nBUG: KASAN: use-after-free in crc_itu_t+0x1d5/0x2b0 lib/crc-itu-t.c:60\nRead of size 1 at addr ffff888041e7d000 by task syz-executor317/5309\n\nCPU: 0 UID: 0 PID: 5309 Comm: syz-executor317 Not tainted 6.12.0-rc4-syzkaller-00261-g850925a8133c #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n crc_itu_t+0x1d5/0x2b0 lib/crc-itu-t.c:60\n udf_update_tag+0x70/0x6a0 fs/udf/misc.c:261\n udf_write_aext+0x4d8/0x7b0 fs/udf/inode.c:2179\n extent_trunc+0x2f7/0x4a0 fs/udf/truncate.c:46\n udf_truncate_tail_extent+0x527/0x7e0 fs/udf/truncate.c:106\n udf_release_file+0xc1/0x120 fs/udf/file.c:185\n __fput+0x23f/0x880 fs/file_table.c:431\n task_work_run+0x24f/0x310 kernel/task_work.c:239\n exit_task_work include/linux/task_work.h:43 [inline]\n do_exit+0xa2f/0x28e0 kernel/exit.c:939\n do_group_exit+0x207/0x2c0 kernel/exit.c:1088\n __do_sys_exit_group kernel/exit.c:1099 [inline]\n __se_sys_exit_group kernel/exit.c:1097 [inline]\n __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1097\n x64_sys_call+0x2634/0x2640 arch/x86/include/generated/asm/syscalls_64.h:232\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n </TASK>\n\nValidate the computed total length against epos->bh->b_size.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48906",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: Correctly set DATA_FIN timeout when number of retransmits is large\n\nSyzkaller with UBSAN uncovered a scenario where a large number of\nDATA_FIN retransmits caused a shift-out-of-bounds in the DATA_FIN\ntimeout calculation:\n\n================================================================================\nUBSAN: shift-out-of-bounds in net/mptcp/protocol.c:470:29\nshift exponent 32 is too large for 32-bit type 'unsigned int'\nCPU: 1 PID: 13059 Comm: kworker/1:0 Not tainted 5.17.0-rc2-00630-g5fbf21c90c60 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nWorkqueue: events mptcp_worker\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n ubsan_epilogue+0xb/0x5a lib/ubsan.c:151\n __ubsan_handle_shift_out_of_bounds.cold+0xb2/0x20e lib/ubsan.c:330\n mptcp_set_datafin_timeout net/mptcp/protocol.c:470 [inline]\n __mptcp_retrans.cold+0x72/0x77 net/mptcp/protocol.c:2445\n mptcp_worker+0x58a/0xa70 net/mptcp/protocol.c:2528\n process_one_work+0x9df/0x16d0 kernel/workqueue.c:2307\n worker_thread+0x95/0xe10 kernel/workqueue.c:2454\n kthread+0x2f4/0x3b0 kernel/kthread.c:377\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295\n </TASK>\n================================================================================\n\nThis change limits the maximum timeout by limiting the size of the\nshift, which keeps all intermediate values in-bounds.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48906",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39940",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm-stripe: fix a possible integer overflow\n\nThere's a possible integer overflow in stripe_io_hints if we have too\nlarge chunk size. Test if the overflow happened, and if it did, don't set\nlimits->io_min and limits->io_opt;",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-04",
                    "modification_date": "2025-10-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38735",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngve: prevent ethtool ops after shutdown\n\nA crash can occur if an ethtool operation is invoked\nafter shutdown() is called.\n\nshutdown() is invoked during system shutdown to stop DMA operations\nwithout performing expensive deallocations. It is discouraged to\nunregister the netdev in this path, so the device may still be visible\nto userspace and kernel helpers.\n\nIn gve, shutdown() tears down most internal data structures. If an\nethtool operation is dispatched after shutdown(), it will dereference\nfreed or NULL pointers, leading to a kernel panic. While graceful\nshutdown normally quiesces userspace before invoking the reboot\nsyscall, forced shutdowns (as observed on GCP VMs) can still trigger\nthis path.\n\nFix by calling netif_device_detach() in shutdown().\nThis marks the device as detached so the ethtool ioctl handler\nwill skip dispatching operations to the driver.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38735",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-05",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40160",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen/events: Return -EEXIST for bound VIRQs\n\nChange find_virq() to return -EEXIST when a VIRQ is bound to a\ndifferent CPU than the one passed in.  With that, remove the BUG_ON()\nfrom bind_virq_to_irq() to propogate the error upwards.\n\nSome VIRQs are per-cpu, but others are per-domain or global.  Those must\nbe bound to CPU0 and can then migrate elsewhere.  The lookup for\nper-domain and global will probably fail when migrated off CPU 0,\nespecially when the current CPU is tracked.  This now returns -EEXIST\ninstead of BUG_ON().\n\nA second call to bind a per-domain or global VIRQ is not expected, but\nmake it non-fatal to avoid trying to look up the irq, since we don't\nknow which per_cpu(virq_to_irq) it will be in.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39756",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: Prevent file descriptor table allocations exceeding INT_MAX\n\nWhen sysctl_nr_open is set to a very high value (for example, 1073741816\nas set by systemd), processes attempting to use file descriptors near\nthe limit can trigger massive memory allocation attempts that exceed\nINT_MAX, resulting in a WARNING in mm/slub.c:\n\n  WARNING: CPU: 0 PID: 44 at mm/slub.c:5027 __kvmalloc_node_noprof+0x21a/0x288\n\nThis happens because kvmalloc_array() and kvmalloc() check if the\nrequested size exceeds INT_MAX and emit a warning when the allocation is\nnot flagged with __GFP_NOWARN.\n\nSpecifically, when nr_open is set to 1073741816 (0x3ffffff8) and a\nprocess calls dup2(oldfd, 1073741880), the kernel attempts to allocate:\n- File descriptor array: 1073741880 * 8 bytes = 8,589,935,040 bytes\n- Multiple bitmaps: ~400MB\n- Total allocation size: > 8GB (exceeding INT_MAX = 2,147,483,647)\n\nReproducer:\n1. Set /proc/sys/fs/nr_open to 1073741816:\n   # echo 1073741816 > /proc/sys/fs/nr_open\n\n2. Run a program that uses a high file descriptor:\n   #include <unistd.h>\n   #include <sys/resource.h>\n\n   int main() {\n       struct rlimit rlim = {1073741824, 1073741824};\n       setrlimit(RLIMIT_NOFILE, &rlim);\n       dup2(2, 1073741880);  // Triggers the warning\n       return 0;\n   }\n\n3. Observe WARNING in dmesg at mm/slub.c:5027\n\nsystemd commit a8b627a introduced automatic bumping of fs.nr_open to the\nmaximum possible value. The rationale was that systems with memory\ncontrol groups (memcg) no longer need separate file descriptor limits\nsince memory is properly accounted. However, this change overlooked\nthat:\n\n1. The kernel's allocation functions still enforce INT_MAX as a maximum\n   size regardless of memcg accounting\n2. Programs and tests that legitimately test file descriptor limits can\n   inadvertently trigger massive allocations\n3. The resulting allocations (>8GB) are impractical and will always fail\n\nsystemd's algorithm starts with INT_MAX and keeps halving the value\nuntil the kernel accepts it. On most systems, this results in nr_open\nbeing set to 1073741816 (0x3ffffff8), which is just under 1GB of file\ndescriptors.\n\nWhile processes rarely use file descriptors near this limit in normal\noperation, certain selftests (like\ntools/testing/selftests/core/unshare_test.c) and programs that test file\ndescriptor limits can trigger this issue.\n\nFix this by adding a check in alloc_fdtable() to ensure the requested\nallocation size does not exceed INT_MAX. This causes the operation to\nfail with -EMFILE instead of triggering a kernel warning and avoids the\nimpractical >8GB memory allocation request.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39756",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40104",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nixgbevf: fix mailbox API compatibility by negotiating supported features\n\nThere was backward compatibility in the terms of mailbox API. Various\ndrivers from various OSes supporting 10G adapters from Intel portfolio\ncould easily negotiate mailbox API.\n\nThis convention has been broken since introducing API 1.4.\nCommit 0062e7cc955e (\"ixgbevf: add VF IPsec offload code\") added support\nfor IPSec which is specific only for the kernel ixgbe driver. None of the\nrest of the Intel 10G PF/VF drivers supports it. And actually lack of\nsupport was not included in the IPSec implementation - there were no such\ncode paths. No possibility to negotiate support for the feature was\nintroduced along with introduction of the feature itself.\n\nCommit 339f28964147 (\"ixgbevf: Add support for new mailbox communication\nbetween PF and VF\") increasing API version to 1.5 did the same - it\nintroduced code supported specifically by the PF ESX driver. It altered API\nversion for the VF driver in the same time not touching the version\ndefined for the PF ixgbe driver. It led to additional discrepancies,\nas the code provided within API 1.6 cannot be supported for Linux ixgbe\ndriver as it causes crashes.\n\nThe issue was noticed some time ago and mitigated by Jake within the commit\nd0725312adf5 (\"ixgbevf: stop attempting IPSEC offload on Mailbox API 1.5\").\nAs a result we have regression for IPsec support and after increasing API\nto version 1.6 ixgbevf driver stopped to support ESX MBX.\n\nTo fix this mess add new mailbox op asking PF driver about supported\nfeatures. Basing on a response determine whether to set support for IPSec\nand ESX-specific enhanced mailbox.\n\nNew mailbox op, for compatibility purposes, must be added within new API\nrevision, as API version of OOT PF & VF drivers is already increased to\n1.6 and doesn't incorporate features negotiate op.\n\nFeatures negotiation mechanism gives possibility to be extended with new\nfeatures when needed in the future.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48977",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: af_can: fix NULL pointer dereference in can_rcv_filter\n\nAnalogue to commit 8aa59e355949 (\"can: af_can: fix NULL pointer\ndereference in can_rx_register()\") we need to check for a missing\ninitialization of ml_priv in the receive path of CAN frames.\n\nSince commit 4e096a18867a (\"net: introduce CAN specific pointer in the\nstruct net_device\") the check for dev->type to be ARPHRD_CAN is not\nsufficient anymore since bonding or tun netdevices claim to be CAN\ndevices but do not initialize ml_priv accordingly.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48977",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38473",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix null-ptr-deref in l2cap_sock_resume_cb()\n\nsyzbot reported null-ptr-deref in l2cap_sock_resume_cb(). [0]\n\nl2cap_sock_resume_cb() has a similar problem that was fixed by commit\n1bff51ea59a9 (\"Bluetooth: fix use-after-free error in lock_sock_nested()\").\n\nSince both l2cap_sock_kill() and l2cap_sock_resume_cb() are executed\nunder l2cap_sock_resume_cb(), we can avoid the issue simply by checking\nif chan->data is NULL.\n\nLet's not access to the killed socket in l2cap_sock_resume_cb().\n\n[0]:\nBUG: KASAN: null-ptr-deref in instrument_atomic_write include/linux/instrumented.h:82 [inline]\nBUG: KASAN: null-ptr-deref in clear_bit include/asm-generic/bitops/instrumented-atomic.h:41 [inline]\nBUG: KASAN: null-ptr-deref in l2cap_sock_resume_cb+0xb4/0x17c net/bluetooth/l2cap_sock.c:1711\nWrite of size 8 at addr 0000000000000570 by task kworker/u9:0/52\n\nCPU: 1 UID: 0 PID: 52 Comm: kworker/u9:0 Not tainted 6.16.0-rc4-syzkaller-g7482bb149b9f #0 PREEMPT\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nWorkqueue: hci0 hci_rx_work\nCall trace:\n show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:501 (C)\n __dump_stack+0x30/0x40 lib/dump_stack.c:94\n dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120\n print_report+0x58/0x84 mm/kasan/report.c:524\n kasan_report+0xb0/0x110 mm/kasan/report.c:634\n check_region_inline mm/kasan/generic.c:-1 [inline]\n kasan_check_range+0x264/0x2a4 mm/kasan/generic.c:189\n __kasan_check_write+0x20/0x30 mm/kasan/shadow.c:37\n instrument_atomic_write include/linux/instrumented.h:82 [inline]\n clear_bit include/asm-generic/bitops/instrumented-atomic.h:41 [inline]\n l2cap_sock_resume_cb+0xb4/0x17c net/bluetooth/l2cap_sock.c:1711\n l2cap_security_cfm+0x524/0xea0 net/bluetooth/l2cap_core.c:7357\n hci_auth_cfm include/net/bluetooth/hci_core.h:2092 [inline]\n hci_auth_complete_evt+0x2e8/0xa4c net/bluetooth/hci_event.c:3514\n hci_event_func net/bluetooth/hci_event.c:7511 [inline]\n hci_event_packet+0x650/0xe9c net/bluetooth/hci_event.c:7565\n hci_rx_work+0x320/0xb18 net/bluetooth/hci_core.c:4070\n process_one_work+0x7e8/0x155c kernel/workqueue.c:3238\n process_scheduled_works kernel/workqueue.c:3321 [inline]\n worker_thread+0x958/0xed8 kernel/workqueue.c:3402\n kthread+0x5fc/0x75c kernel/kthread.c:464\n ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:847",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38473",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-28",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68309",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/AER: Fix NULL pointer access by aer_info\n\nThe kzalloc(GFP_KERNEL) may return NULL, so all accesses to aer_info->xxx\nwill result in kernel panic. Fix it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39808",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: hid-ntrig: fix unable to handle page fault in ntrig_report_version()\n\nin ntrig_report_version(), hdev parameter passed from hid_probe().\nsending descriptor to /dev/uhid can make hdev->dev.parent->parent to null\nif hdev->dev.parent->parent is null, usb_dev has\ninvalid address(0xffffffffffffff58) that hid_to_usb_dev(hdev) returned\nwhen usb_rcvctrlpipe() use usb_dev,it trigger\npage fault error for address(0xffffffffffffff58)\n\nadd null check logic to ntrig_report_version()\nbefore calling hid_to_usb_dev()",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-16",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48978",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: core: fix shift-out-of-bounds in hid_report_raw_event\n\nSyzbot reported shift-out-of-bounds in hid_report_raw_event.\n\nmicrosoft 0003:045E:07DA.0001: hid_field_extract() called with n (128) >\n32! (swapper/0)\n======================================================================\nUBSAN: shift-out-of-bounds in drivers/hid/hid-core.c:1323:20\nshift exponent 127 is too large for 32-bit type 'int'\nCPU: 0 PID: 0 Comm: swapper/0 Not tainted\n6.1.0-rc4-syzkaller-00159-g4bbf3422df78 #0\nHardware name: Google Compute Engine/Google Compute Engine, BIOS\nGoogle 10/26/2022\nCall Trace:\n <IRQ>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e3/0x2cb lib/dump_stack.c:106\n ubsan_epilogue lib/ubsan.c:151 [inline]\n __ubsan_handle_shift_out_of_bounds+0x3a6/0x420 lib/ubsan.c:322\n snto32 drivers/hid/hid-core.c:1323 [inline]\n hid_input_fetch_field drivers/hid/hid-core.c:1572 [inline]\n hid_process_report drivers/hid/hid-core.c:1665 [inline]\n hid_report_raw_event+0xd56/0x18b0 drivers/hid/hid-core.c:1998\n hid_input_report+0x408/0x4f0 drivers/hid/hid-core.c:2066\n hid_irq_in+0x459/0x690 drivers/hid/usbhid/hid-core.c:284\n __usb_hcd_giveback_urb+0x369/0x530 drivers/usb/core/hcd.c:1671\n dummy_timer+0x86b/0x3110 drivers/usb/gadget/udc/dummy_hcd.c:1988\n call_timer_fn+0xf5/0x210 kernel/time/timer.c:1474\n expire_timers kernel/time/timer.c:1519 [inline]\n __run_timers+0x76a/0x980 kernel/time/timer.c:1790\n run_timer_softirq+0x63/0xf0 kernel/time/timer.c:1803\n __do_softirq+0x277/0x75b kernel/softirq.c:571\n __irq_exit_rcu+0xec/0x170 kernel/softirq.c:650\n irq_exit_rcu+0x5/0x20 kernel/softirq.c:662\n sysvec_apic_timer_interrupt+0x91/0xb0 arch/x86/kernel/apic/apic.c:1107\n======================================================================\n\nIf the size of the integer (unsigned n) is bigger than 32 in snto32(),\nshift exponent will be too large for 32-bit type 'int', resulting in a\nshift-out-of-bounds bug.\nFix this by adding a check on the size of the integer (unsigned n) in\nsnto32(). To add support for n greater than 32 bits, set n to 32, if n\nis greater than 32.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48978",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48853",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nswiotlb: fix info leak with DMA_FROM_DEVICE\n\nThe problem I'm addressing was discovered by the LTP test covering\ncve-2018-1000204.\n\nA short description of what happens follows:\n1) The test case issues a command code 00 (TEST UNIT READY) via the SG_IO\n   interface with: dxfer_len == 524288, dxdfer_dir == SG_DXFER_FROM_DEV\n   and a corresponding dxferp. The peculiar thing about this is that TUR\n   is not reading from the device.\n2) In sg_start_req() the invocation of blk_rq_map_user() effectively\n   bounces the user-space buffer. As if the device was to transfer into\n   it. Since commit a45b599ad808 (\"scsi: sg: allocate with __GFP_ZERO in\n   sg_build_indirect()\") we make sure this first bounce buffer is\n   allocated with GFP_ZERO.\n3) For the rest of the story we keep ignoring that we have a TUR, so the\n   device won't touch the buffer we prepare as if the we had a\n   DMA_FROM_DEVICE type of situation. My setup uses a virtio-scsi device\n   and the  buffer allocated by SG is mapped by the function\n   virtqueue_add_split() which uses DMA_FROM_DEVICE for the \"in\" sgs (here\n   scatter-gather and not scsi generics). This mapping involves bouncing\n   via the swiotlb (we need swiotlb to do virtio in protected guest like\n   s390 Secure Execution, or AMD SEV).\n4) When the SCSI TUR is done, we first copy back the content of the second\n   (that is swiotlb) bounce buffer (which most likely contains some\n   previous IO data), to the first bounce buffer, which contains all\n   zeros.  Then we copy back the content of the first bounce buffer to\n   the user-space buffer.\n5) The test case detects that the buffer, which it zero-initialized,\n  ain't all zeros and fails.\n\nOne can argue that this is an swiotlb problem, because without swiotlb\nwe leak all zeros, and the swiotlb should be transparent in a sense that\nit does not affect the outcome (if all other participants are well\nbehaved).\n\nCopying the content of the original buffer into the swiotlb buffer is\nthe only way I can think of to make swiotlb transparent in such\nscenarios. So let's do just that if in doubt, but allow the driver\nto tell us that the whole mapped buffer is going to be overwritten,\nin which case we can preserve the old behavior and avoid the performance\nimpact of the extra bounce.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48853",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-12-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38359",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/mm: Fix in_atomic() handling in do_secure_storage_access()\n\nKernel user spaces accesses to not exported pages in atomic context\nincorrectly try to resolve the page fault.\nWith debug options enabled call traces like this can be seen:\n\nBUG: sleeping function called from invalid context at kernel/locking/rwsem.c:1523\nin_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 419074, name: qemu-system-s39\npreempt_count: 1, expected: 0\nRCU nest depth: 0, expected: 0\nINFO: lockdep is turned off.\nPreemption disabled at:\n[<00000383ea47cfa2>] copy_page_from_iter_atomic+0xa2/0x8a0\nCPU: 12 UID: 0 PID: 419074 Comm: qemu-system-s39\nTainted: G        W           6.16.0-20250531.rc0.git0.69b3a602feac.63.fc42.s390x+debug #1 PREEMPT\nTainted: [W]=WARN\nHardware name: IBM 3931 A01 703 (LPAR)\nCall Trace:\n [<00000383e990d282>] dump_stack_lvl+0xa2/0xe8\n [<00000383e99bf152>] __might_resched+0x292/0x2d0\n [<00000383eaa7c374>] down_read+0x34/0x2d0\n [<00000383e99432f8>] do_secure_storage_access+0x108/0x360\n [<00000383eaa724b0>] __do_pgm_check+0x130/0x220\n [<00000383eaa842e4>] pgm_check_handler+0x114/0x160\n [<00000383ea47d028>] copy_page_from_iter_atomic+0x128/0x8a0\n([<00000383ea47d016>] copy_page_from_iter_atomic+0x116/0x8a0)\n [<00000383e9c45eae>] generic_perform_write+0x16e/0x310\n [<00000383e9eb87f4>] ext4_buffered_write_iter+0x84/0x160\n [<00000383e9da0de4>] vfs_write+0x1c4/0x460\n [<00000383e9da123c>] ksys_write+0x7c/0x100\n [<00000383eaa7284e>] __do_syscall+0x15e/0x280\n [<00000383eaa8417e>] system_call+0x6e/0x90\nINFO: lockdep is turned off.\n\nIt is not allowed to take the mmap_lock while in atomic context. Therefore\nhandle such a secure storage access fault as if the accessed page is not\nmapped: the uaccess function will return -EFAULT, and the caller has to\ndeal with this. Usually this means that the access is retried in process\ncontext, which allows to resolve the page fault (or in this case export the\npage).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38359",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-11-18",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49134",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum: Guard against invalid local ports\n\nWhen processing events generated by the device's firmware, the driver\nprotects itself from events reported for non-existent local ports, but\nnot for the CPU port (local port 0), which exists, but does not have all\nthe fields as any local port.\n\nThis can result in a NULL pointer dereference when trying access\n'struct mlxsw_sp_port' fields which are not initialized for CPU port.\n\nCommit 63b08b1f6834 (\"mlxsw: spectrum: Protect driver from buggy firmware\")\nalready handled such issue by bailing early when processing a PUDE event\nreported for the CPU port.\n\nGeneralize the approach by moving the check to a common function and\nmaking use of it in all relevant places.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49134",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38709",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nloop: Avoid updating block size under exclusive owner\n\nSyzbot came up with a reproducer where a loop device block size is\nchanged underneath a mounted filesystem. This causes a mismatch between\nthe block device block size and the block size stored in the superblock\ncausing confusion in various places such as fs/buffer.c. The particular\nissue triggered by syzbot was a warning in __getblk_slow() due to\nrequested buffer size not matching block device block size.\n\nFix the problem by getting exclusive hold of the loop device to change\nits block size. This fails if somebody (such as filesystem) has already\nan exclusive ownership of the block device and thus prevents modifying\nthe loop device under some exclusive owner which doesn't expect it.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38709",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2025-12-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48696",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nregmap: spi: Reserve space for register address/padding\n\nCurrently the max_raw_read and max_raw_write limits in regmap_spi struct\ndo not take into account the additional size of the transmitted register\naddress and padding.  This may result in exceeding the maximum permitted\nSPI message size, which could cause undefined behaviour, e.g. data\ncorruption.\n\nFix regmap_get_spi_bus() to properly adjust the above mentioned limits\nby reserving space for the register address/padding as set in the regmap\nconfiguration.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48696",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2025-04-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47092",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: VMX: Always clear vmx->fail on emulation_required\n\nRevert a relatively recent change that set vmx->fail if the vCPU is in L2\nand emulation_required is true, as that behavior is completely bogus.\nSetting vmx->fail and synthesizing a VM-Exit is contradictory and wrong:\n\n  (a) it's impossible to have both a VM-Fail and VM-Exit\n  (b) vmcs.EXIT_REASON is not modified on VM-Fail\n  (c) emulation_required refers to guest state and guest state checks are\n      always VM-Exits, not VM-Fails.\n\nFor KVM specifically, emulation_required is handled before nested exits\nin __vmx_handle_exit(), thus setting vmx->fail has no immediate effect,\ni.e. KVM calls into handle_invalid_guest_state() and vmx->fail is ignored.\nSetting vmx->fail can ultimately result in a WARN in nested_vmx_vmexit()\nfiring when tearing down the VM as KVM never expects vmx->fail to be set\nwhen L2 is active, KVM always reflects those errors into L1.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 21158 at arch/x86/kvm/vmx/nested.c:4548\n                                nested_vmx_vmexit+0x16bd/0x17e0\n                                arch/x86/kvm/vmx/nested.c:4547\n  Modules linked in:\n  CPU: 0 PID: 21158 Comm: syz-executor.1 Not tainted 5.16.0-rc3-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:nested_vmx_vmexit+0x16bd/0x17e0 arch/x86/kvm/vmx/nested.c:4547\n  Code: <0f> 0b e9 2e f8 ff ff e8 57 b3 5d 00 0f 0b e9 00 f1 ff ff 89 e9 80\n  Call Trace:\n   vmx_leave_nested arch/x86/kvm/vmx/nested.c:6220 [inline]\n   nested_vmx_free_vcpu+0x83/0xc0 arch/x86/kvm/vmx/nested.c:330\n   vmx_free_vcpu+0x11f/0x2a0 arch/x86/kvm/vmx/vmx.c:6799\n   kvm_arch_vcpu_destroy+0x6b/0x240 arch/x86/kvm/x86.c:10989\n   kvm_vcpu_destroy+0x29/0x90 arch/x86/kvm/../../../virt/kvm/kvm_main.c:441\n   kvm_free_vcpus arch/x86/kvm/x86.c:11426 [inline]\n   kvm_arch_destroy_vm+0x3ef/0x6b0 arch/x86/kvm/x86.c:11545\n   kvm_destroy_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:1189 [inline]\n   kvm_put_kvm+0x751/0xe40 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1220\n   kvm_vcpu_release+0x53/0x60 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3489\n   __fput+0x3fc/0x870 fs/file_table.c:280\n   task_work_run+0x146/0x1c0 kernel/task_work.c:164\n   exit_task_work include/linux/task_work.h:32 [inline]\n   do_exit+0x705/0x24f0 kernel/exit.c:832\n   do_group_exit+0x168/0x2d0 kernel/exit.c:929\n   get_signal+0x1740/0x2120 kernel/signal.c:2852\n   arch_do_signal_or_restart+0x9c/0x730 arch/x86/kernel/signal.c:868\n   handle_signal_work kernel/entry/common.c:148 [inline]\n   exit_to_user_mode_loop kernel/entry/common.c:172 [inline]\n   exit_to_user_mode_prepare+0x191/0x220 kernel/entry/common.c:207\n   __syscall_exit_to_user_mode_work kernel/entry/common.c:289 [inline]\n   syscall_exit_to_user_mode+0x2e/0x70 kernel/entry/common.c:300\n   do_syscall_64+0x53/0xd0 arch/x86/entry/common.c:86\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47092",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-04",
                    "modification_date": "2025-02-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38465",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetlink: Fix wraparounds of sk->sk_rmem_alloc.\n\nNetlink has this pattern in some places\n\n  if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n  \tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n\n, which has the same problem fixed by commit 5a465a0da13e (\"udp:\nFix multiple wraparounds of sk->sk_rmem_alloc.\").\n\nFor example, if we set INT_MAX to SO_RCVBUFFORCE, the condition\nis always false as the two operands are of int.\n\nThen, a single socket can eat as many skb as possible until OOM\nhappens, and we can see multiple wraparounds of sk->sk_rmem_alloc.\n\nLet's fix it by using atomic_add_return() and comparing the two\nvariables as unsigned int.\n\nBefore:\n  [root@fedora ~]# ss -f netlink\n  Recv-Q      Send-Q Local Address:Port                Peer Address:Port\n  -1668710080 0               rtnl:nl_wraparound/293               *\n\nAfter:\n  [root@fedora ~]# ss -f netlink\n  Recv-Q     Send-Q Local Address:Port                Peer Address:Port\n  2147483072 0               rtnl:nl_wraparound/290               *\n  ^\n  `--- INT_MAX - 576",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38465",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68313",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/CPU/AMD: Add RDSEED fix for Zen5\n\nThere's an issue with RDSEED's 16-bit and 32-bit register output\nvariants on Zen5 which return a random value of 0 \"at a rate inconsistent\nwith randomness while incorrectly signaling success (CF=1)\". Search the\nweb for AMD-SB-7055 for more detail.\n\nAdd a fix glue which checks microcode revisions.\n\n  [ bp: Add microcode revisions checking, rewrite. ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49123",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: Fix frames flush failure caused by deadlock\n\nWe are seeing below warnings:\n\nkernel: [25393.301506] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0\nkernel: [25398.421509] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0\nkernel: [25398.421831] ath11k_pci 0000:01:00.0: dropping mgmt frame for vdev 0, is_started 0\n\nthis means ath11k fails to flush mgmt. frames because wmi_mgmt_tx_work\nhas no chance to run in 5 seconds.\n\nBy setting /proc/sys/kernel/hung_task_timeout_secs to 20 and increasing\nATH11K_FLUSH_TIMEOUT to 50 we get below warnings:\n\nkernel: [  120.763160] INFO: task wpa_supplicant:924 blocked for more than 20 seconds.\nkernel: [  120.763169]       Not tainted 5.10.90 #12\nkernel: [  120.763177] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\nkernel: [  120.763186] task:wpa_supplicant  state:D stack:    0 pid:  924 ppid:     1 flags:0x000043a0\nkernel: [  120.763201] Call Trace:\nkernel: [  120.763214]  __schedule+0x785/0x12fa\nkernel: [  120.763224]  ? lockdep_hardirqs_on_prepare+0xe2/0x1bb\nkernel: [  120.763242]  schedule+0x7e/0xa1\nkernel: [  120.763253]  schedule_timeout+0x98/0xfe\nkernel: [  120.763266]  ? run_local_timers+0x4a/0x4a\nkernel: [  120.763291]  ath11k_mac_flush_tx_complete+0x197/0x2b1 [ath11k 13c3a9bf37790f4ac8103b3decf7ab4008ac314a]\nkernel: [  120.763306]  ? init_wait_entry+0x2e/0x2e\nkernel: [  120.763343]  __ieee80211_flush_queues+0x167/0x21f [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763378]  __ieee80211_recalc_idle+0x105/0x125 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763411]  ieee80211_recalc_idle+0x14/0x27 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763441]  ieee80211_free_chanctx+0x77/0xa2 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763473]  __ieee80211_vif_release_channel+0x100/0x131 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763540]  ieee80211_vif_release_channel+0x66/0x81 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763572]  ieee80211_destroy_auth_data+0xa3/0xe6 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763612]  ieee80211_mgd_deauth+0x178/0x29b [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]\nkernel: [  120.763654]  cfg80211_mlme_deauth+0x1a8/0x22c [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]\nkernel: [  120.763697]  nl80211_deauthenticate+0xfa/0x123 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]\nkernel: [  120.763715]  genl_rcv_msg+0x392/0x3c2\nkernel: [  120.763750]  ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]\nkernel: [  120.763782]  ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]\nkernel: [  120.763802]  ? genl_rcv+0x36/0x36\nkernel: [  120.763814]  netlink_rcv_skb+0x89/0xf7\nkernel: [  120.763829]  genl_rcv+0x28/0x36\nkernel: [  120.763840]  netlink_unicast+0x179/0x24b\nkernel: [  120.763854]  netlink_sendmsg+0x393/0x401\nkernel: [  120.763872]  sock_sendmsg+0x72/0x76\nkernel: [  120.763886]  ____sys_sendmsg+0x170/0x1e6\nkernel: [  120.763897]  ? copy_msghdr_from_user+0x7a/0xa2\nkernel: [  120.763914]  ___sys_sendmsg+0x95/0xd1\nkernel: [  120.763940]  __sys_sendmsg+0x85/0xbf\nkernel: [  120.763956]  do_syscall_64+0x43/0x55\nkernel: [  120.763966]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\nkernel: [  120.763977] RIP: 0033:0x79089f3fcc83\nkernel: [  120.763986] RSP: 002b:00007ffe604f0508 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nkernel: [  120.763997] RAX: ffffffffffffffda RBX: 000059b40e987690 RCX: 000079089f3fcc83\nkernel: [  120.764006] RDX: 0000000000000000 RSI: 00007ffe604f0558 RDI: 0000000000000009\nkernel: [  120.764014] RBP: 00007ffe604f0540 R08: 0000000000000004 R09: 0000000000400000\nkernel: [  120.764023] R10: 00007ffe604f0638 R11: 0000000000000246 R12: 000059b40ea04980\nkernel: [  120.764032] R13: 00007ffe604\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49123",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40102",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: Prevent access to vCPU events before init\n\nAnother day, another syzkaller bug. KVM erroneously allows userspace to\npend vCPU events for a vCPU that hasn't been initialized yet, leading to\nKVM interpreting a bunch of uninitialized garbage for routing /\ninjecting the exception.\n\nIn one case the injection code and the hyp disagree on whether the vCPU\nhas a 32bit EL1 and put the vCPU into an illegal mode for AArch64,\ntripping the BUG() in exception_target_el() during the next injection:\n\n  kernel BUG at arch/arm64/kvm/inject_fault.c:40!\n  Internal error: Oops - BUG: 00000000f2000800 [#1]  SMP\n  CPU: 3 UID: 0 PID: 318 Comm: repro Not tainted 6.17.0-rc4-00104-g10fd0285305d #6 PREEMPT\n  Hardware name: linux,dummy-virt (DT)\n  pstate: 21402009 (nzCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n  pc : exception_target_el+0x88/0x8c\n  lr : pend_serror_exception+0x18/0x13c\n  sp : ffff800082f03a10\n  x29: ffff800082f03a10 x28: ffff0000cb132280 x27: 0000000000000000\n  x26: 0000000000000000 x25: ffff0000c2a99c20 x24: 0000000000000000\n  x23: 0000000000008000 x22: 0000000000000002 x21: 0000000000000004\n  x20: 0000000000008000 x19: ffff0000c2a99c20 x18: 0000000000000000\n  x17: 0000000000000000 x16: 0000000000000000 x15: 00000000200000c0\n  x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\n  x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000\n  x8 : ffff800082f03af8 x7 : 0000000000000000 x6 : 0000000000000000\n  x5 : ffff800080f621f0 x4 : 0000000000000000 x3 : 0000000000000000\n  x2 : 000000000040009b x1 : 0000000000000003 x0 : ffff0000c2a99c20\n  Call trace:\n   exception_target_el+0x88/0x8c (P)\n   kvm_inject_serror_esr+0x40/0x3b4\n   __kvm_arm_vcpu_set_events+0xf0/0x100\n   kvm_arch_vcpu_ioctl+0x180/0x9d4\n   kvm_vcpu_ioctl+0x60c/0x9f4\n   __arm64_sys_ioctl+0xac/0x104\n   invoke_syscall+0x48/0x110\n   el0_svc_common.constprop.0+0x40/0xe0\n   do_el0_svc+0x1c/0x28\n   el0_svc+0x34/0xf0\n   el0t_64_sync_handler+0xa0/0xe4\n   el0t_64_sync+0x198/0x19c\n  Code: f946bc01 b4fffe61 9101e020 17fffff2 (d4210000)\n\nReject the ioctls outright as no sane VMM would call these before\nKVM_ARM_VCPU_INIT anyway. Even if it did the exception would've been\nthrown away by the eventual reset of the vCPU's state.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47620",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: refactor malicious adv data check\n\nCheck for out-of-bound read was being performed at the end of while\nnum_reports loop, and would fill journal with false positives. Added\ncheck to beginning of loop processing so that it doesn't get checked\nafter ptr has been advanced.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47620",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68261",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: add i_data_sem protection in ext4_destroy_inline_data_nolock()\n\nFix a race between inline data destruction and block mapping.\n\nThe function ext4_destroy_inline_data_nolock() changes the inode data\nlayout by clearing EXT4_INODE_INLINE_DATA and setting EXT4_INODE_EXTENTS.\nAt the same time, another thread may execute ext4_map_blocks(), which\ntests EXT4_INODE_EXTENTS to decide whether to call ext4_ext_map_blocks()\nor ext4_ind_map_blocks().\n\nWithout i_data_sem protection, ext4_ind_map_blocks() may receive inode\nwith EXT4_INODE_EXTENTS flag and triggering assert.\n\nkernel BUG at fs/ext4/indirect.c:546!\nEXT4-fs (loop2): unmounting filesystem.\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nRIP: 0010:ext4_ind_map_blocks.cold+0x2b/0x5a fs/ext4/indirect.c:546\n\nCall Trace:\n <TASK>\n ext4_map_blocks+0xb9b/0x16f0 fs/ext4/inode.c:681\n _ext4_get_block+0x242/0x590 fs/ext4/inode.c:822\n ext4_block_write_begin+0x48b/0x12c0 fs/ext4/inode.c:1124\n ext4_write_begin+0x598/0xef0 fs/ext4/inode.c:1255\n ext4_da_write_begin+0x21e/0x9c0 fs/ext4/inode.c:3000\n generic_perform_write+0x259/0x5d0 mm/filemap.c:3846\n ext4_buffered_write_iter+0x15b/0x470 fs/ext4/file.c:285\n ext4_file_write_iter+0x8e0/0x17f0 fs/ext4/file.c:679\n call_write_iter include/linux/fs.h:2271 [inline]\n do_iter_readv_writev+0x212/0x3c0 fs/read_write.c:735\n do_iter_write+0x186/0x710 fs/read_write.c:861\n vfs_iter_write+0x70/0xa0 fs/read_write.c:902\n iter_file_splice_write+0x73b/0xc90 fs/splice.c:685\n do_splice_from fs/splice.c:763 [inline]\n direct_splice_actor+0x10f/0x170 fs/splice.c:950\n splice_direct_to_actor+0x33a/0xa10 fs/splice.c:896\n do_splice_direct+0x1a9/0x280 fs/splice.c:1002\n do_sendfile+0xb13/0x12c0 fs/read_write.c:1255\n __do_sys_sendfile64 fs/read_write.c:1323 [inline]\n __se_sys_sendfile64 fs/read_write.c:1309 [inline]\n __x64_sys_sendfile64+0x1cf/0x210 fs/read_write.c:1309\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x6e/0xd8",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48889",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: Intel: sof-nau8825: fix module alias overflow\n\nThe maximum name length for a platform_device_id entry is 20 characters\nincluding the trailing NUL byte. The sof_nau8825.c file exceeds that,\nwhich causes an obscure error message:\n\nsound/soc/intel/boards/snd-soc-sof_nau8825.mod.c:35:45: error: illegal character encoding in string literal [-Werror,-Winvalid-source-encoding]\nMODULE_ALIAS(\"platform:adl_max98373_nau8825<U+0018><AA>\");\n                                                   ^~~~\ninclude/linux/module.h:168:49: note: expanded from macro 'MODULE_ALIAS'\n                                                ^~~~~~\ninclude/linux/module.h:165:56: note: expanded from macro 'MODULE_INFO'\n                                                       ^~~~\ninclude/linux/moduleparam.h:26:47: note: expanded from macro '__MODULE_INFO'\n                = __MODULE_INFO_PREFIX __stringify(tag) \"=\" info\n\nI could not figure out how to make the module handling robust enough\nto handle this better, but as a quick fix, using slightly shorter\nnames that are still unique avoids the build issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48889",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-21",
                    "modification_date": "2024-09-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49116",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: use memset avoid memory leaks\n\nUse memset to initialize structs to prevent memory leaks\nin l2cap_ecred_connect",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49116",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48802",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/proc: task_mmu.c: don't read mapcount for migration entry\n\nThe syzbot reported the below BUG:\n\n  kernel BUG at include/linux/page-flags.h:785!\n  invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n  CPU: 1 PID: 4392 Comm: syz-executor560 Not tainted 5.16.0-rc6-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:PageDoubleMap include/linux/page-flags.h:785 [inline]\n  RIP: 0010:__page_mapcount+0x2d2/0x350 mm/util.c:744\n  Call Trace:\n    page_mapcount include/linux/mm.h:837 [inline]\n    smaps_account+0x470/0xb10 fs/proc/task_mmu.c:466\n    smaps_pte_entry fs/proc/task_mmu.c:538 [inline]\n    smaps_pte_range+0x611/0x1250 fs/proc/task_mmu.c:601\n    walk_pmd_range mm/pagewalk.c:128 [inline]\n    walk_pud_range mm/pagewalk.c:205 [inline]\n    walk_p4d_range mm/pagewalk.c:240 [inline]\n    walk_pgd_range mm/pagewalk.c:277 [inline]\n    __walk_page_range+0xe23/0x1ea0 mm/pagewalk.c:379\n    walk_page_vma+0x277/0x350 mm/pagewalk.c:530\n    smap_gather_stats.part.0+0x148/0x260 fs/proc/task_mmu.c:768\n    smap_gather_stats fs/proc/task_mmu.c:741 [inline]\n    show_smap+0xc6/0x440 fs/proc/task_mmu.c:822\n    seq_read_iter+0xbb0/0x1240 fs/seq_file.c:272\n    seq_read+0x3e0/0x5b0 fs/seq_file.c:162\n    vfs_read+0x1b5/0x600 fs/read_write.c:479\n    ksys_read+0x12d/0x250 fs/read_write.c:619\n    do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n    do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n    entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe reproducer was trying to read /proc/$PID/smaps when calling\nMADV_FREE at the mean time.  MADV_FREE may split THPs if it is called\nfor partial THP.  It may trigger the below race:\n\n           CPU A                         CPU B\n           -----                         -----\n  smaps walk:                      MADV_FREE:\n  page_mapcount()\n    PageCompound()\n                                   split_huge_page()\n    page = compound_head(page)\n    PageDoubleMap(page)\n\nWhen calling PageDoubleMap() this page is not a tail page of THP anymore\nso the BUG is triggered.\n\nThis could be fixed by elevated refcount of the page before calling\nmapcount, but that would prevent it from counting migration entries, and\nit seems overkilling because the race just could happen when PMD is\nsplit so all PTE entries of tail pages are actually migration entries,\nand smaps_account() does treat migration entries as mapcount == 1 as\nKirill pointed out.\n\nAdd a new parameter for smaps_account() to tell this entry is migration\nentry then skip calling page_mapcount().  Don't skip getting mapcount\nfor device private entries since they do track references with mapcount.\n\nPagemap also has the similar issue although it was not reported.  Fixed\nit as well.\n\n[shy828301@gmail.com: v4]\n[nathan@kernel.org: avoid unused variable warning in pagemap_pmd_range()]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48802",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-10-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39857",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix one NULL pointer dereference in smc_ib_is_sg_need_sync()\n\nBUG: kernel NULL pointer dereference, address: 00000000000002ec\nPGD 0 P4D 0\nOops: Oops: 0000 [#1] SMP PTI\nCPU: 28 UID: 0 PID: 343 Comm: kworker/28:1 Kdump: loaded Tainted: G        OE       6.17.0-rc2+ #9 NONE\nTainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014\nWorkqueue: smc_hs_wq smc_listen_work [smc]\nRIP: 0010:smc_ib_is_sg_need_sync+0x9e/0xd0 [smc]\n...\nCall Trace:\n <TASK>\n smcr_buf_map_link+0x211/0x2a0 [smc]\n __smc_buf_create+0x522/0x970 [smc]\n smc_buf_create+0x3a/0x110 [smc]\n smc_find_rdma_v2_device_serv+0x18f/0x240 [smc]\n ? smc_vlan_by_tcpsk+0x7e/0xe0 [smc]\n smc_listen_find_device+0x1dd/0x2b0 [smc]\n smc_listen_work+0x30f/0x580 [smc]\n process_one_work+0x18c/0x340\n worker_thread+0x242/0x360\n kthread+0xe7/0x220\n ret_from_fork+0x13a/0x160\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nIf the software RoCE device is used, ibdev->dma_device is a null pointer.\nAs a result, the problem occurs. Null pointer detection is added to\nprevent problems.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48969",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen-netfront: Fix NULL sring after live migration\n\nA NAPI is setup for each network sring to poll data to kernel\nThe sring with source host is destroyed before live migration and\nnew sring with target host is setup after live migration.\nThe NAPI for the old sring is not deleted until setup new sring\nwith target host after migration. With busy_poll/busy_read enabled,\nthe NAPI can be polled before got deleted when resume VM.\n\nBUG: unable to handle kernel NULL pointer dereference at\n0000000000000008\nIP: xennet_poll+0xae/0xd20\nPGD 0 P4D 0\nOops: 0000 [#1] SMP PTI\nCall Trace:\n finish_task_switch+0x71/0x230\n timerqueue_del+0x1d/0x40\n hrtimer_try_to_cancel+0xb5/0x110\n xennet_alloc_rx_buffers+0x2a0/0x2a0\n napi_busy_loop+0xdb/0x270\n sock_poll+0x87/0x90\n do_sys_poll+0x26f/0x580\n tracing_map_insert+0x1d4/0x2f0\n event_hist_trigger+0x14a/0x260\n\n finish_task_switch+0x71/0x230\n __schedule+0x256/0x890\n recalc_sigpending+0x1b/0x50\n xen_sched_clock+0x15/0x20\n __rb_reserve_next+0x12d/0x140\n ring_buffer_lock_reserve+0x123/0x3d0\n event_triggers_call+0x87/0xb0\n trace_event_buffer_commit+0x1c4/0x210\n xen_clocksource_get_cycles+0x15/0x20\n ktime_get_ts64+0x51/0xf0\n SyS_ppoll+0x160/0x1a0\n SyS_ppoll+0x160/0x1a0\n do_syscall_64+0x73/0x130\n entry_SYSCALL_64_after_hwframe+0x41/0xa6\n...\nRIP: xennet_poll+0xae/0xd20 RSP: ffffb4f041933900\nCR2: 0000000000000008\n---[ end trace f8601785b354351c ]---\n\nxen frontend should remove the NAPIs for the old srings before live\nmigration as the bond srings are destroyed\n\nThere is a tiny window between the srings are set to NULL and\nthe NAPIs are disabled, It is safe as the NAPI threads are still\nfrozen at that time",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48969",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38539",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Add down_write(trace_event_sem) when adding trace event\n\nWhen a module is loaded, it adds trace events defined by the module. It\nmay also need to modify the modules trace printk formats to replace enum\nnames with their values.\n\nIf two modules are loaded at the same time, the adding of the event to the\nftrace_events list can corrupt the walking of the list in the code that is\nmodifying the printk format strings and crash the kernel.\n\nThe addition of the event should take the trace_event_sem for write while\nit adds the new event.\n\nAlso add a lockdep_assert_held() on that semaphore in\n__trace_add_event_dirs() as it iterates the list.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38539",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-16",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38560",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/sev: Evict cache lines during SNP memory validation\n\nAn SNP cache coherency vulnerability requires a cache line eviction\nmitigation when validating memory after a page state change to private.\nThe specific mitigation is to touch the first and last byte of each 4K\npage that is being validated. There is no need to perform the mitigation\nwhen performing a page state change to shared and rescinding validation.\n\nCPUID bit Fn8000001F_EBX[31] defines the COHERENCY_SFW_NO CPUID bit\nthat, when set, indicates that the software mitigation for this\nvulnerability is not needed.\n\nImplement the mitigation and invoke it when validating memory (making it\nprivate) and the COHERENCY_SFW_NO bit is not set, indicating the SNP\nguest is vulnerable.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39782",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: prevent softlockup in jbd2_log_do_checkpoint()\n\nBoth jbd2_log_do_checkpoint() and jbd2_journal_shrink_checkpoint_list()\nperiodically release j_list_lock after processing a batch of buffers to\navoid long hold times on the j_list_lock. However, since both functions\ncontend for j_list_lock, the combined time spent waiting and processing\ncan be significant.\n\njbd2_journal_shrink_checkpoint_list() explicitly calls cond_resched() when\nneed_resched() is true to avoid softlockups during prolonged operations.\nBut jbd2_log_do_checkpoint() only exits its loop when need_resched() is\ntrue, relying on potentially sleeping functions like __flush_batch() or\nwait_on_buffer() to trigger rescheduling. If those functions do not sleep,\nthe kernel may hit a softlockup.\n\nwatchdog: BUG: soft lockup - CPU#3 stuck for 156s! [kworker/u129:2:373]\nCPU: 3 PID: 373 Comm: kworker/u129:2 Kdump: loaded Not tainted 6.6.0+ #10\nHardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.27 06/13/2017\nWorkqueue: writeback wb_workfn (flush-7:2)\npstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : native_queued_spin_lock_slowpath+0x358/0x418\nlr : jbd2_log_do_checkpoint+0x31c/0x438 [jbd2]\nCall trace:\n native_queued_spin_lock_slowpath+0x358/0x418\n jbd2_log_do_checkpoint+0x31c/0x438 [jbd2]\n __jbd2_log_wait_for_space+0xfc/0x2f8 [jbd2]\n add_transaction_credits+0x3bc/0x418 [jbd2]\n start_this_handle+0xf8/0x560 [jbd2]\n jbd2__journal_start+0x118/0x228 [jbd2]\n __ext4_journal_start_sb+0x110/0x188 [ext4]\n ext4_do_writepages+0x3dc/0x740 [ext4]\n ext4_writepages+0xa4/0x190 [ext4]\n do_writepages+0x94/0x228\n __writeback_single_inode+0x48/0x318\n writeback_sb_inodes+0x204/0x590\n __writeback_inodes_wb+0x54/0xf8\n wb_writeback+0x2cc/0x3d8\n wb_do_writeback+0x2e0/0x2f8\n wb_workfn+0x80/0x2a8\n process_one_work+0x178/0x3e8\n worker_thread+0x234/0x3b8\n kthread+0xf0/0x108\n ret_from_fork+0x10/0x20\n\nSo explicitly call cond_resched() in jbd2_log_do_checkpoint() to avoid\nsoftlockup.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49077",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmmmremap.c: avoid pointless invalidate_range_start/end on mremap(old_size=0)\n\nIf an mremap() syscall with old_size=0 ends up in move_page_tables(), it\nwill call invalidate_range_start()/invalidate_range_end() unnecessarily,\ni.e.  with an empty range.\n\nThis causes a WARN in KVM's mmu_notifier.  In the past, empty ranges\nhave been diagnosed to be off-by-one bugs, hence the WARNing.  Given the\nlow (so far) number of unique reports, the benefits of detecting more\nbuggy callers seem to outweigh the cost of having to fix cases such as\nthis one, where userspace is doing something silly.  In this particular\ncase, an early return from move_page_tables() is enough to fix the\nissue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49077",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48911",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_queue: fix possible use-after-free\n\nEric Dumazet says:\n  The sock_hold() side seems suspect, because there is no guarantee\n  that sk_refcnt is not already 0.\n\nOn failure, we cannot queue the packet and need to indicate an\nerror.  The packet will be dropped by the caller.\n\nv2: split skb prefetch hunk into separate change",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48911",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47397",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: break out if skb_header_pointer returns NULL in sctp_rcv_ootb\n\nWe should always check if skb_header_pointer's return is NULL before\nusing it, otherwise it may cause null-ptr-deref, as syzbot reported:\n\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  RIP: 0010:sctp_rcv_ootb net/sctp/input.c:705 [inline]\n  RIP: 0010:sctp_rcv+0x1d84/0x3220 net/sctp/input.c:196\n  Call Trace:\n  <IRQ>\n   sctp6_rcv+0x38/0x60 net/sctp/ipv6.c:1109\n   ip6_protocol_deliver_rcu+0x2e9/0x1ca0 net/ipv6/ip6_input.c:422\n   ip6_input_finish+0x62/0x170 net/ipv6/ip6_input.c:463\n   NF_HOOK include/linux/netfilter.h:307 [inline]\n   NF_HOOK include/linux/netfilter.h:301 [inline]\n   ip6_input+0x9c/0xd0 net/ipv6/ip6_input.c:472\n   dst_input include/net/dst.h:460 [inline]\n   ip6_rcv_finish net/ipv6/ip6_input.c:76 [inline]\n   NF_HOOK include/linux/netfilter.h:307 [inline]\n   NF_HOOK include/linux/netfilter.h:301 [inline]\n   ipv6_rcv+0x28c/0x3c0 net/ipv6/ip6_input.c:297",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47397",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-46961",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/gic-v3: Do not enable irqs when handling spurious interrups\n\nWe triggered the following error while running our 4.19 kernel\nwith the pseudo-NMI patches backported to it:\n\n[   14.816231] ------------[ cut here ]------------\n[   14.816231] kernel BUG at irq.c:99!\n[   14.816232] Internal error: Oops - BUG: 0 [#1] SMP\n[   14.816232] Process swapper/0 (pid: 0, stack limit = 0x(____ptrval____))\n[   14.816233] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O      4.19.95.aarch64 #14\n[   14.816233] Hardware name: evb (DT)\n[   14.816234] pstate: 80400085 (Nzcv daIf +PAN -UAO)\n[   14.816234] pc : asm_nmi_enter+0x94/0x98\n[   14.816235] lr : asm_nmi_enter+0x18/0x98\n[   14.816235] sp : ffff000008003c50\n[   14.816235] pmr_save: 00000070\n[   14.816237] x29: ffff000008003c50 x28: ffff0000095f56c0\n[   14.816238] x27: 0000000000000000 x26: ffff000008004000\n[   14.816239] x25: 00000000015e0000 x24: ffff8008fb916000\n[   14.816240] x23: 0000000020400005 x22: ffff0000080817cc\n[   14.816241] x21: ffff000008003da0 x20: 0000000000000060\n[   14.816242] x19: 00000000000003ff x18: ffffffffffffffff\n[   14.816243] x17: 0000000000000008 x16: 003d090000000000\n[   14.816244] x15: ffff0000095ea6c8 x14: ffff8008fff5ab40\n[   14.816244] x13: ffff8008fff58b9d x12: 0000000000000000\n[   14.816245] x11: ffff000008c8a200 x10: 000000008e31fca5\n[   14.816246] x9 : ffff000008c8a208 x8 : 000000000000000f\n[   14.816247] x7 : 0000000000000004 x6 : ffff8008fff58b9e\n[   14.816248] x5 : 0000000000000000 x4 : 0000000080000000\n[   14.816249] x3 : 0000000000000000 x2 : 0000000080000000\n[   14.816250] x1 : 0000000000120000 x0 : ffff0000095f56c0\n[   14.816251] Call trace:\n[   14.816251]  asm_nmi_enter+0x94/0x98\n[   14.816251]  el1_irq+0x8c/0x180                    (IRQ C)\n[   14.816252]  gic_handle_irq+0xbc/0x2e4\n[   14.816252]  el1_irq+0xcc/0x180                    (IRQ B)\n[   14.816253]  arch_timer_handler_virt+0x38/0x58\n[   14.816253]  handle_percpu_devid_irq+0x90/0x240\n[   14.816253]  generic_handle_irq+0x34/0x50\n[   14.816254]  __handle_domain_irq+0x68/0xc0\n[   14.816254]  gic_handle_irq+0xf8/0x2e4\n[   14.816255]  el1_irq+0xcc/0x180                    (IRQ A)\n[   14.816255]  arch_cpu_idle+0x34/0x1c8\n[   14.816255]  default_idle_call+0x24/0x44\n[   14.816256]  do_idle+0x1d0/0x2c8\n[   14.816256]  cpu_startup_entry+0x28/0x30\n[   14.816256]  rest_init+0xb8/0xc8\n[   14.816257]  start_kernel+0x4c8/0x4f4\n[   14.816257] Code: 940587f1 d5384100 b9401001 36a7fd01 (d4210000)\n[   14.816258] Modules linked in: start_dp(O) smeth(O)\n[   15.103092] ---[ end trace 701753956cb14aa8 ]---\n[   15.103093] Kernel panic - not syncing: Fatal exception in interrupt\n[   15.103099] SMP: stopping secondary CPUs\n[   15.103100] Kernel Offset: disabled\n[   15.103100] CPU features: 0x36,a2400218\n[   15.103100] Memory Limit: none\n\nwhich is cause by a 'BUG_ON(in_nmi())' in nmi_enter().\n\nFrom the call trace, we can find three interrupts (noted A, B, C above):\ninterrupt (A) is preempted by (B), which is further interrupted by (C).\n\nSubsequent investigations show that (B) results in nmi_enter() being\ncalled, but that it actually is a spurious interrupt. Furthermore,\ninterrupts are reenabled in the context of (B), and (C) fires with\nNMI priority. We end-up with a nested NMI situation, something\nwe definitely do not want to (and cannot) handle.\n\nThe bug here is that spurious interrupts should never result in any\nstate change, and we should just return to the interrupted context.\nMoving the handling of spurious interrupts as early as possible in\nthe GICv3 handler fixes this issue.\n\n[maz: rewrote commit message, corrected Fixes: tag]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46961",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-27",
                    "modification_date": "2025-04-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49048",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: fix panic when forwarding a pkt with no in6 dev\n\nkongweibin reported a kernel panic in ip6_forward() when input interface\nhas no in6 dev associated.\n\nThe following tc commands were used to reproduce this panic:\ntc qdisc del dev vxlan100 root\ntc qdisc add dev vxlan100 root netem corrupt 5%",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49048",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40075",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_metrics: use dst_dev_net_rcu()\n\nReplace three dst_dev() with a lockdep enabled helper.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38001",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: hfsc: Address reentrant enqueue adding class to eltree twice\n\nSavino says:\n    \"We are writing to report that this recent patch\n    (141d34391abbb315d68556b7c67ad97885407547) [1]\n    can be bypassed, and a UAF can still occur when HFSC is utilized with\n    NETEM.\n\n    The patch only checks the cl->cl_nactive field to determine whether\n    it is the first insertion or not [2], but this field is only\n    incremented by init_vf [3].\n\n    By using HFSC_RSC (which uses init_ed) [4], it is possible to bypass the\n    check and insert the class twice in the eltree.\n    Under normal conditions, this would lead to an infinite loop in\n    hfsc_dequeue for the reasons we already explained in this report [5].\n\n    However, if TBF is added as root qdisc and it is configured with a\n    very low rate,\n    it can be utilized to prevent packets from being dequeued.\n    This behavior can be exploited to perform subsequent insertions in the\n    HFSC eltree and cause a UAF.\"\n\nTo fix both the UAF and the infinite loop, with netem as an hfsc child,\ncheck explicitly in hfsc_enqueue whether the class is already in the eltree\nwhenever the HFSC_RSC flag is set.\n\n[1] https://web.git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=141d34391abbb315d68556b7c67ad97885407547\n[2] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L1572\n[3] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L677\n[4] https://elixir.bootlin.com/linux/v6.15-rc5/source/net/sched/sch_hfsc.c#L1574\n[5] https://lore.kernel.org/netdev/8DuRWwfqjoRDLDmBMlIfbrsZg9Gx50DHJc1ilxsEBNe2D6NMoigR_eIRIG0LOjMc3r10nUUZtArXx4oZBIdUfZQrwjcQhdinnMis_0G7VEk=@willsroot.io/T/#u",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38001",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-06-06",
                    "modification_date": "2025-12-17",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2025-38553",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: Restrict conditions for adding duplicating netems to qdisc tree\n\nnetem_enqueue's duplication prevention logic breaks when a netem\nresides in a qdisc tree with other netems - this can lead to a\nsoft lockup and OOM loop in netem_dequeue, as seen in [1].\nEnsure that a duplicating netem cannot exist in a tree with other\nnetems.\n\nPrevious approaches suggested in discussions in chronological order:\n\n1) Track duplication status or ttl in the sk_buff struct. Considered\ntoo specific a use case to extend such a struct, though this would\nbe a resilient fix and address other previous and potential future\nDOS bugs like the one described in loopy fun [2].\n\n2) Restrict netem_enqueue recursion depth like in act_mirred with a\nper cpu variable. However, netem_dequeue can call enqueue on its\nchild, and the depth restriction could be bypassed if the child is a\nnetem.\n\n3) Use the same approach as in 2, but add metadata in netem_skb_cb\nto handle the netem_dequeue case and track a packet's involvement\nin duplication. This is an overly complex approach, and Jamal\nnotes that the skb cb can be overwritten to circumvent this\nsafeguard.\n\n4) Prevent the addition of a netem to a qdisc tree if its ancestral\npath contains a netem. However, filters and actions can cause a\npacket to change paths when re-enqueued to the root from netem\nduplication, leading us to the current solution: prevent a\nduplicating netem from inhabiting the same tree as other netems.\n\n[1] https://lore.kernel.org/netdev/8DuRWwfqjoRDLDmBMlIfbrsZg9Gx50DHJc1ilxsEBNe2D6NMoigR_eIRIG0LOjMc3r10nUUZtArXx4oZBIdUfZQrwjcQhdinnMis_0G7VEk=@willsroot.io/\n[2] https://lwn.net/Articles/719297/",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38553",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48844",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_core: Fix leaking sent_cmd skb\n\nsent_cmd memory is not freed before freeing hci_dev causing it to leak\nit contents.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48844",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-4135",
                    "description": "A memory leak vulnerability was found in the Linux kernel's eBPF for the Simulated networking device driver in the way user uses BPF for the device such that function nsim_map_alloc_elem being called. A local user could use this flaw to get unauthorized access to some data.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-4135",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-07-14",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48904",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/amd: Fix I/O page table memory leak\n\nThe current logic updates the I/O page table mode for the domain\nbefore calling the logic to free memory used for the page table.\nThis results in IOMMU page table memory leak, and can be observed\nwhen launching VM w/ pass-through devices.\n\nFix by freeing the memory used for page table before updating the mode.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48904",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48861",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvdpa: fix use-after-free on vp_vdpa_remove\n\nWhen vp_vdpa driver is unbind, vp_vdpa is freed in vdpa_unregister_device\nand then vp_vdpa->mdev.pci_dev is dereferenced in vp_modern_remove,\ntriggering use-after-free.\n\nCall Trace of unbinding driver free vp_vdpa :\ndo_syscall_64\n  vfs_write\n    kernfs_fop_write_iter\n      device_release_driver_internal\n        pci_device_remove\n          vp_vdpa_remove\n            vdpa_unregister_device\n              kobject_release\n                device_release\n                  kfree\n\nCall Trace of dereference vp_vdpa->mdev.pci_dev:\nvp_modern_remove\n  pci_release_selected_regions\n    pci_release_region\n      pci_resource_len\n        pci_resource_end\n          (dev)->resource[(bar)].end",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48861",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47359",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix soft lockup during fsstress\n\nBelow traces are observed during fsstress and system got hung.\n[  130.698396] watchdog: BUG: soft lockup - CPU#6 stuck for 26s!",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47359",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49110",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: conntrack: revisit gc autotuning\n\nas of commit 4608fdfc07e1\n(\"netfilter: conntrack: collect all entries in one cycle\")\nconntrack gc was changed to run every 2 minutes.\n\nOn systems where conntrack hash table is set to large value, most evictions\nhappen from gc worker rather than the packet path due to hash table\ndistribution.\n\nThis causes netlink event overflows when events are collected.\n\nThis change collects average expiry of scanned entries and\nreschedules to the average remaining value, within 1 to 60 second interval.\n\nTo avoid event overflows, reschedule after each bucket and add a\nlimit for both run time and number of evictions per run.\n\nIf more entries have to be evicted, reschedule and restart 1 jiffy\ninto the future.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49110",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-36789",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: dev: can_get_echo_skb(): prevent call to kfree_skb() in hard IRQ context\n\nIf a driver calls can_get_echo_skb() during a hardware IRQ (which is often, but\nnot always, the case), the 'WARN_ON(in_irq)' in\nnet/core/skbuff.c#skb_release_head_state() might be triggered, under network\ncongestion circumstances, together with the potential risk of a NULL pointer\ndereference.\n\nThe root cause of this issue is the call to kfree_skb() instead of\ndev_kfree_skb_irq() in net/core/dev.c#enqueue_to_backlog().\n\nThis patch prevents the skb to be freed within the call to netif_rx() by\nincrementing its reference count with skb_get(). The skb is finally freed by\none of the in-irq-context safe functions: dev_consume_skb_any() or\ndev_kfree_skb_any(). The \"any\" version is used because some drivers might call\ncan_get_echo_skb() in a normal context.\n\nThe reason for this issue to occur is that initially, in the core network\nstack, loopback skb were not supposed to be received in hardware IRQ context.\nThe CAN stack is an exeption.\n\nThis bug was previously reported back in 2017 in [1] but the proposed patch\nnever got accepted.\n\nWhile [1] directly modifies net/core/dev.c, we try to propose here a\nsmoother modification local to CAN network stack (the assumption\nbehind is that only CAN devices are affected by this issue).\n\n[1] http://lore.kernel.org/r/57a3ffb6-3309-3ad5-5a34-e93c3fe3614d@cetitec.com",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-36789",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-04-17",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-46908",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Use correct permission flag for mixed signed bounds arithmetic\n\nWe forbid adding unknown scalars with mixed signed bounds due to the\nspectre v1 masking mitigation. Hence this also needs bypass_spec_v1\nflag instead of allow_ptr_leaks.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46908",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-27",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47227",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/fpu: Prevent state corruption in __fpu__restore_sig()\n\nThe non-compacted slowpath uses __copy_from_user() and copies the entire\nuser buffer into the kernel buffer, verbatim.  This means that the kernel\nbuffer may now contain entirely invalid state on which XRSTOR will #GP.\nvalidate_user_xstate_header() can detect some of that corruption, but that\nleaves the onus on callers to clear the buffer.\n\nPrior to XSAVES support, it was possible just to reinitialize the buffer,\ncompletely, but with supervisor states that is not longer possible as the\nbuffer clearing code split got it backwards. Fixing that is possible but\nnot corrupting the state in the first place is more robust.\n\nAvoid corruption of the kernel XSAVE buffer by using copy_user_to_xstate()\nwhich validates the XSAVE header contents before copying the actual states\nto the kernel. copy_user_to_xstate() was previously only called for\ncompacted-format kernel buffers, but it works for both compacted and\nnon-compacted forms.\n\nUsing it for the non-compacted form is slower because of multiple\n__copy_from_user() operations, but that cost is less important than robust\ncode in an already slow path.\n\n[ Changelog polished by Dave Hansen ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47227",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-29",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38495",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: core: ensure the allocated report buffer can contain the reserved report ID\n\nWhen the report ID is not used, the low level transport drivers expect\nthe first byte to be 0. However, currently the allocated buffer not\naccount for that extra byte, meaning that instead of having 8 guaranteed\nbytes for implement to be working, we only have 7.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38495",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-28",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38337",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: fix data-race and null-ptr-deref in jbd2_journal_dirty_metadata()\n\nSince handle->h_transaction may be a NULL pointer, so we should change it\nto call is_handle_aborted(handle) first before dereferencing it.\n\nAnd the following data-race was reported in my fuzzer:\n\n==================================================================\nBUG: KCSAN: data-race in jbd2_journal_dirty_metadata / jbd2_journal_dirty_metadata\n\nwrite to 0xffff888011024104 of 4 bytes by task 10881 on cpu 1:\n jbd2_journal_dirty_metadata+0x2a5/0x770 fs/jbd2/transaction.c:1556\n __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358\n ext4_do_update_inode fs/ext4/inode.c:5220 [inline]\n ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869\n __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074\n ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103\n....\n\nread to 0xffff888011024104 of 4 bytes by task 10880 on cpu 0:\n jbd2_journal_dirty_metadata+0xf2/0x770 fs/jbd2/transaction.c:1512\n __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358\n ext4_do_update_inode fs/ext4/inode.c:5220 [inline]\n ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869\n __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074\n ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103\n....\n\nvalue changed: 0x00000000 -> 0x00000001\n==================================================================\n\nThis issue is caused by missing data-race annotation for jh->b_modified.\nTherefore, the missing annotation needs to be added.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38337",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47316",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: fix NULL dereference in nfs3svc_encode_getaclres\n\nIn error cases the dentry may be NULL.\n\nBefore 20798dfe249a, the encoder also checked dentry and\nd_really_is_positive(dentry), but that looks like overkill to me--zero\nstatus should be enough to guarantee a positive dentry.\n\nThis isn't the first time we've seen an error-case NULL dereference\nhidden in the initialization of a local variable in an xdr encoder.  But\nI went back through the other recent rewrites and didn't spot any\nsimilar bugs.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47316",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38701",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: do not BUG when INLINE_DATA_FL lacks system.data xattr\n\nA syzbot fuzzed image triggered a BUG_ON in ext4_update_inline_data()\nwhen an inode had the INLINE_DATA_FL flag set but was missing the\nsystem.data extended attribute.\n\nSince this can happen due to a maiciouly fuzzed file system, we\nshouldn't BUG, but rather, report it as a corrupted file system.\n\nAdd similar replacements of BUG_ON with EXT4_ERROR_INODE() ii\next4_create_inline_data() and ext4_inline_data_truncate().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38701",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47552",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-mq: cancel blk-mq dispatch work in both blk_cleanup_queue and disk_release()\n\nFor avoiding to slow down queue destroy, we don't call\nblk_mq_quiesce_queue() in blk_cleanup_queue(), instead of delaying to\ncancel dispatch work in blk_release_queue().\n\nHowever, this way has caused kernel oops[1], reported by Changhui. The log\nshows that scsi_device can be freed before running blk_release_queue(),\nwhich is expected too since scsi_device is released after the scsi disk\nis closed and the scsi_device is removed.\n\nFixes the issue by canceling blk-mq dispatch work in both blk_cleanup_queue()\nand disk_release():\n\n1) when disk_release() is run, the disk has been closed, and any sync\ndispatch activities have been done, so canceling dispatch work is enough to\nquiesce filesystem I/O dispatch activity.\n\n2) in blk_cleanup_queue(), we only focus on passthrough request, and\npassthrough request is always explicitly allocated & freed by\nits caller, so once queue is frozen, all sync dispatch activity\nfor passthrough request has been done, then it is enough to just cancel\ndispatch work for avoiding any dispatch activity.\n\n[1] kernel panic log\n[12622.769416] BUG: kernel NULL pointer dereference, address: 0000000000000300\n[12622.777186] #PF: supervisor read access in kernel mode\n[12622.782918] #PF: error_code(0x0000) - not-present page\n[12622.788649] PGD 0 P4D 0\n[12622.791474] Oops: 0000 [#1] PREEMPT SMP PTI\n[12622.796138] CPU: 10 PID: 744 Comm: kworker/10:1H Kdump: loaded Not tainted 5.15.0+ #1\n[12622.804877] Hardware name: Dell Inc. PowerEdge R730/0H21J3, BIOS 1.5.4 10/002/2015\n[12622.813321] Workqueue: kblockd blk_mq_run_work_fn\n[12622.818572] RIP: 0010:sbitmap_get+0x75/0x190\n[12622.823336] Code: 85 80 00 00 00 41 8b 57 08 85 d2 0f 84 b1 00 00 00 45 31 e4 48 63 cd 48 8d 1c 49 48 c1 e3 06 49 03 5f 10 4c 8d 6b 40 83 f0 01 <48> 8b 33 44 89 f2 4c 89 ef 0f b6 c8 e8 fa f3 ff ff 83 f8 ff 75 58\n[12622.844290] RSP: 0018:ffffb00a446dbd40 EFLAGS: 00010202\n[12622.850120] RAX: 0000000000000001 RBX: 0000000000000300 RCX: 0000000000000004\n[12622.858082] RDX: 0000000000000006 RSI: 0000000000000082 RDI: ffffa0b7a2dfe030\n[12622.866042] RBP: 0000000000000004 R08: 0000000000000001 R09: ffffa0b742721334\n[12622.874003] R10: 0000000000000008 R11: 0000000000000008 R12: 0000000000000000\n[12622.881964] R13: 0000000000000340 R14: 0000000000000000 R15: ffffa0b7a2dfe030\n[12622.889926] FS:  0000000000000000(0000) GS:ffffa0baafb40000(0000) knlGS:0000000000000000\n[12622.898956] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[12622.905367] CR2: 0000000000000300 CR3: 0000000641210001 CR4: 00000000001706e0\n[12622.913328] Call Trace:\n[12622.916055]  <TASK>\n[12622.918394]  scsi_mq_get_budget+0x1a/0x110\n[12622.922969]  __blk_mq_do_dispatch_sched+0x1d4/0x320\n[12622.928404]  ? pick_next_task_fair+0x39/0x390\n[12622.933268]  __blk_mq_sched_dispatch_requests+0xf4/0x140\n[12622.939194]  blk_mq_sched_dispatch_requests+0x30/0x60\n[12622.944829]  __blk_mq_run_hw_queue+0x30/0xa0\n[12622.949593]  process_one_work+0x1e8/0x3c0\n[12622.954059]  worker_thread+0x50/0x3b0\n[12622.958144]  ? rescuer_thread+0x370/0x370\n[12622.962616]  kthread+0x158/0x180\n[12622.966218]  ? set_kthread_struct+0x40/0x40\n[12622.970884]  ret_from_fork+0x22/0x30\n[12622.974875]  </TASK>\n[12622.977309] Modules linked in: scsi_debug rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs sunrpc dm_multipath intel_rapl_msr intel_rapl_common dell_wmi_descriptor sb_edac rfkill video x86_pkg_temp_thermal intel_powerclamp dcdbas coretemp kvm_intel kvm mgag200 irqbypass i2c_algo_bit rapl drm_kms_helper ipmi_ssif intel_cstate intel_uncore syscopyarea sysfillrect sysimgblt fb_sys_fops pcspkr cec mei_me lpc_ich mei ipmi_si ipmi_devintf ipmi_msghandler acpi_power_meter drm fuse xfs libcrc32c sr_mod cdrom sd_mod t10_pi sg ixgbe ahci libahci crct10dif_pclmul crc32_pclmul crc32c_intel libata megaraid_sas ghash_clmulni_intel tg3 wdat_w\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47552",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48703",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nthermal/int340x_thermal: handle data_vault when the value is ZERO_SIZE_PTR\n\nIn some case, the GDDV returns a package with a buffer which has\nzero length. It causes that kmemdup() returns ZERO_SIZE_PTR (0x10).\n\nThen the data_vault_read() got NULL point dereference problem when\naccessing the 0x10 value in data_vault.\n\n[   71.024560] BUG: kernel NULL pointer dereference, address:\n0000000000000010\n\nThis patch uses ZERO_OR_NULL_PTR() for checking ZERO_SIZE_PTR or\nNULL value in data_vault.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48703",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-03",
                    "modification_date": "2025-07-17",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49109",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: fix inode reference leakage in ceph_get_snapdir()\n\nThe ceph_get_inode() will search for or insert a new inode into the\nhash for the given vino, and return a reference to it. If new is\nnon-NULL, its reference is consumed.\n\nWe should release the reference when in error handing cases.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49109",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48799",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix list corruption in perf_cgroup_switch()\n\nThere's list corruption on cgrp_cpuctx_list. This happens on the\nfollowing path:\n\n  perf_cgroup_switch: list_for_each_entry(cgrp_cpuctx_list)\n      cpu_ctx_sched_in\n         ctx_sched_in\n            ctx_pinned_sched_in\n              merge_sched_in\n                  perf_cgroup_event_disable: remove the event from the list\n\nUse list_for_each_entry_safe() to allow removing an entry during\niteration.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48799",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-10-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40171",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet-fc: move lsop put work to nvmet_fc_ls_req_op\n\nIt\u2019s possible for more than one async command to be in flight from\n__nvmet_fc_send_ls_req. For each command, a tgtport reference is taken.\n\nIn the current code, only one put work item is queued at a time, which\nresults in a leaked reference.\n\nTo fix this, move the work item to the nvmet_fc_ls_req_op struct, which\nalready tracks all resources related to the command.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38694",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: dvb-frontends: dib7090p: fix null-ptr-deref in dib7090p_rw_on_apb()\n\nIn dib7090p_rw_on_apb, msg is controlled by user. When msg[0].buf is null and\nmsg[0].len is zero, former checks on msg[0].buf would be passed. If accessing\nmsg[0].buf[2] without sanity check, null pointer deref would happen. We add\ncheck on msg[0].len to prevent crash. Similar issue occurs when access\nmsg[1].buf[0] and msg[1].buf[1].\n\nSimilar commit: commit 0ed554fd769a (\"media: dvb-usb: az6027: fix null-ptr-deref in az6027_i2c_xfer()\")",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40026",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Don't (re)check L1 intercepts when completing userspace I/O\n\nWhen completing emulation of instruction that generated a userspace exit\nfor I/O, don't recheck L1 intercepts as KVM has already finished that\nphase of instruction execution, i.e. has already committed to allowing L2\nto perform I/O.  If L1 (or host userspace) modifies the I/O permission\nbitmaps during the exit to userspace,  KVM will treat the access as being\nintercepted despite already having emulated the I/O access.\n\nPivot on EMULTYPE_NO_DECODE to detect that KVM is completing emulation.\nOf the three users of EMULTYPE_NO_DECODE, only complete_emulated_io() (the\nintended \"recipient\") can reach the code in question.  gp_interception()'s\nuse is mutually exclusive with is_guest_mode(), and\ncomplete_emulated_insn_gp() unconditionally pairs EMULTYPE_NO_DECODE with\nEMULTYPE_SKIP.\n\nThe bad behavior was detected by a syzkaller program that toggles port I/O\ninterception during the userspace I/O exit, ultimately resulting in a WARN\non vcpu->arch.pio.count being non-zero due to KVM no completing emulation\nof the I/O instruction.\n\n  WARNING: CPU: 23 PID: 1083 at arch/x86/kvm/x86.c:8039 emulator_pio_in_out+0x154/0x170 [kvm]\n  Modules linked in: kvm_intel kvm irqbypass\n  CPU: 23 UID: 1000 PID: 1083 Comm: repro Not tainted 6.16.0-rc5-c1610d2d66b1-next-vm #74 NONE\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:emulator_pio_in_out+0x154/0x170 [kvm]\n  PKRU: 55555554\n  Call Trace:\n   <TASK>\n   kvm_fast_pio+0xd6/0x1d0 [kvm]\n   vmx_handle_exit+0x149/0x610 [kvm_intel]\n   kvm_arch_vcpu_ioctl_run+0xda8/0x1ac0 [kvm]\n   kvm_vcpu_ioctl+0x244/0x8c0 [kvm]\n   __x64_sys_ioctl+0x8a/0xd0\n   do_syscall_64+0x5d/0xc60\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n   </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38439",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt_en: Set DMA unmap len correctly for XDP_REDIRECT\n\nWhen transmitting an XDP_REDIRECT packet, call dma_unmap_len_set()\nwith the proper length instead of 0.  This bug triggers this warning\non a system with IOMMU enabled:\n\nWARNING: CPU: 36 PID: 0 at drivers/iommu/dma-iommu.c:842 __iommu_dma_unmap+0x159/0x170\nRIP: 0010:__iommu_dma_unmap+0x159/0x170\nCode: a8 00 00 00 00 48 c7 45 b0 00 00 00 00 48 c7 45 c8 00 00 00 00 48 c7 45 a0 ff ff ff ff 4c 89 45\nb8 4c 89 45 c0 e9 77 ff ff ff <0f> 0b e9 60 ff ff ff e8 8b bf 6a 00 66 66 2e 0f 1f 84 00 00 00 00\nRSP: 0018:ff22d31181150c88 EFLAGS: 00010206\nRAX: 0000000000002000 RBX: 00000000e13a0000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: ff22d31181150cf0 R08: ff22d31181150ca8 R09: 0000000000000000\nR10: 0000000000000000 R11: ff22d311d36c9d80 R12: 0000000000001000\nR13: ff13544d10645010 R14: ff22d31181150c90 R15: ff13544d0b2bac00\nFS: 0000000000000000(0000) GS:ff13550908a00000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00005be909dacff8 CR3: 0008000173408003 CR4: 0000000000f71ef0\nPKRU: 55555554\nCall Trace:\n<IRQ>\n? show_regs+0x6d/0x80\n? __warn+0x89/0x160\n? __iommu_dma_unmap+0x159/0x170\n? report_bug+0x17e/0x1b0\n? handle_bug+0x46/0x90\n? exc_invalid_op+0x18/0x80\n? asm_exc_invalid_op+0x1b/0x20\n? __iommu_dma_unmap+0x159/0x170\n? __iommu_dma_unmap+0xb3/0x170\niommu_dma_unmap_page+0x4f/0x100\ndma_unmap_page_attrs+0x52/0x220\n? srso_alias_return_thunk+0x5/0xfbef5\n? xdp_return_frame+0x2e/0xd0\nbnxt_tx_int_xdp+0xdf/0x440 [bnxt_en]\n__bnxt_poll_work_done+0x81/0x1e0 [bnxt_en]\nbnxt_poll+0xd3/0x1e0 [bnxt_en]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38439",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-22",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47168",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: fix an incorrect limit in filelayout_decode_layout()\n\nThe \"sizeof(struct nfs_fh)\" is two bytes too large and could lead to\nmemory corruption.  It should be NFS_MAXFHSIZE because that's the size\nof the ->data[] buffer.\n\nI reversed the size of the arguments to put the variable on the left.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47168",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-25",
                    "modification_date": "2025-03-17",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48986",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/gup: fix gup_pud_range() for dax\n\nFor dax pud, pud_huge() returns true on x86. So the function works as long\nas hugetlb is configured. However, dax doesn't depend on hugetlb.\nCommit 414fd080d125 (\"mm/gup: fix gup_pmd_range() for dax\") fixed\ndevmap-backed huge PMDs, but missed devmap-backed huge PUDs. Fix this as\nwell.\n\nThis fixes the below kernel panic:\n\ngeneral protection fault, probably for non-canonical address 0x69e7c000cc478: 0000 [#1] SMP\n\t< snip >\nCall Trace:\n<TASK>\nget_user_pages_fast+0x1f/0x40\niov_iter_get_pages+0xc6/0x3b0\n? mempool_alloc+0x5d/0x170\nbio_iov_iter_get_pages+0x82/0x4e0\n? bvec_alloc+0x91/0xc0\n? bio_alloc_bioset+0x19a/0x2a0\nblkdev_direct_IO+0x282/0x480\n? __io_complete_rw_common+0xc0/0xc0\n? filemap_range_has_page+0x82/0xc0\ngeneric_file_direct_write+0x9d/0x1a0\n? inode_update_time+0x24/0x30\n__generic_file_write_iter+0xbd/0x1e0\nblkdev_write_iter+0xb4/0x150\n? io_import_iovec+0x8d/0x340\nio_write+0xf9/0x300\nio_issue_sqe+0x3c3/0x1d30\n? sysvec_reschedule_ipi+0x6c/0x80\n__io_queue_sqe+0x33/0x240\n? fget+0x76/0xa0\nio_submit_sqes+0xe6a/0x18d0\n? __fget_light+0xd1/0x100\n__x64_sys_io_uring_enter+0x199/0x880\n? __context_tracking_enter+0x1f/0x70\n? irqentry_exit_to_user_mode+0x24/0x30\n? irqentry_exit+0x1d/0x30\n? __context_tracking_exit+0xe/0x70\ndo_syscall_64+0x3b/0x90\nentry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7fc97c11a7be\n\t< snip >\n</TASK>\n---[ end trace 48b2e0e67debcaeb ]---\nRIP: 0010:internal_get_user_pages_fast+0x340/0x990\n\t< snip >\nKernel panic - not syncing: Fatal exception\nKernel Offset: disabled",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48986",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-11-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49126",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: mpi3mr: Fix memory leaks\n\nFix memory leaks related to operational reply queue's memory segments which\nare not getting freed while unloading the driver.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49126",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48865",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: fix kernel panic when enabling bearer\n\nWhen enabling a bearer on a node, a kernel panic is observed:\n\n[    4.498085] RIP: 0010:tipc_mon_prep+0x4e/0x130 [tipc]\n...\n[    4.520030] Call Trace:\n[    4.520689]  <IRQ>\n[    4.521236]  tipc_link_build_proto_msg+0x375/0x750 [tipc]\n[    4.522654]  tipc_link_build_state_msg+0x48/0xc0 [tipc]\n[    4.524034]  __tipc_node_link_up+0xd7/0x290 [tipc]\n[    4.525292]  tipc_rcv+0x5da/0x730 [tipc]\n[    4.526346]  ? __netif_receive_skb_core+0xb7/0xfc0\n[    4.527601]  tipc_l2_rcv_msg+0x5e/0x90 [tipc]\n[    4.528737]  __netif_receive_skb_list_core+0x20b/0x260\n[    4.530068]  netif_receive_skb_list_internal+0x1bf/0x2e0\n[    4.531450]  ? dev_gro_receive+0x4c2/0x680\n[    4.532512]  napi_complete_done+0x6f/0x180\n[    4.533570]  virtnet_poll+0x29c/0x42e [virtio_net]\n...\n\nThe node in question is receiving activate messages in another\nthread after changing bearer status to allow message sending/\nreceiving in current thread:\n\n         thread 1           |              thread 2\n         --------           |              --------\n                            |\ntipc_enable_bearer()        |\n  test_and_set_bit_lock()   |\n    tipc_bearer_xmit_skb()  |\n                            | tipc_l2_rcv_msg()\n                            |   tipc_rcv()\n                            |     __tipc_node_link_up()\n                            |       tipc_link_build_state_msg()\n                            |         tipc_link_build_proto_msg()\n                            |           tipc_mon_prep()\n                            |           {\n                            |             ...\n                            |             // null-pointer dereference\n                            |             u16 gen = mon->dom_gen;\n                            |             ...\n                            |           }\n  // Not being executed yet |\n  tipc_mon_create()         |\n  {                         |\n    ...                     |\n    // allocate             |\n    mon = kzalloc();        |\n    ...                     |\n  }                         |\n\nMonitoring pointer in thread 2 is dereferenced before monitoring data\nis allocated in thread 1. This causes kernel panic.\n\nThis commit fixes it by allocating the monitoring data before enabling\nthe bearer to receive messages.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48865",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48850",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet-sysfs: add check for netdevice being present to speed_show\n\nWhen bringing down the netdevice or system shutdown, a panic can be\ntriggered while accessing the sysfs path because the device is already\nremoved.\n\n    [  755.549084] mlx5_core 0000:12:00.1: Shutdown was called\n    [  756.404455] mlx5_core 0000:12:00.0: Shutdown was called\n    ...\n    [  757.937260] BUG: unable to handle kernel NULL pointer dereference at           (null)\n    [  758.031397] IP: [<ffffffff8ee11acb>] dma_pool_alloc+0x1ab/0x280\n\n    crash> bt\n    ...\n    PID: 12649  TASK: ffff8924108f2100  CPU: 1   COMMAND: \"amsd\"\n    ...\n     #9 [ffff89240e1a38b0] page_fault at ffffffff8f38c778\n        [exception RIP: dma_pool_alloc+0x1ab]\n        RIP: ffffffff8ee11acb  RSP: ffff89240e1a3968  RFLAGS: 00010046\n        RAX: 0000000000000246  RBX: ffff89243d874100  RCX: 0000000000001000\n        RDX: 0000000000000000  RSI: 0000000000000246  RDI: ffff89243d874090\n        RBP: ffff89240e1a39c0   R8: 000000000001f080   R9: ffff8905ffc03c00\n        R10: ffffffffc04680d4  R11: ffffffff8edde9fd  R12: 00000000000080d0\n        R13: ffff89243d874090  R14: ffff89243d874080  R15: 0000000000000000\n        ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n    #10 [ffff89240e1a39c8] mlx5_alloc_cmd_msg at ffffffffc04680f3 [mlx5_core]\n    #11 [ffff89240e1a3a18] cmd_exec at ffffffffc046ad62 [mlx5_core]\n    #12 [ffff89240e1a3ab8] mlx5_cmd_exec at ffffffffc046b4fb [mlx5_core]\n    #13 [ffff89240e1a3ae8] mlx5_core_access_reg at ffffffffc0475434 [mlx5_core]\n    #14 [ffff89240e1a3b40] mlx5e_get_fec_caps at ffffffffc04a7348 [mlx5_core]\n    #15 [ffff89240e1a3bb0] get_fec_supported_advertised at ffffffffc04992bf [mlx5_core]\n    #16 [ffff89240e1a3c08] mlx5e_get_link_ksettings at ffffffffc049ab36 [mlx5_core]\n    #17 [ffff89240e1a3ce8] __ethtool_get_link_ksettings at ffffffff8f25db46\n    #18 [ffff89240e1a3d48] speed_show at ffffffff8f277208\n    #19 [ffff89240e1a3dd8] dev_attr_show at ffffffff8f0b70e3\n    #20 [ffff89240e1a3df8] sysfs_kf_seq_show at ffffffff8eedbedf\n    #21 [ffff89240e1a3e18] kernfs_seq_show at ffffffff8eeda596\n    #22 [ffff89240e1a3e28] seq_read at ffffffff8ee76d10\n    #23 [ffff89240e1a3e98] kernfs_fop_read at ffffffff8eedaef5\n    #24 [ffff89240e1a3ed8] vfs_read at ffffffff8ee4e3ff\n    #25 [ffff89240e1a3f08] sys_read at ffffffff8ee4f27f\n    #26 [ffff89240e1a3f50] system_call_fastpath at ffffffff8f395f92\n\n    crash> net_device.state ffff89443b0c0000\n      state = 0x5  (__LINK_STATE_START| __LINK_STATE_NOCARRIER)\n\nTo prevent this scenario, we also make sure that the netdevice is present.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48850",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39965",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxfrm: xfrm_alloc_spi shouldn't use 0 as SPI\n\nx->id.spi == 0 means \"no SPI assigned\", but since commit\n94f39804d891 (\"xfrm: Duplicate SPI Handling\"), we now create states\nand add them to the byspi list with this value.\n\n__xfrm_state_delete doesn't remove those states from the byspi list,\nsince they shouldn't be there, and this shows up as a UAF the next\ntime we go through the byspi list.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-13",
                    "modification_date": "2025-10-14",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-46976",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915: Fix crash in auto_retire\n\nThe retire logic uses the 2 lower bits of the pointer to the retire\nfunction to store flags. However, the auto_retire function is not\nguaranteed to be aligned to a multiple of 4, which causes crashes as\nwe jump to the wrong address, for example like this:\n\n2021-04-24T18:03:53.804300Z WARNING kernel: [  516.876901] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n2021-04-24T18:03:53.804310Z WARNING kernel: [  516.876906] CPU: 7 PID: 146 Comm: kworker/u16:6 Tainted: G     U            5.4.105-13595-g3cd84167b2df #1\n2021-04-24T18:03:53.804311Z WARNING kernel: [  516.876907] Hardware name: Google Volteer2/Volteer2, BIOS Google_Volteer2.13672.76.0 02/22/2021\n2021-04-24T18:03:53.804312Z WARNING kernel: [  516.876911] Workqueue: events_unbound active_work\n2021-04-24T18:03:53.804313Z WARNING kernel: [  516.876914] RIP: 0010:auto_retire+0x1/0x20\n2021-04-24T18:03:53.804314Z WARNING kernel: [  516.876916] Code: e8 01 f2 ff ff eb 02 31 db 48 89 d8 5b 5d c3 0f 1f 44 00 00 55 48 89 e5 f0 ff 87 c8 00 00 00 0f 88 ab 47 4a 00 31 c0 5d c3 0f <1f> 44 00 00 55 48 89 e5 f0 ff 8f c8 00 00 00 0f 88 9a 47 4a 00 74\n2021-04-24T18:03:53.804319Z WARNING kernel: [  516.876918] RSP: 0018:ffff9b4d809fbe38 EFLAGS: 00010286\n2021-04-24T18:03:53.804320Z WARNING kernel: [  516.876919] RAX: 0000000000000007 RBX: ffff927915079600 RCX: 0000000000000007\n2021-04-24T18:03:53.804320Z WARNING kernel: [  516.876921] RDX: ffff9b4d809fbe40 RSI: 0000000000000286 RDI: ffff927915079600\n2021-04-24T18:03:53.804321Z WARNING kernel: [  516.876922] RBP: ffff9b4d809fbe68 R08: 8080808080808080 R09: fefefefefefefeff\n2021-04-24T18:03:53.804321Z WARNING kernel: [  516.876924] R10: 0000000000000010 R11: ffffffff92e44bd8 R12: ffff9279150796a0\n2021-04-24T18:03:53.804322Z WARNING kernel: [  516.876925] R13: ffff92791c368180 R14: ffff927915079640 R15: 000000001c867605\n2021-04-24T18:03:53.804323Z WARNING kernel: [  516.876926] FS:  0000000000000000(0000) GS:ffff92791ffc0000(0000) knlGS:0000000000000000\n2021-04-24T18:03:53.804323Z WARNING kernel: [  516.876928] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n2021-04-24T18:03:53.804324Z WARNING kernel: [  516.876929] CR2: 0000239514955000 CR3: 00000007f82da001 CR4: 0000000000760ee0\n2021-04-24T18:03:53.804325Z WARNING kernel: [  516.876930] PKRU: 55555554\n2021-04-24T18:03:53.804325Z WARNING kernel: [  516.876931] Call Trace:\n2021-04-24T18:03:53.804326Z WARNING kernel: [  516.876935]  __active_retire+0x77/0xcf\n2021-04-24T18:03:53.804326Z WARNING kernel: [  516.876939]  process_one_work+0x1da/0x394\n2021-04-24T18:03:53.804327Z WARNING kernel: [  516.876941]  worker_thread+0x216/0x375\n2021-04-24T18:03:53.804327Z WARNING kernel: [  516.876944]  kthread+0x147/0x156\n2021-04-24T18:03:53.804335Z WARNING kernel: [  516.876946]  ? pr_cont_work+0x58/0x58\n2021-04-24T18:03:53.804335Z WARNING kernel: [  516.876948]  ? kthread_blkcg+0x2e/0x2e\n2021-04-24T18:03:53.804336Z WARNING kernel: [  516.876950]  ret_from_fork+0x1f/0x40\n2021-04-24T18:03:53.804336Z WARNING kernel: [  516.876952] Modules linked in: cdc_mbim cdc_ncm cdc_wdm xt_cgroup rfcomm cmac algif_hash algif_skcipher af_alg xt_MASQUERADE uinput snd_soc_rt5682_sdw snd_soc_rt5682 snd_soc_max98373_sdw snd_soc_max98373 snd_soc_rl6231 regmap_sdw snd_soc_sof_sdw snd_soc_hdac_hdmi snd_soc_dmic snd_hda_codec_hdmi snd_sof_pci snd_sof_intel_hda_common intel_ipu6_psys snd_sof_xtensa_dsp soundwire_intel soundwire_generic_allocation soundwire_cadence snd_sof_intel_hda snd_sof snd_soc_hdac_hda snd_soc_acpi_intel_match snd_soc_acpi snd_hda_ext_core soundwire_bus snd_hda_intel snd_intel_dspcfg snd_hda_codec snd_hwdep snd_hda_core intel_ipu6_isys videobuf2_dma_contig videobuf2_v4l2 videobuf2_common videobuf2_memops mei_hdcp intel_ipu6 ov2740 ov8856 at24 sx9310 dw9768 v4l2_fwnode cros_ec_typec intel_pmc_mux roles acpi_als typec fuse iio_trig_sysfs cros_ec_light_prox cros_ec_lid_angle cros_ec_sensors cros\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-46976",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2025-01-10",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48648",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsfc: fix null pointer dereference in efx_hard_start_xmit\n\nTrying to get the channel from the tx_queue variable here is wrong\nbecause we can only be here if tx_queue is NULL, so we shouldn't\ndereference it. As the above comment in the code says, this is very\nunlikely to happen, but it's wrong anyway so let's fix it.\n\nI hit this issue because of a different bug that caused tx_queue to be\nNULL. If that happens, this is the error message that we get here:\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000020\n  [...]\n  RIP: 0010:efx_hard_start_xmit+0x153/0x170 [sfc]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48648",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-01-14",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40211",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: video: Fix use-after-free in acpi_video_switch_brightness()\n\nThe switch_brightness_work delayed work accesses device->brightness\nand device->backlight, freed by acpi_video_dev_unregister_backlight()\nduring device removal.\n\nIf the work executes after acpi_video_bus_unregister_backlight()\nfrees these resources, it causes a use-after-free when\nacpi_video_switch_brightness() dereferences device->brightness or\ndevice->backlight.\n\nFix this by calling cancel_delayed_work_sync() for each device's\nswitch_brightness_work in acpi_video_bus_remove_notify_handler()\nafter removing the notify handler that queues the work. This ensures\nthe work completes before the memory is freed.\n\n[ rjw: Changelog edit ]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-21",
                    "modification_date": "2025-12-06",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48653",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: Don't double unplug aux on peer initiated reset\n\nIn the IDC callback that is accessed when the aux drivers request a reset,\nthe function to unplug the aux devices is called.  This function is also\ncalled in the ice_prepare_for_reset function. This double call is causing\na \"scheduling while atomic\" BUG.\n\n[  662.676430] ice 0000:4c:00.0 rocep76s0: cqp opcode = 0x1 maj_err_code = 0xffff min_err_code = 0x8003\n\n[  662.676609] ice 0000:4c:00.0 rocep76s0: [Modify QP Cmd Error][op_code=8] status=-29 waiting=1 completion_err=1 maj=0xffff min=0x8003\n\n[  662.815006] ice 0000:4c:00.0 rocep76s0: ICE OICR event notification: oicr = 0x10000003\n\n[  662.815014] ice 0000:4c:00.0 rocep76s0: critical PE Error, GLPE_CRITERR=0x00011424\n\n[  662.815017] ice 0000:4c:00.0 rocep76s0: Requesting a reset\n\n[  662.815475] BUG: scheduling while atomic: swapper/37/0/0x00010002\n\n[  662.815475] BUG: scheduling while atomic: swapper/37/0/0x00010002\n[  662.815477] Modules linked in: rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs rfkill 8021q garp mrp stp llc vfat fat rpcrdma intel_rapl_msr intel_rapl_common sunrpc i10nm_edac rdma_ucm nfit ib_srpt libnvdimm ib_isert iscsi_target_mod x86_pkg_temp_thermal intel_powerclamp coretemp target_core_mod snd_hda_intel ib_iser snd_intel_dspcfg libiscsi snd_intel_sdw_acpi scsi_transport_iscsi kvm_intel iTCO_wdt rdma_cm snd_hda_codec kvm iw_cm ipmi_ssif iTCO_vendor_support snd_hda_core irqbypass crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hwdep snd_seq snd_seq_device rapl snd_pcm snd_timer isst_if_mbox_pci pcspkr isst_if_mmio irdma intel_uncore idxd acpi_ipmi joydev isst_if_common snd mei_me idxd_bus ipmi_si soundcore i2c_i801 mei ipmi_devintf i2c_smbus i2c_ismt ipmi_msghandler acpi_power_meter acpi_pad rv(OE) ib_uverbs ib_cm ib_core xfs libcrc32c ast i2c_algo_bit drm_vram_helper drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm_ttm_helpe\n r ttm\n[  662.815546]  nvme nvme_core ice drm crc32c_intel i40e t10_pi wmi pinctrl_emmitsburg dm_mirror dm_region_hash dm_log dm_mod fuse\n[  662.815557] Preemption disabled at:\n[  662.815558] [<0000000000000000>] 0x0\n[  662.815563] CPU: 37 PID: 0 Comm: swapper/37 Kdump: loaded Tainted: G S         OE     5.17.1 #2\n[  662.815566] Hardware name: Intel Corporation D50DNP/D50DNP, BIOS SE5C6301.86B.6624.D18.2111021741 11/02/2021\n[  662.815568] Call Trace:\n[  662.815572]  <IRQ>\n[  662.815574]  dump_stack_lvl+0x33/0x42\n[  662.815581]  __schedule_bug.cold.147+0x7d/0x8a\n[  662.815588]  __schedule+0x798/0x990\n[  662.815595]  schedule+0x44/0xc0\n[  662.815597]  schedule_preempt_disabled+0x14/0x20\n[  662.815600]  __mutex_lock.isra.11+0x46c/0x490\n[  662.815603]  ? __ibdev_printk+0x76/0xc0 [ib_core]\n[  662.815633]  device_del+0x37/0x3d0\n[  662.815639]  ice_unplug_aux_dev+0x1a/0x40 [ice]\n[  662.815674]  ice_schedule_reset+0x3c/0xd0 [ice]\n[  662.815693]  irdma_iidc_event_handler.cold.7+0xb6/0xd3 [irdma]\n[  662.815712]  ? bitmap_find_next_zero_area_off+0x45/0xa0\n[  662.815719]  ice_send_event_to_aux+0x54/0x70 [ice]\n[  662.815741]  ice_misc_intr+0x21d/0x2d0 [ice]\n[  662.815756]  __handle_irq_event_percpu+0x4c/0x180\n[  662.815762]  handle_irq_event_percpu+0xf/0x40\n[  662.815764]  handle_irq_event+0x34/0x60\n[  662.815766]  handle_edge_irq+0x9a/0x1c0\n[  662.815770]  __common_interrupt+0x62/0x100\n[  662.815774]  common_interrupt+0xb4/0xd0\n[  662.815779]  </IRQ>\n[  662.815780]  <TASK>\n[  662.815780]  asm_common_interrupt+0x1e/0x40\n[  662.815785] RIP: 0010:cpuidle_enter_state+0xd6/0x380\n[  662.815789] Code: 49 89 c4 0f 1f 44 00 00 31 ff e8 65 d7 95 ff 45 84 ff 74 12 9c 58 f6 c4 02 0f 85 64 02 00 00 31 ff e8 ae c5 9c ff fb 45 85 f6 <0f> 88 12 01 00 00 49 63 d6 4c 2b 24 24 48 8d 04 52 48 8d 04 82 49\n[  662.815791] RSP: 0018:ff2c2c4f18edbe80 EFLAGS: 00000202\n[  662.815793] RAX: ff280805df140000 RBX: 0000000000000002 RCX: 000000000000001f\n[  662.815795] RDX: 0000009a52da2d08 R\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48653",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-04-28",
                    "modification_date": "2025-09-19",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47038",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: avoid deadlock between hci_dev->lock and socket lock\n\nCommit eab2404ba798 (\"Bluetooth: Add BT_PHY socket option\") added a\ndependency between socket lock and hci_dev->lock that could lead to\ndeadlock.\n\nIt turns out that hci_conn_get_phy() is not in any way relying on hdev\nbeing immutable during the runtime of this function, neither does it even\nlook at any of the members of hdev, and as such there is no need to hold\nthat lock.\n\nThis fixes the lockdep splat below:\n\n ======================================================\n WARNING: possible circular locking dependency detected\n 5.12.0-rc1-00026-g73d464503354 #10 Not tainted\n ------------------------------------------------------\n bluetoothd/1118 is trying to acquire lock:\n ffff8f078383c078 (&hdev->lock){+.+.}-{3:3}, at: hci_conn_get_phy+0x1c/0x150 [bluetooth]\n\n but task is already holding lock:\n ffff8f07e831d920 (sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP){+.+.}-{0:0}, at: l2cap_sock_getsockopt+0x8b/0x610\n\n which lock already depends on the new lock.\n\n the existing dependency chain (in reverse order) is:\n\n -> #3 (sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP){+.+.}-{0:0}:\n        lock_sock_nested+0x72/0xa0\n        l2cap_sock_ready_cb+0x18/0x70 [bluetooth]\n        l2cap_config_rsp+0x27a/0x520 [bluetooth]\n        l2cap_sig_channel+0x658/0x1330 [bluetooth]\n        l2cap_recv_frame+0x1ba/0x310 [bluetooth]\n        hci_rx_work+0x1cc/0x640 [bluetooth]\n        process_one_work+0x244/0x5f0\n        worker_thread+0x3c/0x380\n        kthread+0x13e/0x160\n        ret_from_fork+0x22/0x30\n\n -> #2 (&chan->lock#2/1){+.+.}-{3:3}:\n        __mutex_lock+0xa3/0xa10\n        l2cap_chan_connect+0x33a/0x940 [bluetooth]\n        l2cap_sock_connect+0x141/0x2a0 [bluetooth]\n        __sys_connect+0x9b/0xc0\n        __x64_sys_connect+0x16/0x20\n        do_syscall_64+0x33/0x80\n        entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n -> #1 (&conn->chan_lock){+.+.}-{3:3}:\n        __mutex_lock+0xa3/0xa10\n        l2cap_chan_connect+0x322/0x940 [bluetooth]\n        l2cap_sock_connect+0x141/0x2a0 [bluetooth]\n        __sys_connect+0x9b/0xc0\n        __x64_sys_connect+0x16/0x20\n        do_syscall_64+0x33/0x80\n        entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n -> #0 (&hdev->lock){+.+.}-{3:3}:\n        __lock_acquire+0x147a/0x1a50\n        lock_acquire+0x277/0x3d0\n        __mutex_lock+0xa3/0xa10\n        hci_conn_get_phy+0x1c/0x150 [bluetooth]\n        l2cap_sock_getsockopt+0x5a9/0x610 [bluetooth]\n        __sys_getsockopt+0xcc/0x200\n        __x64_sys_getsockopt+0x20/0x30\n        do_syscall_64+0x33/0x80\n        entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n other info that might help us debug this:\n\n Chain exists of:\n   &hdev->lock --> &chan->lock#2/1 --> sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP\n\n  Possible unsafe locking scenario:\n\n        CPU0                    CPU1\n        ----                    ----\n   lock(sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP);\n                                lock(&chan->lock#2/1);\n                                lock(sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP);\n   lock(&hdev->lock);\n\n  *** DEADLOCK ***\n\n 1 lock held by bluetoothd/1118:\n  #0: ffff8f07e831d920 (sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP){+.+.}-{0:0}, at: l2cap_sock_getsockopt+0x8b/0x610 [bluetooth]\n\n stack backtrace:\n CPU: 3 PID: 1118 Comm: bluetoothd Not tainted 5.12.0-rc1-00026-g73d464503354 #10\n Hardware name: LENOVO 20K5S22R00/20K5S22R00, BIOS R0IET38W (1.16 ) 05/31/2017\n Call Trace:\n  dump_stack+0x7f/0xa1\n  check_noncircular+0x105/0x120\n  ? __lock_acquire+0x147a/0x1a50\n  __lock_acquire+0x147a/0x1a50\n  lock_acquire+0x277/0x3d0\n  ? hci_conn_get_phy+0x1c/0x150 [bluetooth]\n  ? __lock_acquire+0x2e1/0x1a50\n  ? lock_is_held_type+0xb4/0x120\n  ? hci_conn_get_phy+0x1c/0x150 [bluetooth]\n  __mutex_lock+0xa3/0xa10\n  ? hci_conn_get_phy+0x1c/0x150 [bluetooth]\n  ? lock_acquire+0x277/0x3d0\n  ? mark_held_locks+0x49/0x70\n  ? mark_held_locks+0x49/0x70\n  ? hci_conn_get_phy+0x1c/0x150 [bluetooth]\n  hci_conn_get_phy+0x\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47038",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2024-12-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48914",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen/netfront: destroy queues before real_num_tx_queues is zeroed\n\nxennet_destroy_queues() relies on info->netdev->real_num_tx_queues to\ndelete queues. Since d7dac083414eb5bb99a6d2ed53dc2c1b405224e5\n(\"net-sysfs: update the queue counts in the unregistration path\"),\nunregister_netdev() indirectly sets real_num_tx_queues to 0. Those two\nfacts together means, that xennet_destroy_queues() called from\nxennet_remove() cannot do its job, because it's called after\nunregister_netdev(). This results in kfree-ing queues that are still\nlinked in napi, which ultimately crashes:\n\n    BUG: kernel NULL pointer dereference, address: 0000000000000000\n    #PF: supervisor read access in kernel mode\n    #PF: error_code(0x0000) - not-present page\n    PGD 0 P4D 0\n    Oops: 0000 [#1] PREEMPT SMP PTI\n    CPU: 1 PID: 52 Comm: xenwatch Tainted: G        W         5.16.10-1.32.fc32.qubes.x86_64+ #226\n    RIP: 0010:free_netdev+0xa3/0x1a0\n    Code: ff 48 89 df e8 2e e9 00 00 48 8b 43 50 48 8b 08 48 8d b8 a0 fe ff ff 48 8d a9 a0 fe ff ff 49 39 c4 75 26 eb 47 e8 ed c1 66 ff <48> 8b 85 60 01 00 00 48 8d 95 60 01 00 00 48 89 ef 48 2d 60 01 00\n    RSP: 0000:ffffc90000bcfd00 EFLAGS: 00010286\n    RAX: 0000000000000000 RBX: ffff88800edad000 RCX: 0000000000000000\n    RDX: 0000000000000001 RSI: ffffc90000bcfc30 RDI: 00000000ffffffff\n    RBP: fffffffffffffea0 R08: 0000000000000000 R09: 0000000000000000\n    R10: 0000000000000000 R11: 0000000000000001 R12: ffff88800edad050\n    R13: ffff8880065f8f88 R14: 0000000000000000 R15: ffff8880066c6680\n    FS:  0000000000000000(0000) GS:ffff8880f3300000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: 0000000000000000 CR3: 00000000e998c006 CR4: 00000000003706e0\n    Call Trace:\n     <TASK>\n     xennet_remove+0x13d/0x300 [xen_netfront]\n     xenbus_dev_remove+0x6d/0xf0\n     __device_release_driver+0x17a/0x240\n     device_release_driver+0x24/0x30\n     bus_remove_device+0xd8/0x140\n     device_del+0x18b/0x410\n     ? _raw_spin_unlock+0x16/0x30\n     ? klist_iter_exit+0x14/0x20\n     ? xenbus_dev_request_and_reply+0x80/0x80\n     device_unregister+0x13/0x60\n     xenbus_dev_changed+0x18e/0x1f0\n     xenwatch_thread+0xc0/0x1a0\n     ? do_wait_intr_irq+0xa0/0xa0\n     kthread+0x16b/0x190\n     ? set_kthread_struct+0x40/0x40\n     ret_from_fork+0x22/0x30\n     </TASK>\n\nFix this by calling xennet_destroy_queues() from xennet_uninit(),\nwhen real_num_tx_queues is still available. This ensures that queues are\ndestroyed when real_num_tx_queues is set to 0, regardless of how\nunregister_netdev() was called.\n\nOriginally reported at\nhttps://github.com/QubesOS/qubes-issues/issues/7257",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48914",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-38206",
                    "description": "The mac80211 subsystem in the Linux kernel before 5.12.13, when a device supporting only 5 GHz is used, allows attackers to cause a denial of service (NULL pointer dereference in the radiotap parser) by injecting a frame with 802.11a rates.",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-38206",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2021-08-08",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68265",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme: fix admin request_queue lifetime\n\nThe namespaces can access the controller's admin request_queue, and\nstale references on the namespaces may exist after tearing down the\ncontroller. Ensure the admin request_queue is active by moving the\ncontroller's 'put' to after all controller references have been released\nto ensure no one is can access the request_queue. This fixes a reported\nuse-after-free bug:\n\n  BUG: KASAN: slab-use-after-free in blk_queue_enter+0x41c/0x4a0\n  Read of size 8 at addr ffff88c0a53819f8 by task nvme/3287\n  CPU: 67 UID: 0 PID: 3287 Comm: nvme Tainted: G            E       6.13.2-ga1582f1a031e #15\n  Tainted: [E]=UNSIGNED_MODULE\n  Hardware name: Jabil /EGS 2S MB1, BIOS 1.00 06/18/2025\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x4f/0x60\n   print_report+0xc4/0x620\n   ? _raw_spin_lock_irqsave+0x70/0xb0\n   ? _raw_read_unlock_irqrestore+0x30/0x30\n   ? blk_queue_enter+0x41c/0x4a0\n   kasan_report+0xab/0xe0\n   ? blk_queue_enter+0x41c/0x4a0\n   blk_queue_enter+0x41c/0x4a0\n   ? __irq_work_queue_local+0x75/0x1d0\n   ? blk_queue_start_drain+0x70/0x70\n   ? irq_work_queue+0x18/0x20\n   ? vprintk_emit.part.0+0x1cc/0x350\n   ? wake_up_klogd_work_func+0x60/0x60\n   blk_mq_alloc_request+0x2b7/0x6b0\n   ? __blk_mq_alloc_requests+0x1060/0x1060\n   ? __switch_to+0x5b7/0x1060\n   nvme_submit_user_cmd+0xa9/0x330\n   nvme_user_cmd.isra.0+0x240/0x3f0\n   ? force_sigsegv+0xe0/0xe0\n   ? nvme_user_cmd64+0x400/0x400\n   ? vfs_fileattr_set+0x9b0/0x9b0\n   ? cgroup_update_frozen_flag+0x24/0x1c0\n   ? cgroup_leave_frozen+0x204/0x330\n   ? nvme_ioctl+0x7c/0x2c0\n   blkdev_ioctl+0x1a8/0x4d0\n   ? blkdev_common_ioctl+0x1930/0x1930\n   ? fdget+0x54/0x380\n   __x64_sys_ioctl+0x129/0x190\n   do_syscall_64+0x5b/0x160\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n  RIP: 0033:0x7f765f703b0b\n  Code: ff ff ff 85 c0 79 9b 49 c7 c4 ff ff ff ff 5b 5d 4c 89 e0 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d dd 52 0f 00 f7 d8 64 89 01 48\n  RSP: 002b:00007ffe2cefe808 EFLAGS: 00000202 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 00007ffe2cefe860 RCX: 00007f765f703b0b\n  RDX: 00007ffe2cefe860 RSI: 00000000c0484e41 RDI: 0000000000000003\n  RBP: 0000000000000000 R08: 0000000000000003 R09: 0000000000000000\n  R10: 00007f765f611d50 R11: 0000000000000202 R12: 0000000000000003\n  R13: 00000000c0484e41 R14: 0000000000000001 R15: 00007ffe2cefea60\n   </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38710",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: Validate i_depth for exhash directories\n\nA fuzzer test introduced corruption that ends up with a depth of 0 in\ndir_e_read(), causing an undefined shift by 32 at:\n\n  index = hash >> (32 - dip->i_depth);\n\nAs calculated in an open-coded way in dir_make_exhash(), the minimum\ndepth for an exhash directory is ilog2(sdp->sd_hash_ptrs) and 0 is\ninvalid as sdp->sd_hash_ptrs is fixed as sdp->bsize / 16 at mount time.\n\nSo we can avoid the undefined behaviour by checking for depth values\nlower than the minimum in gfs2_dinode_in(). Values greater than the\nmaximum are already being checked for there.\n\nAlso switch the calculation in dir_make_exhash() to use ilog2() to\nclarify how the depth is calculated.\n\nTested with the syzkaller repro.c and xfstests '-g quick'.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38710",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2025-11-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68310",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/pci: Avoid deadlock between PCI error recovery and mlx5 crdump\n\nDo not block PCI config accesses through pci_cfg_access_lock() when\nexecuting the s390 variant of PCI error recovery: Acquire just\ndevice_lock() instead of pci_dev_lock() as powerpc's EEH and\ngenerig PCI AER processing do.\n\nDuring error recovery testing a pair of tasks was reported to be hung:\n\nmlx5_core 0000:00:00.1: mlx5_health_try_recover:338:(pid 5553): health recovery flow aborted, PCI reads still not working\nINFO: task kmcheck:72 blocked for more than 122 seconds.\n      Not tainted 5.14.0-570.12.1.bringup7.el9.s390x #1\n\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\ntask:kmcheck         state:D stack:0     pid:72    tgid:72    ppid:2      flags:0x00000000\nCall Trace:\n [<000000065256f030>] __schedule+0x2a0/0x590\n [<000000065256f356>] schedule+0x36/0xe0\n [<000000065256f572>] schedule_preempt_disabled+0x22/0x30\n [<0000000652570a94>] __mutex_lock.constprop.0+0x484/0x8a8\n [<000003ff800673a4>] mlx5_unload_one+0x34/0x58 [mlx5_core]\n [<000003ff8006745c>] mlx5_pci_err_detected+0x94/0x140 [mlx5_core]\n [<0000000652556c5a>] zpci_event_attempt_error_recovery+0xf2/0x398\n [<0000000651b9184a>] __zpci_event_error+0x23a/0x2c0\nINFO: task kworker/u1664:6:1514 blocked for more than 122 seconds.\n      Not tainted 5.14.0-570.12.1.bringup7.el9.s390x #1\n\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\ntask:kworker/u1664:6 state:D stack:0     pid:1514  tgid:1514  ppid:2      flags:0x00000000\nWorkqueue: mlx5_health0000:00:00.0 mlx5_fw_fatal_reporter_err_work [mlx5_core]\nCall Trace:\n [<000000065256f030>] __schedule+0x2a0/0x590\n [<000000065256f356>] schedule+0x36/0xe0\n [<0000000652172e28>] pci_wait_cfg+0x80/0xe8\n [<0000000652172f94>] pci_cfg_access_lock+0x74/0x88\n [<000003ff800916b6>] mlx5_vsc_gw_lock+0x36/0x178 [mlx5_core]\n [<000003ff80098824>] mlx5_crdump_collect+0x34/0x1c8 [mlx5_core]\n [<000003ff80074b62>] mlx5_fw_fatal_reporter_dump+0x6a/0xe8 [mlx5_core]\n [<0000000652512242>] devlink_health_do_dump.part.0+0x82/0x168\n [<0000000652513212>] devlink_health_report+0x19a/0x230\n [<000003ff80075a12>] mlx5_fw_fatal_reporter_err_work+0xba/0x1b0 [mlx5_core]\n\nNo kernel log of the exact same error with an upstream kernel is\navailable - but the very same deadlock situation can be constructed there,\ntoo:\n\n- task: kmcheck\n  mlx5_unload_one() tries to acquire devlink lock while the PCI error\n  recovery code has set pdev->block_cfg_access by way of\n  pci_cfg_access_lock()\n- task: kworker\n  mlx5_crdump_collect() tries to set block_cfg_access through\n  pci_cfg_access_lock() while devlink_health_report() had acquired\n  the devlink lock.\n\nA similar deadlock situation can be reproduced by requesting a\ncrdump with\n  > devlink health dump show pci/<BDF> reporter fw_fatal\n\nwhile PCI error recovery is executed on the same <BDF> physical function\nby mlx5_core's pci_error_handlers. On s390 this can be injected with\n  > zpcictl --reset-fw <BDF>\n\nTests with this patch failed to reproduce that second deadlock situation,\nthe devlink command is rejected with \"kernel answers: Permission denied\" -\nand we get a kernel log message of:\n\nmlx5_core 1ed0:00:00.1: mlx5_crdump_collect:50:(pid 254382): crdump: failed to lock vsc gw err -5\n\nbecause the config read of VSC_SEMAPHORE is rejected by the underlying\nhardware.\n\nTwo prior attempts to address this issue have been discussed and\nultimately rejected [see link], with the primary argument that s390's\nimplementation of PCI error recovery is imposing restrictions that\nneither powerpc's EEH nor PCI AER handling need. Tests show that PCI\nerror recovery on s390 is running to completion even without blocking\naccess to PCI config space.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40070",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\npps: fix warning in pps_register_cdev when register device fail\n\nSimilar to previous commit 2a934fdb01db (\"media: v4l2-dev: fix error\nhandling in __video_register_device()\"), the release hook should be set\nbefore device_register(). Otherwise, when device_register() return error\nand put_device() try to callback the release function, the below warning\nmay happen.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 1 PID: 4760 at drivers/base/core.c:2567 device_release+0x1bd/0x240 drivers/base/core.c:2567\n  Modules linked in:\n  CPU: 1 UID: 0 PID: 4760 Comm: syz.4.914 Not tainted 6.17.0-rc3+ #1 NONE\n  RIP: 0010:device_release+0x1bd/0x240 drivers/base/core.c:2567\n  Call Trace:\n   <TASK>\n   kobject_cleanup+0x136/0x410 lib/kobject.c:689\n   kobject_release lib/kobject.c:720 [inline]\n   kref_put include/linux/kref.h:65 [inline]\n   kobject_put+0xe9/0x130 lib/kobject.c:737\n   put_device+0x24/0x30 drivers/base/core.c:3797\n   pps_register_cdev+0x2da/0x370 drivers/pps/pps.c:402\n   pps_register_source+0x2f6/0x480 drivers/pps/kapi.c:108\n   pps_tty_open+0x190/0x310 drivers/pps/clients/pps-ldisc.c:57\n   tty_ldisc_open+0xa7/0x120 drivers/tty/tty_ldisc.c:432\n   tty_set_ldisc+0x333/0x780 drivers/tty/tty_ldisc.c:563\n   tiocsetd drivers/tty/tty_io.c:2429 [inline]\n   tty_ioctl+0x5d1/0x1700 drivers/tty/tty_io.c:2728\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:598 [inline]\n   __se_sys_ioctl fs/ioctl.c:584 [inline]\n   __x64_sys_ioctl+0x194/0x210 fs/ioctl.c:584\n   do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n   do_syscall_64+0x5f/0x2a0 arch/x86/entry/syscall_64.c:94\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n   </TASK>\n\nBefore commit c79a39dc8d06 (\"pps: Fix a use-after-free\"),\npps_register_cdev() call device_create() to create pps->dev, which will\ninit dev->release to device_create_release(). Now the comment is outdated,\njust remove it.\n\nThanks for the reminder from Calvin Owens, 'kfree_pps' should be removed\nin pps_register_source() to avoid a double free in the failure case.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-28",
                    "modification_date": "2025-10-30",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48829",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix NFSv3 SETATTR/CREATE's handling of large file sizes\n\niattr::ia_size is a loff_t, so these NFSv3 procedures must be\ncareful to deal with incoming client size values that are larger\nthan s64_max without corrupting the value.\n\nSilently capping the value results in storing a different value\nthan the client passed in which is unexpected behavior, so remove\nthe min_t() check in decode_sattr3().\n\nNote that RFC 1813 permits only the WRITE procedure to return\nNFS3ERR_FBIG. We believe that NFSv3 reference implementations\nalso return NFS3ERR_FBIG when ia_size is too large.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48829",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-10-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49096",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sfc: add missing xdp queue reinitialization\n\nAfter rx/tx ring buffer size is changed, kernel panic occurs when\nit acts XDP_TX or XDP_REDIRECT.\n\nWhen tx/rx ring buffer size is changed(ethtool -G), sfc driver\nreallocates and reinitializes rx and tx queues and their buffer\n(tx_queue->buffer).\nBut it misses reinitializing xdp queues(efx->xdp_tx_queues).\nSo, while it is acting XDP_TX or XDP_REDIRECT, it uses the uninitialized\ntx_queue->buffer.\n\nA new function efx_set_xdp_channels() is separated from efx_set_channels()\nto handle only xdp queues.\n\nSplat looks like:\n   BUG: kernel NULL pointer dereference, address: 000000000000002a\n   #PF: supervisor write access in kernel mode\n   #PF: error_code(0x0002) - not-present page\n   PGD 0 P4D 0\n   Oops: 0002 [#4] PREEMPT SMP NOPTI\n   RIP: 0010:efx_tx_map_chunk+0x54/0x90 [sfc]\n   CPU: 2 PID: 0 Comm: swapper/2 Tainted: G      D           5.17.0+ #55 e8beeee8289528f11357029357cf\n   Code: 48 8b 8d a8 01 00 00 48 8d 14 52 4c 8d 2c d0 44 89 e0 48 85 c9 74 0e 44 89 e2 4c 89 f6 48 80\n   RSP: 0018:ffff92f121e45c60 EFLAGS: 00010297\n   RIP: 0010:efx_tx_map_chunk+0x54/0x90 [sfc]\n   RAX: 0000000000000040 RBX: ffff92ea506895c0 RCX: ffffffffc0330870\n   RDX: 0000000000000001 RSI: 00000001139b10ce RDI: ffff92ea506895c0\n   RBP: ffffffffc0358a80 R08: 00000001139b110d R09: 0000000000000000\n   R10: 0000000000000001 R11: ffff92ea414c0088 R12: 0000000000000040\n   R13: 0000000000000018 R14: 00000001139b10ce R15: ffff92ea506895c0\n   FS:  0000000000000000(0000) GS:ffff92f121ec0000(0000) knlGS:0000000000000000\n   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   Code: 48 8b 8d a8 01 00 00 48 8d 14 52 4c 8d 2c d0 44 89 e0 48 85 c9 74 0e 44 89 e2 4c 89 f6 48 80\n   CR2: 000000000000002a CR3: 00000003e6810004 CR4: 00000000007706e0\n   RSP: 0018:ffff92f121e85c60 EFLAGS: 00010297\n   PKRU: 55555554\n   RAX: 0000000000000040 RBX: ffff92ea50689700 RCX: ffffffffc0330870\n   RDX: 0000000000000001 RSI: 00000001145a90ce RDI: ffff92ea50689700\n   RBP: ffffffffc0358a80 R08: 00000001145a910d R09: 0000000000000000\n   R10: 0000000000000001 R11: ffff92ea414c0088 R12: 0000000000000040\n   R13: 0000000000000018 R14: 00000001145a90ce R15: ffff92ea50689700\n   FS:  0000000000000000(0000) GS:ffff92f121e80000(0000) knlGS:0000000000000000\n   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   CR2: 000000000000002a CR3: 00000003e6810005 CR4: 00000000007706e0\n   PKRU: 55555554\n   Call Trace:\n    <IRQ>\n    efx_xdp_tx_buffers+0x12b/0x3d0 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]\n    __efx_rx_packet+0x5c3/0x930 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]\n    efx_rx_packet+0x28c/0x2e0 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]\n    efx_ef10_ev_process+0x5f8/0xf40 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]\n    ? enqueue_task_fair+0x95/0x550\n    efx_poll+0xc4/0x360 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49096",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2018-16862",
                    "description": "A security flaw was found in the Linux kernel in a way that the cleancache subsystem clears an inode after the final file truncation (removal). The new file created with the same inode may contain leftover pages from cleancache and the old file data instead of the new one.",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2018-16862",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2018-11-26",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38614",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\neventpoll: Fix semi-unbounded recursion\n\nEnsure that epoll instances can never form a graph deeper than\nEP_MAX_NESTS+1 links.\n\nCurrently, ep_loop_check_proc() ensures that the graph is loop-free and\ndoes some recursion depth checks, but those recursion depth checks don't\nlimit the depth of the resulting tree for two reasons:\n\n - They don't look upwards in the tree.\n - If there are multiple downwards paths of different lengths, only one of\n   the paths is actually considered for the depth check since commit\n   28d82dc1c4ed (\"epoll: limit paths\").\n\nEssentially, the current recursion depth check in ep_loop_check_proc() just\nserves to prevent it from recursing too deeply while checking for loops.\n\nA more thorough check is done in reverse_path_check() after the new graph\nedge has already been created; this checks, among other things, that no\npaths going upwards from any non-epoll file with a length of more than 5\nedges exist. However, this check does not apply to non-epoll files.\n\nAs a result, it is possible to recurse to a depth of at least roughly 500,\ntested on v6.15. (I am unsure if deeper recursion is possible; and this may\nhave changed with commit 8c44dac8add7 (\"eventpoll: Fix priority inversion\nproblem\").)\n\nTo fix it:\n\n1. In ep_loop_check_proc(), note the subtree depth of each visited node,\nand use subtree depths for the total depth calculation even when a subtree\nhas already been visited.\n2. Add ep_get_upwards_depth_proc() for similarly determining the maximum\ndepth of an upwards walk.\n3. In ep_loop_check(), use these values to limit the total path length\nbetween epoll nodes to EP_MAX_NESTS edges.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38614",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-19",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40140",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: Remove disruptive netif_wake_queue in rtl8150_set_multicast\n\nsyzbot reported WARNING in rtl8150_start_xmit/usb_submit_urb.\nThis is the sequence of events that leads to the warning:\n\nrtl8150_start_xmit() {\n\tnetif_stop_queue();\n\tusb_submit_urb(dev->tx_urb);\n}\n\nrtl8150_set_multicast() {\n\tnetif_stop_queue();\n\tnetif_wake_queue();\t\t<-- wakes up TX queue before URB is done\n}\n\nrtl8150_start_xmit() {\n\tnetif_stop_queue();\n\tusb_submit_urb(dev->tx_urb);\t<-- double submission\n}\n\nrtl8150_set_multicast being the ndo_set_rx_mode callback should not be\ncalling netif_stop_queue and notif_start_queue as these handle\nTX queue synchronization.\n\nThe net core function dev_set_rx_mode handles the synchronization\nfor rtl8150_set_multicast making it safe to remove these locks.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-11-12",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48793",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: nSVM: fix potential NULL derefernce on nested migration\n\nTurns out that due to review feedback and/or rebases\nI accidentally moved the call to nested_svm_load_cr3 to be too early,\nbefore the NPT is enabled, which is very wrong to do.\n\nKVM can't even access guest memory at that point as nested NPT\nis needed for that, and of course it won't initialize the walk_mmu,\nwhich is main issue the patch was addressing.\n\nFix this for real.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48793",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40283",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btusb: reorder cleanup in btusb_disconnect to avoid UAF\n\nThere is a KASAN: slab-use-after-free read in btusb_disconnect().\nCalling \"usb_driver_release_interface(&btusb_driver, data->intf)\" will\nfree the btusb data associated with the interface. The same data is\nthen used later in the function, hence the UAF.\n\nFix by moving the accesses to btusb data to before the data is free'd.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-06",
                    "modification_date": "2025-12-08",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49072",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpio: Restrict usage of GPIO chip irq members before initialization\n\nGPIO chip irq members are exposed before they could be completely\ninitialized and this leads to race conditions.\n\nOne such issue was observed for the gc->irq.domain variable which\nwas accessed through the I2C interface in gpiochip_to_irq() before\nit could be initialized by gpiochip_add_irqchip(). This resulted in\nKernel NULL pointer dereference.\n\nFollowing are the logs for reference :-\n\nkernel: Call Trace:\nkernel:  gpiod_to_irq+0x53/0x70\nkernel:  acpi_dev_gpio_irq_get_by+0x113/0x1f0\nkernel:  i2c_acpi_get_irq+0xc0/0xd0\nkernel:  i2c_device_probe+0x28a/0x2a0\nkernel:  really_probe+0xf2/0x460\nkernel: RIP: 0010:gpiochip_to_irq+0x47/0xc0\n\nTo avoid such scenarios, restrict usage of GPIO chip irq members before\nthey are completely initialized.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49072",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47557",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_ets: don't peek at classes beyond 'nbands'\n\nwhen the number of DRR classes decreases, the round-robin active list can\ncontain elements that have already been freed in ets_qdisc_change(). As a\nconsequence, it's possible to see a NULL dereference crash, caused by the\nattempt to call cl->qdisc->ops->peek(cl->qdisc) when cl->qdisc is NULL:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000018\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 1 PID: 910 Comm: mausezahn Not tainted 5.16.0-rc1+ #475\n Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014\n RIP: 0010:ets_qdisc_dequeue+0x129/0x2c0 [sch_ets]\n Code: c5 01 41 39 ad e4 02 00 00 0f 87 18 ff ff ff 49 8b 85 c0 02 00 00 49 39 c4 0f 84 ba 00 00 00 49 8b ad c0 02 00 00 48 8b 7d 10 <48> 8b 47 18 48 8b 40 38 0f ae e8 ff d0 48 89 c3 48 85 c0 0f 84 9d\n RSP: 0000:ffffbb36c0b5fdd8 EFLAGS: 00010287\n RAX: ffff956678efed30 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000002 RSI: ffffffff9b938dc9 RDI: 0000000000000000\n RBP: ffff956678efed30 R08: e2f3207fe360129c R09: 0000000000000000\n R10: 0000000000000001 R11: 0000000000000001 R12: ffff956678efeac0\n R13: ffff956678efe800 R14: ffff956611545000 R15: ffff95667ac8f100\n FS:  00007f2aa9120740(0000) GS:ffff95667b800000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000018 CR3: 000000011070c000 CR4: 0000000000350ee0\n Call Trace:\n  <TASK>\n  qdisc_peek_dequeued+0x29/0x70 [sch_ets]\n  tbf_dequeue+0x22/0x260 [sch_tbf]\n  __qdisc_run+0x7f/0x630\n  net_tx_action+0x290/0x4c0\n  __do_softirq+0xee/0x4f8\n  irq_exit_rcu+0xf4/0x130\n  sysvec_apic_timer_interrupt+0x52/0xc0\n  asm_sysvec_apic_timer_interrupt+0x12/0x20\n RIP: 0033:0x7f2aa7fc9ad4\n Code: b9 ff ff 48 8b 54 24 18 48 83 c4 08 48 89 ee 48 89 df 5b 5d e9 ed fc ff ff 0f 1f 00 66 2e 0f 1f 84 00 00 00 00 00 f3 0f 1e fa <53> 48 83 ec 10 48 8b 05 10 64 33 00 48 8b 00 48 85 c0 0f 85 84 00\n RSP: 002b:00007ffe5d33fab8 EFLAGS: 00000202\n RAX: 0000000000000002 RBX: 0000561f72c31460 RCX: 0000561f72c31720\n RDX: 0000000000000002 RSI: 0000561f72c31722 RDI: 0000561f72c31720\n RBP: 000000000000002a R08: 00007ffe5d33fa40 R09: 0000000000000014\n R10: 0000000000000000 R11: 0000000000000246 R12: 0000561f7187e380\n R13: 0000000000000000 R14: 0000000000000000 R15: 0000561f72c31460\n  </TASK>\n Modules linked in: sch_ets sch_tbf dummy rfkill iTCO_wdt intel_rapl_msr iTCO_vendor_support intel_rapl_common joydev virtio_balloon lpc_ich i2c_i801 i2c_smbus pcspkr ip_tables xfs libcrc32c crct10dif_pclmul crc32_pclmul crc32c_intel ahci libahci ghash_clmulni_intel serio_raw libata virtio_blk virtio_console virtio_net net_failover failover sunrpc dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000018\n\nEnsuring that 'alist' was never zeroed [1] was not sufficient, we need to\nremove from the active list those elements that are no more SP nor DRR.\n\n[1] https://lore.kernel.org/netdev/60d274838bf09777f0371253416e8af71360bc08.1633609148.git.dcaratti@redhat.com/\n\nv3: fix race between ets_qdisc_change() and ets_qdisc_dequeue() delisting\n    DRR classes beyond 'nbands' in ets_qdisc_change() with the qdisc lock\n    acquired, thanks to Cong Wang.\n\nv2: when a NULL qdisc is found in the DRR active list, try to dequeue skb\n    from the next list item.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47557",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38334",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/sgx: Prevent attempts to reclaim poisoned pages\n\nTL;DR: SGX page reclaim touches the page to copy its contents to\nsecondary storage. SGX instructions do not gracefully handle machine\nchecks. Despite this, the existing SGX code will try to reclaim pages\nthat it _knows_ are poisoned. Avoid even trying to reclaim poisoned pages.\n\nThe longer story:\n\nPages used by an enclave only get epc_page->poison set in\narch_memory_failure() but they currently stay on sgx_active_page_list until\nsgx_encl_release(), with the SGX_EPC_PAGE_RECLAIMER_TRACKED flag untouched.\n\nepc_page->poison is not checked in the reclaimer logic meaning that, if other\nconditions are met, an attempt will be made to reclaim an EPC page that was\npoisoned.  This is bad because 1. we don't want that page to end up added\nto another enclave and 2. it is likely to cause one core to shut down\nand the kernel to panic.\n\nSpecifically, reclaiming uses microcode operations including \"EWB\" which\naccesses the EPC page contents to encrypt and write them out to non-SGX\nmemory.  Those operations cannot handle MCEs in their accesses other than\nby putting the executing core into a special shutdown state (affecting\nboth threads with HT.)  The kernel will subsequently panic on the\nremaining cores seeing the core didn't enter MCE handler(s) in time.\n\nCall sgx_unmark_page_reclaimable() to remove the affected EPC page from\nsgx_active_page_list on memory error to stop it being considered for\nreclaiming.\n\nTesting epc_page->poison in sgx_reclaim_pages() would also work but I assume\nit's better to add code in the less likely paths.\n\nThe affected EPC page is not added to &node->sgx_poison_page_list until\nlater in sgx_encl_release()->sgx_free_epc_page() when it is EREMOVEd.\nMembership on other lists doesn't change to avoid changing any of the\nlists' semantics except for sgx_active_page_list.  There's a \"TBD\" comment\nin arch_memory_failure() about pre-emptive actions, the goal here is not\nto address everything that it may imply.\n\nThis also doesn't completely close the time window when a memory error\nnotification will be fatal (for a not previously poisoned EPC page) --\nthe MCE can happen after sgx_reclaim_pages() has selected its candidates\nor even *inside* a microcode operation (actually easy to trigger due to\nthe amount of time spent in them.)\n\nThe spinlock in sgx_unmark_page_reclaimable() is safe because\nmemory_failure() runs in process context and no spinlocks are held,\nexplicitly noted in a mm/memory-failure.c comment.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38334",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48938",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nCDC-NCM: avoid overflow in sanity checking\n\nA broken device may give an extreme offset like 0xFFF0\nand a reasonable length for a fragment. In the sanity\ncheck as formulated now, this will create an integer\noverflow, defeating the sanity check. Both offset\nand offset + len need to be checked in such a manner\nthat no overflow can occur.\nAnd those quantities should be unsigned.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48938",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-11-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68297",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: fix crash in process_v2_sparse_read() for encrypted directories\n\nThe crash in process_v2_sparse_read() for fscrypt-encrypted directories\nhas been reported. Issue takes place for Ceph msgr2 protocol in secure\nmode. It can be reproduced by the steps:\n\nsudo mount -t ceph :/ /mnt/cephfs/ -o name=admin,fs=cephfs,ms_mode=secure\n\n(1) mkdir /mnt/cephfs/fscrypt-test-3\n(2) cp area_decrypted.tar /mnt/cephfs/fscrypt-test-3\n(3) fscrypt encrypt --source=raw_key --key=./my.key /mnt/cephfs/fscrypt-test-3\n(4) fscrypt lock /mnt/cephfs/fscrypt-test-3\n(5) fscrypt unlock --key=my.key /mnt/cephfs/fscrypt-test-3\n(6) cat /mnt/cephfs/fscrypt-test-3/area_decrypted.tar\n(7) Issue has been triggered\n\n[  408.072247] ------------[ cut here ]------------\n[  408.072251] WARNING: CPU: 1 PID: 392 at net/ceph/messenger_v2.c:865\nceph_con_v2_try_read+0x4b39/0x72f0\n[  408.072267] Modules linked in: intel_rapl_msr intel_rapl_common\nintel_uncore_frequency_common intel_pmc_core pmt_telemetry pmt_discovery\npmt_class intel_pmc_ssram_telemetry intel_vsec kvm_intel joydev kvm irqbypass\npolyval_clmulni ghash_clmulni_intel aesni_intel rapl input_leds psmouse\nserio_raw i2c_piix4 vga16fb bochs vgastate i2c_smbus floppy mac_hid qemu_fw_cfg\npata_acpi sch_fq_codel rbd msr parport_pc ppdev lp parport efi_pstore\n[  408.072304] CPU: 1 UID: 0 PID: 392 Comm: kworker/1:3 Not tainted 6.17.0-rc7+\n[  408.072307] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.17.0-5.fc42 04/01/2014\n[  408.072310] Workqueue: ceph-msgr ceph_con_workfn\n[  408.072314] RIP: 0010:ceph_con_v2_try_read+0x4b39/0x72f0\n[  408.072317] Code: c7 c1 20 f0 d4 ae 50 31 d2 48 c7 c6 60 27 d5 ae 48 c7 c7 f8\n8e 6f b0 68 60 38 d5 ae e8 00 47 61 fe 48 83 c4 18 e9 ac fc ff ff <0f> 0b e9 06\nfe ff ff 4c 8b 9d 98 fd ff ff 0f 84 64 e7 ff ff 89 85\n[  408.072319] RSP: 0018:ffff88811c3e7a30 EFLAGS: 00010246\n[  408.072322] RAX: ffffed1024874c6f RBX: ffffea00042c2b40 RCX: 0000000000000f38\n[  408.072324] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n[  408.072325] RBP: ffff88811c3e7ca8 R08: 0000000000000000 R09: 00000000000000c8\n[  408.072326] R10: 00000000000000c8 R11: 0000000000000000 R12: 00000000000000c8\n[  408.072327] R13: dffffc0000000000 R14: ffff8881243a6030 R15: 0000000000003000\n[  408.072329] FS:  0000000000000000(0000) GS:ffff88823eadf000(0000)\nknlGS:0000000000000000\n[  408.072331] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  408.072332] CR2: 000000c0003c6000 CR3: 000000010c106005 CR4: 0000000000772ef0\n[  408.072336] PKRU: 55555554\n[  408.072337] Call Trace:\n[  408.072338]  <TASK>\n[  408.072340]  ? sched_clock_noinstr+0x9/0x10\n[  408.072344]  ? __pfx_ceph_con_v2_try_read+0x10/0x10\n[  408.072347]  ? _raw_spin_unlock+0xe/0x40\n[  408.072349]  ? finish_task_switch.isra.0+0x15d/0x830\n[  408.072353]  ? __kasan_check_write+0x14/0x30\n[  408.072357]  ? mutex_lock+0x84/0xe0\n[  408.072359]  ? __pfx_mutex_lock+0x10/0x10\n[  408.072361]  ceph_con_workfn+0x27e/0x10e0\n[  408.072364]  ? metric_delayed_work+0x311/0x2c50\n[  408.072367]  process_one_work+0x611/0xe20\n[  408.072371]  ? __kasan_check_write+0x14/0x30\n[  408.072373]  worker_thread+0x7e3/0x1580\n[  408.072375]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[  408.072378]  ? __pfx_worker_thread+0x10/0x10\n[  408.072381]  kthread+0x381/0x7a0\n[  408.072383]  ? __pfx__raw_spin_lock_irq+0x10/0x10\n[  408.072385]  ? __pfx_kthread+0x10/0x10\n[  408.072387]  ? __kasan_check_write+0x14/0x30\n[  408.072389]  ? recalc_sigpending+0x160/0x220\n[  408.072392]  ? _raw_spin_unlock_irq+0xe/0x50\n[  408.072394]  ? calculate_sigpending+0x78/0xb0\n[  408.072395]  ? __pfx_kthread+0x10/0x10\n[  408.072397]  ret_from_fork+0x2b6/0x380\n[  408.072400]  ? __pfx_kthread+0x10/0x10\n[  408.072402]  ret_from_fork_asm+0x1a/0x30\n[  408.072406]  </TASK>\n[  408.072407] ---[ end trace 0000000000000000 ]---\n[  408.072418] Oops: general protection fault, probably for non-canonical\naddress 0xdffffc00000000\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2021-47559",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: Fix NULL pointer dereferencing in smc_vlan_by_tcpsk()\n\nCoverity reports a possible NULL dereferencing problem:\n\nin smc_vlan_by_tcpsk():\n6. returned_null: netdev_lower_get_next returns NULL (checked 29 out of 30 times).\n7. var_assigned: Assigning: ndev = NULL return value from netdev_lower_get_next.\n1623                ndev = (struct net_device *)netdev_lower_get_next(ndev, &lower);\nCID 1468509 (#1 of 1): Dereference null return value (NULL_RETURNS)\n8. dereference: Dereferencing a pointer that might be NULL ndev when calling is_vlan_dev.\n1624                if (is_vlan_dev(ndev)) {\n\nRemove the manual implementation and use netdev_walk_all_lower_dev() to\niterate over the lower devices. While on it remove an obsolete function\nparameter comment.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47559",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47141",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngve: Add NULL pointer checks when freeing irqs.\n\nWhen freeing notification blocks, we index priv->msix_vectors.\nIf we failed to allocate priv->msix_vectors (see abort_with_msix_vectors)\nthis could lead to a NULL pointer dereference if the driver is unloaded.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47141",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-03-25",
                    "modification_date": "2024-12-20",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68188",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: use dst_dev_rcu() in tcp_fastopen_active_disable_ofo_check()\n\nUse RCU to avoid a pair of atomic operations and a potential\nUAF on dst_dev()->flags.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-16",
                    "modification_date": "2025-12-18",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2022-48711",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: improve size validations for received domain records\n\nThe function tipc_mon_rcv() allows a node to receive and process\ndomain_record structs from peer nodes to track their views of the\nnetwork topology.\n\nThis patch verifies that the number of members in a received domain\nrecord does not exceed the limit defined by MAX_MON_DOMAIN, something\nthat may otherwise lead to a stack overflow.\n\ntipc_mon_rcv() is called from the function tipc_link_proto_rcv(), where\nwe are reading a 32 bit message data length field into a uint16.  To\navert any risk of bit overflow, we add an extra sanity check for this in\nthat function.  We cannot see that happen with the current code, but\nfuture designers being unaware of this risk, may introduce it by\nallowing delivery of very large (> 64k) sk buffers from the bearer\nlayer.  This potential problem was identified by Eric Dumazet.\n\nThis fixes CVE-2022-0435",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48711",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-20",
                    "modification_date": "2025-09-17",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38644",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: reject TDLS operations when station is not associated\n\nsyzbot triggered a WARN in ieee80211_tdls_oper() by sending\nNL80211_TDLS_ENABLE_LINK immediately after NL80211_CMD_CONNECT,\nbefore association completed and without prior TDLS setup.\n\nThis left internal state like sdata->u.mgd.tdls_peer uninitialized,\nleading to a WARN_ON() in code paths that assumed it was valid.\n\nReject the operation early if not in station mode or not associated.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38644",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48982",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix crash when replugging CSR fake controllers\n\nIt seems fake CSR 5.0 clones can cause the suspend notifier to be\nregistered twice causing the following kernel panic:\n\n[   71.986122] Call Trace:\n[   71.986124]  <TASK>\n[   71.986125]  blocking_notifier_chain_register+0x33/0x60\n[   71.986130]  hci_register_dev+0x316/0x3d0 [bluetooth 99b5497ea3d09708fa1366c1dc03288bf3cca8da]\n[   71.986154]  btusb_probe+0x979/0xd85 [btusb e1e0605a4f4c01984a4b9c8ac58c3666ae287477]\n[   71.986159]  ? __pm_runtime_set_status+0x1a9/0x300\n[   71.986162]  ? ktime_get_mono_fast_ns+0x3e/0x90\n[   71.986167]  usb_probe_interface+0xe3/0x2b0\n[   71.986171]  really_probe+0xdb/0x380\n[   71.986174]  ? pm_runtime_barrier+0x54/0x90\n[   71.986177]  __driver_probe_device+0x78/0x170\n[   71.986180]  driver_probe_device+0x1f/0x90\n[   71.986183]  __device_attach_driver+0x89/0x110\n[   71.986186]  ? driver_allows_async_probing+0x70/0x70\n[   71.986189]  bus_for_each_drv+0x8c/0xe0\n[   71.986192]  __device_attach+0xb2/0x1e0\n[   71.986195]  bus_probe_device+0x92/0xb0\n[   71.986198]  device_add+0x422/0x9a0\n[   71.986201]  ? sysfs_merge_group+0xd4/0x110\n[   71.986205]  usb_set_configuration+0x57a/0x820\n[   71.986208]  usb_generic_driver_probe+0x4f/0x70\n[   71.986211]  usb_probe_device+0x3a/0x110\n[   71.986213]  really_probe+0xdb/0x380\n[   71.986216]  ? pm_runtime_barrier+0x54/0x90\n[   71.986219]  __driver_probe_device+0x78/0x170\n[   71.986221]  driver_probe_device+0x1f/0x90\n[   71.986224]  __device_attach_driver+0x89/0x110\n[   71.986227]  ? driver_allows_async_probing+0x70/0x70\n[   71.986230]  bus_for_each_drv+0x8c/0xe0\n[   71.986232]  __device_attach+0xb2/0x1e0\n[   71.986235]  bus_probe_device+0x92/0xb0\n[   71.986237]  device_add+0x422/0x9a0\n[   71.986239]  ? _dev_info+0x7d/0x98\n[   71.986242]  ? blake2s_update+0x4c/0xc0\n[   71.986246]  usb_new_device.cold+0x148/0x36d\n[   71.986250]  hub_event+0xa8a/0x1910\n[   71.986255]  process_one_work+0x1c4/0x380\n[   71.986259]  worker_thread+0x51/0x390\n[   71.986262]  ? rescuer_thread+0x3b0/0x3b0\n[   71.986264]  kthread+0xdb/0x110\n[   71.986266]  ? kthread_complete_and_exit+0x20/0x20\n[   71.986268]  ret_from_fork+0x1f/0x30\n[   71.986273]  </TASK>\n[   71.986274] ---[ end trace 0000000000000000 ]---\n[   71.986284] btusb: probe of 2-1.6:1.0 failed with error -17",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48982",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2025-09-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38645",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Check device memory pointer before usage\n\nAdd a NULL check before accessing device memory to prevent a crash if\ndev->dm allocation in mlx5_init_once() fails.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38645",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-08-22",
                    "modification_date": "2026-01-07",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39742",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA: hfi1: fix possible divide-by-zero in find_hw_thread_mask()\n\nThe function divides number of online CPUs by num_core_siblings, and\nlater checks the divider by zero. This implies a possibility to get\nand divide-by-zero runtime error. Fix it by moving the check prior to\ndivision. This also helps to save one indentation level.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-39742",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-11",
                    "modification_date": "2026-01-09",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48864",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvdpa/mlx5: add validation for VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command\n\nWhen control vq receives a VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command\nrequest from the driver, presently there is no validation against the\nnumber of queue pairs to configure, or even if multiqueue had been\nnegotiated or not is unverified. This may lead to kernel panic due to\nuninitialized resource for the queues were there any bogus request\nsent down by untrusted driver. Tie up the loose ends there.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48864",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38344",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPICA: fix acpi parse and parseext cache leaks\n\nACPICA commit 8829e70e1360c81e7a5a901b5d4f48330e021ea5\n\nI'm Seunghun Han, and I work for National Security Research Institute of\nSouth Korea.\n\nI have been doing a research on ACPI and found an ACPI cache leak in ACPI\nearly abort cases.\n\nBoot log of ACPI cache leak is as follows:\n[    0.352414] ACPI: Added _OSI(Module Device)\n[    0.353182] ACPI: Added _OSI(Processor Device)\n[    0.353182] ACPI: Added _OSI(3.0 _SCP Extensions)\n[    0.353182] ACPI: Added _OSI(Processor Aggregator Device)\n[    0.356028] ACPI: Unable to start the ACPI Interpreter\n[    0.356799] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)\n[    0.360215] kmem_cache_destroy Acpi-State: Slab cache still has objects\n[    0.360648] CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W\n4.12.0-rc4-next-20170608+ #10\n[    0.361273] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS\nvirtual_box 12/01/2006\n[    0.361873] Call Trace:\n[    0.362243]  ? dump_stack+0x5c/0x81\n[    0.362591]  ? kmem_cache_destroy+0x1aa/0x1c0\n[    0.362944]  ? acpi_sleep_proc_init+0x27/0x27\n[    0.363296]  ? acpi_os_delete_cache+0xa/0x10\n[    0.363646]  ? acpi_ut_delete_caches+0x6d/0x7b\n[    0.364000]  ? acpi_terminate+0xa/0x14\n[    0.364000]  ? acpi_init+0x2af/0x34f\n[    0.364000]  ? __class_create+0x4c/0x80\n[    0.364000]  ? video_setup+0x7f/0x7f\n[    0.364000]  ? acpi_sleep_proc_init+0x27/0x27\n[    0.364000]  ? do_one_initcall+0x4e/0x1a0\n[    0.364000]  ? kernel_init_freeable+0x189/0x20a\n[    0.364000]  ? rest_init+0xc0/0xc0\n[    0.364000]  ? kernel_init+0xa/0x100\n[    0.364000]  ? ret_from_fork+0x25/0x30\n\nI analyzed this memory leak in detail. I found that \u201cAcpi-State\u201d cache and\n\u201cAcpi-Parse\u201d cache were merged because the size of cache objects was same\nslab cache size.\n\nI finally found \u201cAcpi-Parse\u201d cache and \u201cAcpi-parse_ext\u201d cache were leaked\nusing SLAB_NEVER_MERGE flag in kmem_cache_create() function.\n\nReal ACPI cache leak point is as follows:\n[    0.360101] ACPI: Added _OSI(Module Device)\n[    0.360101] ACPI: Added _OSI(Processor Device)\n[    0.360101] ACPI: Added _OSI(3.0 _SCP Extensions)\n[    0.361043] ACPI: Added _OSI(Processor Aggregator Device)\n[    0.364016] ACPI: Unable to start the ACPI Interpreter\n[    0.365061] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)\n[    0.368174] kmem_cache_destroy Acpi-Parse: Slab cache still has objects\n[    0.369332] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W\n4.12.0-rc4-next-20170608+ #8\n[    0.371256] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS\nvirtual_box 12/01/2006\n[    0.372000] Call Trace:\n[    0.372000]  ? dump_stack+0x5c/0x81\n[    0.372000]  ? kmem_cache_destroy+0x1aa/0x1c0\n[    0.372000]  ? acpi_sleep_proc_init+0x27/0x27\n[    0.372000]  ? acpi_os_delete_cache+0xa/0x10\n[    0.372000]  ? acpi_ut_delete_caches+0x56/0x7b\n[    0.372000]  ? acpi_terminate+0xa/0x14\n[    0.372000]  ? acpi_init+0x2af/0x34f\n[    0.372000]  ? __class_create+0x4c/0x80\n[    0.372000]  ? video_setup+0x7f/0x7f\n[    0.372000]  ? acpi_sleep_proc_init+0x27/0x27\n[    0.372000]  ? do_one_initcall+0x4e/0x1a0\n[    0.372000]  ? kernel_init_freeable+0x189/0x20a\n[    0.372000]  ? rest_init+0xc0/0xc0\n[    0.372000]  ? kernel_init+0xa/0x100\n[    0.372000]  ? ret_from_fork+0x25/0x30\n[    0.388039] kmem_cache_destroy Acpi-parse_ext: Slab cache still has objects\n[    0.389063] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W\n4.12.0-rc4-next-20170608+ #8\n[    0.390557] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS\nvirtual_box 12/01/2006\n[    0.392000] Call Trace:\n[    0.392000]  ? dump_stack+0x5c/0x81\n[    0.392000]  ? kmem_cache_destroy+0x1aa/0x1c0\n[    0.392000]  ? acpi_sleep_proc_init+0x27/0x27\n[    0.392000]  ? acpi_os_delete_cache+0xa/0x10\n[    0.392000]  ? acpi_ut_delete_caches+0x6d/0x7b\n[    0.392000]  ? acpi_terminate+0xa/0x14\n[    0.392000]  ? acpi_init+0x2af/0x3\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38344",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-10",
                    "modification_date": "2025-12-16",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48909",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix connection leak\n\nThere's a potential leak issue under following execution sequence :\n\nsmc_release  \t\t\t\tsmc_connect_work\nif (sk->sk_state == SMC_INIT)\n\t\t\t\t\tsend_clc_confirim\n\ttcp_abort();\n\t\t\t\t\t...\n\t\t\t\t\tsk.sk_state = SMC_ACTIVE\nsmc_close_active\nswitch(sk->sk_state) {\n...\ncase SMC_ACTIVE:\n\tsmc_close_final()\n\t// then wait peer closed\n\nUnfortunately, tcp_abort() may discard CLC CONFIRM messages that are\nstill in the tcp send buffer, in which case our connection token cannot\nbe delivered to the server side, which means that we cannot get a\npassive close message at all. Therefore, it is impossible for the to be\ndisconnected at all.\n\nThis patch tries a very simple way to avoid this issue, once the state\nhas changed to SMC_ACTIVE after tcp_abort(), we can actively abort the\nsmc connection, considering that the state is SMC_INIT before\ntcp_abort(), abandoning the complete disconnection process should not\ncause too much problem.\n\nIn fact, this problem may exist as long as the CLC CONFIRM message is\nnot received by the server. Whether a timer should be added after\nsmc_close_final() needs to be discussed in the future. But even so, this\npatch provides a faster release for connection in above case, it should\nalso be valuable.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48909",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38725",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: asix_devices: add phy_mask for ax88772 mdio bus\n\nWithout setting phy_mask for ax88772 mdio bus, current driver may create\nat most 32 mdio phy devices with phy address range from 0x00 ~ 0x1f.\nDLink DUB-E100 H/W Ver B1 is such a device. However, only one main phy\ndevice will bind to net phy driver. This is creating issue during system\nsuspend/resume since phy_polling_mode() in phy_state_machine() will\ndirectly deference member of phydev->drv for non-main phy devices. Then\nNULL pointer dereference issue will occur. Due to only external phy or\ninternal phy is necessary, add phy_mask for ax88772 mdio bus to workarnoud\nthe issue.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38725",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2026-01-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-40020",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: peak_usb: fix shift-out-of-bounds issue\n\nExplicitly uses a 64-bit constant when the number of bits used for its\nshifting is 32 (which is the case for PC CAN FD interfaces supported by\nthis driver).\n\n[mkl: update subject, apply manually]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-10-24",
                    "modification_date": "2025-10-27",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39795",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: avoid possible overflow for chunk_sectors check in blk_stack_limits()\n\nIn blk_stack_limits(), we check that the t->chunk_sectors value is a\nmultiple of the t->physical_block_size value.\n\nHowever, by finding the chunk_sectors value in bytes, we may overflow\nthe unsigned int which holds chunk_sectors, so change the check to be\nbased on sectors.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-12",
                    "modification_date": "2025-11-03",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48811",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nibmvnic: don't release napi in __ibmvnic_open()\n\nIf __ibmvnic_open() encounters an error such as when setting link state,\nit calls release_resources() which frees the napi structures needlessly.\nInstead, have __ibmvnic_open() only clean up the work it did so far (i.e.\ndisable napi and irqs) and leave the rest to the callers.\n\nIf caller of __ibmvnic_open() is ibmvnic_open(), it should release the\nresources immediately. If the caller is do_reset() or do_hard_reset(),\nthey will release the resources on the next reset.\n\nThis fixes following crash that occurred when running the drmgr command\nseveral times to add/remove a vnic interface:\n\n\t[102056] ibmvnic 30000003 env3: Disabling rx_scrq[6] irq\n\t[102056] ibmvnic 30000003 env3: Disabling rx_scrq[7] irq\n\t[102056] ibmvnic 30000003 env3: Replenished 8 pools\n\tKernel attempted to read user page (10) - exploit attempt? (uid: 0)\n\tBUG: Kernel NULL pointer dereference on read at 0x00000010\n\tFaulting instruction address: 0xc000000000a3c840\n\tOops: Kernel access of bad area, sig: 11 [#1]\n\tLE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA pSeries\n\t...\n\tCPU: 9 PID: 102056 Comm: kworker/9:2 Kdump: loaded Not tainted 5.16.0-rc5-autotest-g6441998e2e37 #1\n\tWorkqueue: events_long __ibmvnic_reset [ibmvnic]\n\tNIP:  c000000000a3c840 LR: c0080000029b5378 CTR: c000000000a3c820\n\tREGS: c0000000548e37e0 TRAP: 0300   Not tainted  (5.16.0-rc5-autotest-g6441998e2e37)\n\tMSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 28248484  XER: 00000004\n\tCFAR: c0080000029bdd24 DAR: 0000000000000010 DSISR: 40000000 IRQMASK: 0\n\tGPR00: c0080000029b55d0 c0000000548e3a80 c0000000028f0200 0000000000000000\n\t...\n\tNIP [c000000000a3c840] napi_enable+0x20/0xc0\n\tLR [c0080000029b5378] __ibmvnic_open+0xf0/0x430 [ibmvnic]\n\tCall Trace:\n\t[c0000000548e3a80] [0000000000000006] 0x6 (unreliable)\n\t[c0000000548e3ab0] [c0080000029b55d0] __ibmvnic_open+0x348/0x430 [ibmvnic]\n\t[c0000000548e3b40] [c0080000029bcc28] __ibmvnic_reset+0x500/0xdf0 [ibmvnic]\n\t[c0000000548e3c60] [c000000000176228] process_one_work+0x288/0x570\n\t[c0000000548e3d00] [c000000000176588] worker_thread+0x78/0x660\n\t[c0000000548e3da0] [c0000000001822f0] kthread+0x1c0/0x1d0\n\t[c0000000548e3e10] [c00000000000cf64] ret_from_kernel_thread+0x5c/0x64\n\tInstruction dump:\n\t7d2948f8 792307e0 4e800020 60000000 3c4c01eb 384239e0 f821ffd1 39430010\n\t38a0fff6 e92d1100 f9210028 39200000 <e9030010> f9010020 60420000 e9210020\n\t---[ end trace 5f8033b08fd27706 ]---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48811",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-09-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48975",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpiolib: fix memory leak in gpiochip_setup_dev()\n\nHere is a backtrace report about memory leak detected in\ngpiochip_setup_dev():\n\nunreferenced object 0xffff88810b406400 (size 512):\n  comm \"python3\", pid 1682, jiffies 4295346908 (age 24.090s)\n  backtrace:\n    kmalloc_trace\n    device_add\t\tdevice_private_init at drivers/base/core.c:3361\n\t\t\t(inlined by) device_add at drivers/base/core.c:3411\n    cdev_device_add\n    gpiolib_cdev_register\n    gpiochip_setup_dev\n    gpiochip_add_data_with_key\n\ngcdev_register() & gcdev_unregister() would call device_add() &\ndevice_del() (no matter CONFIG_GPIO_CDEV is enabled or not) to\nregister/unregister device.\n\nHowever, if device_add() succeeds, some resource (like\nstruct device_private allocated by device_private_init())\nis not released by device_del().\n\nTherefore, after device_add() succeeds by gcdev_register(), it\nneeds to call put_device() to release resource in the error handle\npath.\n\nHere we move forward the register of release function, and let it\nrelease every piece of resource by put_device() instead of kfree().\n\nWhile at it, fix another subtle issue, i.e. when gc->ngpio is equal\nto 0, we still call kcalloc() and, in case of further error, kfree()\non the ZERO_PTR pointer, which is not NULL. It's not a bug per se,\nbut rather waste of the resources and potentially wrong expectation\nabout contents of the gdev->descs variable.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48975",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38692",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: add cluster chain loop check for dir\n\nAn infinite loop may occur if the following conditions occur due to\nfile system corruption.\n\n(1) Condition for exfat_count_dir_entries() to loop infinitely.\n    - The cluster chain includes a loop.\n    - There is no UNUSED entry in the cluster chain.\n\n(2) Condition for exfat_create_upcase_table() to loop infinitely.\n    - The cluster chain of the root directory includes a loop.\n    - There are no UNUSED entry and up-case table entry in the cluster\n      chain of the root directory.\n\n(3) Condition for exfat_load_bitmap() to loop infinitely.\n    - The cluster chain of the root directory includes a loop.\n    - There are no UNUSED entry and bitmap entry in the cluster chain\n      of the root directory.\n\n(4) Condition for exfat_find_dir_entry() to loop infinitely.\n    - The cluster chain includes a loop.\n    - The unused directory entries were exhausted by some operation.\n\n(5) Condition for exfat_check_dir_empty() to loop infinitely.\n    - The cluster chain includes a loop.\n    - The unused directory entries were exhausted by some operation.\n    - All files and sub-directories under the directory are deleted.\n\nThis commit adds checks to break the above infinite loop.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38692",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-04",
                    "modification_date": "2025-11-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-39838",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: prevent NULL pointer dereference in UTF16 conversion\n\nThere can be a NULL pointer dereference bug here. NULL is passed to\n__cifs_sfu_make_node without checks, which passes it unchecked to\ncifs_strndup_to_utf16, which in turn passes it to\ncifs_local_to_utf16_bytes where '*from' is dereferenced, causing a crash.\n\nThis patch adds a check for NULL 'src' in cifs_strndup_to_utf16 and\nreturns NULL early to prevent dereferencing NULL pointer.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-09-19",
                    "modification_date": "2026-01-02",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47595",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_ets: don't remove idle classes from the round-robin list\n\nShuang reported that the following script:\n\n 1) tc qdisc add dev ddd0 handle 10: parent 1: ets bands 8 strict 4 priomap 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n 2) mausezahn ddd0  -A 10.10.10.1 -B 10.10.10.2 -c 0 -a own -b 00:c1:a0:c1:a0:00 -t udp &\n 3) tc qdisc change dev ddd0 handle 10: ets bands 4 strict 2 quanta 2500 2500 priomap 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n\ncrashes systematically when line 2) is commented:\n\n list_del corruption, ffff8e028404bd30->next is LIST_POISON1 (dead000000000100)\n ------------[ cut here ]------------\n kernel BUG at lib/list_debug.c:47!\n invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 0 PID: 954 Comm: tc Not tainted 5.16.0-rc4+ #478\n Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014\n RIP: 0010:__list_del_entry_valid.cold.1+0x12/0x47\n Code: fe ff 0f 0b 48 89 c1 4c 89 c6 48 c7 c7 08 42 1b 87 e8 1d c5 fe ff 0f 0b 48 89 fe 48 89 c2 48 c7 c7 98 42 1b 87 e8 09 c5 fe ff <0f> 0b 48 c7 c7 48 43 1b 87 e8 fb c4 fe ff 0f 0b 48 89 f2 48 89 fe\n RSP: 0018:ffffae46807a3888 EFLAGS: 00010246\n RAX: 000000000000004e RBX: 0000000000000007 RCX: 0000000000000202\n RDX: 0000000000000000 RSI: ffffffff871ac536 RDI: 00000000ffffffff\n RBP: ffffae46807a3a10 R08: 0000000000000000 R09: c0000000ffff7fff\n R10: 0000000000000001 R11: ffffae46807a36a8 R12: ffff8e028404b800\n R13: ffff8e028404bd30 R14: dead000000000100 R15: ffff8e02fafa2400\n FS:  00007efdc92e4480(0000) GS:ffff8e02fb600000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000682f48 CR3: 00000001058be000 CR4: 0000000000350ef0\n Call Trace:\n  <TASK>\n  ets_qdisc_change+0x58b/0xa70 [sch_ets]\n  tc_modify_qdisc+0x323/0x880\n  rtnetlink_rcv_msg+0x169/0x4a0\n  netlink_rcv_skb+0x50/0x100\n  netlink_unicast+0x1a5/0x280\n  netlink_sendmsg+0x257/0x4d0\n  sock_sendmsg+0x5b/0x60\n  ____sys_sendmsg+0x1f2/0x260\n  ___sys_sendmsg+0x7c/0xc0\n  __sys_sendmsg+0x57/0xa0\n  do_syscall_64+0x3a/0x80\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7efdc8031338\n Code: 89 02 48 c7 c0 ff ff ff ff eb b5 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 8d 05 25 43 2c 00 8b 00 85 c0 75 17 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 58 c3 0f 1f 80 00 00 00 00 41 54 41 89 d4 55\n RSP: 002b:00007ffdf1ce9828 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 0000000061b37a97 RCX: 00007efdc8031338\n RDX: 0000000000000000 RSI: 00007ffdf1ce9890 RDI: 0000000000000003\n RBP: 0000000000000000 R08: 0000000000000001 R09: 000000000078a940\n R10: 000000000000000c R11: 0000000000000246 R12: 0000000000000001\n R13: 0000000000688880 R14: 0000000000000000 R15: 0000000000000000\n  </TASK>\n Modules linked in: sch_ets sch_tbf dummy rfkill iTCO_wdt iTCO_vendor_support intel_rapl_msr intel_rapl_common joydev pcspkr i2c_i801 virtio_balloon i2c_smbus lpc_ich ip_tables xfs libcrc32c crct10dif_pclmul crc32_pclmul crc32c_intel serio_raw ghash_clmulni_intel ahci libahci libata virtio_blk virtio_console virtio_net net_failover failover sunrpc dm_mirror dm_region_hash dm_log dm_mod [last unloaded: sch_ets]\n ---[ end trace f35878d1912655c2 ]---\n RIP: 0010:__list_del_entry_valid.cold.1+0x12/0x47\n Code: fe ff 0f 0b 48 89 c1 4c 89 c6 48 c7 c7 08 42 1b 87 e8 1d c5 fe ff 0f 0b 48 89 fe 48 89 c2 48 c7 c7 98 42 1b 87 e8 09 c5 fe ff <0f> 0b 48 c7 c7 48 43 1b 87 e8 fb c4 fe ff 0f 0b 48 89 f2 48 89 fe\n RSP: 0018:ffffae46807a3888 EFLAGS: 00010246\n RAX: 000000000000004e RBX: 0000000000000007 RCX: 0000000000000202\n RDX: 0000000000000000 RSI: ffffffff871ac536 RDI: 00000000ffffffff\n RBP: ffffae46807a3a10 R08: 0000000000000000 R09: c0000000ffff7fff\n R10: 0000000000000001 R11: ffffae46807a36a8 R12: ffff8e028404b800\n R13: ffff8e028404bd30 R14: dead000000000100 R15: ffff8e02fafa2400\n FS:  00007efdc92e4480(0000) GS:ffff8e02fb600000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000000000\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47595",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-06-19",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48828",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSD: Fix ia_size underflow\n\niattr::ia_size is a loff_t, which is a signed 64-bit type. NFSv3 and\nNFSv4 both define file size as an unsigned 64-bit type. Thus there\nis a range of valid file size values an NFS client can send that is\nalready larger than Linux can handle.\n\nCurrently decode_fattr4() dumps a full u64 value into ia_size. If\nthat value happens to be larger than S64_MAX, then ia_size\nunderflows. I'm about to fix up the NFSv3 behavior as well, so let's\ncatch the underflow in the common code path: nfsd_setattr().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48828",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-09-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48876",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix initialization of rx->link and rx->link_sta\n\nThere are some codepaths that do not initialize rx->link_sta properly. This\ncauses a crash in places which assume that rx->link_sta is valid if rx->sta\nis valid.\nOne known instance is triggered by __ieee80211_rx_h_amsdu being called from\nfast-rx. It results in a crash like this one:\n\n BUG: kernel NULL pointer dereference, address: 00000000000000a8\n #PF: supervisor write access in kernel mode\n #PF: error_code(0x0002) - not-present page PGD 0 P4D 0\n Oops: 0002 [#1] PREEMPT SMP PTI\n CPU: 1 PID: 506 Comm: mt76-usb-rx phy Tainted: G            E      6.1.0-debian64x+1.7 #3\n Hardware name: ZOTAC ZBOX-ID92/ZBOX-IQ01/ZBOX-ID92/ZBOX-IQ01, BIOS B220P007 05/21/2014\n RIP: 0010:ieee80211_deliver_skb+0x62/0x1f0 [mac80211]\n Code: 00 48 89 04 24 e8 9e a7 c3 df 89 c0 48 03 1c c5 a0 ea 39 a1 4c 01 6b 08 48 ff 03 48\n       83 7d 28 00 74 11 48 8b 45 30 48 63 55 44 <48> 83 84 d0 a8 00 00 00 01 41 8b 86 c0\n       11 00 00 8d 50 fd 83 fa 01\n RSP: 0018:ffff999040803b10 EFLAGS: 00010286\n RAX: 0000000000000000 RBX: ffffb9903f496480 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffff999040803ce0 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000000 R12: ffff8d21828ac900\n R13: 000000000000004a R14: ffff8d2198ed89c0 R15: ffff8d2198ed8000\n FS:  0000000000000000(0000) GS:ffff8d24afe80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00000000000000a8 CR3: 0000000429810002 CR4: 00000000001706e0\n Call Trace:\n  <TASK>\n  __ieee80211_rx_h_amsdu+0x1b5/0x240 [mac80211]\n  ? ieee80211_prepare_and_rx_handle+0xcdd/0x1320 [mac80211]\n  ? __local_bh_enable_ip+0x3b/0xa0\n  ieee80211_prepare_and_rx_handle+0xcdd/0x1320 [mac80211]\n  ? prepare_transfer+0x109/0x1a0 [xhci_hcd]\n  ieee80211_rx_list+0xa80/0xda0 [mac80211]\n  mt76_rx_complete+0x207/0x2e0 [mt76]\n  mt76_rx_poll_complete+0x357/0x5a0 [mt76]\n  mt76u_rx_worker+0x4f5/0x600 [mt76_usb]\n  ? mt76_get_min_avg_rssi+0x140/0x140 [mt76]\n  __mt76_worker_fn+0x50/0x80 [mt76]\n  kthread+0xed/0x120\n  ? kthread_complete_and_exit+0x20/0x20\n  ret_from_fork+0x22/0x30\n\nSince the initialization of rx->link and rx->link_sta is rather convoluted\nand duplicated in many places, clean it up by using a helper function to\nset it.\n\n[remove unnecessary rx->sta->sta.mlo check]",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48876",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-21",
                    "modification_date": "2024-08-29",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47307",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: prevent NULL deref in cifs_compose_mount_options()\n\nThe optional @ref parameter might contain an NULL node_name, so\nprevent dereferencing it in cifs_compose_mount_options().\n\nAddresses-Coverity: 1476408 (\"Explicit null dereferenced\")",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47307",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-26",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2023-53987",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nping: Fix potentail NULL deref for /proc/net/icmp.\n\nAfter commit dbca1596bbb0 (\"ping: convert to RCU lookups, get rid\nof rwlock\"), we use RCU for ping sockets, but we should use spinlock\nfor /proc/net/icmp to avoid a potential NULL deref mentioned in\nthe previous patch.\n\nLet's go back to using spinlock there.\n\nNote we can convert ping sockets to use hlist instead of hlist_nulls\nbecause we do not use SLAB_TYPESAFE_BY_RCU for ping sockets.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-12-24",
                    "modification_date": "2025-12-29",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "high",
                    "aqua_score": 9.1,
                    "aqua_severity": "high",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: important",
                    "aqua_score_classification": "Vendor Severity: important"
                },
                {
                    "name": "CVE-2022-48868",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: Let probe fail when workqueue cannot be enabled\n\nThe workqueue is enabled when the appropriate driver is loaded and\ndisabled when the driver is removed. When the driver is removed it\nassumes that the workqueue was enabled successfully and proceeds to\nfree allocations made during workqueue enabling.\n\nFailure during workqueue enabling does not prevent the driver from\nbeing loaded. This is because the error path within drv_enable_wq()\nreturns success unless a second failure is encountered\nduring the error path. By returning success it is possible to load\nthe driver even if the workqueue cannot be enabled and\nallocations that do not exist are attempted to be freed during\ndriver remove.\n\nSome examples of problematic flows:\n(a)\n\n idxd_dmaengine_drv_probe() -> drv_enable_wq() -> idxd_wq_request_irq():\n In above flow, if idxd_wq_request_irq() fails then\n idxd_wq_unmap_portal() is called on error exit path, but\n drv_enable_wq() returns 0 because idxd_wq_disable() succeeds. The\n driver is thus loaded successfully.\n\n idxd_dmaengine_drv_remove()->drv_disable_wq()->idxd_wq_unmap_portal()\n Above flow on driver unload triggers the WARN in devm_iounmap() because\n the device resource has already been removed during error path of\n drv_enable_wq().\n\n(b)\n\n idxd_dmaengine_drv_probe() -> drv_enable_wq() -> idxd_wq_request_irq():\n In above flow, if idxd_wq_request_irq() fails then\n idxd_wq_init_percpu_ref() is never called to initialize the percpu\n counter, yet the driver loads successfully because drv_enable_wq()\n returns 0.\n\n idxd_dmaengine_drv_remove()->__idxd_wq_quiesce()->percpu_ref_kill():\n Above flow on driver unload triggers a BUG when attempting to drop the\n initial ref of the uninitialized percpu ref:\n BUG: kernel NULL pointer dereference, address: 0000000000000010\n\nFix the drv_enable_wq() error path by returning the original error that\nindicates failure of workqueue enabling. This ensures that the probe\nfails when an error is encountered and the driver remove paths are only\nattempted when the workqueue was enabled successfully.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48868",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-21",
                    "modification_date": "2024-09-04",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47562",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix vsi->txq_map sizing\n\nThe approach of having XDP queue per CPU regardless of user's setting\nexposed a hidden bug that could occur in case when Rx queue count differ\nfrom Tx queue count. Currently vsi->txq_map's size is equal to the\ndoubled vsi->alloc_txq, which is not correct due to the fact that XDP\nrings were previously based on the Rx queue count. Below splat can be\nseen when ethtool -L is used and XDP rings are configured:\n\n[  682.875339] BUG: kernel NULL pointer dereference, address: 000000000000000f\n[  682.883403] #PF: supervisor read access in kernel mode\n[  682.889345] #PF: error_code(0x0000) - not-present page\n[  682.895289] PGD 0 P4D 0\n[  682.898218] Oops: 0000 [#1] PREEMPT SMP PTI\n[  682.903055] CPU: 42 PID: 2878 Comm: ethtool Tainted: G           OE     5.15.0-rc5+ #1\n[  682.912214] Hardware name: Intel Corp. GRANTLEY/GRANTLEY, BIOS GRRFCRB1.86B.0276.D07.1605190235 05/19/2016\n[  682.923380] RIP: 0010:devres_remove+0x44/0x130\n[  682.928527] Code: 49 89 f4 55 48 89 fd 4c 89 ff 53 48 83 ec 10 e8 92 b9 49 00 48 8b 9d a8 02 00 00 48 8d 8d a0 02 00 00 49 89 c2 48 39 cb 74 0f <4c> 3b 63 10 74 25 48 8b 5b 08 48 39 cb 75 f1 4c 89 ff 4c 89 d6 e8\n[  682.950237] RSP: 0018:ffffc90006a679f0 EFLAGS: 00010002\n[  682.956285] RAX: 0000000000000286 RBX: ffffffffffffffff RCX: ffff88908343a370\n[  682.964538] RDX: 0000000000000001 RSI: ffffffff81690d60 RDI: 0000000000000000\n[  682.972789] RBP: ffff88908343a0d0 R08: 0000000000000000 R09: 0000000000000000\n[  682.981040] R10: 0000000000000286 R11: 3fffffffffffffff R12: ffffffff81690d60\n[  682.989282] R13: ffffffff81690a00 R14: ffff8890819807a8 R15: ffff88908343a36c\n[  682.997535] FS:  00007f08c7bfa740(0000) GS:ffff88a03fd00000(0000) knlGS:0000000000000000\n[  683.006910] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  683.013557] CR2: 000000000000000f CR3: 0000001080a66003 CR4: 00000000003706e0\n[  683.021819] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  683.030075] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  683.038336] Call Trace:\n[  683.041167]  devm_kfree+0x33/0x50\n[  683.045004]  ice_vsi_free_arrays+0x5e/0xc0 [ice]\n[  683.050380]  ice_vsi_rebuild+0x4c8/0x750 [ice]\n[  683.055543]  ice_vsi_recfg_qs+0x9a/0x110 [ice]\n[  683.060697]  ice_set_channels+0x14f/0x290 [ice]\n[  683.065962]  ethnl_set_channels+0x333/0x3f0\n[  683.070807]  genl_family_rcv_msg_doit+0xea/0x150\n[  683.076152]  genl_rcv_msg+0xde/0x1d0\n[  683.080289]  ? channels_prepare_data+0x60/0x60\n[  683.085432]  ? genl_get_cmd+0xd0/0xd0\n[  683.089667]  netlink_rcv_skb+0x50/0xf0\n[  683.094006]  genl_rcv+0x24/0x40\n[  683.097638]  netlink_unicast+0x239/0x340\n[  683.102177]  netlink_sendmsg+0x22e/0x470\n[  683.106717]  sock_sendmsg+0x5e/0x60\n[  683.110756]  __sys_sendto+0xee/0x150\n[  683.114894]  ? handle_mm_fault+0xd0/0x2a0\n[  683.119535]  ? do_user_addr_fault+0x1f3/0x690\n[  683.134173]  __x64_sys_sendto+0x25/0x30\n[  683.148231]  do_syscall_64+0x3b/0xc0\n[  683.161992]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nFix this by taking into account the value that num_possible_cpus()\nyields in addition to vsi->alloc_txq instead of doubling the latter.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47562",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-24",
                    "modification_date": "2025-01-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47260",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix a potential NULL dereference in nfs_get_client()\n\nNone of the callers are expecting NULL returns from nfs_get_client() so\nthis code will lead to an Oops.  It's better to return an error\npointer.  I expect that this is dead code so hopefully no one is\naffected.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47260",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2024-12-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-68756",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: Use RCU in blk_mq_[un]quiesce_tagset() instead of set->tag_list_lock\n\nblk_mq_{add,del}_queue_tag_set() functions add and remove queues from\ntagset, the functions make sure that tagset and queues are marked as\nshared when two or more queues are attached to the same tagset.\nInitially a tagset starts as unshared and when the number of added\nqueues reaches two, blk_mq_add_queue_tag_set() marks it as shared along\nwith all the queues attached to it. When the number of attached queues\ndrops to 1 blk_mq_del_queue_tag_set() need to mark both the tagset and\nthe remaining queues as unshared.\n\nBoth functions need to freeze current queues in tagset before setting on\nunsetting BLK_MQ_F_TAG_QUEUE_SHARED flag. While doing so, both functions\nhold set->tag_list_lock mutex, which makes sense as we do not want\nqueues to be added or deleted in the process. This used to work fine\nuntil commit 98d81f0df70c (\"nvme: use blk_mq_[un]quiesce_tagset\")\nmade the nvme driver quiesce tagset instead of quiscing individual\nqueues. blk_mq_quiesce_tagset() does the job and quiesce the queues in\nset->tag_list while holding set->tag_list_lock also.\n\nThis results in deadlock between two threads with these stacktraces:\n\n  __schedule+0x47c/0xbb0\n  ? timerqueue_add+0x66/0xb0\n  schedule+0x1c/0xa0\n  schedule_preempt_disabled+0xa/0x10\n  __mutex_lock.constprop.0+0x271/0x600\n  blk_mq_quiesce_tagset+0x25/0xc0\n  nvme_dev_disable+0x9c/0x250\n  nvme_timeout+0x1fc/0x520\n  blk_mq_handle_expired+0x5c/0x90\n  bt_iter+0x7e/0x90\n  blk_mq_queue_tag_busy_iter+0x27e/0x550\n  ? __blk_mq_complete_request_remote+0x10/0x10\n  ? __blk_mq_complete_request_remote+0x10/0x10\n  ? __call_rcu_common.constprop.0+0x1c0/0x210\n  blk_mq_timeout_work+0x12d/0x170\n  process_one_work+0x12e/0x2d0\n  worker_thread+0x288/0x3a0\n  ? rescuer_thread+0x480/0x480\n  kthread+0xb8/0xe0\n  ? kthread_park+0x80/0x80\n  ret_from_fork+0x2d/0x50\n  ? kthread_park+0x80/0x80\n  ret_from_fork_asm+0x11/0x20\n\n  __schedule+0x47c/0xbb0\n  ? xas_find+0x161/0x1a0\n  schedule+0x1c/0xa0\n  blk_mq_freeze_queue_wait+0x3d/0x70\n  ? destroy_sched_domains_rcu+0x30/0x30\n  blk_mq_update_tag_set_shared+0x44/0x80\n  blk_mq_exit_queue+0x141/0x150\n  del_gendisk+0x25a/0x2d0\n  nvme_ns_remove+0xc9/0x170\n  nvme_remove_namespaces+0xc7/0x100\n  nvme_remove+0x62/0x150\n  pci_device_remove+0x23/0x60\n  device_release_driver_internal+0x159/0x200\n  unbind_store+0x99/0xa0\n  kernfs_fop_write_iter+0x112/0x1e0\n  vfs_write+0x2b1/0x3d0\n  ksys_write+0x4e/0xb0\n  do_syscall_64+0x5b/0x160\n  entry_SYSCALL_64_after_hwframe+0x4b/0x53\n\nThe top stacktrace is showing nvme_timeout() called to handle nvme\ncommand timeout. timeout handler is trying to disable the controller and\nas a first step, it needs to blk_mq_quiesce_tagset() to tell blk-mq not\nto call queue callback handlers. The thread is stuck waiting for\nset->tag_list_lock as it tries to walk the queues in set->tag_list.\n\nThe lock is held by the second thread in the bottom stack which is\nwaiting for one of queues to be frozen. The queue usage counter will\ndrop to zero after nvme_timeout() finishes, and this will not happen\nbecause the thread will wait for this mutex forever.\n\nGiven that [un]quiescing queue is an operation that does not need to\nsleep, update blk_mq_[un]quiesce_tagset() to use RCU instead of taking\nset->tag_list_lock, update blk_mq_{add,del}_queue_tag_set() to use RCU\nsafe list operations. Also, delete INIT_LIST_HEAD(&q->tag_set_list)\nin blk_mq_del_queue_tag_set() because we can not re-initialize it while\nthe list is being traversed under RCU. The deleted queue will not be\nadded/deleted to/from a tagset and it will be freed in blk_free_queue()\nafter the end of RCU grace period.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47685",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2026-01-05",
                    "modification_date": "2026-01-11",
                    "nvd_score_v3": 9.1,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 9.1,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47225",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix deadlock in AP/VLAN handling\n\nSyzbot reports that when you have AP_VLAN interfaces that are up\nand close the AP interface they belong to, we get a deadlock. No\nsurprise - since we dev_close() them with the wiphy mutex held,\nwhich goes back into the netdev notifier in cfg80211 and tries to\nacquire the wiphy mutex there.\n\nTo fix this, we need to do two things:\n 1) prevent changing iftype while AP_VLANs are up, we can't\n    easily fix this case since cfg80211 already calls us with\n    the wiphy mutex held, but change_interface() is relatively\n    rare in drivers anyway, so changing iftype isn't used much\n    (and userspace has to fall back to down/change/up anyway)\n 2) pull the dev_close() loop over VLANs out of the wiphy mutex\n    section in the normal stop case",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47225",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-04-04",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48916",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/vt-d: Fix double list_add when enabling VMD in scalable mode\n\nWhen enabling VMD and IOMMU scalable mode, the following kernel panic\ncall trace/kernel log is shown in Eagle Stream platform (Sapphire Rapids\nCPU) during booting:\n\npci 0000:59:00.5: Adding to iommu group 42\n...\nvmd 0000:59:00.5: PCI host bridge to bus 10000:80\npci 10000:80:01.0: [8086:352a] type 01 class 0x060400\npci 10000:80:01.0: reg 0x10: [mem 0x00000000-0x0001ffff 64bit]\npci 10000:80:01.0: enabling Extended Tags\npci 10000:80:01.0: PME# supported from D0 D3hot D3cold\npci 10000:80:01.0: DMAR: Setup RID2PASID failed\npci 10000:80:01.0: Failed to add to iommu group 42: -16\npci 10000:80:03.0: [8086:352b] type 01 class 0x060400\npci 10000:80:03.0: reg 0x10: [mem 0x00000000-0x0001ffff 64bit]\npci 10000:80:03.0: enabling Extended Tags\npci 10000:80:03.0: PME# supported from D0 D3hot D3cold\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:29!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 7 Comm: kworker/0:1 Not tainted 5.17.0-rc3+ #7\nHardware name: Lenovo ThinkSystem SR650V3/SB27A86647, BIOS ESE101Y-1.00 01/13/2022\nWorkqueue: events work_for_cpu_fn\nRIP: 0010:__list_add_valid.cold+0x26/0x3f\nCode: 9a 4a ab ff 4c 89 c1 48 c7 c7 40 0c d9 9e e8 b9 b1 fe ff 0f\n      0b 48 89 f2 4c 89 c1 48 89 fe 48 c7 c7 f0 0c d9 9e e8 a2 b1\n      fe ff <0f> 0b 48 89 d1 4c 89 c6 4c 89 ca 48 c7 c7 98 0c d9\n      9e e8 8b b1 fe\nRSP: 0000:ff5ad434865b3a40 EFLAGS: 00010246\nRAX: 0000000000000058 RBX: ff4d61160b74b880 RCX: ff4d61255e1fffa8\nRDX: 0000000000000000 RSI: 00000000fffeffff RDI: ffffffff9fd34f20\nRBP: ff4d611d8e245c00 R08: 0000000000000000 R09: ff5ad434865b3888\nR10: ff5ad434865b3880 R11: ff4d61257fdc6fe8 R12: ff4d61160b74b8a0\nR13: ff4d61160b74b8a0 R14: ff4d611d8e245c10 R15: ff4d611d8001ba70\nFS:  0000000000000000(0000) GS:ff4d611d5ea00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ff4d611fa1401000 CR3: 0000000aa0210001 CR4: 0000000000771ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <TASK>\n intel_pasid_alloc_table+0x9c/0x1d0\n dmar_insert_one_dev_info+0x423/0x540\n ? device_to_iommu+0x12d/0x2f0\n intel_iommu_attach_device+0x116/0x290\n __iommu_attach_device+0x1a/0x90\n iommu_group_add_device+0x190/0x2c0\n __iommu_probe_device+0x13e/0x250\n iommu_probe_device+0x24/0x150\n iommu_bus_notifier+0x69/0x90\n blocking_notifier_call_chain+0x5a/0x80\n device_add+0x3db/0x7b0\n ? arch_memremap_can_ram_remap+0x19/0x50\n ? memremap+0x75/0x140\n pci_device_add+0x193/0x1d0\n pci_scan_single_device+0xb9/0xf0\n pci_scan_slot+0x4c/0x110\n pci_scan_child_bus_extend+0x3a/0x290\n vmd_enable_domain.constprop.0+0x63e/0x820\n vmd_probe+0x163/0x190\n local_pci_probe+0x42/0x80\n work_for_cpu_fn+0x13/0x20\n process_one_work+0x1e2/0x3b0\n worker_thread+0x1c4/0x3a0\n ? rescuer_thread+0x370/0x370\n kthread+0xc7/0xf0\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x1f/0x30\n </TASK>\nModules linked in:\n---[ end trace 0000000000000000 ]---\n...\nKernel panic - not syncing: Fatal exception\nKernel Offset: 0x1ca00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n---[ end Kernel panic - not syncing: Fatal exception ]---\n\nThe following 'lspci' output shows devices '10000:80:*' are subdevices of\nthe VMD device 0000:59:00.5:\n\n  $ lspci\n  ...\n  0000:59:00.5 RAID bus controller: Intel Corporation Volume Management Device NVMe RAID Controller (rev 20)\n  ...\n  10000:80:01.0 PCI bridge: Intel Corporation Device 352a (rev 03)\n  10000:80:03.0 PCI bridge: Intel Corporation Device 352b (rev 03)\n  10000:80:05.0 PCI bridge: Intel Corporation Device 352c (rev 03)\n  10000:80:07.0 PCI bridge: Intel Corporation Device 352d (rev 03)\n  10000:81:00.0 Non-Volatile memory controller: Intel Corporation NVMe Datacenter SSD [3DNAND, Beta Rock Controller]\n  10000:82:00\n---truncated---",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48916",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-09-12",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48910",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv6: ensure we call ipv6_mc_down() at most once\n\nThere are two reasons for addrconf_notify() to be called with NETDEV_DOWN:\neither the network device is actually going down, or IPv6 was disabled\non the interface.\n\nIf either of them stays down while the other is toggled, we repeatedly\ncall the code for NETDEV_DOWN, including ipv6_mc_down(), while never\ncalling the corresponding ipv6_mc_up() in between. This will cause a\nnew entry in idev->mc_tomb to be allocated for each multicast group\nthe interface is subscribed to, which in turn leaks one struct ifmcaddr6\nper nontrivial multicast group the interface is subscribed to.\n\nThe following reproducer will leak at least $n objects:\n\nip addr add ff2e::4242/32 dev eth0 autojoin\nsysctl -w net.ipv6.conf.eth0.disable_ipv6=1\nfor i in $(seq 1 $n); do\n\tip link set up eth0; ip link set down eth0\ndone\n\nJoining groups with IPV6_ADD_MEMBERSHIP (unprivileged) or setting the\nsysctl net.ipv6.conf.eth0.forwarding to 1 (=> subscribing to ff02::2)\ncan also be used to create a nontrivial idev->mc_list, which will the\nleak objects with the right up-down-sequence.\n\nBased on both sources for NETDEV_DOWN events the interface IPv6 state\nshould be considered:\n\n - not ready if the network interface is not ready OR IPv6 is disabled\n   for it\n - ready if the network interface is ready AND IPv6 is enabled for it\n\nThe functions ipv6_mc_up() and ipv6_down() should only be run when this\nstate changes.\n\nImplement this by remembering when the IPv6 state is ready, and only\nrun ipv6_mc_down() if it actually changed from ready to not ready.\n\nThe other direction (not ready -> ready) already works correctly, as:\n\n - the interface notification triggered codepath for NETDEV_UP /\n   NETDEV_CHANGE returns early if ipv6 is disabled, and\n - the disable_ipv6=0 triggered codepath skips fully initializing the\n   interface as long as addrconf_link_ready(dev) returns false\n - calling ipv6_mc_up() repeatedly does not leak anything",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48910",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-08-22",
                    "modification_date": "2024-11-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-0171",
                    "description": "A flaw was found in the Linux kernel. The existing KVM SEV API has a vulnerability that allows a non-root (host) user-level application to crash the host kernel by creating a confidential guest VM instance in AMD CPU that supports Secure Encrypted Virtualization (SEV).",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0171",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2022-08-26",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49154",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: SVM: fix panic on out-of-bounds guest IRQ\n\nAs guest_irq is coming from KVM_IRQFD API call, it may trigger\ncrash in svm_update_pi_irte() due to out-of-bounds:\n\ncrash> bt\nPID: 22218  TASK: ffff951a6ad74980  CPU: 73  COMMAND: \"vcpu8\"\n #0 [ffffb1ba6707fa40] machine_kexec at ffffffff8565b397\n #1 [ffffb1ba6707fa90] __crash_kexec at ffffffff85788a6d\n #2 [ffffb1ba6707fb58] crash_kexec at ffffffff8578995d\n #3 [ffffb1ba6707fb70] oops_end at ffffffff85623c0d\n #4 [ffffb1ba6707fb90] no_context at ffffffff856692c9\n #5 [ffffb1ba6707fbf8] exc_page_fault at ffffffff85f95b51\n #6 [ffffb1ba6707fc50] asm_exc_page_fault at ffffffff86000ace\n    [exception RIP: svm_update_pi_irte+227]\n    RIP: ffffffffc0761b53  RSP: ffffb1ba6707fd08  RFLAGS: 00010086\n    RAX: ffffb1ba6707fd78  RBX: ffffb1ba66d91000  RCX: 0000000000000001\n    RDX: 00003c803f63f1c0  RSI: 000000000000019a  RDI: ffffb1ba66db2ab8\n    RBP: 000000000000019a   R8: 0000000000000040   R9: ffff94ca41b82200\n    R10: ffffffffffffffcf  R11: 0000000000000001  R12: 0000000000000001\n    R13: 0000000000000001  R14: ffffffffffffffcf  R15: 000000000000005f\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #7 [ffffb1ba6707fdb8] kvm_irq_routing_update at ffffffffc09f19a1 [kvm]\n #8 [ffffb1ba6707fde0] kvm_set_irq_routing at ffffffffc09f2133 [kvm]\n #9 [ffffb1ba6707fe18] kvm_vm_ioctl at ffffffffc09ef544 [kvm]\n    RIP: 00007f143c36488b  RSP: 00007f143a4e04b8  RFLAGS: 00000246\n    RAX: ffffffffffffffda  RBX: 00007f05780041d0  RCX: 00007f143c36488b\n    RDX: 00007f05780041d0  RSI: 000000004008ae6a  RDI: 0000000000000020\n    RBP: 00000000000004e8   R8: 0000000000000008   R9: 00007f05780041e0\n    R10: 00007f0578004560  R11: 0000000000000246  R12: 00000000000004e0\n    R13: 000000000000001a  R14: 00007f1424001c60  R15: 00007f0578003bc0\n    ORIG_RAX: 0000000000000010  CS: 0033  SS: 002b\n\nVmx have been fix this in commit 3a8b0677fc61 (KVM: VMX: Do not BUG() on\nout-of-bounds guest IRQ), so we can just copy source from that to fix\nthis.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49154",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-09-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-4543",
                    "description": "A flaw named \"EntryBleed\" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-4543",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2023-01-11",
                    "modification_date": "2025-04-08",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49021",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phy: fix null-ptr-deref while probe() failed\n\nI got a null-ptr-deref report as following when doing fault injection test:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000058\nOops: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 1 PID: 253 Comm: 507-spi-dm9051 Tainted: G    B            N 6.1.0-rc3+\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nRIP: 0010:klist_put+0x2d/0xd0\nCall Trace:\n <TASK>\n klist_remove+0xf1/0x1c0\n device_release_driver_internal+0x23e/0x2d0\n bus_remove_device+0x1bd/0x240\n device_del+0x357/0x770\n phy_device_remove+0x11/0x30\n mdiobus_unregister+0xa5/0x140\n release_nodes+0x6a/0xa0\n devres_release_all+0xf8/0x150\n device_unbind_cleanup+0x19/0xd0\n\n//probe path:\nphy_device_register()\n  device_add()\n\nphy_connect\n  phy_attach_direct() //set device driver\n    probe() //it's failed, driver is not bound\n    device_bind_driver() // probe failed, it's not called\n\n//remove path:\nphy_device_remove()\n  device_del()\n    device_release_driver_internal()\n      __device_release_driver() //dev->drv is not NULL\n        klist_remove() <- knode_driver is not added yet, cause null-ptr-deref\n\nIn phy_attach_direct(), after setting the 'dev->driver', probe() fails,\ndevice_bind_driver() is not called, so the knode_driver->n_klist is not\nset, then it causes null-ptr-deref in __device_release_driver() while\ndeleting device. Fix this by setting dev->driver to NULL in the error\npath in phy_attach_direct().",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49021",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-10-21",
                    "modification_date": "2024-10-24",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-49130",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: mhi: use mhi_sync_power_up()\n\nIf amss.bin was missing ath11k would crash during 'rmmod ath11k_pci'. The\nreason for that was that we were using mhi_async_power_up() which does not\ncheck any errors. But mhi_sync_power_up() on the other hand does check for\nerrors so let's use that to fix the crash.\n\nI was not able to find a reason why an async version was used.\nath11k_mhi_start() (which enables state ATH11K_MHI_POWER_ON) is called from\nath11k_hif_power_up(), which can sleep. So sync version should be safe to use\nhere.\n\n[  145.569731] general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC KASAN PTI\n[  145.569789] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n[  145.569843] CPU: 2 PID: 1628 Comm: rmmod Kdump: loaded Tainted: G        W         5.16.0-wt-ath+ #567\n[  145.569898] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021\n[  145.569956] RIP: 0010:ath11k_hal_srng_access_begin+0xb5/0x2b0 [ath11k]\n[  145.570028] Code: df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 ec 01 00 00 48 8b ab a8 00 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 ea 48 c1 ea 03 <0f> b6 14 02 48 89 e8 83 e0 07 83 c0 03 45 85 ed 75 48 38 d0 7c 08\n[  145.570089] RSP: 0018:ffffc900025d7ac0 EFLAGS: 00010246\n[  145.570144] RAX: dffffc0000000000 RBX: ffff88814fca2dd8 RCX: 1ffffffff50cb455\n[  145.570196] RDX: 0000000000000000 RSI: ffff88814fca2dd8 RDI: ffff88814fca2e80\n[  145.570252] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffa8659497\n[  145.570329] R10: fffffbfff50cb292 R11: 0000000000000001 R12: ffff88814fca0000\n[  145.570410] R13: 0000000000000000 R14: ffff88814fca2798 R15: ffff88814fca2dd8\n[  145.570465] FS:  00007fa399988540(0000) GS:ffff888233e00000(0000) knlGS:0000000000000000\n[  145.570519] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  145.570571] CR2: 00007fa399b51421 CR3: 0000000137898002 CR4: 00000000003706e0\n[  145.570623] Call Trace:\n[  145.570675]  <TASK>\n[  145.570727]  ? ath11k_ce_tx_process_cb+0x34b/0x860 [ath11k]\n[  145.570797]  ath11k_ce_tx_process_cb+0x356/0x860 [ath11k]\n[  145.570864]  ? tasklet_init+0x150/0x150\n[  145.570919]  ? ath11k_ce_alloc_pipes+0x280/0x280 [ath11k]\n[  145.570986]  ? tasklet_clear_sched+0x42/0xe0\n[  145.571042]  ? tasklet_kill+0xe9/0x1b0\n[  145.571095]  ? tasklet_clear_sched+0xe0/0xe0\n[  145.571148]  ? irq_has_action+0x120/0x120\n[  145.571202]  ath11k_ce_cleanup_pipes+0x45a/0x580 [ath11k]\n[  145.571270]  ? ath11k_pci_stop+0x10e/0x170 [ath11k_pci]\n[  145.571345]  ath11k_core_stop+0x8a/0xc0 [ath11k]\n[  145.571434]  ath11k_core_deinit+0x9e/0x150 [ath11k]\n[  145.571499]  ath11k_pci_remove+0xd2/0x260 [ath11k_pci]\n[  145.571553]  pci_device_remove+0x9a/0x1c0\n[  145.571605]  __device_release_driver+0x332/0x660\n[  145.571659]  driver_detach+0x1e7/0x2c0\n[  145.571712]  bus_remove_driver+0xe2/0x2d0\n[  145.571772]  pci_unregister_driver+0x21/0x250\n[  145.571826]  __do_sys_delete_module+0x30a/0x4b0\n[  145.571879]  ? free_module+0xac0/0xac0\n[  145.571933]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370\n[  145.571986]  ? syscall_enter_from_user_mode+0x1d/0x50\n[  145.572039]  ? lockdep_hardirqs_on+0x79/0x100\n[  145.572097]  do_syscall_64+0x3b/0x90\n[  145.572153]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49130",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-02-26",
                    "modification_date": "2025-10-01",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2022-48810",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nipmr,ip6mr: acquire RTNL before calling ip[6]mr_free_table() on failure path\n\nip[6]mr_free_table() can only be called under RTNL lock.\n\nRTNL: assertion failed at net/core/dev.c (10367)\nWARNING: CPU: 1 PID: 5890 at net/core/dev.c:10367 unregister_netdevice_many+0x1246/0x1850 net/core/dev.c:10367\nModules linked in:\nCPU: 1 PID: 5890 Comm: syz-executor.2 Not tainted 5.16.0-syzkaller-11627-g422ee58dc0ef #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:unregister_netdevice_many+0x1246/0x1850 net/core/dev.c:10367\nCode: 0f 85 9b ee ff ff e8 69 07 4b fa ba 7f 28 00 00 48 c7 c6 00 90 ae 8a 48 c7 c7 40 90 ae 8a c6 05 6d b1 51 06 01 e8 8c 90 d8 01 <0f> 0b e9 70 ee ff ff e8 3e 07 4b fa 4c 89 e7 e8 86 2a 59 fa e9 ee\nRSP: 0018:ffffc900046ff6e0 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: ffff888050f51d00 RSI: ffffffff815fa008 RDI: fffff520008dfece\nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffffff815f3d6e R11: 0000000000000000 R12: 00000000fffffff4\nR13: dffffc0000000000 R14: ffffc900046ff750 R15: ffff88807b7dc000\nFS:  00007f4ab736e700(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fee0b4f8990 CR3: 000000001e7d2000 CR4: 00000000003506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n mroute_clean_tables+0x244/0xb40 net/ipv6/ip6mr.c:1509\n ip6mr_free_table net/ipv6/ip6mr.c:389 [inline]\n ip6mr_rules_init net/ipv6/ip6mr.c:246 [inline]\n ip6mr_net_init net/ipv6/ip6mr.c:1306 [inline]\n ip6mr_net_init+0x3f0/0x4e0 net/ipv6/ip6mr.c:1298\n ops_init+0xaf/0x470 net/core/net_namespace.c:140\n setup_net+0x54f/0xbb0 net/core/net_namespace.c:331\n copy_net_ns+0x318/0x760 net/core/net_namespace.c:475\n create_new_namespaces+0x3f6/0xb20 kernel/nsproxy.c:110\n copy_namespaces+0x391/0x450 kernel/nsproxy.c:178\n copy_process+0x2e0c/0x7300 kernel/fork.c:2167\n kernel_clone+0xe7/0xab0 kernel/fork.c:2555\n __do_sys_clone+0xc8/0x110 kernel/fork.c:2672\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f4ab89f9059\nCode: Unable to access opcode bytes at RIP 0x7f4ab89f902f.\nRSP: 002b:00007f4ab736e118 EFLAGS: 00000206 ORIG_RAX: 0000000000000038\nRAX: ffffffffffffffda RBX: 00007f4ab8b0bf60 RCX: 00007f4ab89f9059\nRDX: 0000000020000280 RSI: 0000000020000270 RDI: 0000000040200000\nRBP: 00007f4ab8a5308d R08: 0000000020000300 R09: 0000000020000300\nR10: 00000000200002c0 R11: 0000000000000206 R12: 0000000000000000\nR13: 00007ffc3977cc1f R14: 00007f4ab736e300 R15: 0000000000022000\n </TASK>",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-48810",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-07-16",
                    "modification_date": "2025-10-03",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2025-38412",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: dell-wmi-sysman: Fix WMI data block retrieval in sysfs callbacks\n\nAfter retrieving WMI data blocks in sysfs callbacks, check for the\nvalidity of them before dereferencing their content.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2025-38412",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2025-07-25",
                    "modification_date": "2025-12-23",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47395",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: limit injected vht mcs/nss in ieee80211_parse_tx_radiotap\n\nLimit max values for vht mcs and nss in ieee80211_parse_tx_radiotap\nroutine in order to fix the following warning reported by syzbot:\n\nWARNING: CPU: 0 PID: 10717 at include/net/mac80211.h:989 ieee80211_rate_set_vht include/net/mac80211.h:989 [inline]\nWARNING: CPU: 0 PID: 10717 at include/net/mac80211.h:989 ieee80211_parse_tx_radiotap+0x101e/0x12d0 net/mac80211/tx.c:2244\nModules linked in:\nCPU: 0 PID: 10717 Comm: syz-executor.5 Not tainted 5.14.0-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:ieee80211_rate_set_vht include/net/mac80211.h:989 [inline]\nRIP: 0010:ieee80211_parse_tx_radiotap+0x101e/0x12d0 net/mac80211/tx.c:2244\nRSP: 0018:ffffc9000186f3e8 EFLAGS: 00010216\nRAX: 0000000000000618 RBX: ffff88804ef76500 RCX: ffffc900143a5000\nRDX: 0000000000040000 RSI: ffffffff888f478e RDI: 0000000000000003\nRBP: 00000000ffffffff R08: 0000000000000000 R09: 0000000000000100\nR10: ffffffff888f46f9 R11: 0000000000000000 R12: 00000000fffffff8\nR13: ffff88804ef7653c R14: 0000000000000001 R15: 0000000000000004\nFS:  00007fbf5718f700(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000001b2de23000 CR3: 000000006a671000 CR4: 00000000001506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n ieee80211_monitor_select_queue+0xa6/0x250 net/mac80211/iface.c:740\n netdev_core_pick_tx+0x169/0x2e0 net/core/dev.c:4089\n __dev_queue_xmit+0x6f9/0x3710 net/core/dev.c:4165\n __bpf_tx_skb net/core/filter.c:2114 [inline]\n __bpf_redirect_no_mac net/core/filter.c:2139 [inline]\n __bpf_redirect+0x5ba/0xd20 net/core/filter.c:2162\n ____bpf_clone_redirect net/core/filter.c:2429 [inline]\n bpf_clone_redirect+0x2ae/0x420 net/core/filter.c:2401\n bpf_prog_eeb6f53a69e5c6a2+0x59/0x234\n bpf_dispatcher_nop_func include/linux/bpf.h:717 [inline]\n __bpf_prog_run include/linux/filter.h:624 [inline]\n bpf_prog_run include/linux/filter.h:631 [inline]\n bpf_test_run+0x381/0xa30 net/bpf/test_run.c:119\n bpf_prog_test_run_skb+0xb84/0x1ee0 net/bpf/test_run.c:663\n bpf_prog_test_run kernel/bpf/syscall.c:3307 [inline]\n __sys_bpf+0x2137/0x5df0 kernel/bpf/syscall.c:4605\n __do_sys_bpf kernel/bpf/syscall.c:4691 [inline]\n __se_sys_bpf kernel/bpf/syscall.c:4689 [inline]\n __x64_sys_bpf+0x75/0xb0 kernel/bpf/syscall.c:4689\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x4665f9",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47395",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-05-21",
                    "modification_date": "2025-09-25",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2021-47045",
                    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix null pointer dereference in lpfc_prep_els_iocb()\n\nIt is possible to call lpfc_issue_els_plogi() passing a did for which no\nmatching ndlp is found. A call is then made to lpfc_prep_els_iocb() with a\nnull pointer to a lpfc_nodelist structure resulting in a null pointer\ndereference.\n\nFix by returning an error status if no valid ndlp is found. Fix up comments\nregarding ndlp reference counting.",
                    "nvd_score_version": "CVSS v2",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2021-47045",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2024-02-28",
                    "modification_date": "2024-12-06",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                },
                {
                    "name": "CVE-2020-13844",
                    "description": "Arm Armv8-A core implementations utilizing speculative execution past unconditional changes in control flow may allow unauthorized disclosure of information to an attacker with local user access via a side-channel analysis, aka \"straight-line speculation.\"",
                    "nvd_score": 2.1,
                    "nvd_score_version": "CVSS v2",
                    "nvd_vectors": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
                    "nvd_severity": "low",
                    "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2020-13844",
                    "vendor_score_version": "CVSS v2",
                    "publish_date": "2020-06-08",
                    "modification_date": "2024-11-21",
                    "nvd_score_v3": 5.5,
                    "nvd_vectors_v3": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "nvd_severity_v3": "medium",
                    "aqua_score": 5.5,
                    "aqua_severity": "medium",
                    "aqua_vectors": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
                    "aqua_scoring_system": "CVSS V3",
                    "aqua_severity_classification": "Vendor Severity: moderate",
                    "aqua_score_classification": "Vendor Severity: moderate"
                }
            ]
        }
    ],
    "vulnerability_summary": {
        "total": 1,
        "critical": 2,
        "high": 565,
        "medium": 432,
        "low": 1,
        "negligible": 0,
        "sensitive": 0,
        "malware": 0,
        "score_average": 6905.8
    },
    "scan_options": {
        "scan_executables": true,
        "scan_sensitive_data": true,
        "scan_malware": true,
        "scan_files": true,
        "scan_timeout": 3600000000000,
        "manual_pull_fallback": true,
        "save_adhoc_scans": true,
        "use_cvss3": true,
        "dockerless": true,
        "system_image_platform": "amd64:::",
        "scan_elf": true,
        "enable_fast_scanning": true,
        "memoryThrottling": true,
        "suggest_os_upgrade": true,
        "adhoc_scan_retention": 30
    }
}